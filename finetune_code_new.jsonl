{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the cache_manager.py file and how do they manage cached data?"}, {"role": "assistant", "content": "# Content from: #<cache_manager.py>#\nimport glob\nimport os\nimport pathlib\n\nfrom typing_extensions import List, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from .description import ObjectDescription\n\n\nclass CacheManager:\n\n    \"\"\"\n    The CacheManager is responsible for caching object description files and managing the cache directory.\n    \"\"\"\n\n    mesh_extensions: List[str] = [\".obj\", \".stl\"]\n    \"\"\"\n    The file extensions of mesh files.\n    \"\"\"\n\n    def __init__(self, cache_dir: str, data_directory: List[str]):\n        \"\"\"\n        Initializes the CacheManager.\n\n        :param cache_dir: The directory where the cached files are stored.\n        :param data_directory: The directory where all resource files are stored.\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.data_directory = data_directory\n\n    def update_cache_dir_with_object(self, path: str, ignore_cached_files: bool,\n                                     object_description: 'ObjectDescription', object_name: str) -> str:\n        \"\"\"\n        Checks if the file is already in the cache directory, if not it will be preprocessed and saved in the cache.\n\n        :param path: The path of the file to preprocess and save in the cache directory.\n        :param ignore_cached_files: If True, the file will be preprocessed and saved in the cache directory even if it\n         is already cached.\n        :param object_description: The object description of the file.\n        :param object_name: The name of the object.\n        \"\"\"\n        path_object = pathlib.Path(path)\n        extension = path_object.suffix\n\n        self.create_cache_dir_if_not_exists()\n\n        # save correct path in case the file is already in the cache directory\n        cache_path = self.cache_dir + object_description.get_file_name(path_object, extension, object_name)\n\n        if not self.is_cached(path, object_description) or ignore_cached_files:\n            # if file is not yet cached preprocess the description file and save it in the cache directory.\n            path = self.look_for_file_in_data_dir(path_object)\n            self.generate_description_and_write_to_cache(path, object_name, extension, cache_path, object_description)\n\n        return cache_path\n\n    def generate_description_and_write_to_cache(self, path: str, name: str, extension: str, cache_path: str,\n                                                object_description: 'ObjectDescription') -> None:\n        \"\"\"\n        Generates the description from the file at the given path and writes it to the cache directory.\n\n        :param path: The path of the file to preprocess.\n        :param name: The name of the object.\n        :param extension: The file extension of the file to preprocess.\n        :param cache_path: The path of the file in the cache directory.\n        :param object_description: The object description of the file.\n        \"\"\"\n        description_string = object_description.generate_description_from_file(path, name, extension)\n        self.write_to_cache(description_string, cache_path)\n\n    @staticmethod\n    def write_to_cache(description_string: str, cache_path: str) -> None:\n        \"\"\"\n        Writes the description string to the cache directory.\n\n        :param description_string: The description string to write to the cache directory.\n        :param cache_path: The path of the file in the cache directory.\n        \"\"\"\n        with open(cache_path, \"w\") as file:\n            file.write(description_string)\n\n    def look_for_file_in_data_dir(self, path_object: pathlib.Path) -> str:\n        \"\"\"\n        Looks for a file in the data directory of the World. If the file is not found in the data directory, this method\n        raises a FileNotFoundError.\n\n        :param path_object: The pathlib object of the file to look for.\n        \"\"\"\n        name = path_object.name\n        for data_dir in self.data_directory:\n            data_path = pathlib.Path(data_dir).joinpath(\"**\")\n            for file in glob.glob(str(data_path), recursive=True):\n                file_path = pathlib.Path(file)\n                if file_path.name == name:\n                    print(f\"Found file {name} in {file_path}\")\n                    return str(file_path)\n\n        raise FileNotFoundError(\n            f\"File {name} could not be found in the resource directory {self.data_directory}\")\n\n    def create_cache_dir_if_not_exists(self):\n        \"\"\"\n        Creates the cache directory if it does not exist.\n        \"\"\"\n        if not pathlib.Path(self.cache_dir).exists():\n            os.mkdir(self.cache_dir)\n\n    def is_cached(self, path: str, object_description: 'ObjectDescription') -> bool:\n        \"\"\"\n        Checks if the file in the given path is already cached or if\n        there is already a cached file with the given name, this is the case if a .stl, .obj file or a description from\n        the parameter server is used.\n\n        :param path: The path of the file to check.\n        :param object_description: The object description of the file.\n        :return: True if there already exists a cached file, False in any other case.\n        \"\"\"\n        return True if self.check_with_extension(path) else self.check_without_extension(path, object_description)\n\n    def check_with_extension(self, path: str) -> bool:\n        \"\"\"\n        Checks if the file in the given ath exists in the cache directory including file extension.\n\n        :param path: The path of the file to check.\n        \"\"\"\n        file_name = pathlib.Path(path).name\n        full_path = pathlib.Path(self.cache_dir + file_name)\n        return full_path.exists()\n\n    def check_without_extension(self, path: str, object_description: 'ObjectDescription') -> bool:\n        \"\"\"\n        Checks if the file in the given path exists in the cache directory without file extension,\n        the extension is added after the file name manually in this case.\n\n        :param path: The path of the file to check.\n        :param object_description: The object description of the file.\n        \"\"\"\n        file_stem = pathlib.Path(path).stem\n        full_path = pathlib.Path(self.cache_dir + file_stem + object_description.get_file_extension())\n        return full_path.exists()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the costmaps.py file and how do they contribute to cost map generation?"}, {"role": "assistant", "content": "# Content from: #<costmaps.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nfrom typing_extensions import Tuple, List, Optional\n\nimport matplotlib.pyplot as plt\nfrom dataclasses import dataclass\n\nimport numpy as np\nimport psutil\nimport rospy\nfrom matplotlib import colors\nfrom nav_msgs.msg import OccupancyGrid, MapMetaData\n\nfrom .datastructures.world import UseProspectionWorld\nfrom .world_concepts.world_object import Object\nfrom .description import Link\nfrom .local_transformer import LocalTransformer\nfrom .datastructures.pose import Pose, Transform\nfrom .datastructures.world import World\nfrom .datastructures.dataclasses import AxisAlignedBoundingBox, BoxVisualShape, Color\n\nimport pybullet as p\n\n\n@dataclass\nclass Rectangle:\n    \"\"\"\n    A rectangle that is described by a lower and upper x and y value.\n    \"\"\"\n    x_lower: float\n    x_upper: float\n    y_lower: float\n    y_upper: float\n\n    def translate(self, x: float, y: float):\n        \"\"\"Translate the rectangle by x and y\"\"\"\n        self.x_lower += x\n        self.x_upper += x\n        self.y_lower += y\n        self.y_upper += y\n\n    def scale(self, x_factor: float, y_factor: float):\n        \"\"\"Scale the rectangle by x_factor and y_factor\"\"\"\n        self.x_lower *= x_factor\n        self.x_upper *= x_factor\n        self.y_lower *= y_factor\n        self.y_upper *= y_factor\n\n\nclass Costmap:\n    \"\"\"\n    The base class of all Costmaps which implements the visualization of costmaps\n    in the World.\n    \"\"\"\n\n    def __init__(self, resolution: float,\n                 height: int,\n                 width: int,\n                 origin: Pose,\n                 map: np.ndarray,\n                 world: Optional[World] = None):\n        \"\"\"\n        The constructor of the base class of all Costmaps.\n\n        :param resolution: The distance in metre in the real-world which is\n         represented by a single entry in the costmap.\n        :param height: The height of the costmap.\n        :param width: The width of the costmap.\n        :param origin: The origin of the costmap, in world coordinate frame. The origin of the costmap is located in the\n         centre of the costmap.\n        :param map: The costmap represents as a 2D numpy array.\n        :param world: The World for which the costmap should be created.\n        \"\"\"\n        self.world = world if world else World.current_world\n        self.resolution: float = resolution\n        self.size: int = height\n        self.height: int = height\n        self.width: int = width\n        local_transformer = LocalTransformer()\n        self.origin: Pose = local_transformer.transform_pose(origin, 'map')\n        self.map: np.ndarray = map\n        self.vis_ids: List[int] = []\n\n    def visualize(self) -> None:\n        \"\"\"\n        Visualizes a costmap in the BulletWorld, the visualisation works by\n        subdividing the costmap in rectangles which are then visualized as pybullet\n        visual shapes.\n        \"\"\"\n        if self.vis_ids != []:\n            return\n\n        # working on a copy of the costmap, since found rectangles are deleted\n        map = np.copy(self.map)\n        curr_width = 0\n        curr_height = 0\n        curr_pose = []\n        boxes = []\n        # Finding all rectangles in the costmap\n        for i in range(0, map.shape[0]):\n            for j in range(0, map.shape[1]):\n                if map[i][j] > 0:\n                    curr_width = self._find_consectuive_line((i, j), map)\n                    curr_pose = (i, j)\n                    curr_height = self._find_max_box_height((i, j), curr_width, map)\n                    avg = np.average(map[i:i + curr_height, j:j + curr_width])\n                    boxes.append([curr_pose, curr_height, curr_width, avg])\n                    map[i:i + curr_height, j:j + curr_width] = 0\n        cells = []\n        # Creation of the visual shapes, for documentation of the visual shapes\n        # please look here: https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit#heading=h.q1gn7v6o58bf\n        for box in boxes:\n            visual = p.createVisualShape(p.GEOM_BOX,\n                                         halfExtents=[(box[1] * self.resolution) / 2, (box[2] * self.resolution) / 2,\n                                                      0.001],\n                                         rgbaColor=[1, 0, 0, 0.6],\n                                         visualFramePosition=[(box[0][0] + box[1] / 2) * self.resolution,\n                                                              (box[0][1] + box[2] / 2) * self.resolution, 0.])\n            cells.append(visual)\n        # Set to 127 for since this is the maximal amount of links in a multibody\n        for cell_parts in self._chunks(cells, 127):\n            # Dummy paramater since these are needed to spawn visual shapes as a\n            # multibody.\n            link_poses = [[0, 0, 0] for c in cell_parts]\n            link_orientations = [[0, 0, 0, 1] for c in cell_parts]\n            link_masses = [1.0 for c in cell_parts]\n            link_parent = [0 for c in cell_parts]\n            link_joints = [p.JOINT_FIXED for c in cell_parts]\n            link_collision = [-1 for c in cell_parts]\n            link_joint_axis = [[1, 0, 0] for c in cell_parts]\n            # The position at which the multibody will be spawned. Offset such that\n            # the origin referes to the centre of the costmap.\n            # origin_pose = self.origin.position_as_list()\n            # base_pose = [origin_pose[0] - self.height / 2 * self.resolution,\n            #              origin_pose[1] - self.width / 2 * self.resolution, origin_pose[2]]\n\n            offset = [[-self.height / 2 * self.resolution, -self.width / 2 * self.resolution, 0.05], [0, 0, 0, 1]]\n            new_pose = p.multiplyTransforms(self.origin.position_as_list(), self.origin.orientation_as_list(),\n                                            offset[0], offset[1])\n\n            map_obj = p.createMultiBody(baseVisualShapeIndex=-1, linkVisualShapeIndices=cell_parts,\n                                        basePosition=new_pose[0], baseOrientation=new_pose[1], linkPositions=link_poses,\n                                        # [0, 0, 1, 0]\n                                        linkMasses=link_masses, linkOrientations=link_orientations,\n                                        linkInertialFramePositions=link_poses,\n                                        linkInertialFrameOrientations=link_orientations, linkParentIndices=link_parent,\n                                        linkJointTypes=link_joints, linkJointAxis=link_joint_axis,\n                                        linkCollisionShapeIndices=link_collision)\n            self.vis_ids.append(map_obj)\n\n    def _chunks(self, lst: List, n: int) -> List:\n        \"\"\"\n        Yield successive n-sized chunks from lst.\n\n        :param lst: The list from which chunks should be yielded\n        :param n: Size of the chunks\n        :return: A list of size n from lst\n        \"\"\"\n        for i in range(0, len(lst), n):\n            yield lst[i:i + n]\n\n    def close_visualization(self) -> None:\n        \"\"\"\n        Removes the visualization from the World.\n        \"\"\"\n        for v_id in self.vis_ids:\n            self.world.remove_object_by_id(v_id)\n        self.vis_ids = []\n\n    def _find_consectuive_line(self, start: Tuple[int, int], map: np.ndarray) -> int:\n        \"\"\"\n        Finds the number of consecutive entries in the costmap which are greater\n        than zero.\n\n        :param start: The indices in the costmap from which the consecutive line should be found.\n        :param map: The costmap in which the line should be found.\n        :return: The length of the consecutive line of entries greater than zero.\n        \"\"\"\n        width = map.shape[1]\n        lenght = 0\n        for i in range(start[1], width):\n            if map[start[0]][i] > 0:\n                lenght += 1\n            else:\n                return lenght\n        return lenght\n\n    def _find_max_box_height(self, start: Tuple[int, int], length: int, map: np.ndarray) -> int:\n        \"\"\"\n        Finds the maximal height for a rectangle with a given width in a costmap.\n        The method traverses one row at a time and checks if all entries for the\n        given width are greater than zero. If an entry is less or equal than zero\n        the height is returned.\n\n        :param start: The indices in the costmap from which the method should start.\n        :param length: The given width for the rectangle\n        :param map: The costmap in which should be searched.\n        :return: The height of the rectangle.\n        \"\"\"\n        height, width = map.shape\n        curr_height = 1\n        for i in range(start[0], height):\n            for j in range(start[1], start[1] + length):\n                if map[i][j] <= 0:\n                    return curr_height\n            curr_height += 1\n        return curr_height\n\n    def merge(self, other_cm: Costmap) -> Costmap:\n        \"\"\"\n        Merges the values of two costmaps and returns a new costmap that has for\n        every cell the merged values of both inputs. To merge two costmaps they\n        need to fulfill 3 constrains:\n\n        1. They need to have the same size\n        2. They need to have the same x and y coordinates in the origin\n        3. They need to have the same resolution\n\n        If any of these constrains is not fulfilled a ValueError will be raised.\n\n        :param other_cm: The other costmap with which this costmap should be merged.\n        :return: A new costmap that contains the merged values\n        \"\"\"\n        if self.size != other_cm.size:\n            raise ValueError(\"You can only merge costmaps of the same size.\")\n        elif self.origin.position.x != other_cm.origin.position.x or self.origin.position.y != other_cm.origin.position.y \\\n                or self.origin.orientation != other_cm.origin.orientation:\n            raise ValueError(\"To merge costmaps, the x and y coordinate as well as the orientation must be equal.\")\n        elif self.resolution != other_cm.resolution:\n            raise ValueError(\"To merge two costmaps their resolution must be equal.\")\n        new_map = np.zeros((self.height, self.width))\n        # A nunpy array of the positions where both costmaps are greater than 0\n        merge = np.logical_and(self.map > 0, other_cm.map > 0)\n        new_map[merge] = self.map[merge] * other_cm.map[merge]\n        new_map = (new_map / np.max(new_map)).reshape((self.height, self.width))\n        return Costmap(self.resolution, self.height, self.width, self.origin, new_map)\n\n    def __add__(self, other: Costmap) -> Costmap:\n        \"\"\"\n        Overloading of the \"+\" operator for merging of Costmaps. Furthermore, checks if 'other' is actual a Costmap and\n        raises a ValueError if this is not the case. Please check :func:`~Costmap.merge` for further information of merging.\n\n        :param other: Another Costmap\n        :return: A new Costmap that contains the merged values from this Costmap and the other Costmap\n        \"\"\"\n        if isinstance(other, Costmap):\n            return self.merge(other)\n        else:\n            raise ValueError(f\"Can only combine two costmaps other type was {type(other)}\")\n\n    def partitioning_rectangles(self) -> List[Rectangle]:\n        \"\"\"\n        Partition the map attached to this costmap into rectangles. The rectangles are axis aligned, exhaustive and\n        disjoint sets.\n\n        :return: A list containing the partitioning rectangles\n        \"\"\"\n        ocm_map = np.copy(self.map)\n        origin = np.array([self.height / 2, self.width / 2]) * -1\n        rectangles = []\n\n        # for every index pair (i, j) in the occupancy costmap\n        for i in range(0, self.map.shape[0]):\n            for j in range(0, self.map.shape[1]):\n\n                # if this index has not been used yet\n                if ocm_map[i][j] > 0:\n                    curr_width = self._find_consectuive_line((i, j), ocm_map)\n                    curr_pose = (i, j)\n                    curr_height = self._find_max_box_height((i, j), curr_width, ocm_map)\n\n                    # calculate the rectangle in the costmap\n                    x_lower = curr_pose[0]\n                    x_upper = curr_pose[0] + curr_height\n                    y_lower = curr_pose[1]\n                    y_upper = curr_pose[1] + curr_width\n\n                    # mark the found rectangle as occupied\n                    ocm_map[i:i + curr_height, j:j + curr_width] = 0\n\n                    # transform rectangle to map space\n                    rectangle = Rectangle(x_lower, x_upper, y_lower, y_upper)\n                    rectangle.translate(*origin)\n                    rectangle.scale(self.resolution, self.resolution)\n                    rectangles.append(rectangle)\n\n        return rectangles\n\n\nclass OccupancyCostmap(Costmap):\n    \"\"\"\n    The occupancy Costmap represents a map of the environment where obstacles or\n    positions which are inaccessible for a robot have a value of -1.\n    \"\"\"\n\n    def __init__(self, distance_to_obstacle: float,\n                 from_ros: Optional[bool] = False,\n                 size: Optional[int] = 100,\n                 resolution: Optional[float] = 0.02,\n                 origin: Optional[Pose] = None,\n                 world: Optional[World] = None):\n        \"\"\"\n        Constructor for the Occupancy costmap, the actual costmap is received\n        from the ROS map_server and wrapped by this class. Meta-data about the\n        costmap is also received from the map_server.\n\n        :param distance_to_obstacle: The distance by which the obstacles should be\n            inflated. Meaning that obstacles in the costmap are growing bigger by this\n            distance.\n        :param from_ros: This determines if the Occupancy map should be created\n            from the map provided by the ROS map_server or from the World.\n            If True then the map from the ROS map_server will be used otherwise\n            the Occupancy map will be created from the World.\n        :param size: The length of the side of the costmap. The costmap will be created\n            as a square. This will only be used if from_ros is False.\n        :param resolution: The resolution of this costmap. This determines how much\n            meter one pixel in the costmap represents. This is only used if from_ros\n            is False.\n        :param origin: This determines the origin of the costmap. The origin will\n            be in the middle of the costmap. This parameter is only used if from_ros\n            is False.\n        \"\"\"\n        self.world = world if world else World.current_world\n        if from_ros:\n            meta = self._get_map_metadata()\n            self.original_map = np.reshape(self._get_map(), (meta.height, meta.width))\n            self.meta_origin = [meta.origin.position.x, meta.origin.position.y, meta.origin.position.z]\n            self.resolution = meta.resolution\n            self.height = meta.height\n            self.width = meta.width\n            # Nunber of cells that have to be between a valid cell and an obstacle\n            self.distance_obstacle = max(int(distance_to_obstacle / self.resolution), 1)\n            Costmap.__init__(self, meta.resolution, meta.height, meta.width,\n                             self._calculate_diff_origin(meta.height, meta.width),\n                             np.rot90(np.flip(self._convert_map(self.original_map), 0)))\n        else:\n            self.size = size\n            self.origin = Pose() if not origin else origin\n            self.resolution = resolution\n            self.distance_obstacle = max(int(distance_to_obstacle / self.resolution), 1)\n            self.map = self._create_from_world(size, resolution)\n            Costmap.__init__(self, resolution, size, size, self.origin, self.map)\n\n    def _calculate_diff_origin(self, height: int, width: int) -> Pose:\n        \"\"\"\n        Calculates the difference between the origin of the costmap\n        as stated by the meta-data and the actual middle of the costmap which\n        is used by PyCRAM to visualize the costmap. The origin as stated by the\n        meta-data refers to the position of the global coordinate frame with\n        the bottom left corner as reference.\n\n        :param height: The height of the costmap\n        :param width: The width of the costmap\n        :return: The difference between the actual origin and center of the costmap\n        \"\"\"\n        actual_origin = [int(height / 2) * self.resolution, int(width / 2) * self.resolution, 0]\n        origin = np.array(self.meta_origin) + np.array(actual_origin)\n        return Pose(origin.tolist())\n\n    @staticmethod\n    def _get_map() -> np.ndarray:\n        \"\"\"\n        Receives the map array from the map_server converts it and into a numpy array.\n\n        :return: The costmap as a numpy array.\n        \"\"\"\n        print(\"Waiting for Map\")\n        map = rospy.wait_for_message(\"/map\", OccupancyGrid)\n        print(\"Recived Map\")\n        return np.array(map.data)\n\n    @staticmethod\n    def _get_map_metadata() -> MapMetaData:\n        \"\"\"\n        Receives the meta-data about the costmap from the map_server and returns it.\n        The meta-data contains things like, height, width, origin and resolution.\n\n        :return: The meta-data for the costmap array.\n        \"\"\"\n        print(\"Waiting for Map Meta Data\")\n        meta = rospy.wait_for_message(\"/map_metadata\", MapMetaData)\n        print(\"Recived Meta Data\")\n        return meta\n\n    def _convert_map(self, map: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Converts the Occupancy Map received from ROS to be more consistent\n        with how PyCRAM handles its costmap. Every possible cell for a robot to stand\n        is set to one while anything else is set to zero. Additionally, this method\n        also takes into account the distance_to_obstacle parameter and sets cell values\n        that are too close to an obstacle to 0.\n\n        :param map: The map that should be converted. Represented as 2d numpy array\n        :return: The converted map. Represented as 2d numpy array.\n        \"\"\"\n        map = np.pad(map, (int(self.distance_obstacle / 2), int(self.distance_obstacle / 2)))\n\n        sub_shape = (self.distance_obstacle, self.distance_obstacle)\n        view_shape = tuple(np.subtract(map.shape, sub_shape) + 1) + sub_shape\n        strides = map.strides + map.strides\n\n        sub_matrices = np.lib.stride_tricks.as_strided(map, view_shape, strides)\n        sub_matrices = sub_matrices.reshape(sub_matrices.shape[:-2] + (-1,))\n        sum = np.sum(sub_matrices, axis=2)\n        return (sum == 0).astype('int16')\n\n    def create_sub_map(self, sub_origin: Pose, size: int) -> Costmap:\n        \"\"\"\n        Creates a smaller map from the overall occupancy map, the new map is centered\n        around the point specified by \"sub_origin\" and has the size \"size\". The\n        resolution of the costmap stays the same for the sub costmap.\n\n        :param sub_origin: The point in global coordinate frame, around which the sub costmap should be centered.\n        :param size: The size the sub costmap should have.\n        :return: The sub costmap, represented as 2d numpy array.\n        \"\"\"\n        # To ensure this is a numpy array\n        sub_origin = np.array(sub_origin.position_as_list())\n        # Since origin obtained from the meta data uses bottom left corner as reference.\n        sub_origin *= -1\n        # Calculates origin of sub costmap as vector between origin and given sub_origin\n        new_origin = np.array(self.meta_origin) + sub_origin\n        # Convert from vector in meter to index values\n        new_origin /= self.resolution\n        new_origin = np.abs(new_origin)\n        # Offset to top left corner, for easier slicing\n        new_origin = (new_origin - size / 2).astype(int)\n\n        # slices a submap with size \"size\" around the given origin\n        sub_map = self.original_map[new_origin[1]: new_origin[1] + size,\n                  new_origin[0]: new_origin[0] + size]\n        # Convert map to fit with the other costmaps\n        sub_map = np.rot90(np.flip(self._convert_map(sub_map), 0))\n        return Costmap(self.resolution, size, size, Pose(list(sub_origin * -1)), sub_map)\n\n    def _create_from_world(self, size: int, resolution: float) -> np.ndarray:\n        \"\"\"\n        Creates an Occupancy Costmap for the specified World.\n        This map marks every position as valid that has no object above it. After\n        creating the costmap the distance to obstacle parameter is applied.\n\n        :param size: The size of this costmap. The size specifies the length of one side of the costmap. The costmap is created as a square.\n        :param resolution: The resolution of this costmap. This determines how much meter a pixel in the costmap represents.\n        \"\"\"\n        origin_position = self.origin.position_as_list()\n        # Generate 2d grid with indices\n        indices = np.concatenate(np.dstack(np.mgrid[int(-size / 2):int(size / 2), int(-size / 2):int(size / 2)]),\n                                 axis=0) * resolution + np.array(origin_position[:2])\n        # Add the z-coordinate to the grid, which is either 0 or 10\n        indices_0 = np.pad(indices, (0, 1), mode='constant', constant_values=5)[:-1]\n        indices_10 = np.pad(indices, (0, 1), mode='constant', constant_values=0)[:-1]\n        # Zips both arrays such that there are tuples for every coordinate that\n        # only differ in the z-coordinate\n        rays = np.dstack(np.dstack((indices_0, indices_10))).T\n\n        res = np.zeros(len(rays))\n        # Using the World rayTest to check if there is an object above the position\n        # if there is no object the position is marked as valid\n        # 16383 is the maximal number of rays that can be processed in a batch\n        i = 0\n        j = 0\n        for n in self._chunks(np.array(rays), 16380):\n            # with UseProspectionWorld():\n            r_t = World.current_world.ray_test_batch(n[:, 0], n[:, 1], num_threads=0)\n            while r_t is None:\n                r_t = World.current_world.ray_test_batch(n[:, 0], n[:, 1], num_threads=0)\n            j += len(n)\n            if World.robot:\n                attached_objs_id = [o.id for o in self.world.robot.attachments.keys()]\n                res[i:j] = [\n                    1 if ray[0] == -1 or ray[0] == self.world.robot.id or ray[0] in attached_objs_id else 0 for\n                    ray in r_t]\n            else:\n                res[i:j] = [1 if ray[0] == -1 else 0 for ray in r_t]\n            i += len(n)\n\n        res = np.flip(np.reshape(np.array(res), (size, size)))\n\n        map = np.pad(res, (int(self.distance_obstacle / 2), int(self.distance_obstacle / 2)))\n\n        sub_shape = (self.distance_obstacle * 2, self.distance_obstacle * 2)\n        view_shape = tuple(np.subtract(map.shape, sub_shape) + 1) + sub_shape\n        strides = map.strides + map.strides\n\n        sub_matrices = np.lib.stride_tricks.as_strided(map, view_shape, strides)\n        sub_matrices = sub_matrices.reshape(sub_matrices.shape[:-2] + (-1,))\n\n        sum = np.sum(sub_matrices, axis=2)\n        map = (sum == (self.distance_obstacle * 2) ** 2).astype('int16')\n        # The map loses some size due to the strides and because I dont want to\n        # deal with indices outside of the index range\n        offset = self.size - map.shape[0]\n        odd = 0 if offset % 2 == 0 else 1\n        map = np.pad(map, (offset // 2, offset // 2 + odd))\n\n        return np.flip(map)\n\n    def _chunks(self, lst: List, n: int) -> List:\n        \"\"\"\n        Yield successive n-sized chunks from lst.\n\n        :param lst: The list from which chunks should be yielded\n        :param n: Size of the chunks\n        :return: A list of size n from lst\n        \"\"\"\n        for i in range(0, len(lst), n):\n            yield lst[i:i + n]\n\n\nclass VisibilityCostmap(Costmap):\n    \"\"\"\n    A costmap that represents the visibility of a specific point for every position around\n    this point. For a detailed explanation on how the creation of the costmap works\n    please look here: `PhD Thesis (page 173) <https://mediatum.ub.tum.de/doc/1239461/1239461.pdf>`_\n    \"\"\"\n\n    def __init__(self, min_height: float,\n                 max_height: float,\n                 size: Optional[int] = 100,\n                 resolution: Optional[float] = 0.02,\n                 origin: Optional[Pose] = None,\n                 world: Optional[World] = None):\n        \"\"\"\n        Visibility Costmaps show for every position around the origin pose if the origin can be seen from this pose.\n        The costmap is able to deal with height differences of the camera while in a single position, for example, if\n        the robot has a movable torso.\n\n        :param min_height: This is the minimal height the camera can be. This parameter\n            is mostly relevant if the vertical position of the camera can change.\n        :param max_height: This is the maximal height the camera can be. This is\n            mostly relevant if teh vertical position of the camera can change.\n        :param size: The length of the side of the costmap, the costmap is created\n            as a square.\n        :param resolution: This parameter specifies how much meter a pixel in the\n            costmap represents.\n        :param origin: The pose in world coordinate frame around which the\n            costmap should be created.\n        :param world: The World for which the costmap should be created.\n        \"\"\"\n        if (11 * size ** 2 + size ** 3) * 2 > psutil.virtual_memory().available:\n            raise OSError(\"Not enough free RAM to calculate a costmap of this size\")\n\n        self.world = world if world else World.current_world\n        self.map = np.zeros((size, size))\n        self.size = size\n        self.resolution = resolution\n        # for pr2 = 1.27\n        self.max_height: float = max_height\n        # for pr2 = 1.6\n        self.min_height: float = min_height\n        self.origin: Pose = Pose() if not origin else origin\n        self._generate_map()\n        Costmap.__init__(self, resolution, size, size, self.origin, self.map)\n\n    def _create_images(self) -> List[np.ndarray]:\n        \"\"\"\n        Creates four depth images in every direction around the point\n        for which the costmap should be created. The depth images are converted\n        to metre, meaning that every entry in the depth images represents the\n        distance to the next object in metre.\n\n        :return: A list of four depth images, the images are represented as 2D arrays.\n        \"\"\"\n        images = []\n        camera_pose = self.origin\n\n        with UseProspectionWorld():\n            origin_copy = self.origin.copy()\n            origin_copy.position.y += 1\n            images.append(\n                self.world.get_images_for_target(origin_copy, camera_pose, size=self.size)[1])\n\n            origin_copy = self.origin.copy()\n            origin_copy.position.x -= 1\n            images.append(self.world.get_images_for_target(origin_copy, camera_pose, size=self.size)[1])\n\n            origin_copy = self.origin.copy()\n            origin_copy.position.y -= 1\n            images.append(self.world.get_images_for_target(origin_copy, camera_pose, size=self.size)[1])\n\n            origin_copy = self.origin.copy()\n            origin_copy.position.x += 1\n            images.append(self.world.get_images_for_target(origin_copy, camera_pose, size=self.size)[1])\n\n        for i in range(0, 4):\n            images[i] = self._depth_buffer_to_meter(images[i])\n        return images\n\n    def _depth_buffer_to_meter(self, buffer: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Converts the depth images generated by the World to represent\n        each position in metre.\n\n        :return: The depth image in metre\n        \"\"\"\n        near = 0.2\n        far = 100\n        return far * near / (far - (far - near) * buffer)\n\n    def _generate_map(self):\n        \"\"\"\n        This method generates the resulting density map by using the algorithm explained\n        in Lorenz MÃ¶senlechners `PhD Thesis (page 178) <https://mediatum.ub.tum.de/doc/1239461/1239461.pdf>`_\n        The resulting map is then saved to :py:attr:`self.map`\n        \"\"\"\n        depth_imgs = self._create_images()\n        # A 2D array where every cell contains the arctan2 value with respect to\n        # the middle of the array. Additionally, the interval is shifted such that\n        # it is between 0 and 2pi\n        tan = np.arctan2(np.mgrid[-int(self.size / 2): int(self.size / 2), -int(self.size / 2): int(self.size / 2)][0],\n                         np.mgrid[-int(self.size / 2): int(self.size / 2), -int(self.size / 2): int(self.size / 2)][\n                             1]) + np.pi\n        res = np.zeros(tan.shape)\n\n        # Just for completion, since the res array has zeros in every position this\n        # operation is not necessary.\n        # res[np.logical_and(tan <= np.pi * 0.25, tan >= np.pi * 1.75)] = 0\n\n        # Creates a 2D array which contains the index of the depth image for every\n        # coordinate\n        res[np.logical_and(tan >= np.pi * 1.25, tan <= np.pi * 1.75)] = 3\n        res[np.logical_and(tan >= np.pi * 0.75, tan < np.pi * 1.25)] = 2\n        res[np.logical_and(tan >= np.pi * 0.25, tan < np.pi * 0.75)] = 1\n\n        indices = np.dstack(np.mgrid[0: self.size, 0: self.size])\n        depth_indices = np.zeros(indices.shape)\n        # x-value of index: res == n, :1\n        # y-value of index: res == n, 1:2\n\n        # (y, size-x-1) for index between 1.25 pi and 1.75 pi\n        depth_indices[res == 3, :1] = indices[res == 3, 1:2]\n        depth_indices[res == 3, 1:2] = self.size - indices[res == 3, :1] - 1\n\n        # (size-x-1, y) for index between 0.75 pi and 1.25 pi\n        depth_indices[res == 2, :1] = self.size - indices[res == 2, :1] - 1\n        depth_indices[res == 2, 1:2] = indices[res == 2, 1:2]\n\n        # (size-y-1, x) for index between 0.25 pi and 0.75 pi\n        depth_indices[res == 1, :1] = self.size - indices[res == 1, 1:2] - 1\n        depth_indices[res == 1, 1:2] = indices[res == 1, :1]\n\n        # (x, y) for index between 0.25 pi and 1.75 pi\n        depth_indices[res == 0, :1] = indices[res == 0, :1]\n        depth_indices[res == 0, 1:2] = indices[res == 0, 1:2]\n\n        # Convert back to origin in the middle of the costmap\n        depth_indices[:, :, :1] -= self.size / 2\n        depth_indices[:, :, 1:2] = np.absolute(self.size / 2 - depth_indices[:, :, 1:2])\n\n        # Sets the y index for the coordinates of the middle of the costmap to 1,\n        # the computed value is 0 which would cause an error in the next step where\n        # the calculation divides the x coordinates by the y coordinates\n        depth_indices[int(self.size / 2), int(self.size / 2), 1] = 1\n\n        # Calculate columns for the respective position in the costmap\n        columns = np.around(((depth_indices[:, :, :1] / depth_indices[:, :, 1:2])\n                             * (self.size / 2)) + self.size / 2).reshape((self.size, self.size)).astype('int16')\n\n        # An array with size * size that contains the euclidean distance to the\n        # origin (in the middle of the costmap) from every cell\n        distances = np.maximum(np.linalg.norm(np.dstack(np.mgrid[-int(self.size / 2): int(self.size / 2), \\\n                                                        -int(self.size / 2): int(self.size / 2)]), axis=2), 0.001)\n\n        # Row ranges\n        # Calculation of the ranges of coordinates in the row which have to be\n        # taken into account. The range is from r_min to r_max.\n        # These are two arrays with shape: size*size, the r_min constrains the beginning\n        # of the range for every coordinate and r_max contains the end for each\n        # coordinate\n        r_min = (np.arctan((self.min_height - self.origin.position.z) / distances) * self.size) + self.size / 2\n        r_max = (np.arctan((self.max_height - self.origin.position.z) / distances) * self.size) + self.size / 2\n\n        r_min = np.minimum(np.around(r_min), self.size - 1).astype('int16')\n        r_max = np.minimum(np.around(r_max), self.size - 1).astype('int16')\n\n        rs = np.dstack((r_min, r_max + 1)).reshape((self.size ** 2, 2))\n        r = np.arange(self.size)\n        # Calculates a mask from the r_min and r_max values. This mask is for every\n        # coordinate respectively and determines which values from the computed column\n        # of the depth image should be taken into account for the costmap.\n        # A Mask of a single coordinate has the length of the column of the depth image\n        # and together with the computed column at this coordinate determines which\n        # values of the depth image make up the value of the visibility costmap at this\n        # point.\n        mask = ((rs[:, 0, None] <= r) & (rs[:, 1, None] > r)).reshape((self.size, self.size, self.size))\n\n        values = np.zeros((self.size, self.size))\n        map = np.zeros((self.size, self.size))\n        # This is done to iterate over the depth images one at a time\n        for i in range(4):\n            row_masks = mask[res == i].T\n            # This statement does several things, first it takes the values from\n            # the depth image for this quarter of the costmap. The values taken are\n            # the complete columns of the depth image (which where computed beforehand)\n            # and checks if the values in them are greater than the distance to the\n            # respective coordinates. This does not take the row ranges into account.\n            values = depth_imgs[i][:, columns[res == i].flatten()] > \\\n                     np.tile(distances[res == i][:, None], (1, self.size)).T * self.resolution\n            # This applies the created mask of the row ranges to the values of\n            # the columns which are compared in the previous statement\n            masked = np.ma.masked_array(values, mask=~row_masks)\n            # The calculated values are added to the costmap\n            map[res == i] = np.sum(masked, axis=0)\n        map /= np.max(map)\n        # Weird flipping shit so that the map fits the orientation of the visualization.\n        # the costmap in itself is consistent and just needs to be flipped to fit the world coordinate system\n        map = np.flip(map, axis=0)\n        map = np.flip(map)\n        self.map = map\n\n\nclass GaussianCostmap(Costmap):\n    \"\"\"\n    Gaussian Costmaps are 2D gaussian distributions around the origin with the given mean and sigma\n    \"\"\"\n\n    def __init__(self, mean: int, sigma: float, resolution: Optional[float] = 0.02,\n                 origin: Optional[Pose] = None):\n        \"\"\"\n        This Costmap creates a 2D gaussian distribution around the origin with\n        the specified size.\n\n        :param mean: The mean input for the gaussian distribution, this also specifies\n            the length of the side of the resulting costmap. The costmap is Created\n            as a square.\n        :param sigma: The sigma input for the gaussian distribution.\n        :param resolution: The resolution of the costmap, this specifies how much\n            meter a pixel represents.\n        :param origin: The origin of the costmap around which it will be created.\n        \"\"\"\n        self.gau: np.ndarray = self._gaussian_window(mean, sigma)\n        self.map: np.ndarray = np.outer(self.gau, self.gau)\n        self.size: float = mean\n        self.origin: Pose = Pose() if not origin else origin\n        Costmap.__init__(self, resolution, mean, mean, self.origin, self.map)\n\n    def _gaussian_window(self, mean: int, std: float) -> np.ndarray:\n        \"\"\"\n        This method creates a window of values with a gaussian distribution of\n        size \"mean\" and standart deviation \"std\".\n        Code from `Scipy <https://github.com/scipy/scipy/blob/v0.14.0/scipy/signal/windows.py#L976>`_\n        \"\"\"\n        n = np.arange(0, mean) - (mean - 1.0) / 2.0\n        sig2 = 2 * std * std\n        w = np.exp(-n ** 2 / sig2)\n        return w\n\n\nclass SemanticCostmap(Costmap):\n    \"\"\"\n    Semantic Costmaps represent a 2D distribution over a link of an Object. An example of this would be a Costmap for a\n    table surface.\n    \"\"\"\n\n    def __init__(self, object, urdf_link_name, size=100, resolution=0.02, world=None):\n        \"\"\"\n        Creates a semantic costmap for the given parameter. The semantic costmap will be on top of the link of the given\n        Object.\n\n        :param object: The object of which the link is a part\n        :param urdf_link_name: The link name, as stated in the URDF\n        :param resolution: Resolution of the final costmap\n        :param world: The World from which the costmap should be created\n        \"\"\"\n        self.world: World = world if world else World.current_world\n        self.object: Object = object\n        self.link: Link = object.get_link(urdf_link_name)\n        self.resolution: float = resolution\n        self.origin: Pose = object.get_link_pose(urdf_link_name)\n        self.height: int = 0\n        self.width: int = 0\n        self.map: np.ndarray = []\n        self.generate_map()\n\n        Costmap.__init__(self, resolution, self.height, self.width, self.origin, self.map)\n\n    def generate_map(self) -> None:\n        \"\"\"\n        Generates the semantic costmap according to the provided parameters. To do this the axis aligned bounding box (AABB)\n        for the link name will be used. Height and width of the final Costmap will be the x and y sizes of the AABB.\n        \"\"\"\n        min_p, max_p = self.get_aabb_for_link().get_min_max_points()\n        self.height = int((max_p.x - min_p.x) // self.resolution)\n        self.width = int((max_p.y - min_p.y) // self.resolution)\n        self.map = np.ones((self.height, self.width))\n\n    def get_aabb_for_link(self) -> AxisAlignedBoundingBox:\n        \"\"\"\n        Returns the axis aligned bounding box (AABB) of the link provided when creating this costmap. To try and let the\n        AABB as close to the actual object as possible, the Object will be rotated such that the link will be in the\n        identity orientation.\n\n        :return: Two points in world coordinate space, which span a rectangle\n        \"\"\"\n        prospection_object = World.current_world.get_prospection_object_for_object(self.object)\n        with UseProspectionWorld():\n            prospection_object.set_orientation(Pose(orientation=[0, 0, 0, 1]))\n            link_pose_trans = self.link.transform\n            inverse_trans = link_pose_trans.invert()\n            prospection_object.set_orientation(inverse_trans.to_pose())\n            return self.link.get_axis_aligned_bounding_box()\n\n\ncmap = colors.ListedColormap(['white', 'black', 'green', 'red', 'blue'])\n\n\n# Mainly used for debugging\n# Data is 2d array\ndef plot_grid(data: np.ndarray) -> None:\n    \"\"\"\n    An auxiliary method only used for debugging, it will plot a 2D numpy array using MatplotLib.\n    \"\"\"\n    rows = data.shape[0]\n    cols = data.shape[1]\n    fig, ax = plt.subplots()\n    ax.imshow(data, cmap=cmap)\n    # draw gridlines\n    # ax.grid(which='major', axis='both', linestyle='-', rgba_color='k', linewidth=1)\n    ax.set_xticks(np.arange(0.5, rows, 1));\n    ax.set_yticks(np.arange(0.5, cols, 1));\n    plt.tick_params(axis='both', labelsize=0, length=0)\n    # fig.set_size_inches((8.5, 11), forward=False)\n    # plt.savefig(saveImageName + \".png\", dpi=500)\n    plt.show()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the description.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<description.py>#\nfrom __future__ import annotations\n\nimport logging\nimport pathlib\nfrom abc import ABC, abstractmethod\n\nimport rospy\nfrom geometry_msgs.msg import Point, Quaternion\nfrom typing_extensions import Tuple, Union, Any, List, Optional, Dict, TYPE_CHECKING\n\nfrom .datastructures.enums import JointType\nfrom .local_transformer import LocalTransformer\nfrom .datastructures.pose import Pose, Transform\nfrom .datastructures.world import WorldEntity\nfrom .datastructures.dataclasses import JointState, AxisAlignedBoundingBox, Color, LinkState, VisualShape\n\nif TYPE_CHECKING:\n    from .world_concepts.world_object import Object\n\n\nclass EntityDescription(ABC):\n\n    \"\"\"\n    A class that represents a description of an entity. This can be a link, joint or object description.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def origin(self) -> Pose:\n        \"\"\"\n        Returns the origin of this entity.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        Returns the name of this entity.\n        \"\"\"\n        pass\n\n\nclass LinkDescription(EntityDescription):\n    \"\"\"\n    A class that represents a link description of an object.\n    \"\"\"\n\n    def __init__(self, parsed_link_description: Any):\n        self.parsed_description = parsed_link_description\n\n    @property\n    @abstractmethod\n    def geometry(self) -> Union[VisualShape, None]:\n        \"\"\"\n        Returns the geometry type of the collision element of this link.\n        \"\"\"\n        pass\n\n\nclass JointDescription(EntityDescription):\n    \"\"\"\n    A class that represents the description of a joint.\n    \"\"\"\n\n    def __init__(self, parsed_joint_description: Any):\n        self.parsed_description = parsed_joint_description\n\n    @property\n    @abstractmethod\n    def type(self) -> JointType:\n        \"\"\"\n        :return: The type of this joint.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def axis(self) -> Point:\n        \"\"\"\n        :return: The axis of this joint, for example the rotation axis for a revolute joint.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def has_limits(self) -> bool:\n        \"\"\"\n        Checks if this joint has limits.\n\n        :return: True if the joint has limits, False otherwise.\n        \"\"\"\n        pass\n\n    @property\n    def limits(self) -> Tuple[float, float]:\n        \"\"\"\n        :return: The lower and upper limits of this joint.\n        \"\"\"\n        lower, upper = self.lower_limit, self.upper_limit\n        if lower > upper:\n            lower, upper = upper, lower\n        return lower, upper\n\n    @property\n    @abstractmethod\n    def lower_limit(self) -> Union[float, None]:\n        \"\"\"\n        :return: The lower limit of this joint, or None if the joint has no limits.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def upper_limit(self) -> Union[float, None]:\n        \"\"\"\n        :return: The upper limit of this joint, or None if the joint has no limits.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def parent_link_name(self) -> str:\n        \"\"\"\n        :return: The name of the parent link of this joint.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def child_link_name(self) -> str:\n        \"\"\"\n        :return: The name of the child link of this joint.\n        \"\"\"\n        pass\n\n    @property\n    def damping(self) -> float:\n        \"\"\"\n        :return: The damping of this joint.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def friction(self) -> float:\n        \"\"\"\n        :return: The friction of this joint.\n        \"\"\"\n        raise NotImplementedError\n\n\nclass ObjectEntity(WorldEntity):\n    \"\"\"\n    An abstract base class that represents a physical part/entity of an Object.\n    This can be a link or a joint of an Object.\n    \"\"\"\n\n    def __init__(self, _id: int, obj: Object):\n        WorldEntity.__init__(self, _id, obj.world)\n        self.object: Object = obj\n\n    @property\n    @abstractmethod\n    def pose(self) -> Pose:\n        \"\"\"\n        :return: The pose of this entity relative to the world frame.\n        \"\"\"\n        pass\n\n    @property\n    def transform(self) -> Transform:\n        \"\"\"\n        Returns the transform of this entity.\n\n        :return: The transform of this entity.\n        \"\"\"\n        return self.pose.to_transform(self.tf_frame)\n\n    @property\n    @abstractmethod\n    def tf_frame(self) -> str:\n        \"\"\"\n        Returns the tf frame of this entity.\n\n        :return: The tf frame of this entity.\n        \"\"\"\n        pass\n\n    @property\n    def object_id(self) -> int:\n        \"\"\"\n        :return: the id of the object to which this entity belongs.\n        \"\"\"\n        return self.object.id\n\n\nclass Link(ObjectEntity, LinkDescription, ABC):\n    \"\"\"\n    Represents a link of an Object in the World.\n    \"\"\"\n\n    def __init__(self, _id: int, link_description: LinkDescription, obj: Object):\n        ObjectEntity.__init__(self, _id, obj)\n        LinkDescription.__init__(self, link_description.parsed_description)\n        self.local_transformer: LocalTransformer = LocalTransformer()\n        self.constraint_ids: Dict[Link, int] = {}\n        self._update_pose()\n\n    @property\n    def current_state(self) -> LinkState:\n        return LinkState(self.constraint_ids.copy())\n\n    @current_state.setter\n    def current_state(self, link_state: LinkState) -> None:\n        self.constraint_ids = link_state.constraint_ids\n\n    def add_fixed_constraint_with_link(self, child_link: 'Link') -> int:\n        \"\"\"\n        Adds a fixed constraint between this link and the given link, used to create attachments for example.\n\n        :param child_link: The child link to which a fixed constraint should be added.\n        :return: The unique id of the constraint.\n        \"\"\"\n        constraint_id = self.world.add_fixed_constraint(self,\n                                                        child_link,\n                                                        child_link.get_transform_from_link(self))\n        self.constraint_ids[child_link] = constraint_id\n        child_link.constraint_ids[self] = constraint_id\n        return constraint_id\n\n    def remove_constraint_with_link(self, child_link: 'Link') -> None:\n        \"\"\"\n        Removes the constraint between this link and the given link.\n\n        :param child_link: The child link of the constraint that should be removed.\n        \"\"\"\n        self.world.remove_constraint(self.constraint_ids[child_link])\n        del self.constraint_ids[child_link]\n        if self in child_link.constraint_ids.keys():\n            del child_link.constraint_ids[self]\n\n    @property\n    def is_root(self) -> bool:\n        \"\"\"\n        Returns whether this link is the root link of the object.\n\n        :return: True if this link is the root link, False otherwise.\n        \"\"\"\n        return self.object.get_root_link_id() == self.id\n\n    def update_transform(self, transform_time: Optional[rospy.Time] = None) -> None:\n        \"\"\"\n        Updates the transformation of this link at the given time.\n\n        :param transform_time: The time at which the transformation should be updated.\n        \"\"\"\n        self.local_transformer.update_transforms([self.transform], transform_time)\n\n    def get_transform_to_link(self, link: 'Link') -> Transform:\n        \"\"\"\n        Returns the transformation from this link to the given link.\n\n        :param link: The link to which the transformation should be returned.\n        :return: A Transform object with the transformation from this link to the given link.\n        \"\"\"\n        return link.get_transform_from_link(self)\n\n    def get_transform_from_link(self, link: 'Link') -> Transform:\n        \"\"\"\n        Returns the transformation from the given link to this link.\n\n        :param link: The link from which the transformation should be returned.\n        :return: A Transform object with the transformation from the given link to this link.\n        \"\"\"\n        return self.get_pose_wrt_link(link).to_transform(self.tf_frame)\n\n    def get_pose_wrt_link(self, link: 'Link') -> Pose:\n        \"\"\"\n        Returns the pose of this link with respect to the given link.\n\n        :param link: The link with respect to which the pose should be returned.\n        :return: A Pose object with the pose of this link with respect to the given link.\n        \"\"\"\n        return self.local_transformer.transform_pose(self.pose, link.tf_frame)\n\n    def get_axis_aligned_bounding_box(self) -> AxisAlignedBoundingBox:\n        \"\"\"\n        Returns the axis aligned bounding box of this link.\n\n        :return: An AxisAlignedBoundingBox object with the axis aligned bounding box of this link.\n        \"\"\"\n        return self.world.get_link_axis_aligned_bounding_box(self)\n\n    @property\n    def position(self) -> Point:\n        \"\"\"\n        The getter for the position of the link relative to the world frame.\n\n        :return: A Point object containing the position of the link relative to the world frame.\n        \"\"\"\n        return self.pose.position\n\n    @property\n    def position_as_list(self) -> List[float]:\n        \"\"\"\n        The getter for the position of the link relative to the world frame as a list.\n\n        :return: A list containing the position of the link relative to the world frame.\n        \"\"\"\n        return self.pose.position_as_list()\n\n    @property\n    def orientation(self) -> Quaternion:\n        \"\"\"\n        The getter for the orientation of the link relative to the world frame.\n\n        :return: A Quaternion object containing the orientation of the link relative to the world frame.\n        \"\"\"\n        return self.pose.orientation\n\n    @property\n    def orientation_as_list(self) -> List[float]:\n        \"\"\"\n        The getter for the orientation of the link relative to the world frame as a list.\n\n        :return: A list containing the orientation of the link relative to the world frame.\n        \"\"\"\n        return self.pose.orientation_as_list()\n\n    def _update_pose(self) -> None:\n        \"\"\"\n        Updates the current pose of this link from the world.\n        \"\"\"\n        self._current_pose = self.world.get_link_pose(self)\n\n    @property\n    def pose(self) -> Pose:\n        \"\"\"\n        The pose of the link relative to the world frame.\n\n        :return: A Pose object containing the pose of the link relative to the world frame.\n        \"\"\"\n        return self._current_pose\n\n    @property\n    def pose_as_list(self) -> List[List[float]]:\n        \"\"\"\n        The pose of the link relative to the world frame as a list.\n\n        :return: A list containing the position and orientation of the link relative to the world frame.\n        \"\"\"\n        return self.pose.to_list()\n\n    def get_origin_transform(self) -> Transform:\n        \"\"\"\n        Returns the transformation between the link frame and the origin frame of this link.\n        \"\"\"\n        return self.origin.to_transform(self.tf_frame)\n\n    @property\n    def color(self) -> Color:\n        \"\"\"\n        The getter for the rgba_color of this link.\n\n        :return: A Color object containing the rgba_color of this link.\n        \"\"\"\n        return self.world.get_link_color(self)\n\n    @color.setter\n    def color(self, color: Color) -> None:\n        \"\"\"\n        The setter for the color of this link, could be rgb or rgba.\n\n        :param color: The color as a list of floats, either rgb or rgba.\n        \"\"\"\n        self.world.set_link_color(self, color)\n\n    @property\n    def origin_transform(self) -> Transform:\n        \"\"\"\n        :return: The transform from world to origin of entity.\n        \"\"\"\n        return self.origin.to_transform(self.tf_frame)\n\n    @property\n    def tf_frame(self) -> str:\n        \"\"\"\n        The name of the tf frame of this link.\n        \"\"\"\n        return f\"{self.object.tf_frame}/{self.name}\"\n\n    def __eq__(self, other):\n        return self.id == other.id and self.object == other.object and self.name == other.name\n\n    def __copy__(self):\n        return Link(self.id, self, self.object)\n\n    def __hash__(self):\n        return hash((self.id, self.object, self.name))\n\n\nclass RootLink(Link, ABC):\n    \"\"\"\n    Represents the root link of an Object in the World.\n    It differs from the normal AbstractLink class in that the pose ande the tf_frame is the same as that of the object.\n    \"\"\"\n\n    def __init__(self, obj: Object):\n        super().__init__(obj.get_root_link_id(), obj.get_root_link_description(), obj)\n\n    @property\n    def tf_frame(self) -> str:\n        \"\"\"\n        Returns the tf frame of the root link, which is the same as the tf frame of the object.\n        \"\"\"\n        return self.object.tf_frame\n\n    def _update_pose(self) -> None:\n        self._current_pose = self.object.get_pose()\n\n    def __copy__(self):\n        return RootLink(self.object)\n\n\nclass Joint(ObjectEntity, JointDescription, ABC):\n    \"\"\"\n    Represents a joint of an Object in the World.\n    \"\"\"\n\n    def __init__(self, _id: int,\n                 joint_description: JointDescription,\n                 obj: Object):\n        ObjectEntity.__init__(self, _id, obj)\n        JointDescription.__init__(self, joint_description.parsed_description)\n        self._update_position()\n\n    @property\n    def tf_frame(self) -> str:\n        \"\"\"\n        The tf frame of a joint is the tf frame of the child link.\n        \"\"\"\n        return self.child_link.tf_frame\n\n    @property\n    def pose(self) -> Pose:\n        \"\"\"\n        Returns the pose of this joint. The pose is the pose of the child link of this joint.\n\n        :return: The pose of this joint.\n        \"\"\"\n        return self.child_link.pose\n\n    def _update_position(self) -> None:\n        \"\"\"\n        Updates the current position of the joint from the physics simulator.\n        \"\"\"\n        self._current_position = self.world.get_joint_position(self)\n\n    @property\n    def parent_link(self) -> Link:\n        \"\"\"\n        Returns the parent link of this joint.\n\n        :return: The parent link as a AbstractLink object.\n        \"\"\"\n        return self.object.get_link(self.parent_link_name)\n\n    @property\n    def child_link(self) -> Link:\n        \"\"\"\n        Returns the child link of this joint.\n\n        :return: The child link as a AbstractLink object.\n        \"\"\"\n        return self.object.get_link(self.child_link_name)\n\n    @property\n    def position(self) -> float:\n        return self._current_position\n\n    def reset_position(self, position: float) -> None:\n        self.world.reset_joint_position(self, position)\n        self._update_position()\n\n    def get_object_id(self) -> int:\n        \"\"\"\n        Returns the id of the object to which this joint belongs.\n\n        :return: The integer id of the object to which this joint belongs.\n        \"\"\"\n        return self.object.id\n\n    @position.setter\n    def position(self, joint_position: float) -> None:\n        \"\"\"\n        Sets the position of the given joint to the given joint pose. If the pose is outside the joint limits,\n         an error will be printed. However, the joint will be set either way.\n\n        :param joint_position: The target pose for this joint\n        \"\"\"\n        # TODO Limits for rotational (infinite) joints are 0 and 1, they should be considered separately\n        if self.has_limits:\n            low_lim, up_lim = self.limits\n            if not low_lim <= joint_position <= up_lim:\n                logging.warning(\n                    f\"The joint position has to be within the limits of the joint. The joint limits for {self.name}\"\n                    f\" are {low_lim} and {up_lim}\")\n                logging.warning(f\"The given joint position was: {joint_position}\")\n                # Temporarily disabled because kdl outputs values exciting joint limits\n                # return\n        self.reset_position(joint_position)\n\n    def enable_force_torque_sensor(self) -> None:\n        self.world.enable_joint_force_torque_sensor(self.object, self.id)\n\n    def disable_force_torque_sensor(self) -> None:\n        self.world.disable_joint_force_torque_sensor(self.object, self.id)\n\n    def get_reaction_force_torque(self) -> List[float]:\n        return self.world.get_joint_reaction_force_torque(self.object, self.id)\n\n    def get_applied_motor_torque(self) -> float:\n        return self.world.get_applied_joint_motor_torque(self.object, self.id)\n\n    @property\n    def current_state(self) -> JointState:\n        return JointState(self.position)\n\n    @current_state.setter\n    def current_state(self, joint_state: JointState) -> None:\n        \"\"\"\n        Updates the current state of this joint from the given joint state if the position is different.\n\n        :param joint_state: The joint state to update from.\n        \"\"\"\n        if self._current_position != joint_state.position:\n            self.position = joint_state.position\n\n    def __copy__(self):\n        return Joint(self.id, self, self.object)\n\n    def __eq__(self, other):\n        return self.id == other.id and self.object == other.object and self.name == other.name\n\n    def __hash__(self):\n        return hash((self.id, self.object, self.name))\n\n\nclass ObjectDescription(EntityDescription):\n\n    \"\"\"\n    A class that represents the description of an object.\n    \"\"\"\n\n    mesh_extensions: Tuple[str] = (\".obj\", \".stl\", \".dae\")\n    \"\"\"\n    The file extensions of the mesh files that can be used to generate a description file.\n    \"\"\"\n\n    class Link(Link, ABC):\n        ...\n\n    class RootLink(RootLink, ABC):\n        ...\n\n    class Joint(Joint, ABC):\n        ...\n\n    def __init__(self, path: Optional[str] = None):\n        \"\"\"\n        :param path: The path of the file to update the description data from.\n        \"\"\"\n        if path:\n            self.update_description_from_file(path)\n        else:\n            self._parsed_description = None\n\n    def update_description_from_file(self, path: str) -> None:\n        \"\"\"\n        Updates the description of this object from the file at the given path.\n\n        :param path: The path of the file to update from.\n        \"\"\"\n        self._parsed_description = self.load_description(path)\n\n    @property\n    def parsed_description(self) -> Any:\n        \"\"\"\n        Return the object parsed from the description file.\n        \"\"\"\n        return self._parsed_description\n\n    @parsed_description.setter\n    def parsed_description(self, parsed_description: Any):\n        \"\"\"\n        :param parsed_description: The parsed description object (depends on the description file type).\n        \"\"\"\n        self._parsed_description = parsed_description\n\n    @abstractmethod\n    def load_description(self, path: str) -> Any:\n        \"\"\"\n        Loads the description from the file at the given path.\n\n        :param path: The path to the source file, if only a filename is provided then the resources directories will be\n         searched.\n        \"\"\"\n        pass\n\n    def generate_description_from_file(self, path: str, name: str, extension: str) -> str:\n        \"\"\"\n        Generates and preprocesses the description from the file at the given path and returns the preprocessed\n        description as a string.\n\n        :param path: The path of the file to preprocess.\n        :param name: The name of the object.\n        :param extension: The file extension of the file to preprocess.\n        :return: The processed description string.\n        \"\"\"\n        description_string = None\n\n        if extension in self.mesh_extensions:\n            description_string = self.generate_from_mesh_file(path, name)\n        elif extension == self.get_file_extension():\n            description_string = self.generate_from_description_file(path)\n        else:\n            try:\n                # Using the description from the parameter server\n                description_string = self.generate_from_parameter_server(path)\n            except KeyError:\n                logging.warning(f\"Couldn't find dile data in the ROS parameter server\")\n        if description_string is None:\n            logging.error(f\"Could not find file with path {path} in the resources directory nor\"\n                          f\" in the ros parameter server.\")\n            raise FileNotFoundError\n\n        return description_string\n\n    def get_file_name(self, path_object: pathlib.Path, extension: str, object_name: str) -> str:\n        \"\"\"\n        Returns the file name of the description file.\n\n        :param path_object: The path object of the description file or the mesh file.\n        :param extension: The file extension of the description file or the mesh file.\n        :param object_name: The name of the object.\n        :return: The file name of the description file.\n        \"\"\"\n        if extension in self.mesh_extensions:\n            file_name = path_object.stem + self.get_file_extension()\n        elif extension == self.get_file_extension():\n            file_name = path_object.name\n        else:\n            file_name = object_name + self.get_file_extension()\n\n        return file_name\n\n    @classmethod\n    @abstractmethod\n    def generate_from_mesh_file(cls, path: str, name: str) -> str:\n        \"\"\"\n        Generates a description file from one of the mesh types defined in the mesh_extensions and\n        returns the path of the generated file.\n\n        :param path: The path to the .obj file.\n        :param name: The name of the object.\n        :return: The path of the generated description file.\n        \"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def generate_from_description_file(cls, path: str) -> str:\n        \"\"\"\n        Preprocesses the given file and returns the preprocessed description string.\n\n        :param path: The path of the file to preprocess.\n        :return: The preprocessed description string.\n        \"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def generate_from_parameter_server(cls, name: str) -> str:\n        \"\"\"\n        Preprocesses the description from the ROS parameter server and returns the preprocessed description string.\n\n        :param name: The name of the description on the parameter server.\n        :return: The preprocessed description string.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def links(self) -> List[LinkDescription]:\n        \"\"\"\n        :return: A list of links descriptions of this object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_link_by_name(self, link_name: str) -> LinkDescription:\n        \"\"\"\n        :return: The link description with the given name.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def joints(self) -> List[JointDescription]:\n        \"\"\"\n        :return: A list of joints descriptions of this object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_joint_by_name(self, joint_name: str) -> JointDescription:\n        \"\"\"\n        :return: The joint description with the given name.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_root(self) -> str:\n        \"\"\"\n        :return: the name of the root link of this object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_chain(self, start_link_name: str, end_link_name: str) -> List[str]:\n        \"\"\"\n        :return: the chain of links from 'start_link_name' to 'end_link_name'.\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def get_file_extension() -> str:\n        \"\"\"\n        :return: The file extension of the description file.\n        \"\"\"\n        pass\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the designator.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<designator.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field, fields\nfrom abc import ABC, abstractmethod\nfrom inspect import isgenerator, isgeneratorfunction\n\nimport rospy\ntry:\n    import owlready2\nexcept ImportError:\n    owlready2 = None\n    rospy.logwarn(\"owlready2 is not installed!\")\n\nfrom sqlalchemy.orm.session import Session\n\nfrom .datastructures.world import World\nfrom .world_concepts.world_object import Object as WorldObject\nfrom .utils import GeneratorList, bcolors\nfrom threading import Lock\nfrom time import time\nfrom typing_extensions import Type, List, Dict, Any, Optional, Union, get_type_hints, Callable, Iterable, TYPE_CHECKING, get_args, get_origin\n\nfrom .local_transformer import LocalTransformer\nfrom .language import Language\nfrom .datastructures.pose import Pose\nfrom .robot_description import RobotDescription\nfrom .datastructures.enums import ObjectType\n\nimport logging\n\nfrom .orm.action_designator import (Action as ORMAction)\nfrom .orm.object_designator import (Object as ORMObjectDesignator)\nfrom .orm.motion_designator import Motion as ORMMotionDesignator\n\nfrom .orm.base import RobotState, ProcessMetaData\nfrom .tasktree import with_tree\n\nif TYPE_CHECKING:\n    from .ontology.ontology_common import OntologyConceptHolder\n\n\nclass DesignatorError(Exception):\n    \"\"\"Implementation of designator errors.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Create a new designator error.\"\"\"\n        Exception.__init__(self, *args, **kwargs)\n\n\nclass ResolutionError(Exception):\n    def __init__(self, missing_properties: List[str], wrong_type: Dict, current_type: Any, designator: Designator):\n        self.error = f\"\\nSome requiered properties where missing or had the wrong type when grounding the Designator: {designator}.\\n\"\n        self.missing = f\"The missing properties where: {missing_properties}\\n\"\n        self.wrong = f\"The properties with the wrong type along with the currrent -and right type :\\n\"\n        self.head = \"Property   |   Current Type    |     Right Type\\n-------------------------------------------------------------\\n\"\n        self.tab = \"\"\n        for prop in wrong_type.keys():\n            self.tab += prop + \"     \" + str(current_type[prop]) + \"      \" + str(wrong_type[prop]) + \"\\n\"\n        self.message = self.error\n        if missing_properties != []:\n            self.message += self.missing\n        if wrong_type != {}:\n            self.message += self.wrong + self.head + self.tab\n        self.message = f\"{bcolors.BOLD}{bcolors.FAIL}\" + self.message + f\"{bcolors.ENDC}\"\n        super(ResolutionError, self).__init__(self.message)\n\n\nclass Designator(ABC):\n    \"\"\"\n    Implementation of designators. DEPRECTAED SINCE DESIGNATOR DESCRIPTIONS ARE USED AS BASE CLASS\n\n    Designators are objects containing sequences of key-value pairs. They can be resolved which means to generate real\n    parameters for executing performables from these pairs of key and value.\n\n    :ivar timestamp: The timestamp of creation of reference or None if still not referencing an object.\n    \"\"\"\n\n\n    resolvers = {}\n    \"\"\"\n    List of all designator resolvers. Designator resolvers are functions which take a designator as\n    argument and return a list of solutions. A solution can also be a generator. \n    \"\"\"\n\n    def __init__(self, description: DesignatorDescription, parent: Optional[Designator] = None):\n        \"\"\"Create a new desginator.\n\n        Arguments:\n        :param description: A list of tuples (key-value pairs) describing this designator.\n        :param parent: The parent to equate with (default is None).\n        \"\"\"\n        self._mutex: Lock = Lock()\n        self._parent: Union[Designator, None] = None\n        self._successor: Union[Designator, None] = None\n        self._effective: bool = False\n        self._data: Any = None\n        self._solutions = None\n        self._index: int = 0\n        self.timestamp = None\n        self._description: DesignatorDescription = description\n\n        if parent is not None:\n            self.equate(parent)\n\n    def equate(self, parent: Designator) -> None:\n        \"\"\"Equate the designator with the given parent.\n\n        Arguments:\n        parent -- the parent to equate with.\n        \"\"\"\n        if self.equal(parent):\n            return\n\n        youngest_parent = parent.current()\n        first_parent = parent.first()\n\n        if self._parent is not None:\n            first_parent._parent = self._parent\n            first_parent._parent._successor = first_parent\n\n        self._parent = youngest_parent\n        youngest_parent._successor = self\n\n    def equal(self, other: Designator) -> bool:\n        \"\"\"Check if the designator describes the same entity as another designator, i.e. if they are equated.\n\n        Arguments:\n        other -- the other designator.\n        \"\"\"\n        return other.first() is self.first()\n\n    def first(self) -> Designator:\n        \"\"\"Return the first ancestor in the chain of equated designators.\"\"\"\n        if self._parent is None:\n            return self\n\n        return self._parent.first()\n\n    def current(self) -> Designator:\n        \"\"\"Return the newest designator, i.e. that one that has been equated last to the designator or one of its\n        equated designators.\"\"\"\n        if self._successor is None:\n            return self\n\n        return self._successor.current()\n\n    def _reference(self) -> Any:\n        \"\"\"This is a helper method for internal usage only.\n\n        This method is to be overwritten instead of the reference method.\n        \"\"\"\n        resolver = self.resolvers[self._description.resolver]\n        if self._solutions is None:\n            def generator():\n                solution = resolver(self)\n                if isgeneratorfunction(solution):\n                    solution = solution()\n\n                if isgenerator(solution):\n                    while True:\n                        try:\n                            yield next(solution)\n                        except StopIteration:\n                            break\n                else:\n                    yield solution\n\n            self._solutions = GeneratorList(generator)\n\n        if self._data is not None:\n            return self._data\n\n        try:\n            self._data = self._solutions.get(self._index)\n            return self._data\n        except StopIteration:\n            raise DesignatorError('There was no Solution for this Designator')\n\n    def reference(self) -> Any:\n        \"\"\"Try to dereference the designator and return its data object or raise DesignatorError if it is not an\n        effective designator. \"\"\"\n        with self._mutex:\n            ret = self._reference()\n\n        self._effective = True\n\n        if self.timestamp is None:\n            self.timestamp = time()\n\n        return ret\n\n    @abstractmethod\n    def next_solution(self):\n        \"\"\"Return another solution for the effective designator or None if none exists. The next solution is a newly\n        constructed designator with identical properties that is equated to the designator since it describes the same\n        entity. \"\"\"\n        pass\n\n    def solutions(self, from_root: Optional[Designator] = None):\n        \"\"\"Return a generator for all solutions of the designator.\n\n        Arguments:\n        from_root -- if not None, the generator for all solutions beginning from with the original designator is returned (default is None).\n        \"\"\"\n        if from_root is not None:\n            desig = self.first()\n        else:\n            desig = self\n\n        def generator(desig):\n            while desig is not None:\n                try:\n                    yield desig.reference()\n                except DesignatorError:\n                    pass\n\n                desig = desig.next_solution()\n\n        return generator(desig)\n\n    def copy(self, new_properties: Optional[List] = None) -> Designator:\n        \"\"\"Construct a new designator with the same properties as this one. If new properties are specified, these will\n        be merged with the old ones while the new properties are dominant in this relation.\n\n        Arguments:\n        new_properties -- a list of new properties to merge into the old ones (default is None).\n        \"\"\"\n        description = self._description.copy()\n\n        if new_properties:\n            for key, value in new_properties:\n                description.__dict__[key] = value\n\n        return self.__class__(description)\n\n    def make_effective(self, properties: Optional[List] = None,\n                       data: Optional[Any] = None,\n                       timestamp: Optional[float] = None) -> Designator:\n        \"\"\"Create a new effective designator of the same type as this one. If no properties are specified, this ones are used.\n\n        Arguments:\n        new_properties -- a list of properties (default is None).\n        data -- the low-level data structure the new designator describes (default is None).\n        timestamp -- the timestamp of creation of reference (default is the current).\n        \"\"\"\n        if properties is None:\n            properties = self._description\n\n        desig = self.__class__(properties)\n        desig._effective = True\n        desig._data = data\n\n        if timestamp is None:\n            desig.timestamp = time()\n        else:\n            desig.timestamp = timestamp\n\n        return desig\n\n    def newest_effective(self) -> Designator:\n        \"\"\"Return the newest effective designator.\"\"\"\n\n        def find_effective(desig):\n            if desig is None or desig._effective:\n                return desig\n\n            return find_effective(desig._parent)\n\n        return find_effective(self.current())\n\n    def prop_value(self, key: str) -> Any:\n        \"\"\"Return the first value matching the specified property key.\n\n        Arguments:\n        key -- the key to return the value of.\n        \"\"\"\n        try:\n            return self._description.__dict__[key]\n        except KeyError:\n            logging.error(f\"The given key '{key}' is not in this Designator\")\n            return None\n\n    def check_constraints(self, properties: List) -> bool:\n        \"\"\"Return True if all the given properties match, False otherwise.\n\n        Arguments:\n        properties -- the properties which have to match. A property can be a tuple in which case its first value is the\n        key of a property which must equal the second value. Otherwise it's simply the key of a property which must be\n        not None.\n        \"\"\"\n        for prop in properties:\n            if type(prop) == tuple:\n                key, value = prop\n\n                if self.prop_value(key) != value:\n                    return False\n            else:\n                if self.prop_value(prop) is None:\n                    return False\n\n        return True\n\n    def make_dictionary(self, properties: List) -> Dict:\n        \"\"\" DEPRECATED, Moved to the description. Function only keept because of\n        backward compatability.\n        Return the given properties as dictionary.\n\n        Arguments:\n        properties -- the properties to create a dictionary of. A property can be a tuple in which case its first value\n        is the dictionary key and the second value is the dictionary value. Otherwise it's simply the dictionary key\n        and the key of a property which is the dictionary value.\n        \"\"\"\n\n        return self._description.make_dictionary(properties)\n\n    def rename_prop(self, old: str, new: str) -> Designator:\n        old_value = self.prop_value(old)\n        if old_value is not None:\n            self._description.__dict__[new] = old_value\n            del self._description.__dict__[old]\n        else:\n            raise DesignatorError(\"Old property does not exists.\")\n        return self.current()\n\n\nclass DesignatorDescription(ABC):\n    \"\"\"\n    :ivar resolve: The specialized_designators function to use for this designator, defaults to self.ground\n    \"\"\"\n\n    def __init__(self, resolver: Optional[Callable] = None, ontology_concept_holders: Optional[List[OntologyConceptHolder]] = None):\n        \"\"\"\n        Create a Designator description.\n\n        :param resolver: The grounding method used for the description. The grounding method creates a location instance that matches the description.\n        :param ontology_concept_holders: A list of holders of ontology concepts that the designator is categorized as or associated with\n        \"\"\"\n\n        if resolver is None:\n            self.resolve = self.ground\n        self.ontology_concept_holders = [] if ontology_concept_holders is None else ontology_concept_holders\n\n    def make_dictionary(self, properties: List[str]):\n        \"\"\"\n        Creates a dictionary of this description with only the given properties\n        included.\n\n        :param properties: A list of properties that should be included in the dictionary.\n                            The given properties have to be an attribute of this description.\n        :return: A dictionary with the properties as keys.\n        \"\"\"\n        attributes = self.__dict__\n        ret = {}\n        for att in attributes.keys():\n            if att in properties:\n                ret[att] = attributes[att]\n        return ret\n\n    def ground(self) -> Any:\n        \"\"\"\n        Should be overwritten with an actual grounding function which infers missing properties.\n        \"\"\"\n        return self\n\n    def get_slots(self) -> List[str]:\n        \"\"\"\n        Returns a list of all slots of this description. Can be used for inspecting different descriptions and debugging.\n\n        :return: A list of all slots.\n        \"\"\"\n        return list(self.__dict__.keys())\n\n    def copy(self) -> DesignatorDescription:\n        return self\n\n    def get_default_ontology_concept(self) -> owlready2.Thing | None:\n        \"\"\"\n        Returns the first element of ontology_concept_holders if there is, else None\n        \"\"\"\n        return self.ontology_concept_holders[0].ontology_concept if self.ontology_concept_holders else None\n\nclass ActionDesignatorDescription(DesignatorDescription, Language):\n    \"\"\"\n    Abstract class for action designator descriptions.\n    Descriptions hold possible parameter ranges for action designators.\n    \"\"\"\n\n    @dataclass\n    class Action:\n        \"\"\"\n        The performable designator with a single element for each list of possible parameter.\n        \"\"\"\n        robot_position: Pose = field(init=False)\n        \"\"\"\n        The position of the robot at the start of the action.\n        \"\"\"\n        robot_torso_height: float = field(init=False)\n        \"\"\"\n        The torso height of the robot at the start of the action.\n        \"\"\"\n\n        robot_type: ObjectType = field(init=False)\n        \"\"\"\n        The type of the robot at the start of the action.\n        \"\"\"\n\n        def __post_init__(self):\n            self.robot_position = World.robot.get_pose()\n            self.robot_torso_height = World.robot.get_joint_position(RobotDescription.current_robot_description.torso_joint)\n            self.robot_type = World.robot.obj_type\n\n        @with_tree\n        def perform(self) -> Any:\n            \"\"\"\n            Executes the action with the single parameters from the description.\n            \"\"\"\n            raise NotImplementedError()\n\n        def to_sql(self) -> ORMAction:\n            \"\"\"\n            Create an ORM object that corresponds to this description.\n\n            :return: The created ORM object.\n            \"\"\"\n            raise NotImplementedError(f\"{type(self)} has no implementation of to_sql. Feel free to implement it.\")\n\n        def insert(self, session: Session, *args, **kwargs) -> ORMAction:\n            \"\"\"\n            Add and commit this and all related objects to the session.\n            Auto-Incrementing primary keys and foreign keys have to be filled by this method.\n\n            :param session: Session with a database that is used to add and commit the objects\n            :param args: Possible extra arguments\n            :param kwargs: Possible extra keyword arguments\n            :return: The completely instanced ORM object\n            \"\"\"\n\n            pose = self.robot_position.insert(session)\n\n            # get or create metadata\n            metadata = ProcessMetaData().insert(session)\n\n            # create robot-state object\n            robot_state = RobotState(self.robot_torso_height, self.robot_type)\n            robot_state.pose = pose\n            robot_state.process_metadata = metadata\n            session.add(robot_state)\n\n            # create action\n            action = self.to_sql()\n            action.process_metadata = metadata\n            action.robot_state = robot_state\n\n            return action\n\n    def __init__(self, resolver=None, ontology_concept_holders: Optional[List[OntologyConceptHolder]] = None):\n        \"\"\"\n        Base of all action designator descriptions.\n\n        :param resolver: An alternative resolver that returns an action designator\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        Language.__init__(self)\n        from .ontology.ontology import OntologyManager\n        self.soma = OntologyManager().soma\n\n    def ground(self) -> Action:\n        \"\"\"Fill all missing parameters and chose plan to execute. \"\"\"\n        raise NotImplementedError(f\"{type(self)}.ground() is not implemented.\")\n\n    def init_ontology_concepts(self, ontology_concept_classes: Dict[str, Type[owlready2.Thing]]):\n        \"\"\"\n        Initialize the ontology concept holders for this action designator\n\n        :param ontology_concept_classes: The ontology concept classes that the action is categorized as or associated with\n        :param ontology_concept_name: The name of the ontology concept instance to be created\n        \"\"\"\n        from .ontology.ontology_common import OntologyConceptHolderStore, OntologyConceptHolder\n        if not self.ontology_concept_holders:\n            for concept_name, concept_class in ontology_concept_classes.items():\n                if concept_class:\n                    existing_holders = OntologyConceptHolderStore().get_ontology_concept_holders_by_class(concept_class)\n                    self.ontology_concept_holders.extend(existing_holders if existing_holders \\\n                                                         else [OntologyConceptHolder(concept_class(concept_name))])\n\n    def __iter__(self):\n        \"\"\"\n        Iterate through all possible performables fitting this description\n\n        :yield: A resolved action designator\n        \"\"\"\n        yield self.ground()\n\n\nclass LocationDesignatorDescription(DesignatorDescription):\n    \"\"\"\n    Parent class of location designator descriptions.\n    \"\"\"\n\n    @dataclass\n    class Location:\n        \"\"\"\n        Resolved location that represents a specific point in the world which satisfies the constraints of the location\n        designator description.\n        \"\"\"\n        pose: Pose\n        \"\"\"\n        The resolved pose of the location designator. Pose is inherited by all location designator.\n        \"\"\"\n\n    def __init__(self, resolver=None, ontology_concept_holders: Optional[List[owlready2.Thing]] = None):\n        super().__init__(resolver, ontology_concept_holders)\n\n    def ground(self) -> Location:\n        \"\"\"\n        Find a location that satisfies all constrains.\n        \"\"\"\n        raise NotImplementedError(f\"{type(self)}.ground() is not implemented.\")\n\n\n#this knowledge should be somewhere else i guess\nSPECIAL_KNOWLEDGE = {\n    'bigknife':\n        [(\"top\", [-0.08, 0, 0])],\n    'whisk':\n        [(\"top\", [-0.08, 0, 0])],\n    'bowl':\n        [(\"front\", [1.0, 2.0, 3.0]),\n         (\"key2\", [4.0, 5.0, 6.0])]\n}\n\n\nclass ObjectDesignatorDescription(DesignatorDescription):\n    \"\"\"\n    Class for object designator descriptions.\n    Descriptions hold possible parameter ranges for object designators.\n    \"\"\"\n\n    @dataclass\n    class Object:\n        \"\"\"\n        A single element that fits the description.\n        \"\"\"\n\n        name: str\n        \"\"\"\n        Name of the object\n        \"\"\"\n\n        obj_type: ObjectType\n        \"\"\"\n        Type of the object\n        \"\"\"\n\n        world_object: Optional[WorldObject]\n        \"\"\"\n        Reference to the World object\n        \"\"\"\n\n        _pose: Optional[Callable] = field(init=False)\n        \"\"\"\n        A callable returning the pose of this object. The _pose member is used overwritten for data copies\n        which will not update when the original world_object is moved.\n        \"\"\"\n\n        def __post_init__(self):\n            if self.world_object:\n                self._pose = self.world_object.get_pose\n\n        def to_sql(self) -> ORMObjectDesignator:\n            \"\"\"\n            Create an ORM object that corresponds to this description.\n\n            :return: The created ORM object.\n            \"\"\"\n            return ORMObjectDesignator(self.obj_type, self.name)\n\n        def insert(self, session: Session) -> ORMObjectDesignator:\n            \"\"\"\n            Add and commit this and all related objects to the session.\n            Auto-Incrementing primary keys and foreign keys have to be filled by this method.\n\n            :param session: Session with a database that is used to add and commit the objects\n            :return: The completely instanced ORM object\n            \"\"\"\n            metadata = ProcessMetaData().insert(session)\n            pose = self.pose.insert(session)\n\n            # create object orm designator\n            obj = self.to_sql()\n            obj.process_metadata = metadata\n            obj.pose = pose\n            session.add(obj)\n            return obj\n\n        def frozen_copy(self) -> 'ObjectDesignatorDescription.Object':\n            \"\"\"\n            Returns a copy of this designator containing only the fields.\n\n            :return: A copy containing only the fields of this class. The WorldObject attached to this pycram object is not copied. The _pose gets set to a method that statically returns the pose of the object when this method was called.\n            \"\"\"\n            result = ObjectDesignatorDescription.Object(self.name, self.obj_type, None)\n            # get current object pose and set resulting pose to always be that\n            pose = self.pose\n            result.pose = lambda: pose\n            return result\n\n        @property\n        def pose(self):\n            \"\"\"\n            Property of the current position and orientation of the object.\n            Evaluate the _pose function.\n\n            :return: Position and orientation\n            \"\"\"\n            return self._pose()\n\n        @pose.setter\n        def pose(self, value: Callable):\n            \"\"\"\n            Set the pose to a new method that returns the current pose.\n\n            :param value: A callable that returns a pose.\n            \"\"\"\n            self._pose = value\n\n        def __repr__(self):\n            return self.__class__.__qualname__ + f\"(\" + ', '.join(\n                [f\"{f.name}={self.__getattribute__(f.name)}\" for f in fields(self)] + [\n                    f\"pose={self.pose}\"]) + ')'\n\n        def special_knowledge_adjustment_pose(self, grasp: str, pose: Pose) -> Pose:\n            \"\"\"\n            Returns the adjusted target pose based on special knowledge for \"grasp front\".\n\n            :param grasp: From which side the object should be grasped\n            :param pose: Pose at which the object should be grasped, before adjustment\n            :return: The adjusted grasp pose\n            \"\"\"\n            lt = LocalTransformer()\n            pose_in_object = lt.transform_pose(pose, self.world_object.tf_frame)\n\n            special_knowledge = []  # Initialize as an empty list\n            if self.obj_type in SPECIAL_KNOWLEDGE:\n                special_knowledge = SPECIAL_KNOWLEDGE[self.obj_type]\n\n            for key, value in special_knowledge:\n                if key == grasp:\n                    # Adjust target pose based on special knowledge\n                    pose_in_object.pose.position.x += value[0]\n                    pose_in_object.pose.position.y += value[1]\n                    pose_in_object.pose.position.z += value[2]\n                    rospy.loginfo(\"Adjusted target pose based on special knowledge for grasp: %s\", grasp)\n                    return pose_in_object\n            return pose\n\n    def __init__(self, names: Optional[List[str]] = None, types: Optional[List[ObjectType]] = None,\n                 resolver: Optional[Callable] = None, ontology_concept_holders: Optional[List[owlready2.Thing]] = None):\n        \"\"\"\n        Base of all object designator descriptions. Every object designator has the name and type of the object.\n\n        :param names: A list of names that could describe the object\n        :param types: A list of types that could represent the object\n        :param resolver: An alternative specialized_designators that returns an object designator for the list of names and types\n        :param ontology_concept_holders: A list of ontology concepts that the object is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.types: Optional[List[ObjectType]] = types\n        self.names: Optional[List[str]] = names\n\n    def ground(self) -> Union[Object, bool]:\n        \"\"\"\n        Return the first object from the world that fits the description.\n\n        :return: A resolved object designator\n        \"\"\"\n        return next(iter(self))\n\n    def __iter__(self) -> Iterable[Object]:\n        \"\"\"\n        Iterate through all possible objects fitting this description\n\n        :yield: A resolved object designator\n        \"\"\"\n        # for every world object\n        for obj in World.current_world.objects:\n\n            # skip if name does not match specification\n            if self.names and obj.name not in self.names:\n                continue\n\n            # skip if type does not match specification\n            if self.types and obj.obj_type not in self.types:\n                continue\n\n            yield self.Object(obj.name, obj.obj_type, obj)\n\n@dataclass\nclass BaseMotion(ABC):\n\n    @abstractmethod\n    def perform(self):\n        \"\"\"\n        Passes this designator to the process module for execution. Will be overwritten by each motion.\n        \"\"\"\n        pass\n        # return ProcessModule.perform(self)\n\n    @abstractmethod\n    def to_sql(self) -> ORMMotionDesignator:\n        \"\"\"\n        Create an ORM object that corresponds to this description. Will be overwritten by each motion.\n\n        :return: The created ORM object.\n        \"\"\"\n        return ORMMotionDesignator()\n\n    @abstractmethod\n    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:\n        \"\"\"\n        Add and commit this and all related objects to the session.\n        Auto-Incrementing primary keys and foreign keys have to be filled by this method.\n\n        :param session: Session with a database that is used to add and commit the objects\n        :param args: Possible extra arguments\n        :param kwargs: Possible extra keyword arguments\n        :return: The completely instanced ORM motion.\n        \"\"\"\n        metadata = ProcessMetaData().insert(session)\n\n        motion = self.to_sql()\n        motion.process_metadata = metadata\n\n        return motion\n\n    def __post_init__(self):\n        \"\"\"\n        Checks if types are missing or wrong\n        \"\"\"\n        right_types = get_type_hints(self)\n        attributes = self.__dict__.copy()\n\n        missing = []\n        wrong_type = {}\n        current_type = {}\n\n        for k in attributes.keys():\n            attribute = attributes[k]\n            attribute_type = type(attributes[k])\n            right_type = right_types[k]\n            types = get_args(right_type)\n            if attribute is None:\n                if not any([x is type(None) for x in get_args(right_type)]):\n                    missing.append(k)\n            elif attribute_type is not right_type:\n                if attribute_type not in types:\n                    if attribute_type not in [get_origin(x) for x in types if x is not type(None)]:\n                        wrong_type[k] = right_types[k]\n                        current_type[k] = attribute_type\n        if missing != [] or wrong_type != {}:\n            raise ResolutionError(missing, wrong_type, current_type, self.__class__)\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the key functions implemented in the failure_handling.py file?"}, {"role": "assistant", "content": "# Content from: #<failure_handling.py>#\nfrom .datastructures.enums import State\nfrom .designator import DesignatorDescription\nfrom .plan_failures import PlanFailure\nfrom threading import Lock\nfrom typing_extensions import Union, Tuple, Any, List\nfrom .language import Language, Monitor\n\n\nclass FailureHandling(Language):\n    \"\"\"\n    Base class for failure handling mechanisms in automated systems or workflows.\n\n    This class provides a structure for implementing different strategies to handle\n    failures that may occur during the execution of a plan or process. It is designed\n    to be extended by subclasses that implement specific failure handling behaviors.\n    \"\"\"\n\n    def __init__(self, designator_description: Union[DesignatorDescription, Monitor]):\n        \"\"\"\n        Initializes a new instance of the FailureHandling class.\n\n        :param Union[DesignatorDescription, Monitor] designator_description: The description or context of the task\n        or process for which the failure handling is being set up.\n        \"\"\"\n        self.designator_description = designator_description\n\n    def perform(self):\n        \"\"\"\n        Abstract method to perform the failure handling mechanism.\n\n        This method should be overridden in subclasses to implement the specific\n        behavior for handling failures.\n\n        :raises NotImplementedError: If the method is not implemented in a subclass.\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass Retry(FailureHandling):\n    \"\"\"\n    A subclass of FailureHandling that implements a retry mechanism.\n\n    This class represents a specific failure handling strategy where the system\n    attempts to retry a failed action a certain number of times before giving up.\n    \"\"\"\n    max_tries: int\n    \"\"\"\n    The maximum number of attempts to retry the action.\n    \"\"\"\n\n    def __init__(self, designator_description: DesignatorDescription, max_tries: int = 3):\n        \"\"\"\n        Initializes a new instance of the Retry class.\n\n        :param designator_description: The description or context of the task or process for which the retry mechanism is being set up.\n        :param max_tries: The maximum number of attempts to retry. Defaults to 3.\n        \"\"\"\n        super().__init__(designator_description)\n        self.max_tries = max_tries\n\n    def perform(self) -> Tuple[State, List[Any]]:\n        \"\"\"\n        Implementation of the retry mechanism.\n\n        This method attempts to perform the action specified in the designator_description.\n        If the action fails, it is retried up to max_tries times. If all attempts fail,\n        the last exception is raised.\n\n        :raises PlanFailure: If all retry attempts fail.\n        \"\"\"\n        tries = 0\n        for action in iter(self.designator_description):\n            tries += 1\n            try:\n                action.perform()\n                break\n            except PlanFailure as e:\n                if tries >= self.max_tries:\n                    raise e\n\n\nclass RetryMonitor(FailureHandling):\n    \"\"\"\n    A subclass of FailureHandling that implements a retry mechanism that works with a Monitor.\n\n    This class represents a specific failure handling strategy that allows us to retry a demo that is\n    being monitored, in case that monitoring condition is triggered.\n    \"\"\"\n    max_tries: int\n    \"\"\"\n    The maximum number of attempts to retry the action.\n    \"\"\"\n    recovery: dict\n    \"\"\"\n    A dictionary that maps exception types to recovery actions\n    \"\"\"\n\n    def __init__(self, designator_description: Monitor, max_tries: int = 3, recovery: dict = None):\n        \"\"\"\n        Initializes a new instance of the RetryMonitor class.\n        :param Monitor designator_description: The Monitor instance to be used.\n        :param int max_tries: The maximum number of attempts to retry. Defaults to 3.\n        :param dict recovery: A dictionary that maps exception types to recovery actions. Defaults to None.\n        \"\"\"\n        super().__init__(designator_description)\n        self.max_tries = max_tries\n        self.lock = Lock()\n        if recovery is None:\n            self.recovery = {}\n        else:\n            if not isinstance(recovery, dict):\n                raise ValueError(\n                    \"Recovery must be a dictionary with exception types as keys and Language instances as values.\")\n            for key, value in recovery.items():\n                if not issubclass(key, BaseException):\n                    raise TypeError(\"Keys in the recovery dictionary must be exception types.\")\n                if not isinstance(value, Language):\n                    raise TypeError(\"Values in the recovery dictionary must be instances of the Language class.\")\n            self.recovery = recovery\n\n    def perform(self) -> Tuple[State, List[Any]]:\n        \"\"\"\n        This method attempts to perform the Monitor + plan specified in the designator_description. If the action\n        fails, it is retried up to max_tries times. If all attempts fail, the last exception is raised. In every\n        loop, we need to clear the kill_event, and set all relevant 'interrupted' variables to False, to make sure\n        the Monitor and plan are executed properly again.\n\n        :raises PlanFailure: If all retry attempts fail.\n\n        :return: The state of the execution performed, as well as a flattened list of the\n        results, in the correct order\n        \"\"\"\n\n        def reset_interrupted(child):\n            child.interrupted = False\n            try:\n                for sub_child in child.children:\n                    reset_interrupted(sub_child)\n            except AttributeError:\n                pass\n\n        def flatten(result):\n            flattened_list = []\n            if result:\n                for item in result:\n                    if isinstance(item, list):\n                        flattened_list.extend(item)\n                    else:\n                        flattened_list.append(item)\n                return flattened_list\n            return None\n\n        status, res = None, None\n        with self.lock:\n            tries = 0\n            while True:\n                self.designator_description.kill_event.clear()\n                self.designator_description.interrupted = False\n                for child in self.designator_description.children:\n                    reset_interrupted(child)\n                try:\n                    status, res = self.designator_description.perform()\n                    break\n                except PlanFailure as e:\n                    tries += 1\n                    if tries >= self.max_tries:\n                        raise e\n                    exception_type = type(e)\n                    if exception_type in self.recovery:\n                        self.recovery[exception_type].perform()\n        return status, flatten(res)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the fluent.py file and how do they work?"}, {"role": "assistant", "content": "# Content from: #<fluent.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nimport operator\n\nfrom enum import Enum\nfrom threading import Condition, Lock\nfrom uuid import uuid4\nfrom typing_extensions import Any, Optional, List, Callable\n\n\nclass Behavior(Enum):\n    \"\"\"Enumeration which can be passed as argument to the pulsed method of fluents to describe how to handle missed pulses in the whenever macro.\n\n    Fields:\n    NEVER -- ignore missed pulses.\n    ONCE -- if pulses were missed, execute the body once more in total.\n    ALWAYS -- if pulses were missed, execute the body once more for each.\n    \"\"\"\n    NEVER = 1\n    ONCE = 2\n    ALWAYS = 3\n\n\nclass Fluent:\n    \"\"\"Implementation of fluents.\n\n    Fluents are thread-safe proxy objects which are used as variables with changing value. This allows threads to\n    observe them and wait for (specific) changes.\n    One can also observe fluents created by the pulsed method of a fluent. These change their value from None to True\n    whenever the parent gets pulsed (or changes its value and thus gets pulsed).\n\n    Fluents can be combined to fluent networks which allows to express complex conditions. A network updates its value\n    whenever one of the fluents it is constructed from changes its value.\n    The most important comparison and math operators (<, <=, ==, !=, >, >=, +, -, *, /) are overloaded to construct a\n    fluent network whenever they are called with at least one fluent as parameter. In addition the comparison operators\n    IS and IS_NOT as well as the logical operators AND, OR and NOT are defined as methods. This is necessary because\n    these operators can't be overloaded. Fluents constructed by comparison or logical operators have the value True or\n    None instead of False, so that they can be used with the wait_for method because it blocks until a value is not None.\n    User defined operators can be created by passing a function as the fluents value.\n    \"\"\"\n\n    def __init__(self, value: Optional[Any] = None, name: str = None):\n        \"\"\"Create a new fluent.\n\n        :param value:  the value of the fluent which can also be a function to create user defined operators (default is None).\n        :param name: the name of the fluent (default is a random string).\n        \"\"\"\n        self._cv: Condition = Condition()\n        self._mutex: Lock = Lock()\n        self._pulses: int = 0\n        self._children: List[Fluent] = []\n        self._handle_missed = Behavior.NEVER\n        self._value: Any = value\n        self._whenever_cbs = []\n\n        if name is not None:\n            self.name: str = name\n        else:\n            self.name: str = str(uuid4())\n\n    def pulsed(self, handle_missed: Behavior = 2) -> Fluent:\n        \"\"\"Create a fluent which changes its value from None to True whenever the parent gets pulsed.\n\n        :param handle_missed: see the docstring of the Behavior enumeration to find out more (default is Behavior.ONCE).\n        \"\"\"\n        fluent = Fluent()\n\n        def value():\n            if fluent._pulses != 0:\n                return True\n            else:\n                return None\n\n        fluent.set_value(value)\n        fluent._handle_missed = handle_missed\n        self.add_child(fluent)\n        return fluent\n\n    def pulse(self) -> None:\n        \"\"\"Pulse a fluent without changing its value.\"\"\"\n        for child in self._children:\n            with child._mutex:\n                child._pulses += 1\n\n            child.pulse()\n        for callback in self._whenever_cbs:\n            callback(self.get_value())\n            with self._mutex:\n                self._pulses -= 1\n            if self._handle_missed == Behavior.NEVER:\n                with self._mutex:\n                    self._pulses = 0\n            elif self._handle_missed == Behavior.ONCE:\n                callback(self.get_value())\n                with self._mutex:\n                    self._pulses = 0\n            elif self._handle_missed == Behavior.ALWAYS:\n                with self._mutex:\n                    for i in range(self._pulses):\n                        callback(self.get_value())\n        with self._cv:\n            self._cv.notify()\n\n    def whenever(self, callback: Callable) -> None:\n        \"\"\"\n        Registers a callback which is called everytime this Fluent is pulsed. The callback should be a Callable. When\n        the callback is called it gets the current value of this Fluent as an argument.\n\n        :param callback: The callback which should be called when pulsed as a Callable.\n        \"\"\"\n        self._whenever_cbs.append(callback)\n\n    def add_child(self, child: Fluent) -> None:\n        \"\"\"Add a child to the fluent which gets pulsed whenever this fluent gets pulsed, too.\n\n        :param child: the child to add.\n        \"\"\"\n        self._children.append(child)\n\n    def get_value(self) -> Any:\n        \"\"\"Return the value of the fluent.\"\"\"\n        with self._mutex:\n            if callable(self._value):\n                return self._value()\n\n            return self._value\n\n    def set_value(self, value: Any) -> None:\n        \"\"\"Change the value of the fluent.\n        Changing the value will also pulse the fluent.\n\n        :param value: the new value of the fluent.\n        \"\"\"\n        with self._mutex:\n            self._value = value\n\n        self.pulse()\n\n    def wait_for(self, timeout: Optional[float] = None):\n        \"\"\"Block the current thread if the value of the fluent is None, until it is not None or until it timed out.\n\n        If the fluent was created by the pulsed method of a fluent, the method blocks until the parent gets pulsed.\n\n        The return value is the last return value of the predicate (value is not None) and will evaluate to False if the method timed out.\n\n        :param timeout: the maximum time to wait (default is None).\n        \"\"\"\n        with self._cv:\n            return self._cv.wait_for(lambda: self.get_value() is not None, timeout)\n\n    def _compare(self, operator, other: Fluent) -> Fluent:\n        \"\"\"This is a helper method for internal usage only.\n\n        Create a fluent which value is a function returning True or None depending on the given comparison operator applied to the operands.\n\n        :param operator: the comparison operator to apply.\n        :param other: the other operand.\n        \"\"\"\n        fluent = Fluent()\n\n        if type(other) == Fluent:\n            def value():\n                if operator(self.get_value(), other.get_value()):\n                    return True\n                else:\n                    return None\n\n            other.add_child(fluent)\n        else:\n            def value():\n                if operator(self.get_value(), other):\n                    return True\n                else:\n                    return None\n\n        self.add_child(fluent)\n        fluent.set_value(value)\n        return fluent\n\n    def __lt__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the < comparsion operator.\n\n        :param other: -- the other operand.\n        \"\"\"\n        return self._compare(operator.lt, other)\n\n    def __leq__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the <= comparsion operator.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._compare(operator.leq, other)\n\n    def __eq__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the == comparsion operator.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._compare(operator.eq, other)\n\n    def __ne__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the != comparsion operator.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._compare(operator.ne, other)\n\n    def IS(self, other: Fluent) -> Fluent:\n        \"\"\"Create a fluent which value is True if the value of its parent is the value of the given operand, None otherwise.\n\n        :param other: -- the other operand which can also be a fluent.\n        \"\"\"\n        return self._compare(operator.is_, other)\n\n    def IS_NOT(self, other: Fluent) -> Fluent:\n        \"\"\"Create a fluent which value is True if the value of its parent is not the value of the given operand, None otherwise.\n\n        :param other: -- the other operand which can also be a fluent.\n        \"\"\"\n        return self._compare(operator.is_not, other)\n\n    def __gt__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the > comparison operator.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._compare(operator.gt, other)\n\n    def __geq__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the >= comparison operator.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._compare(operator.geq, other)\n\n    def _math(self, operator: Callable, operand: Fluent, other: Fluent) -> Fluent:\n        \"\"\"This is a helper method for internal usage only.\n\n        Create a fluent which value is a function returning the value of the given math operator applied to the operands.\n\n        :param operator: the math operator to apply.\n        :param operand: the first operand.\n        :param other: the other operand.\n        \"\"\"\n        fluent = Fluent()\n\n        if type(operand) == Fluent:\n            if type(other) == Fluent:\n                value = lambda: operator(operand.get_value(), other.get_value())\n                other.add_child(fluent)\n            else:\n                value = lambda: operator(operand.get_value(), other)\n\n            operand.add_child(fluent)\n        else:\n            value = lambda: operator(operand, other.get_value())\n            other.add_child(fluent)\n\n        fluent.set_value(value)\n        return fluent\n\n    def __add__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the + math operator.\n\n        :parm other: the other operand.\n        \"\"\"\n        return self._math(operator.add, self, other)\n\n    def __radd__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the + math operator with the first operand not being a fluent.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._math(operator.add, other, self)\n\n    def __sub__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the - math operator.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._math(operator.sub, self, other)\n\n    def __rsub__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the - math operator with the first operand not being a fluent.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._math(operator.sub, other, self)\n\n    def __mul__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the * math operator.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._math(operator.mul, self, other)\n\n    def __rmul__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the * math operator with the first operand not being a fluent.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._math(operator.mul, other, self)\n\n    def __truediv__(self, other: Fluent) -> Fluent:\n        \"\"\"Overload the / math operator.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._math(operator.truediv, self, other)\n\n    def __rtruediv__(self, other) -> Fluent:\n        \"\"\"Overload the / math operator with the first operand not being a fluent.\n\n        :param other: the other operand.\n        \"\"\"\n        return self._math(operator.truediv, other, self)\n\n    def AND(self, other: Fluent) -> Fluent:\n        \"\"\"Create a fluent which value is True if both, the value of its parent and the other operand express True, None otherwise.\n\n        :param other: the other operand which can also be a fluent.\n        \"\"\"\n        fluent = Fluent()\n\n        if type(other) == Fluent:\n            def value():\n                if self.get_value() and other.get_value():\n                    return True\n                else:\n                    return None\n\n            other.add_child(fluent)\n        else:\n            def value():\n                if self.get_value() and other:\n                    return True\n                else:\n                    return None\n\n        self.add_child(fluent)\n        fluent.set_value(value)\n        return fluent\n\n    def OR(self, other: Fluent) -> Fluent:\n        \"\"\"Create a fluent which value is True if either the value of its parent or the other operand express True, None otherwise.\n\n        :param other: the other operand which can also be a fluent.\n        \"\"\"\n        fluent = Fluent()\n\n        if type(other) == Fluent:\n            def value():\n                if self.get_value() or other.get_value():\n                    return True\n                else:\n                    return None\n\n            other.add_child(fluent)\n        else:\n            def value():\n                if self.get_value() or other:\n                    return True\n                else:\n                    return None\n\n        self.add_child(fluent)\n        fluent.set_value(value)\n        return fluent\n\n    def NOT(self) -> Fluent:\n        \"\"\"Create a fluent which value is True if the value of its parent expresses False, None otherwise.\"\"\"\n        def value():\n            if not self.get_value():\n                return True\n            else:\n                return None\n\n        fluent = Fluent(value)\n        self.add_child(fluent)\n        return fluent\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the helper.py file and how are they used in the project?"}, {"role": "assistant", "content": "# Content from: #<helper.py>#\n\"\"\"Implementation of helper functions and classes for internal usage only.\n\nClasses:\nSingleton -- implementation of singleton metaclass\n\"\"\"\nclass Singleton(type):\n    \"\"\"\n    Metaclass for singletons\n    \"\"\"\n\n    _instances = {}\n    \"\"\"\n    Dictionary of singleton child classes inheriting from this metaclass, keyed by child class objects.\n    \"\"\"\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the language.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<language.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nfrom queue import Queue\nimport rospy\nfrom typing_extensions import Iterable, Optional, Callable, Dict, Any, List, Union, Tuple\nfrom anytree import NodeMixin, Node, PreOrderIter\n\nfrom pycram.datastructures.enums import State\nimport threading\n\nfrom .fluent import Fluent\nfrom .plan_failures import PlanFailure, NotALanguageExpression\nfrom .external_interfaces import giskard\n\n\nclass Language(NodeMixin):\n    \"\"\"\n    Parent class for language expressions. Implements the operators as well as methods to reduce the resulting language\n    tree.\n    \"\"\"\n    parallel_blocklist = [\"PickUpAction\", \"PlaceAction\", \"OpenAction\", \"CloseAction\", \"TransportAction\", \"GraspingAction\"]\n    do_not_use_giskard = [\"SetGripperAction\", \"MoveGripperMotion\", \"DetectAction\", \"DetectingMotion\"]\n    block_list: List[int] = []\n    \"\"\"List of thread ids which should be blocked from execution.\"\"\"\n\n    def __init__(self, parent: NodeMixin = None, children: Iterable[NodeMixin] = None):\n        \"\"\"\n        Default constructor for anytree nodes. If the parent is none this is the root node.\n\n        :param parent: The parent node of this node\n        :param children: All children of this node as a tuple oder iterable\n        \"\"\"\n        self.parent = parent\n        self.exceptions = {}\n        self.state = None\n        self.executing_thread = {}\n        self.threads: List[threading.Thread] = []\n        self.interrupted = False\n        self.name = self.__class__.__name__\n        if children:\n            self.children: Language = children\n\n    def resolve(self) -> Language:\n        \"\"\"\n        Dummy method for compatability to designator descriptions\n\n        :return: self reference\n        \"\"\"\n        return self\n\n    def perform(self):\n        \"\"\"\n        This method should be overwritten in subclasses and implement the behaviour of the language expression regarding\n        each child.\n        \"\"\"\n        raise NotImplementedError\n\n    def __add__(self, other: Language) -> Sequential:\n        \"\"\"\n        Language expression for sequential execution.\n\n        :param other: Another Language expression, either a designator or language expression\n        :return: A :func:`~Sequential` object which is the new root node of the language tree\n        \"\"\"\n        if not issubclass(other.__class__, Language):\n            raise NotALanguageExpression(\n                f\"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \\nThe object '{other}' does not inherit from the Language class.\")\n        return Sequential(parent=None, children=(self, other)).simplify()\n\n    def __sub__(self, other: Language) -> TryInOrder:\n        \"\"\"\n        Language expression for try in order.\n\n        :param other: Another Language expression, either a designator or language expression\n        :return: A :func:`~TryInOrder` object which is the new root node of the language tree\n        \"\"\"\n        if not issubclass(other.__class__, Language):\n            raise NotALanguageExpression(\n                f\"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \\nThe object '{other}' does not inherit from the Language class.\")\n        return TryInOrder(parent=None, children=(self, other)).simplify()\n\n    def __or__(self, other: Language) -> Parallel:\n        \"\"\"\n        Language expression for parallel execution.\n\n        :param other: Another Language expression, either a designator or language expression\n        :return: A :func:`~Parallel` object which is the new root node of the language tree\n        \"\"\"\n        if not issubclass(other.__class__, Language):\n            raise NotALanguageExpression(\n                f\"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \\nThe object '{other}' does not inherit from the Language class.\")\n        if self.__class__.__name__ in self.parallel_blocklist or other.__class__.__name__ in self.parallel_blocklist:\n            raise AttributeError(\n                f\"You can not execute the Designator {self if self.__class__.__name__ in self.parallel_blocklist else other} in a parallel language expression.\")\n\n        return Parallel(parent=None, children=(self, other)).simplify()\n\n    def __xor__(self, other: Language) -> TryAll:\n        \"\"\"\n        Language expression for try all execution.\n\n        :param other: Another Language expression, either a designator or language expression\n        :return: A :func:`~TryAll` object which is the new root node of the language tree\n        \"\"\"\n        if not issubclass(other.__class__, Language):\n            raise NotALanguageExpression(\n                f\"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \\nThe object '{other}' does not inherit from the Language class.\")\n        if self.__class__.__name__ in self.parallel_blocklist or other.__class__.__name__ in self.parallel_blocklist:\n            raise AttributeError(\n                f\"You can not execute the Designator {self if self.__class__.__name__ in self.parallel_blocklist else other} in a try all language expression.\")\n        return TryAll(parent=None, children=(self, other)).simplify()\n\n    def __rshift__(self, other: Language):\n        \"\"\"\n        Operator for Monitors, this always makes the Monitor the parent of the other expression.\n        \n        :param other: Another Language expression\n        :return: The Monitor which is now the new root node.\n        \"\"\"\n        if isinstance(self, Monitor) and isinstance(other, Monitor):\n            raise AttributeError(\"You can't attach a Monitor to another Monitor.\")\n        if isinstance(self, Monitor):\n            self.children = [other]\n            return self\n        elif isinstance(other, Monitor):\n            other.children = [self]\n            return other\n\n    def __mul__(self, other: int):\n        \"\"\"\n        Language expression for Repeated execution. The other attribute of this operator has to be an integer.\n\n        :param other: An integer which states how often the Language expression should be repeated\n        :return: A :func:`~Repeat` object which is the new root node of the language tree\n        \"\"\"\n        if not isinstance(other, int):\n            raise AttributeError(\"Repeat can only be used in combination with integers\")\n        return Repeat(parent=None, children=[self], repeat=other)\n\n    def __rmul__(self, other: int):\n        \"\"\"\n        Language expression for Repeated execution. The other attribute of this operator has to be an integer. This is\n        the reversed operator of __mul__ which allows to write:\n\n        .. code-block:: python\n        \n            2 * ParkAction()\n\n        :param other: An integer which states how often the Language expression should be repeated\n        :return: A :func:`~Repeat` object which is the new root node of the language tree\n        \"\"\"\n        if not isinstance(other, int):\n            raise AttributeError(\"Repeat can only be used in combination with integers\")\n        return Repeat(parent=None, children=[self], repeat=other)\n\n    def simplify(self) -> Language:\n        \"\"\"\n        Simplifies the language tree by merging which have a parent-child relation and are of the same type.\n\n        .. code-block::\n\n            <pycram.new_language.Parallel>\n            âââ <pycram.new_language.Parallel>\n            â   âââ <pycram.designators.action_designator.NavigateAction>\n            â   âââ <pycram.designators.action_designator.MoveTorsoAction>\n            âââ <pycram.designators.action_designator.DetectAction>\n\n            would be simplified to:\n\n           <pycram.new_language.Parallel>\n            âââ <pycram.designators.action_designator.NavigateAction>\n            âââ <pycram.designators.action_designator.MoveTorsoAction>\n            âââ <pycram.designators.action_designator.DetectAction>\n\n        \"\"\"\n        for node in PreOrderIter(self.root):\n            for child in node.children:\n                if isinstance(child, Monitor):\n                    continue\n                if type(node) is type(child):\n                    self.merge_nodes(node, child)\n        return self.root\n\n    @staticmethod\n    def merge_nodes(node1: Node, node2: Node) -> None:\n        \"\"\"\n        Merges node1 with node2 in a tree. The children of node2 will be re-parented to node1 and node2 will be deleted\n        from the tree.\n\n        :param node1: Node that should be left in the tree\n        :param node2: Node which children should be appended to node1 and then deleted\n        \"\"\"\n        node2.parent = None\n        node1.children = node2.children + node1.children\n\n    def interrupt(self) -> None:\n        \"\"\"\n        Base method for interrupting the execution of Language expression. To be overwritten in a sub-class.\n        \"\"\"\n        raise NotImplementedError\n\n\nclass Repeat(Language):\n    \"\"\"\n    Executes all children a given number of times.\n    \"\"\"\n    def perform(self):\n        \"\"\"\n        Behaviour of repeat, executes all children in a loop as often as stated on initialization.\n\n        :return:\n        \"\"\"\n        for i in range(self.repeat):\n            for child in self.children:\n                if self.interrupted:\n                    return\n                try:\n                    child.resolve().perform()\n                except PlanFailure as e:\n                    self.root.exceptions[self] = e\n\n    def __init__(self, parent: NodeMixin = None, children: Iterable[NodeMixin] = None, repeat: int = 1):\n        \"\"\"\n        Initializes the Repeat expression with a parent and children for the language tree construction and a number\n        which states how often the children should be executed.\n\n        :param parent: Parent node of this node, if None this will be the root node\n        :param children: A list of children of this node\n        :param repeat: An integer of how often the children should be executed.\n        \"\"\"\n        super().__init__(parent, children)\n        self.repeat: int = repeat\n\n    def interrupt(self) -> None:\n        \"\"\"\n        Stops the execution of this language expression by setting the ``interrupted`` variable to True, adding this\n        thread to the block_list in ProcessModule and interrupting the current giskard goal\n        \"\"\"\n        self.interrupted = True\n        self.block_list.append(threading.get_ident())\n        if giskard.giskard_wrapper:\n            giskard.giskard_wrapper.interrupt()\n\n\nclass Monitor(Language):\n    \"\"\"\n    Monitors a Language Expression and interrupts it when the given condition is evaluated to True.\n\n    Behaviour:\n        This Monitor is attached to a language expression, when perform on this Monitor is called it will start a new\n        thread which continuously checks if the condition is True. When the condition is True the interrupt function of\n        the child will be called.\n    \"\"\"\n    def __init__(self, condition: Union[Callable, Fluent] = None):\n        \"\"\"\n        When initializing a Monitor a condition must be provided. The condition is a callable or a Fluent which returns \\\n        True or False.\n\n        :param condition: The condition upon which the Monitor should interrupt the attached language expression.\n        \"\"\"\n        super().__init__(None, None)\n        self.kill_event = threading.Event()\n        self.exception_queue = Queue()\n        if callable(condition):\n            self.condition = Fluent(condition)\n        elif isinstance(condition, Fluent):\n            self.condition = condition\n        else:\n            raise AttributeError(\"The condition of a Monitor has to be a Callable or a Fluent\")\n\n    def perform(self) -> Tuple[State, Any]:\n        \"\"\"\n        Behavior of the Monitor, starts a new Thread which checks the condition and then performs the attached language\n        expression\n\n        :return: The state of the attached language expression, as well as a list of the results of the children\n        \"\"\"\n        def check_condition():\n            while not self.kill_event.is_set():\n                try:\n                    cond = self.condition.get_value()\n                    if cond:\n                        for child in self.children:\n                            try:\n                                child.interrupt()\n                            except NotImplementedError:\n                                pass\n                        if isinstance(cond, type) and issubclass(cond, Exception):\n                            self.exception_queue.put(cond)\n                        else:\n                            self.exception_queue.put(PlanFailure(\"Condition met in Monitor\"))\n                        return\n                except Exception as e:\n                    self.exception_queue.put(e)\n                    return\n                rospy.sleep(0.1)\n\n        t = threading.Thread(target=check_condition)\n        t.start()\n        try:\n            state, result = self.children[0].perform()\n            if not self.exception_queue.empty():\n                raise self.exception_queue.get()\n        finally:\n            self.kill_event.set()\n            t.join()\n        return state, result\n\n    def interrupt(self) -> None:\n        \"\"\"\n        Calls interrupt for each child\n        \"\"\"\n        for child in self.children:\n            child.interrupt()\n\n\nclass Sequential(Language):\n    \"\"\"\n    Executes all children sequentially, an exception while executing a child does not terminate the whole process.\n    Instead, the exception is saved to a list of all exceptions thrown during execution and returned.\n\n    Behaviour:\n        Returns a tuple containing the final state of execution (SUCCEEDED, FAILED) and a list of results from each\n        child's perform() method. The state is :py:attr:`~State.SUCCEEDED` *iff* all children are executed without\n        exception. In any other case the State :py:attr:`~State.FAILED` will be returned.\n    \"\"\"\n\n    def perform(self) -> Tuple[State, List[Any]]:\n        \"\"\"\n        Behaviour of Sequential, calls perform() on each child sequentially\n\n        :return: The state and list of results according to the behaviour described in :func:`Sequential`\n        \"\"\"\n        children_return_values = [None] * len(self.children)\n        try:\n            for index, child in enumerate(self.children):\n                if self.interrupted:\n                    if threading.get_ident() in self.block_list:\n                        self.block_list.remove(threading.get_ident())\n                    return State.FAILED, children_return_values\n                self.root.executing_thread[child] = threading.get_ident()\n                ret_val = child.resolve().perform()\n                if isinstance(ret_val, tuple):\n                    child_state, child_result = ret_val\n                    children_return_values[index] = child_result\n                else:\n                    children_return_values[index] = ret_val\n        except PlanFailure as e:\n            self.root.exceptions[self] = e\n            return State.FAILED, children_return_values\n        return State.SUCCEEDED, children_return_values\n\n    def interrupt(self) -> None:\n        \"\"\"\n        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True and calling\n        interrupt on the current giskard goal.\n        \"\"\"\n        self.interrupted = True\n        self.block_list.append(threading.get_ident())\n        if giskard.giskard_wrapper:\n            giskard.giskard_wrapper.interrupt()\n\n\nclass TryInOrder(Language):\n    \"\"\"\n    Executes all children sequentially, an exception while executing a child does not terminate the whole process.\n    Instead, the exception is saved to a list of all exceptions thrown during execution and returned.\n\n    Behaviour:\n        Returns a tuple containing the final state of execution (SUCCEEDED, FAILED) and a list of results from each\n        child's perform() method. The state is :py:attr:`~State.SUCCEEDED` if one or more children are executed without\n        exception. In the case that all children could not be executed the State :py:attr:`~State.FAILED` will be returned.\n    \"\"\"\n\n    def perform(self) -> Tuple[State, List[Any]]:\n        \"\"\"\n        Behaviour of TryInOrder, calls perform() on each child sequentially and catches raised exceptions.\n\n        :return: The state and list of results according to the behaviour described in :func:`TryInOrder`\n        \"\"\"\n        failure_list = []\n        children_return_values = [None] * len(self.children)\n        for index, child in enumerate(self.children):\n            if self.interrupted:\n                if threading.get_ident() in self.block_list:\n                    self.block_list.remove(threading.get_ident())\n                return State.INTERRUPTED, children_return_values\n            try:\n                ret_val = child.resolve().perform()\n                if isinstance(ret_val, tuple):\n                    child_state, child_result = ret_val\n                    children_return_values[index] = child_result\n                else:\n                    children_return_values[index] = ret_val\n            except PlanFailure as e:\n                failure_list.append(e)\n        if len(failure_list) > 0:\n            self.root.exceptions[self] = failure_list\n        if len(failure_list) == len(self.children):\n            self.root.exceptions[self] = failure_list\n            return State.FAILED, children_return_values\n        else:\n            return State.SUCCEEDED, children_return_values\n\n    def interrupt(self) -> None:\n        \"\"\"\n        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding\n        the current thread to the block_list in Language and interrupting the current giskard goal.\n        \"\"\"\n        self.interrupted = True\n        self.block_list.append(threading.get_ident())\n        if giskard.giskard_wrapper:\n            giskard.giskard_wrapper.interrupt()\n\n\nclass Parallel(Language):\n    \"\"\"\n    Executes all children in parallel by creating a thread per children and executing them in the respective thread. All\n    exceptions during execution will be caught, saved to a list and returned upon end.\n\n    Behaviour:\n        Returns a tuple containing the final state of execution (SUCCEEDED, FAILED) and a list of results from\n        each child's perform() method. The state is :py:attr:`~State.SUCCEEDED` *iff* all children could be executed without\n        an exception. In any other case the State :py:attr:`~State.FAILED` will be returned.\n\n    \"\"\"\n\n    def perform(self) -> Tuple[State, List[Any]]:\n        \"\"\"\n        Behaviour of Parallel, creates a new thread for each child and calls perform() of the child in the respective\n        thread.\n\n        :return: The state and list of results according to the behaviour described in :func:`Parallel`\n\n        \"\"\"\n        results = [None] * len(self.children)\n        self.threads: List[threading.Thread] = []\n        state = State.SUCCEEDED\n        results_lock = threading.Lock()\n\n        def lang_call(child_node, index):\n            nonlocal state\n            if (\"DesignatorDescription\" in [cls.__name__ for cls in child_node.__class__.__mro__]\n                    and self.__class__.__name__ not in self.do_not_use_giskard):\n                if self not in giskard.par_threads.keys():\n                    giskard.par_threads[self] = [threading.get_ident()]\n                else:\n                    giskard.par_threads[self].append(threading.get_ident())\n            try:\n                self.root.executing_thread[child] = threading.get_ident()\n                result = child_node.resolve().perform()\n                if isinstance(result, tuple):\n                    child_state, child_result = result\n                    with results_lock:\n                        results[index] = child_result\n                else:\n                    with results_lock:\n                        results[index] = result\n            except PlanFailure as e:\n                nonlocal state\n                with results_lock:\n                    state = State.FAILED\n                if self in self.root.exceptions.keys():\n                    self.root.exceptions[self].append(e)\n                else:\n                    self.root.exceptions[self] = [e]\n\n        for index, child in enumerate(self.children):\n            if self.interrupted:\n                state = State.FAILED\n                break\n            t = threading.Thread(target=lambda: lang_call(child, index))\n            t.start()\n            self.threads.append(t)\n        for thread in self.threads:\n            thread.join()\n        with results_lock:\n            for thread in self.threads:\n                if thread.ident in self.block_list:\n                    self.block_list.remove(thread.ident)\n        if self in self.root.exceptions.keys() and len(self.root.exceptions[self]) != 0:\n            state = State.FAILED\n        return state, results\n\n    def interrupt(self) -> None:\n        \"\"\"\n        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding the\n        thread id of all parallel execution threads to the block_list in Language and interrupting the current giskard\n        goal.\n        \"\"\"\n        self.interrupted = True\n        self.block_list += [t.ident for t in self.threads]\n        if giskard.giskard_wrapper:\n            giskard.giskard_wrapper.interrupt()\n\n\nclass TryAll(Language):\n    \"\"\"\n    Executes all children in parallel by creating a thread per children and executing them in the respective thread. All\n    exceptions during execution will be caught, saved to a list and returned upon end.\n\n    Behaviour:\n        Returns a tuple containing the final state of execution (SUCCEEDED, FAILED) and a list of results from each\n        child's perform() method. The state is :py:attr:`~State.SUCCEEDED` if one or more children could be executed\n        without raising an exception. If all children fail the State :py:attr:`~State.FAILED` will be returned.\n    \"\"\"\n\n    def perform(self) -> Tuple[State, List[Any]]:\n        \"\"\"\n        Behaviour of TryAll, creates a new thread for each child and executes all children in their respective threads.\n\n        :return: The state and list of results according to the behaviour described in :func:`TryAll`\n        \"\"\"\n        results = [None] * len(self.children)\n        results_lock = threading.Lock()\n        state = State.SUCCEEDED\n        self.threads: List[threading.Thread] = []\n        failure_list = []\n\n        def lang_call(child_node, index):\n            if (\"DesignatorDescription\" in [cls.__name__ for cls in child_node.__class__.__mro__]\n                    and self.__class__.__name__ not in self.do_not_use_giskard):\n                if self not in giskard.par_threads.keys():\n                    giskard.par_threads[self] = [threading.get_ident()]\n                else:\n                    giskard.par_threads[self].append(threading.get_ident())\n            try:\n                result = child_node.resolve().perform()\n                if isinstance(result, tuple):\n                    child_state, child_result = result\n                    with results_lock:\n                        results[index] = child_result\n                else:\n                    with results_lock:\n                        results[index] = result\n            except PlanFailure as e:\n                failure_list.append(e)\n                if self in self.root.exceptions.keys():\n                    self.root.exceptions[self].append(e)\n                else:\n                    self.root.exceptions[self] = [e]\n        for index, child in enumerate(self.children):\n            if self.interrupted:\n                state = State.FAILED\n                break\n            t = threading.Thread(target=lambda: lang_call(child, index))\n            self.threads.append(t)\n            t.start()\n        for thread in self.threads:\n            thread.join()\n        with results_lock:\n            for thread in self.threads:\n                if thread.ident in self.block_list:\n                    self.block_list.remove(thread.ident)\n        if len(self.children) == len(failure_list):\n            self.root.exceptions[self] = failure_list\n            state = State.FAILED\n        return state, results\n\n    def interrupt(self) -> None:\n        \"\"\"\n        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding the\n        thread id of all parallel execution threads to the block_list in Language and interrupting the current giskard\n        \"\"\"\n        self.interrupted = True\n        self.block_list += [t.ident for t in self.threads]\n        if giskard.giskard_wrapper:\n            giskard.giskard_wrapper.interrupt()\n\n\nclass Code(Language):\n    \"\"\"\n    Executable code block in a plan.\n\n    :ivar function: The function (plan) that was called\n    :ivar kwargs: Dictionary holding the keyword arguments of the function\n    \"\"\"\n\n    def __init__(self, function: Optional[Callable] = None,\n                 kwargs: Optional[Dict] = None):\n        \"\"\"\n        Initialize a code call\n\n        :param function: The function that was called\n        :param kwargs: The keyword arguments of the function as dict\n        \"\"\"\n        self.function: Callable = function\n\n        if kwargs is None:\n            kwargs = dict()\n        self.kwargs: Dict[str, Any] = kwargs\n        self.perform = self.execute\n\n    def execute(self) -> Any:\n        \"\"\"\n        Execute the code with its arguments\n\n        :returns: State.SUCCEEDED, and anything that the function associated with this object will return.\n        \"\"\"\n        child_state = State.SUCCEEDED\n        ret_val = self.function(**self.kwargs)\n        if isinstance(ret_val, tuple):\n            child_state, child_result = ret_val\n        else:\n            child_result = ret_val\n\n        return child_state, child_result\n\n    def interrupt(self) -> None:\n        raise NotImplementedError\n\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the local_transformer.py file and how do they interact with the rest of the code?"}, {"role": "assistant", "content": "# Content from: #<local_transformer.py>#\nimport sys\nimport logging\n\nif 'world' in sys.modules:\n    logging.warning(\"(publisher) Make sure that you are not loading this module from pycram.world.\")\nimport rospy\n\nfrom tf import TransformerROS\nfrom rospy import Duration\n\nfrom geometry_msgs.msg import TransformStamped\nfrom .datastructures.pose import Pose, Transform\nfrom typing_extensions import List, Optional, Union, Iterable\n\n\nclass LocalTransformer(TransformerROS):\n    \"\"\"\n    This class allows to use the TF class TransformerROS without using the ROS\n    network system or the topic /tf, where transforms are usually published to.\n    Instead, a local transformer is saved and allows to publish local transforms,\n    as well the use of TFs convenient lookup functions (see functions below).\n\n    This class uses the robots (currently only one! supported) URDF file to\n    initialize the tfs for the robot. Moreover, the function update_local_transformer_from_btr\n    updates these tfs by copying the tfs state from the world.\n\n    This class extends the TransformerRos, you can find documentation for TransformerROS here:\n    `TFDoc <http://wiki.ros.org/tf/TfUsingPython>`_\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self):\n        if self._initialized: return\n        super().__init__(interpolate=True, cache_time=Duration(10))\n        # Since this file can't import world.py this holds the reference to the current_world\n        self.world = None\n        # TODO: Ask Jonas if this is still needed\n        self.prospection_world = None\n\n        # If the singelton was already initialized\n        self._initialized = True\n\n    def transform_to_object_frame(self, pose: Pose,\n                                  world_object: 'world_concepts.world_object.Object', link_name: str = None) -> Union[\n        Pose, None]:\n        \"\"\"\n        Transforms the given pose to the coordinate frame of the given World object. If no link name is given the\n        base frame of the Object is used, otherwise the link frame is used as target for the transformation.\n\n        :param pose: Pose that should be transformed\n        :param world_object: BulletWorld Object in which frame the pose should be transformed\n        :param link_name: A link of the BulletWorld Object which will be used as target coordinate frame instead\n        :return: The new pose the in coordinate frame of the object\n        \"\"\"\n        if link_name:\n            target_frame = world_object.get_link_tf_frame(link_name)\n        else:\n            target_frame = world_object.tf_frame\n        return self.transform_pose(pose, target_frame)\n\n    def update_transforms_for_objects(self, source_object_name: str, target_object_name: str) -> None:\n        \"\"\"\n        Updates the transforms for objects affected by the transformation. The objects are identified by their names.\n\n        :param source_object_name: Name of the object of the source frame\n        :param target_object_name: Name of the object of the target frame\n        \"\"\"\n        source_object = self.world.get_object_by_name(source_object_name)\n        target_object = self.world.get_object_by_name(target_object_name)\n        for obj in {source_object, target_object}:\n            if obj:\n                obj.update_link_transforms()\n\n    def transform_pose(self, pose: Pose, target_frame: str) -> Optional[Pose]:\n        \"\"\"\n        Transforms a given pose to the target frame after updating the transforms for all objects in the current world.\n\n        :param pose: Pose that should be transformed\n        :param target_frame: Name of the TF frame into which the Pose should be transformed\n        :return: A transformed pose in the target frame\n        \"\"\"\n        self.update_transforms_for_objects(self.get_object_name_for_frame(pose.frame),\n                                           self.get_object_name_for_frame(target_frame))\n\n        copy_pose = pose.copy()\n        copy_pose.header.stamp = rospy.Time(0)\n        if not self.canTransform(target_frame, pose.frame, rospy.Time(0)):\n            rospy.logerr(\n                f\"Can not transform pose: \\n {pose}\\n to frame: {target_frame}.\\n Maybe try calling 'update_transforms_for_object'\")\n            return\n        new_pose = super().transformPose(target_frame, copy_pose)\n\n        copy_pose.pose = new_pose.pose\n        copy_pose.header.frame_id = new_pose.header.frame_id\n        copy_pose.header.stamp = rospy.Time.now()\n\n        return Pose(*copy_pose.to_list(), frame=new_pose.header.frame_id)\n\n    def get_object_name_for_frame(self, frame: str) -> str:\n        \"\"\"\n        Returns the name of the object that is associated with the given frame.\n\n        :param frame: The frame for which the object name should be returned\n        :return: The name of the object associated with the frame\n        \"\"\"\n        return frame.split(\"/\")[0]\n\n    def lookup_transform_from_source_to_target_frame(self, source_frame: str, target_frame: str,\n                                                     time: Optional[rospy.rostime.Time] = None) -> Transform:\n        \"\"\"\n        Update the transforms for all world objects then Look up for the latest known transform that transforms a point\n         from source frame to target frame. If no time is given the last common time between the two frames is used.\n\n        :param source_frame: The frame in which the point is currently represented\n        :param target_frame: The frame in which the point should be represented\n        :param time: Time at which the transform should be looked up\n        :return: The transform from source_frame to target_frame\n        \"\"\"\n        self.update_transforms_for_objects(self.get_object_name_for_frame(source_frame),\n                                           self.get_object_name_for_frame(target_frame))\n\n        tf_time = time if time else self.getLatestCommonTime(source_frame, target_frame)\n        translation, rotation = self.lookupTransform(source_frame, target_frame, tf_time)\n        return Transform(translation, rotation, source_frame, target_frame)\n\n    def update_transforms(self, transforms: Iterable[Transform], time: rospy.Time = None) -> None:\n        \"\"\"\n        Updates transforms by updating the time stamps of the header of each transform. If no time is given the current\n        time is used.\n        \"\"\"\n        time = time if time else rospy.Time.now()\n        for transform in transforms:\n            transform.header.stamp = time\n            self.setTransform(transform)\n\n    def get_all_frames(self) -> List[str]:\n        \"\"\"\n        Returns all know coordinate frames as a list with human-readable entries.\n\n        :return: A list of all know coordinate frames.\n        \"\"\"\n        frames = self.allFramesAsString().split(\"\\n\")\n        frames.remove(\"\")\n        return frames\n\n    def transformPose(self, target_frame, ps) -> Pose:\n        \"\"\"\n        Alias for :func:`~LocalTransformer.transform_pose_to_target_frame` to avoid confusion since a similar method\n         exists in the super class.\n        \"\"\"\n        return self.transform_pose(ps, target_frame)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the common reasons for plan failures in the plan_failures.py script?"}, {"role": "assistant", "content": "# Content from: #<plan_failures.py>#\nclass PlanFailure(Exception):\n    \"\"\"Implementation of plan failures.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Create a new plan failure.\"\"\"\n        Exception.__init__(self, *args, **kwargs)\n\n\nclass NotALanguageExpression(PlanFailure):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass FailureDiagnosis(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass LowLevelFailure(FailureDiagnosis):\n    \"\"\"Failure thrown by low-level modules: robot or projection PMs.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ActionlibActionTimeout(LowLevelFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass HighLevelFailure(FailureDiagnosis):\n    \"\"\"Failure thrown by high-level modules, i.e. plans.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass DeliveringFailed(HighLevelFailure):\n    \"\"\"Thrown when delivering plan completely gives up.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ManipulationLowLevelFailure(LowLevelFailure):\n    \"\"\"Thrown when a low-level, i.e. hardware related, failure is detected in a manipulation action.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass EnvironmentManipulationGoalNotReached(ManipulationLowLevelFailure):\n    \"\"\"Thrown when door / drawer opening / closing goal is still not reached.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass EnvironmentManipulationImpossible(HighLevelFailure):\n    \"\"\"Thrown when environment manipulation cannot be achieved.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass EnvironmentUnreachable(HighLevelFailure):\n    \"\"\"Thrown when environment manipulation in collision or unreachable.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass FetchingFailed(HighLevelFailure):\n    \"\"\"Thrown when fetching plan completely gives up.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass GripperLowLevelFailure(LowLevelFailure):\n    \"\"\"Thrown when a failure involving the gripper hardware occurs.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass GripperClosedCompletely(GripperLowLevelFailure):\n    \"\"\"Thrown when the gripper closed completely, despite not being expected to do so (e.g. because it should have\n    grasped something).\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass GripperGoalNotReached(GripperLowLevelFailure):\n    \"\"\"Thrown when the gripper does not reach its goal.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass LookingHighLevelFailure(HighLevelFailure):\n    \"\"\"High-level failure produced when looking for an object, i.e. it is not a hardware issue but one relating to\n    the looking task, its parameters, and how they relate to the environment.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ManipulationGoalInCollision(HighLevelFailure):\n    \"\"\"Thrown when executing a manipulation action results in a collision.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ManipulationGoalNotReached(ManipulationLowLevelFailure):\n    \"\"\"Thrown when after executing the action, goal is still not reached.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass IKError(PlanFailure):\n    \"\"\"Thrown when no inverse kinematics solution could be found\"\"\"\n    def __init__(self, pose, base_frame, tip_frame):\n        self.message = \"Position {} in frame '{}' is not reachable for end effector: '{}'\".format(pose, base_frame, tip_frame)\n        super(IKError, self).__init__(self.message)\n\n\nclass ManipulationPoseUnreachable(ManipulationLowLevelFailure):\n    \"\"\"Thrown when no IK solution can be found.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass NavigationHighLevelFailure(HighLevelFailure):\n    \"\"\"High-level failure produced while navigating the robot, i.e. it is not a hardware issue but one relating to\n    the navigation task, its parameters, and how they relate to the environment.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass NavigationGoalInCollision(NavigationHighLevelFailure):\n    \"\"\"Navigation goal cannot be reached because the goal itself is already occupied by some other object.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass NavigationLowLevelFailure(LowLevelFailure):\n    \"\"\"Low-level failure produced while navigating the robot, i.e. some kind of hardware issue.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass NavigationGoalNotReached(NavigationLowLevelFailure):\n    \"\"\"Thrown when the base moved as a result of the navigation action but the goal was not reached.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass NavigationPoseUnreachable(NavigationLowLevelFailure):\n    \"\"\"Thrown when the goal pose for navigation is computed to be unreachable.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ObjectNowhereToBeFound(HighLevelFailure):\n    \"\"\"Thrown when the robot cannot find an object of a given description in its surroundings.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ObjectUndeliverable(HighLevelFailure):\n    \"\"\"Thrown when no base positioning can assure a reachable pose to place the object from.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ObjectUnfetchable(HighLevelFailure):\n    \"\"\"Thrown when no base positioning can assure a reachable pose to grasp the object from.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ObjectUnreachable(HighLevelFailure):\n    \"\"\"Thrown when no IK found for particular base pose.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass PerceptionLowLevelFailure(LowLevelFailure):\n    \"\"\"Low-level failure produced while perceiving, i.e. some kind of hardware issue.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass PerceptionObjectNotFound(PerceptionLowLevelFailure):\n    \"\"\"Thrown when an attempt to find an object by perception fails -- and this can still be interpreted as the robot\n    not looking in the right direction, as opposed to the object being absent.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass PerceptionObjectNotInWorld(PerceptionLowLevelFailure):\n    \"\"\"Thrown when an attempt to find an object by perception fails -- and this is because the object can be assumed\n    absent or perhaps is known absent because of the setup of a simulation.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass SearchingFailed(HighLevelFailure):\n    \"\"\"Thrown when searching plan completely gives up.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass TorsoLowLevelFailure(LowLevelFailure):\n    \"\"\"Low-level failure produced while moving the torso, i.e. some kind of hardware issue.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass TorsoGoalNotReached(TorsoLowLevelFailure):\n    \"\"\"Thrown when the torso moved as a result of a torso action but the goal was not reached.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass TorsoGoalUnreachable(TorsoLowLevelFailure):\n    \"\"\"Thrown when the goal for the torso is computed to be unreachable.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass Task(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass Grasping(Task):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass Looking(Task):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ObjectPoseMisestimation(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass SuccessfulCompletion(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ObjectNotFound(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass LocomotorFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ArmFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ObjectLost(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass SensorFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass IllPosedGoalFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass CapabilityAbsenceFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ReachabilityFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass TorsoFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ConfigurationNotReached(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass Timeout(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass EndEffectorFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ObjectUnavailable(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass SustainedFailure(PlanFailure):\n    \"\"\"\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass ReasoningError(PlanFailure):\n    def __init__(*args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\nclass CollisionError(PlanFailure):\n    def __init__(*args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are implemented in the pose_generator_and_validator.py file?"}, {"role": "assistant", "content": "# Content from: #<pose_generator_and_validator.py>#\nimport tf\nimport numpy as np\n\nfrom .datastructures.world import World\nfrom .world_concepts.world_object import Object\nfrom .world_reasoning import contact\nfrom .costmaps import Costmap\nfrom .local_transformer import LocalTransformer\nfrom .datastructures.pose import Pose, Transform\nfrom .robot_description import RobotDescription\nfrom .external_interfaces.ik import request_ik\nfrom .plan_failures import IKError\nfrom .utils import _apply_ik\nfrom typing_extensions import Tuple, List, Union, Dict, Iterable\n\n\nclass PoseGenerator:\n    \"\"\"\n    Crates pose candidates from a given costmap. The generator\n    selects the highest values, amount is given by number_of_sample, and returns the corresponding positions.\n    Orientations are calculated such that the Robot faces the center of the costmap.\n    \"\"\"\n\n    current_orientation_generator = None\n    \"\"\"\n    If no orientation generator is given, this generator is used to generate the orientation of the robot.\n    \"\"\"\n    override_orientation_generator = None\n    \"\"\"\n    Override the orientation generator with a custom generator, which will be used regardless of the current_orientation_generator.\n    \"\"\"\n\n    def __init__(self, costmap: Costmap, number_of_samples=100, orientation_generator=None):\n        \"\"\"\n        :param costmap: The costmap from which poses should be sampled.\n        :param number_of_samples: The number of samples from the costmap that should be returned at max\n        :param orientation_generator: function that generates an orientation given a position and the origin of the costmap\n        \"\"\"\n\n        if not PoseGenerator.current_orientation_generator:\n            PoseGenerator.current_orientation_generator = PoseGenerator.generate_orientation\n\n        self.costmap = costmap\n        self.number_of_samples = number_of_samples\n        self.orientation_generator = orientation_generator if orientation_generator else PoseGenerator.current_orientation_generator\n        if PoseGenerator.override_orientation_generator:\n            self.orientation_generator = PoseGenerator.override_orientation_generator\n\n    def __iter__(self) -> Iterable:\n        \"\"\"\n        A generator that crates pose candidates from a given costmap. The generator\n        selects the highest 100 values and returns the corresponding positions.\n        Orientations are calculated such that the Robot faces the center of the costmap.\n\n        :Yield: A tuple of position and orientation\n        \"\"\"\n\n        # Determines how many positions should be sampled from the costmap\n        if self.number_of_samples == -1:\n            self.number_of_samples = self.costmap.map.flatten().shape[0]\n        indices = np.argpartition(self.costmap.map.flatten(), -self.number_of_samples)[-self.number_of_samples:]\n        indices = np.dstack(np.unravel_index(indices, self.costmap.map.shape)).reshape(self.number_of_samples, 2)\n\n        height = self.costmap.map.shape[0]\n        width = self.costmap.map.shape[1]\n        center = np.array([height // 2, width // 2])\n        for ind in indices:\n            if self.costmap.map[ind[0]][ind[1]] == 0:\n                continue\n            # The position is calculated by creating a vector from the 2D position in the costmap (given by x and y)\n            # and the center of the costmap (since this is the origin). This vector is then turned into a transformation\n            # and muiltiplied with the transformation of the origin.\n            vector_to_origin = (center - ind) * self.costmap.resolution\n            point_to_origin = Transform([*vector_to_origin, 0], frame=\"point\", child_frame=\"origin\")\n            origin_to_map = self.costmap.origin.to_transform(\"origin\").invert()\n            point_to_map = point_to_origin * origin_to_map\n            map_to_point = point_to_map.invert()\n\n            orientation = self.orientation_generator(map_to_point.translation_as_list(), self.costmap.origin)\n            yield Pose(map_to_point.translation_as_list(), orientation)\n\n    @staticmethod\n    def height_generator() -> float:\n        pass\n\n    @staticmethod\n    def generate_orientation(position: List[float], origin: Pose) -> List[float]:\n        \"\"\"\n        This method generates the orientation for a given position in a costmap. The\n        orientation is calculated such that the robot faces the origin of the costmap.\n        This generation is done by simply calculating the arctan between the position,\n        in the costmap, and the origin of the costmap.\n\n        :param position: The position in the costmap. This position is already converted to the world coordinate frame.\n        :param origin: The origin of the costmap. This is also the point which the robot should face.\n        :return: A quaternion of the calculated orientation\n        \"\"\"\n        angle = np.arctan2(position[1] - origin.position.y, position[0] - origin.position.x) + np.pi\n        quaternion = list(tf.transformations.quaternion_from_euler(0, 0, angle, axes=\"sxyz\"))\n        return quaternion\n\n\ndef visibility_validator(pose: Pose,\n                         robot: Object,\n                         object_or_pose: Union[Object, Pose],\n                         world: World) -> bool:\n    \"\"\"\n    This method validates if the robot can see the target position from a given\n    pose candidate. The target position can either be a position, in world coordinate\n    system, or an object in the World. The validation is done by shooting a\n    ray from the camera to the target position and checking that it does not collide\n    with anything else.\n\n    :param pose: The pose candidate that should be validated\n    :param robot: The robot object for which this should be validated\n    :param object_or_pose: The target position or object for which the pose candidate should be validated.\n    :param world: The World instance in which this should be validated.\n    :return: True if the target is visible for the robot, None in any other case.\n    \"\"\"\n    robot_pose = robot.get_pose()\n    if isinstance(object_or_pose, Object):\n        robot.set_pose(pose)\n        camera_pose = robot.get_link_pose(RobotDescription.current_robot_description.get_camera_frame())\n        robot.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))\n        ray = world.ray_test(camera_pose.position_as_list(), object_or_pose.get_position_as_list())\n        res = ray == object_or_pose.id\n    else:\n        robot.set_pose(pose)\n        camera_pose = robot.get_link_pose(RobotDescription.current_robot_description.get_camera_frame())\n        robot.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))\n        # TODO: Check if this is correct\n        ray = world.ray_test(camera_pose.position_as_list(), object_or_pose)\n        res = ray == -1\n    robot.set_pose(robot_pose)\n    return res\n\n\ndef _in_contact(robot: Object, obj: Object, allowed_collision: Dict[Object, List[str]],\n                allowed_robot_links: List[str]) -> bool:\n    \"\"\"\n    This method checks if a given robot is in contact with a given object.\n\n    :param robot: The robot object that should be checked for contact.\n    :param obj: The object that should be checked for contact with the robot.\n    :param allowed_collision: A dictionary that contains the allowed collisions for links of each object in the world.\n    :param allowed_robot_links: A list of links of the robot that are allowed to be in contact with the object.\n    :return: True if the robot is in contact with the object and False otherwise.\n    \"\"\"\n    in_contact, contact_links = contact(robot, obj, return_links=True)\n    allowed_links = allowed_collision[obj] if obj in allowed_collision.keys() else []\n\n    if in_contact:\n        for link in contact_links:\n            if link[0].name in allowed_robot_links or link[1].name in allowed_links:\n                in_contact = False\n                # TODO: in_contact is never set to True after it was set to False is that correct?\n                # TODO: If it is correct, then this loop should break after the first contact is found\n    return in_contact\n\n\ndef reachability_validator(pose: Pose,\n                           robot: Object,\n                           target: Union[Object, Pose],\n                           allowed_collision: Dict[Object, List] = None) -> Tuple[bool, List]:\n    \"\"\"\n    This method validates if a target position is reachable for a pose candidate.\n    This is done by asking the ik solver if there is a valid solution if the\n    robot stands at the position of the pose candidate. if there is a solution\n    the validator returns True and False in any other case.\n\n    :param pose: The pose candidate for which the reachability should be validated\n    :param robot: The robot object in the World for which the reachability should be validated.\n    :param target: The target position or object instance which should be the target for reachability.\n    :param allowed_collision: dict of objects with which the robot is allowed to collide each object correlates to a list of links of which this object consists\n    :return: True if the target is reachable for the robot and False in any other case.\n    \"\"\"\n    if type(target) == Object:\n        target = target.get_pose()\n\n    robot.set_pose(pose)\n    # manipulator_descs = list(\n    #    filter(lambda chain: isinstance(chain[1], ManipulatorDescription), robot_description.chains.items()))\n    manipulator_descs = RobotDescription.current_robot_description.get_manipulator_chains()\n\n    # TODO Make orientation adhere to grasping orientation\n    res = False\n    arms = []\n    for description in manipulator_descs:\n        retract_target_pose = LocalTransformer().transform_pose(target, robot.get_link_tf_frame(description.end_effector.tool_frame))\n        retract_target_pose.position.x -= 0.07  # Care hard coded value copied from PlaceAction class\n\n        # retract_pose needs to be in world frame?\n        retract_target_pose = LocalTransformer().transform_pose(retract_target_pose, \"map\")\n\n        joints = description.joints\n        tool_frame = description.end_effector.tool_frame\n\n        # TODO Make orientation adhere to grasping orientation\n        in_contact = False\n\n        joint_state_before_ik = robot.get_positions_of_all_joints()\n        try:\n            # test the possible solution and apply it to the robot\n            pose, joint_states = request_ik(target, robot, joints, tool_frame)\n            robot.set_pose(pose)\n            robot.set_joint_positions(joint_states)\n            # _apply_ik(robot, resp, joints)\n\n            in_contact = collision_check(robot, allowed_collision)\n            if not in_contact:  # only check for retract pose if pose worked\n                pose, joint_states = request_ik(retract_target_pose, robot, joints, tool_frame)\n                robot.set_pose(pose)\n                robot.set_joint_positions(joint_states)\n                # _apply_ik(robot, resp, joints)\n                in_contact = collision_check(robot, allowed_collision)\n            if not in_contact:\n                arms.append(description.arm_type)\n        except IKError:\n            pass\n        finally:\n            robot.set_joint_positions(joint_state_before_ik)\n    if arms:\n        res = True\n    return res, arms\n\n\ndef collision_check(robot: Object, allowed_collision: Dict[Object, List]):\n    \"\"\"\n    This method checks if a given robot collides with any object within the world\n    which it is not allowed to collide with.\n    This is done checking iterating over every object within the world and checking\n    if the robot collides with it. Careful the floor will be ignored.\n    If there is a collision with an object that was not within the allowed collision\n    list the function returns True else it will return False\n\n    :param robot: The robot object in the (Bullet)World where it should be checked if it collides with something\n    :param allowed_collision: dict of objects with which the robot is allowed to collide each object correlates to a list of links of which this object consists\n    :return: True if the target is reachable for the robot and False in any other case.\n    \"\"\"\n    in_contact = False\n    allowed_robot_links = []\n    if robot in allowed_collision.keys():\n        allowed_robot_links = allowed_collision[robot]\n\n    for obj in World.current_world.objects:\n        if obj.name == \"floor\":\n            continue\n        in_contact= _in_contact(robot, obj, allowed_collision, allowed_robot_links)\n\n    return in_contact\n\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the process_module.py file and how do they interact with other components?"}, {"role": "assistant", "content": "# Content from: #<process_module.py>#\n\"\"\"Implementation of process modules.\n\nClasses:\nProcessModule -- implementation of process modules.\n\"\"\"\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\nimport inspect\nimport threading\nimport time\nfrom abc import ABC\nfrom typing_extensions import Callable, Type, Any, Union\n\nimport rospy\n\nfrom .language import Language\nfrom .robot_description import RobotDescription\nfrom typing_extensions import TYPE_CHECKING\nfrom .datastructures.enums import ExecutionType\n\nif TYPE_CHECKING:\n    from .designators.motion_designator import BaseMotion\n\n\nclass ProcessModule:\n    \"\"\"\n    Implementation of process modules. Process modules are the part that communicate with the outer world to execute\n     designators.\n    \"\"\"\n    execution_delay = False\n    \"\"\"\n    Adds a delay of 0.5 seconds after executing a process module, to make the execution in simulation more realistic\n    \"\"\"\n    block_list = []\n    \"\"\"\n    List of thread ids for which no Process Modules should be executed. This is used as an interrupt mechanism for \n    Designators\n    \"\"\"\n\n    def __init__(self, lock):\n        \"\"\"Create a new process module.\"\"\"\n        self._lock = lock\n\n    def _execute(self, designator: BaseMotion) -> Any:\n        \"\"\"\n        Helper method for internal usage only.\n        This method is to be overwritten instead of the execute method.\n        \"\"\"\n        pass\n\n    def execute(self, designator: BaseMotion) -> Any:\n        \"\"\"\n        Execute the given designator. If there is already another process module of the same kind the `self._lock` will\n        lock this thread until the execution of that process module is finished. This implicitly queues the execution of\n        process modules.\n\n        :param designator: The designator to execute.\n        :return: Return of the Process Module if there is any\n        \"\"\"\n        if threading.get_ident() in Language.block_list:\n            return None\n        with self._lock:\n            ret = self._execute(designator)\n            if ProcessModule.execution_delay:\n                time.sleep(0.5)\n\n        return ret\n\n\nclass RealRobot:\n    \"\"\"\n    Management class for executing designators on the real robot. This is intended to be used in a with environment.\n    When importing this class an instance is imported instead.\n\n    Example:\n\n    .. code-block:: python\n\n        with real_robot:\n            some designators\n    \"\"\"\n\n    def __init__(self):\n        self.pre: str = \"\"\n        self.pre_delay: bool = False\n\n    def __enter__(self):\n        \"\"\"\n        Entering function for 'with' scope, saves the previously set :py:attr:`~ProcessModuleManager.execution_type` and\n        sets it to 'real'\n        \"\"\"\n        self.pre = ProcessModuleManager.execution_type\n        ProcessModuleManager.execution_type = ExecutionType.REAL\n        self.pre_delay = ProcessModule.execution_delay\n        ProcessModule.execution_delay = False\n\n    def __exit__(self, _type, value, traceback):\n        \"\"\"\n        Exit method for the 'with' scope, sets the :py:attr:`~ProcessModuleManager.execution_type` to the previously\n        used one.\n        \"\"\"\n        ProcessModuleManager.execution_type = self.pre\n        ProcessModule.execution_delay = self.pre_delay\n\n    def __call__(self):\n        return self\n\n\nclass SimulatedRobot:\n    \"\"\"\n    Management class for executing designators on the simulated robot. This is intended to be used in\n    a with environment. When importing this class an instance is imported instead.\n\n    Example:\n\n    .. code-block:: python\n\n        with simulated_robot:\n            some designators\n    \"\"\"\n\n    def __init__(self):\n        self.pre: str = \"\"\n\n    def __enter__(self):\n        \"\"\"\n        Entering function for 'with' scope, saves the previously set :py:attr:`~ProcessModuleManager.execution_type` and\n        sets it to 'simulated'\n        \"\"\"\n        self.pre = ProcessModuleManager.execution_type\n        ProcessModuleManager.execution_type = ExecutionType.SIMULATED\n\n    def __exit__(self, _type, value, traceback):\n        \"\"\"\n        Exit method for the 'with' scope, sets the :py:attr:`~ProcessModuleManager.execution_type` to the previously\n        used one.\n        \"\"\"\n        ProcessModuleManager.execution_type = self.pre\n\n    def __call__(self):\n        return self\n\n\nclass SemiRealRobot:\n    \"\"\"\n    Management class for executing designators on the semi-real robot. This is intended to be used in a with environment.\n    When importing this class an instance is imported instead.\n\n    Example:\n\n    .. code-block:: python\n\n        with semi_real_robot:\n            some designators\n    \"\"\"\n\n    def __init__(self):\n        self.pre: str = \"\"\n\n    def __enter__(self):\n        \"\"\"\n        Entering function for 'with' scope, saves the previously set :py:attr:`~ProcessModuleManager.execution_type` and\n        sets it to 'semi_real'\n        \"\"\"\n        self.pre = ProcessModuleManager.execution_type\n        ProcessModuleManager.execution_type = ExecutionType.SEMI_REAL\n\n    def __exit__(self, type, value, traceback):\n        \"\"\"\n        Exit method for the 'with' scope, sets the :py:attr:`~ProcessModuleManager.execution_type` to the previously\n        used one.\n        \"\"\"\n        ProcessModuleManager.execution_type = self.pre\n\n    def __call__(self):\n        return self\n\n\ndef with_real_robot(func: Callable) -> Callable:\n    \"\"\"\n    Decorator to execute designators in the decorated class on the real robot.\n\n    Example:\n\n    .. code-block:: python\n\n        @with_real_robot\n        def plan():\n            some designators\n\n    :param func: Function this decorator is annotating\n    :return: The decorated function wrapped into the decorator\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        pre = ProcessModuleManager.execution_type\n        ProcessModuleManager.execution_type = ExecutionType.REAL\n        ret = func(*args, **kwargs)\n        ProcessModuleManager.execution_type = pre\n        return ret\n\n    return wrapper\n\n\ndef with_simulated_robot(func: Callable) -> Callable:\n    \"\"\"\n    Decorator to execute designators in the decorated class on the simulated robot.\n\n    Example:\n\n    .. code-block:: python\n\n        @with_simulated_robot\n        def plan():\n            some designators\n\n    :param func: Function this decorator is annotating\n    :return: The decorated function wrapped into the decorator\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        pre = ProcessModuleManager.execution_type\n        ProcessModuleManager.execution_type = ExecutionType.Simulated\n        ret = func(*args, **kwargs)\n        ProcessModuleManager.execution_type = pre\n        return ret\n\n    return wrapper\n\n\n# These are imported, so they don't have to be initialized when executing with\nsimulated_robot = SimulatedRobot()\nreal_robot = RealRobot()\nsemi_real_robot = SemiRealRobot()\n\n\nclass ProcessModuleManager(ABC):\n    \"\"\"\n    Base class for managing process modules, any new process modules have to implement this class to register the\n    Process Modules\n    \"\"\"\n    execution_type = None\n    \"\"\"\n    Whether the robot for which the process module is intended for is real or a simulated one\n    \"\"\"\n    available_pms = []\n    \"\"\"\n    List of all available Process Module Managers\n    \"\"\"\n    _instance = None\n    \"\"\"\n    Singelton instance of this Process Module Manager\n    \"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        \"\"\"\n        Creates a new instance if :py:attr:`~ProcessModuleManager._instance` is None, otherwise the instance\n        in :py:attr:`~ProcessModuleManager._instance` is returned.\n        :return: Singelton instance of this Process Module Manager\n        \"\"\"\n        if not cls._instance:\n            cls._instance = super(ProcessModuleManager, cls).__new__(cls)\n            return cls._instance\n        else:\n            return cls._instance\n\n    def __init__(self, robot_name):\n        \"\"\"\n        Registers the Process modules for this robot. The name of the robot has to match the name given in the robot\n        description.\n\n        :param robot_name: Name of the robot for which these Process Modules are intended\n        \"\"\"\n        self.robot_name = robot_name\n        ProcessModuleManager.available_pms.append(self)\n\n    @staticmethod\n    def get_manager() -> Union[ProcessModuleManager, None]:\n        \"\"\"\n        Returns the Process Module manager for the currently loaded robot or None if there is no Manager.\n\n        :return: ProcessModuleManager instance of the current robot\n        \"\"\"\n        manager = None\n        _default_manager = None\n        if not ProcessModuleManager.execution_type:\n            rospy.logerr(\n                f\"No execution_type is set, did you use the with_simulated_robot or with_real_robot decorator?\")\n            return\n\n        for pm_manager in ProcessModuleManager.available_pms:\n            if pm_manager.robot_name == RobotDescription.current_robot_description.name:\n                manager = pm_manager\n            if pm_manager.robot_name == \"default\":\n                _default_manager = pm_manager\n\n        if manager:\n            return manager\n        elif _default_manager:\n            rospy.logwarn_once(f\"No Process Module Manager found for robot: '{RobotDescription.current_robot_description.name}'\"\n                               f\", using default process modules\")\n            return _default_manager\n        else:\n            rospy.logerr(f\"No Process Module Manager found for robot: '{RobotDescription.current_robot_description.name}'\"\n                         f\", and no default process modules available\")\n            return None\n\n    def navigate(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for navigating the robot with respect to\n         the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for navigating\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def pick_up(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for picking up with respect to the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for picking up an object\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def place(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for placing with respect to the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for placing an Object\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def looking(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for looking at a point with respect to\n         the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for looking at a specific point\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def detecting(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for detecting an object with respect to\n         the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for detecting an object\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def move_tcp(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for moving the Tool Center Point with respect to\n         the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for moving the TCP\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def move_arm_joints(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for moving the joints of the robot arm\n        with respect to the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for moving the arm joints\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def world_state_detecting(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for detecting an object using the world state with respect to the\n        :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for world state detecting\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def move_joints(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for moving any joint of the robot with respect to the\n        :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for moving joints\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def move_gripper(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for moving the gripper with respect to\n         the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for moving the gripper\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def open(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for opening drawers with respect to\n         the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for opening drawers\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n    def close(self) -> Type[ProcessModule]:\n        \"\"\"\n        Returns the Process Module for closing drawers with respect to\n         the :py:attr:`~ProcessModuleManager.execution_type`\n\n        :return: The Process Module for closing drawers\n        \"\"\"\n        raise NotImplementedError(\n            f\"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'\")\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What parameters can be configured in the robot_description.py file for a robot simulation?"}, {"role": "assistant", "content": "# Content from: #<robot_description.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nimport rospy\nfrom typing_extensions import List, Dict, Union, Optional\nfrom urdf_parser_py.urdf import URDF\n\nfrom .utils import suppress_stdout_stderr\nfrom .datastructures.enums import Arms, Grasp, GripperState, GripperType\n\n\nclass RobotDescriptionManager:\n    \"\"\"\n    Singleton class to manage multiple robot descriptions. Stores all robot descriptions and loads a robot description\n    according to the name of the loaded robot.\n    \"\"\"\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self):\n        \"\"\"\n        Initialize the RobotDescriptionManager, if no instance exists a new instance is created.\n        \"\"\"\n        if self._initialized: return\n        self.descriptions: Dict[str, RobotDescription] = {}\n        self._initialized = True\n\n    def load_description(self, name: str):\n        \"\"\"\n        Loads a robot description according to the name of the robot. This required that a robot description with the\n        corresponding name is registered.\n\n        :param name: Name of the robot to which the description should be loaded.\n        :return: The loaded robot description.\n        \"\"\"\n        if name in self.descriptions.keys():\n            RobotDescription.current_robot_description = self.descriptions[name]\n            return self.descriptions[name]\n        else:\n            rospy.logerr(f\"Robot description {name} not found\")\n\n    def register_description(self, description: RobotDescription):\n        \"\"\"\n        Register a robot description to the RobotDescriptionManager. The description is stored with the name of the\n        description as key. This will later be used to load the description.\n\n        :param description: RobotDescription to register.\n        \"\"\"\n        if description.name in self.descriptions.keys():\n            raise ValueError(f\"Description {description.name} already exists\")\n        self.descriptions[description.name] = description\n\n\nclass RobotDescription:\n    \"\"\"\n    Base class of a robot description. Contains all necessary information about a robot, like the URDF, the base link,\n    the torso link and joint, the kinematic chains and cameras.\n    \"\"\"\n    current_robot_description: RobotDescription = None\n    \"\"\"\n    The currently loaded robot description.\n    \"\"\"\n    name: str\n    \"\"\"\n    Name of the robot\n    \"\"\"\n    base_link: str\n    \"\"\"\n    Base link of the robot\n    \"\"\"\n    torso_link: str\n    \"\"\"\n    Torso link of the robot\n    \"\"\"\n    torso_joint: str\n    \"\"\"\n    Torso joint of the robot\n    \"\"\"\n    urdf_object: URDF\n    \"\"\"\n    Parsed URDF of the robot\n    \"\"\"\n    kinematic_chains: Dict[str, KinematicChainDescription]\n    \"\"\"\n    All kinematic chains defined for this robot\n    \"\"\"\n    cameras: Dict[str, CameraDescription]\n    \"\"\"\n    All cameras defined for this robot\n    \"\"\"\n    grasps: Dict[Grasp, List[float]]\n    \"\"\"\n    The orientations of the end effector for different grasps\n    \"\"\"\n    links: List[str]\n    \"\"\"\n    All links defined in the URDF\n    \"\"\"\n    joints: List[str]\n    \"\"\"\n    All joints defined in the URDF, by default fixed joints are not included\n    \"\"\"\n\n    def __init__(self, name: str, base_link: str, torso_link: str, torso_joint: str, urdf_path: str):\n        \"\"\"\n        Initialize the RobotDescription. The URDF is loaded from the given path and used as basis for the kinematic\n        chains.\n\n        :param name: Name of the robot\n        :param base_link: Base link of the robot, meaning the first link in the URDF\n        :param torso_link: Torso link of the robot\n        :param torso_joint: Torso joint of the robot, this is the joint that moves the torso upwards if there is one\n        :param urdf_path: Path to the URDF file of the robot\n        \"\"\"\n        self.name = name\n        self.base_link = base_link\n        self.torso_link = torso_link\n        self.torso_joint = torso_joint\n        with suppress_stdout_stderr():\n            # Since parsing URDF causes a lot of warning messages which can't be deactivated, we suppress them\n            self.urdf_object = URDF.from_xml_file(urdf_path)\n        self.kinematic_chains: Dict[str, KinematicChainDescription] = {}\n        self.cameras: Dict[str, CameraDescription] = {}\n        self.grasps: Dict[Grasp, List[float]] = {}\n        self.links: List[str] = [l.name for l in self.urdf_object.links]\n        self.joints: List[str] = [j.name for j in self.urdf_object.joints]\n\n    def add_kinematic_chain_description(self, chain: KinematicChainDescription):\n        \"\"\"\n        Adds a KinematicChainDescription object to the RobotDescription. The chain is stored with the name of the chain\n        as key.\n\n        :param chain: KinematicChainDescription object to add\n        \"\"\"\n        if chain.name in self.kinematic_chains.keys():\n            raise ValueError(f\"Chain {chain.name} already exists for robot {self.name}\")\n        self.kinematic_chains[chain.name] = chain\n\n    def add_kinematic_chain(self, name: str, start_link: str, end_link: str):\n        \"\"\"\n        Creates and adds a KinematicChainDescription object to the RobotDescription.\n\n        :param name: Name of the KinematicChainDescription object\n        :param start_link: First link of the chain\n        :param end_link: Last link of the chain\n        \"\"\"\n        if name in self.kinematic_chains.keys():\n            raise ValueError(f\"Chain {name} already exists for robot {self.name}\")\n        chain = KinematicChainDescription(name, start_link, end_link, self.urdf_object)\n        self.add_kinematic_chain_description(chain)\n\n    def add_camera_description(self, camera: CameraDescription):\n        \"\"\"\n        Adds a CameraDescription object to the RobotDescription. The camera is stored with the name of the camera as key.\n        :param camera: The CameraDescription object to add\n        \"\"\"\n        name = camera.name\n        if name in self.cameras.keys():\n            raise ValueError(f\"Camera {name} already exists for robot {self.name}\")\n        self.cameras[name] = camera\n\n    def add_camera(self, name: str, camera_link: str, minimal_height: float, maximal_height: float):\n        \"\"\"\n        Creates and adds a CameraDescription object to the RobotDescription. Minimal and maximal height of the camera are\n        relevant if the robot has a moveable torso or the camera is mounted on a moveable part of the robot. Otherwise\n        both values can be the same.\n\n        :param name: Name of the CameraDescription object\n        :param camera_link: Link of the camera in the URDF\n        :param minimal_height: Minimal height of the camera\n        :param maximal_height: Maximal height of the camera\n        :return:\n        \"\"\"\n        camera_desc = CameraDescription(name, camera_link, minimal_height, maximal_height)\n        self.cameras[name] = camera_desc\n\n    def add_grasp_orientation(self, grasp: Grasp, orientation: List[float]):\n        \"\"\"\n        Adds a grasp orientation to the robot description. This is used to define the orientation of the end effector\n        when grasping an object.\n\n        :param grasp: Gasp from the Grasp enum which should be added\n        :param orientation: List of floats representing the orientation\n        \"\"\"\n        self.grasps[grasp] = orientation\n\n    def add_grasp_orientations(self, orientations: Dict[Grasp, List[float]]):\n        \"\"\"\n        Adds multiple grasp orientations to the robot description. This is used to define the orientation of the end effector\n        when grasping an object.\n\n        :param orientations: Dictionary of grasp orientations\n        \"\"\"\n        self.grasps.update(orientations)\n\n    def get_manipulator_chains(self) -> List[KinematicChainDescription]:\n        \"\"\"\n        Returns a list of all manipulator chains of the robot which posses an end effector.\n\n        :return: A list of KinematicChainDescription objects\n        \"\"\"\n        result = []\n        for chain in self.kinematic_chains.values():\n            if chain.end_effector:\n                result.append(chain)\n        return result\n\n    def get_camera_frame(self) -> str:\n        \"\"\"\n        Quick method to get the name of a link of a camera. Uses the first camera in the list of cameras.\n\n        :return: A name of the link of a camera\n        \"\"\"\n        return self.cameras[list(self.cameras.keys())[0]].link_name\n\n    def get_default_camera(self) -> CameraDescription:\n        \"\"\"\n        Returns the first camera in the list of cameras.\n\n        :return: A CameraDescription object\n        \"\"\"\n        return self.cameras[list(self.cameras.keys())[0]]\n\n    def get_static_joint_chain(self, kinematic_chain_name: str, configuration_name: str):\n        \"\"\"\n        Returns the static joint states of a kinematic chain for a specific configuration. When trying to access one of\n        the robot arms the function `:func: get_arm_chain` should be used.\n\n        :param kinematic_chain_name:\n        :param configuration_name:\n        :return:\n        \"\"\"\n        if kinematic_chain_name in self.kinematic_chains.keys():\n            if configuration_name in self.kinematic_chains[kinematic_chain_name].static_joint_states.keys():\n                return self.kinematic_chains[kinematic_chain_name].static_joint_states[configuration_name]\n            else:\n                raise ValueError(\n                    f\"There is no static joint state with the name {configuration_name} for Kinematic chain {kinematic_chain_name} of robot {self.name}\")\n        else:\n            raise ValueError(f\"There is no KinematicChain with name {kinematic_chain_name} for robot {self.name}\")\n\n    def get_parent(self, name: str) -> str:\n        \"\"\"\n        Returns the parent of a link or joint in the URDF. Always returns the imeadiate parent, for a link this is a joint\n        and vice versa.\n\n        :param name: Name of the link or joint in the URDF\n        :return: Name of the parent link or joint\n        \"\"\"\n        if name not in self.links and name not in self.joints:\n            raise ValueError(f\"Link or joint {name} not found in URDF\")\n        if name in self.links:\n            if name in self.urdf_object.parent_map:\n                parent_joint, parent_link = self.urdf_object.parent_map[name]\n                return parent_joint\n            else:\n                raise ValueError(f\"Link {name} has no parent\")\n        elif name in self.joints:\n            parent_link = self.urdf_object.joint_map[name].parent\n            return parent_link\n\n    def get_child(self, name: str, return_multiple_children: bool = False) -> Union[str, List[str]]:\n        \"\"\"\n        Returns the child of a link or joint in the URDF. Always returns the immediate child, for a link this is a joint\n        and vice versa. Since a link can have multiple children, the return_multiple_children parameter can be set to\n        True to get a list of all children.\n\n        :param name: Name of the link or joint in the URDF\n        :param return_multiple_children: If True, a list of all children is returned\n        :return: Name of the child link or joint or a list of all children\n        \"\"\"\n        if name not in self.links and name not in self.joints:\n            raise ValueError(f\"Link or joint {name} not found in URDF\")\n        if name in self.links:\n            if name in self.urdf_object.child_map:\n                children = self.urdf_object.child_map[name]\n                # A link can have multiple children\n                child_joints = [child[0] for child in children]\n                if return_multiple_children:\n                    child_joints.reverse()\n                    return child_joints\n                else:\n                    return child_joints[0]\n\n            else:\n                raise ValueError(f\"Link {name} has no children\")\n        elif name in self.joints:\n            child_link = self.urdf_object.joint_map[name].child\n            return child_link\n\n    def get_arm_chain(self, arm: Arms) -> Union[KinematicChainDescription, List[KinematicChainDescription]]:\n        \"\"\"\n        Returns the kinematic chain of a specific arm. If the arm is set to BOTH, all kinematic chains are returned.\n\n        :param arm: Arm for which the chain should be returned\n        :return: KinematicChainDescription object of the arm\n        \"\"\"\n        if arm == Arms.BOTH:\n            return list(filter(lambda chain: chain.arm_type is not None, self.kinematic_chains.values()))\n        for chain in self.kinematic_chains.values():\n            if chain.arm_type == arm:\n                return chain\n        raise ValueError(f\"There is no Kinematic Chain for the Arm {arm}\")\n\n\nclass KinematicChainDescription:\n    \"\"\"\n    Represents a kinematic chain of a robot. A Kinematic chain is a chain of links and joints that are connected to each\n    other and can be moved.\n\n    This class contains all necessary information about the chain, like the start and end\n    link, the URDF object and the joints of the chain.\n    \"\"\"\n\n    name: str\n    \"\"\"\n    Name of the chain\n    \"\"\"\n    start_link: str\n    \"\"\"\n    First link of the chain\n    \"\"\"\n    end_link: str\n    \"\"\"\n    Last link of the chain\n    \"\"\"\n    urdf_object: URDF\n    \"\"\"\n    Parsed URDF of the robot\n    \"\"\"\n    include_fixed_joints: bool\n    \"\"\"\n    If True, fixed joints are included in the chain\n    \"\"\"\n    link_names: List[str]\n    \"\"\"\n    List of all links in the chain\n    \"\"\"\n    joint_names: List[str]\n    \"\"\"\n    List of all joints in the chain\n    \"\"\"\n    end_effector: EndEffectorDescription\n    \"\"\"\n    End effector of the chain, if there is one\n    \"\"\"\n    arm_type: Arms\n    \"\"\"\n    Type of the arm, if the chain is an arm\n    \"\"\"\n    static_joint_states: Dict[str, Dict[str, float]]\n    \"\"\"\n    Dictionary of static joint states for the chain\n    \"\"\"\n\n    def __init__(self, name: str, start_link: str, end_link: str, urdf_object: URDF, arm_type: Arms = None,\n                 include_fixed_joints=False):\n        \"\"\"\n        Initialize the KinematicChainDescription object.\n\n        :param name: Name of the chain\n        :param start_link: First link of the chain\n        :param end_link: Last link of the chain\n        :param urdf_object: URDF object of the robot which is used to get the chain\n        :param arm_type: Type of the arm, if the chain is an arm\n        :param include_fixed_joints: If True, fixed joints are included in the chain\n        \"\"\"\n        self.name: str = name\n        self.start_link: str = start_link\n        self.end_link: str = end_link\n        self.urdf_object: URDF = urdf_object\n        self.include_fixed_joints: bool = include_fixed_joints\n        self.link_names: List[str] = []\n        self.joint_names: List[str] = []\n        self.arm_type: Arms = arm_type\n        self.static_joint_states: Dict[str, Dict[str, float]] = {}\n        self.end_effector = None\n\n        self._init_links()\n        self._init_joints()\n\n    def _init_links(self):\n        \"\"\"\n        Initializes the links of the chain by getting the chain from the URDF object.\n        \"\"\"\n        self.link_names = self.urdf_object.get_chain(self.start_link, self.end_link, joints=False)\n\n    def _init_joints(self):\n        \"\"\"\n        Initializes the joints of the chain by getting the chain from the URDF object.\n        \"\"\"\n        joints = self.urdf_object.get_chain(self.start_link, self.end_link, links=False)\n        self.joint_names = list(filter(lambda j: self.urdf_object.joint_map[j].type != \"fixed\" or self.include_fixed_joints, joints))\n\n    def get_joints(self) -> List[str]:\n        \"\"\"\n        Returns a list of all joints of the chain.\n\n        :return: List of joint names\n        \"\"\"\n        return self.joint_names\n\n    def get_links(self) -> List[str]:\n        \"\"\"\n        Returns a list of all links of the chain.\n\n        :return: List of link names\n        \"\"\"\n        return self.link_names\n\n    @property\n    def links(self) -> List[str]:\n        \"\"\"\n        Property to get the links of the chain.\n\n        :return: List of link names\n        \"\"\"\n        return self.get_links()\n\n    @property\n    def joints(self) -> List[str]:\n        \"\"\"\n        Property to get the joints of the chain.\n\n        :return: List of joint names\n        \"\"\"\n        return self.get_joints()\n\n    def add_static_joint_states(self, name: str, states: dict):\n        \"\"\"\n        Adds static joint states to the chain. These define a specific configuration of the chain.\n\n        :param name: Name of the static joint states\n        :param states: Dictionary of joint names and their values\n        \"\"\"\n        for joint_name, value in states.items():\n            if joint_name not in self.joint_names:\n                raise ValueError(f\"Joint {joint_name} is not part of the chain\")\n        self.static_joint_states[name] = states\n\n    def get_static_joint_states(self, name: str) -> Dict[str, float]:\n        \"\"\"\n        Returns the dictionary of static joint states for a given name of the static joint states.\n\n        :param name: Name of the static joint states\n        :return: Dictionary of joint names and their values\n        \"\"\"\n        try:\n            return self.static_joint_states[name]\n        except KeyError:\n            rospy.logerr(f\"Static joint states for chain {name} not found\")\n\n    def get_tool_frame(self) -> str:\n        \"\"\"\n        Returns the name of the tool frame of the end effector of this chain, if it has an end effector.\n\n        :return: The name of the link of the tool frame in the URDF.\n        \"\"\"\n        if self.end_effector:\n            return self.end_effector.tool_frame\n        else:\n            raise ValueError(f\"The Kinematic chain {self.name} has no end-effector\")\n\n    def get_static_gripper_state(self, state: GripperState) -> Dict[str, float]:\n        \"\"\"\n        Returns the static joint states for the gripper of the chain.\n\n        :param state: Name of the static joint states\n        :return: Dictionary of joint names and their values\n        \"\"\"\n        if self.end_effector:\n            return self.end_effector.static_joint_states[state]\n        else:\n            raise ValueError(f\"The Kinematic chain {self.name} has no end-effector\")\n\n\nclass CameraDescription:\n    \"\"\"\n    Represents a camera mounted on a robot. Contains all necessary information about the camera, like the link name,\n    minimal and maximal height, horizontal and vertical angle and the front facing axis.\n    \"\"\"\n    name: str\n    \"\"\"\n    Name of the camera\n    \"\"\"\n    link_name: str\n    \"\"\"\n    Name of the link in the URDF\n    \"\"\"\n    minimal_height: float\n    \"\"\"\n    Minimal height the camera can be at\n    \"\"\"\n    maximal_height: float\n    \"\"\"\n    Maximal height the camera can be at\n    \"\"\"\n    horizontal_angle: float\n    \"\"\"\n    Horizontal opening angle of the camera\n    \"\"\"\n    vertical_angle: float\n    \"\"\"\n    Vertical opening angle of the camera\n    \"\"\"\n    front_facing_axis: List[int]\n    \"\"\"\n    Axis along which the camera is taking the image\n    \"\"\"\n\n    def __init__(self, name: str, link_name: str, minimal_height: float, maximal_height: float,\n                 horizontal_angle: float = 20, vertical_angle: float = 20, front_facing_axis: List[float] = None):\n        \"\"\"\n        Initialize the CameraDescription object.\n\n        :param name: Name of the camera\n        :param link_name: Name of the link in the URDF\n        :param minimal_height: Minimal height the camera can be at\n        :param maximal_height: Maximal height the camera can be at\n        :param horizontal_angle: Horizontal opening angle of the camera\n        :param vertical_angle: Vertical opening angle of the camera\n        :param front_facing_axis: Axis along which the camera taking the image\n        \"\"\"\n        self.name: str = name\n        self.link_name: str = link_name\n        self.minimal_height: float = minimal_height\n        self.maximal_height: float = maximal_height\n        self.horizontal_angle: float = horizontal_angle\n        self.vertical_angle: float = vertical_angle\n        self.front_facing_axis: List[int] = front_facing_axis if front_facing_axis else [0, 0, 1]\n\n\nclass EndEffectorDescription:\n    \"\"\"\n    Describes an end effector of robot. Contains all necessary information about the end effector, like the\n    base link, the tool frame, the URDF object and the static joint states.\n    \"\"\"\n    name: str\n    \"\"\"\n    Name of the end effector\n    \"\"\"\n    start_link: str\n    \"\"\"\n    Root link of the end effector, every link below this link in the URDF is part of the end effector\n    \"\"\"\n    tool_frame: str\n    \"\"\"\n    Name of the tool frame link in the URDf\n    \"\"\"\n    urdf_object: URDF\n    \"\"\"\n    Parsed URDF of the robot\n    \"\"\"\n    link_names: List[str]\n    \"\"\"\n    List of all links in the end effector\n    \"\"\"\n    joint_names: List[str]\n    \"\"\"\n    List of all joints in the end effector\n    \"\"\"\n    static_joint_states: Dict[GripperState, Dict[str, float]]\n    \"\"\"\n    Dictionary of static joint states for the end effector\n    \"\"\"\n    end_effector_type: GripperType\n    \"\"\"\n    Type of the gripper\n    \"\"\"\n    opening_distance: float\n    \"\"\"\n    Distance the gripper can open, in cm\n    \"\"\"\n\n    def __init__(self, name: str, start_link: str, tool_frame: str, urdf_object: URDF):\n        \"\"\"\n        Initialize the EndEffectorDescription object.\n\n        :param name: Name of the end effector\n        :param start_link: Root link of the end effector, every link below this link in the URDF is part of the end effector\n        :param tool_frame: Name of the tool frame link in the URDf\n        :param urdf_object: URDF object of the robot\n        \"\"\"\n        self.name: str = name\n        self.start_link: str = start_link\n        self.tool_frame: str = tool_frame\n        self.urdf_object: URDF = urdf_object\n        self.link_names: List[str] = []\n        self.joint_names: List[str] = []\n        self.static_joint_states: Dict[GripperState, Dict[str, float]] = {}\n        self._init_links_joints()\n\n    def _init_links_joints(self):\n        \"\"\"\n        Traverses the URDF object to get all links and joints of the end effector below the start link.1\n        \"\"\"\n        start_link_obj = self.urdf_object.link_map[self.start_link]\n        links = [start_link_obj.name]\n        while len(links) != 0:\n            link = links.pop()\n            self.link_names.append(link)\n            if link not in self.urdf_object.child_map:\n                continue\n            else:\n                children = self.urdf_object.child_map[link]\n            for joint, link in children:\n                self.joint_names.append(joint)\n                links.insert(0, link)\n\n    def add_static_joint_states(self, name: GripperState, states: dict):\n        \"\"\"\n        Adds static joint states to the end effector. These define a specific configuration of the end effector. Like\n        open and close configurations of a gripper.\n\n        :param name: Name of the static joint states\n        :param states: Dictionary of joint names and their values\n        \"\"\"\n        for joint_name, value in states.items():\n            if joint_name not in self.joint_names:\n                raise ValueError(f\"Joint {joint_name} is not part of the chain\")\n        self.static_joint_states[name] = states\n\n    @property\n    def links(self) -> List[str]:\n        \"\"\"\n        Property to get the links of the chain.\n\n        :return: List of link names\n        \"\"\"\n        return self.link_names\n\n    @property\n    def joints(self) -> List[str]:\n        \"\"\"\n        Property to get the joints of the chain.\n\n        :return: List of joint names\n        \"\"\"\n        return self.joint_names\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the tasktree.py file and how do they interact with each other?"}, {"role": "assistant", "content": "# Content from: #<tasktree.py>#\n\"\"\"Implementation of TaskTrees using anytree.\"\"\"\n\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nfrom typing_extensions import TYPE_CHECKING\n\nimport datetime\nimport inspect\nimport logging\nfrom typing_extensions import List, Optional, Callable\n\nimport anytree\nimport sqlalchemy.orm.session\nimport tqdm\n\nfrom .datastructures.world import World\nfrom .orm.tasktree import TaskTreeNode as ORMTaskTreeNode\nfrom .orm.base import ProcessMetaData\nfrom .plan_failures import PlanFailure\nfrom .datastructures.enums import TaskStatus\nfrom .datastructures.dataclasses import Color\n\nif TYPE_CHECKING:\n    from .designators.performables import Action\n\n\nclass NoOperation:\n\n    def perform(self):\n        ...\n\n    def __repr__(self):\n        return \"NoOperation\"\n\n\nclass TaskTreeNode(anytree.NodeMixin):\n    \"\"\"\n    TaskTreeNode represents one function that was called during a pycram plan.\n    Additionally, meta information is stored.\n    \"\"\"\n\n    action: Optional[Action]\n    \"\"\"\n    The action and that is performed or None if nothing was performed\n    \"\"\"\n\n    status: TaskStatus\n    \"\"\"\n    The status of the node from the TaskStatus enum.\n    \"\"\"\n\n    start_time: Optional[datetime.datetime]\n    \"\"\"\n    The starting time of the function, optional\n    \"\"\"\n\n    end_time: Optional[datetime.datetime]\n    \"\"\"\n    The ending time of the function, optional\n    \"\"\"\n\n    \"\"\"\n    The reason why this task failed, optional\n    \"\"\"\n\n    def __init__(self, action: Optional[Action] = NoOperation(), parent: Optional[TaskTreeNode] = None,\n                 children: Optional[List[TaskTreeNode]] = None, reason: Optional[Exception] = None):\n        \"\"\"\n        Create a TaskTreeNode\n\n        :param action: The action and that is performed, defaults to None\n        :param parent: The parent function of this function. None if this the parent, optional\n        :param children: An iterable of TaskTreeNode with the ordered children, optional\n        \"\"\"\n        super().__init__()\n\n        if action is None:\n            action = NoOperation()\n\n        self.action = action\n        self.status = TaskStatus.CREATED\n        self.start_time = None\n        self.end_time = None\n        self.parent = parent\n        self.reason: Optional[Exception] = reason\n\n        if children:\n            self.children = children\n\n    @property\n    def name(self):\n        return str(self)\n\n    def __str__(self):\n        return \"Code: %s \\n \" \\\n               \"Status: %s \\n \" \\\n               \"start_time: %s \\n \" \\\n               \"end_time: %s \\n \" \\\n               \"\" % (str(self.action), self.start_time, self.status, self.end_time)\n\n    def __repr__(self):\n        return str(self.action.__class__.__name__)\n\n    def __len__(self):\n        \"\"\"Get the number of nodes that are in this subtree.\"\"\"\n        return 1 + sum([len(child) for child in self.children])\n\n    def to_sql(self) -> ORMTaskTreeNode:\n        \"\"\"Convert this object to the corresponding object in the pycram.orm package.\n\n        :returns:  corresponding pycram.orm.task.TaskTreeNode object\n        \"\"\"\n\n        if self.reason:\n            reason = type(self.reason).__name__\n        else:\n            reason = None\n\n        return ORMTaskTreeNode(self.start_time, self.end_time, self.status.name, reason)\n\n    def insert(self, session: sqlalchemy.orm.session.Session, recursive: bool = True,\n               parent: Optional[TaskTreeNode] = None, use_progress_bar: bool = True,\n               progress_bar: Optional[tqdm.tqdm] = None) -> ORMTaskTreeNode:\n        \"\"\"\n        Insert this node into the database.\n\n        :param session: The current session with the database.\n        :param recursive: Rather if the entire tree should be inserted or just this node, defaults to True\n        :param parent: The parent node, defaults to None\n        :param use_progress_bar: Rather to use a progressbar or not\n        :param progress_bar: The progressbar to update. If a progress bar is desired and this is None, a new one will be\n            created.\n\n        :return: The ORM object that got inserted\n        \"\"\"\n        if use_progress_bar:\n            if not progress_bar:\n                progress_bar = tqdm.tqdm(desc=\"Inserting TaskTree into database\", leave=True, position=0,\n                                         total=len(self) if recursive else 1)\n\n        # convert self to orm object\n        node = self.to_sql()\n\n        # insert action if possible\n        if getattr(self.action, \"insert\", None):\n            action = self.action.insert(session)\n            node.action = action\n        else:\n            action = None\n            node.action = None\n\n        # get and set metadata\n        metadata = ProcessMetaData().insert(session)\n        node.process_metadata = metadata\n\n        # set node parent\n        node.parent = parent\n\n        # add the node to the session; note that the instance is not yet committed to the db, but rather in a\n        # pending state\n        session.add(node)\n\n        if progress_bar:\n            progress_bar.update()\n\n        # if recursive, insert all children\n        if recursive:\n            [child.insert(session, parent=node, use_progress_bar=use_progress_bar, progress_bar=progress_bar)\n             for child in self.children]\n\n        # once recursion is done and the root node is reached again, commit the session to the database\n        if self.parent is None:\n            session.commit()\n\n        return node\n\n\nclass SimulatedTaskTree:\n    \"\"\"TaskTree for execution in a 'new' simulation.\"\"\"\n\n    def __enter__(self):\n        \"\"\"At the beginning of a with statement the current task tree and world will be suspended and remembered.\n        Fresh structures are then available inside the with statement.\"\"\"\n        global task_tree\n\n        self.suspended_tree = task_tree\n        self.world_state = World.current_world.save_state()\n        self.simulated_root = TaskTreeNode()\n        task_tree = self.simulated_root\n        World.current_world.add_text(\"Simulating...\", [0, 0, 1.75], color=Color.from_rgb([0, 0, 0]),\n                                     parent_object_id=1)\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"\n        Restore the old state at the end of a with block.\n        \"\"\"\n        global task_tree\n        task_tree = self.suspended_tree\n        World.current_world.restore_state(self.world_state)\n        World.current_world.remove_text()\n\n\ntask_tree: Optional[TaskTreeNode] = None\n\"\"\"Current TaskTreeNode\"\"\"\n\n\ndef reset_tree() -> None:\n    \"\"\"\n    Reset the current task tree to an empty root (NoOperation) node.\n    \"\"\"\n    global task_tree\n    task_tree = TaskTreeNode()\n    task_tree.start_time = datetime.datetime.now()\n    task_tree.status = TaskStatus.RUNNING\n\n\nreset_tree()\n\n\ndef with_tree(fun: Callable) -> Callable:\n    \"\"\"\n    Decorator that records the function name, arguments and execution metadata in the task tree.\n\n    :param fun: The function to record the data from.\n    \"\"\"\n\n    def handle_tree(*args, **kwargs):\n\n        # get the task tree\n        global task_tree\n\n        # parse keyword arguments\n        keyword_arguments = inspect.getcallargs(fun, *args, **kwargs)\n\n        # try to get self object since this represents the action object\n        action = keyword_arguments.get(\"self\", None)\n\n        # create the task tree node\n        task_tree = TaskTreeNode(action, parent=task_tree)\n\n        # Try to execute the task\n        try:\n            task_tree.status = TaskStatus.CREATED\n            task_tree.start_time = datetime.datetime.now()\n            result = fun(*args, **kwargs)\n\n            # if it succeeded set the flag\n            task_tree.status = TaskStatus.SUCCEEDED\n\n        # iff a PlanFailure occurs\n        except PlanFailure as e:\n\n            # log the error and set the flag\n            logging.exception(\"Task execution failed at %s. Reason %s\" % (repr(task_tree), e))\n            task_tree.reason = e\n            task_tree.status = TaskStatus.FAILED\n            raise e\n        finally:\n            # set and time and update current node pointer\n            task_tree.end_time = datetime.datetime.now()\n            task_tree = task_tree.parent\n        return result\n\n    return handle_tree\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the utils.py file and how are they used in the project?"}, {"role": "assistant", "content": "# Content from: #<utils.py>#\n\"\"\"Implementation of helper functions and classes for internal usage only.\n\nFunctions:\n_block -- wrap multiple statements into a single block.\n\nClasses:\nGeneratorList -- implementation of generator list wrappers.\n\"\"\"\nfrom inspect import isgeneratorfunction\nfrom typing_extensions import List, Tuple, Callable\n\nimport os\n\nfrom .datastructures.pose import Pose\nimport math\n\nfrom typing_extensions import Dict\n\n\nclass bcolors:\n    \"\"\"\n    Color codes which can be used to highlight Text in the Terminal. For example,\n    for warnings.\n    Usage:\n    Firstly import the class into the file.\n    print(f'{bcolors.WARNING} Some Text {bcolors.ENDC}')\n    \"\"\"\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\n\ndef _apply_ik(robot: 'pycram.world_concepts.WorldObject', pose_and_joint_poses: Tuple[Pose, Dict[str, float]]) -> None:\n    \"\"\"\n    Apllies a list of joint poses calculated by an inverse kinematics solver to a robot\n\n    :param robot: The robot the joint poses should be applied on\n    :param pose_and_joint_poses: The base pose and joint states as returned by the ik solver\n    :return: None\n    \"\"\"\n    pose, joint_states = pose_and_joint_poses\n    robot.set_pose(pose)\n    robot.set_joint_positions(joint_states)\n\n\nclass GeneratorList:\n    \"\"\"Implementation of generator list wrappers.\n\n    Generator lists store the elements of a generator, so these can be fetched multiple times.\n\n    Methods:\n    get -- get the element at a specific index.\n    has -- check if an element at a specific index exists.\n    \"\"\"\n\n    def __init__(self, generator: Callable):\n        \"\"\"Create a new generator list.\n\n        Arguments:\n        generator -- the generator to use.\n        \"\"\"\n        if isgeneratorfunction(generator):\n            self._generator = generator()\n        else:\n            self._generator = generator\n\n        self._generated = []\n\n    def get(self, index: int = 0):\n        \"\"\"Get the element at a specific index or raise StopIteration if it doesn't exist.\n\n        Arguments:\n        index -- the index to get the element of.\n        \"\"\"\n        while len(self._generated) <= index:\n            self._generated.append(next(self._generator))\n\n        return self._generated[index]\n\n    def has(self, index: int) -> bool:\n        \"\"\"Check if an element at a specific index exists and return True or False.\n\n        Arguments:\n        index -- the index to check for.\n        \"\"\"\n        try:\n            self.get(index)\n            return True\n        except StopIteration:\n            return False\n\n\ndef axis_angle_to_quaternion(axis: List, angle: float) -> Tuple:\n    \"\"\"\n    Convert axis-angle to quaternion.\n\n    :param axis: (x, y, z) tuple representing rotation axis.\n    :param angle: rotation angle in degree\n    :return: The quaternion representing the axis angle\n    \"\"\"\n    angle = math.radians(angle)\n    axis_length = math.sqrt(sum([i ** 2 for i in axis]))\n    normalized_axis = tuple(i / axis_length for i in axis)\n\n    x = normalized_axis[0] * math.sin(angle / 2)\n    y = normalized_axis[1] * math.sin(angle / 2)\n    z = normalized_axis[2] * math.sin(angle / 2)\n    w = math.cos(angle / 2)\n\n    return (x, y, z, w)\n\n\nclass suppress_stdout_stderr(object):\n    \"\"\"\n    A context manager for doing a \"deep suppression\" of stdout and stderr in\n    Python, i.e. will suppress all prints, even if the print originates in a\n    compiled C/Fortran sub-function.\n\n    This will not suppress raised exceptions, since exceptions are printed\n    to stderr just before a script exits, and after the context manager has\n    exited (at least, I think that is why it lets exceptions through).\n    Copied from https://stackoverflow.com/questions/11130156/suppress-stdout-stderr-print-from-python-functions\n    \"\"\"\n\n    def __init__(self):\n        # Open a pair of null files\n        self.null_fds = [os.open(os.devnull, os.O_RDWR) for x in range(2)]\n        # Save the actual stdout (1) and stderr (2) file descriptors.\n        self.save_fds = [os.dup(1), os.dup(2)]\n\n    def __enter__(self):\n        # Assign the null pointers to stdout and stderr.\n        # This one is not needed for URDF parsing output\n        # os.dup2(self.null_fds[0], 1)\n        os.dup2(self.null_fds[1], 2)\n\n    def __exit__(self, *_):\n        # Re-assign the real stdout/stderr back to (1) and (2)\n        # This one is not needed for URDF parsing output\n        # os.dup2(self.save_fds[0], 1)\n        os.dup2(self.save_fds[1], 2)\n        # Close all file descriptors\n        for fd in self.null_fds + self.save_fds:\n            os.close(fd)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the world_reasoning.py file and how do they contribute to the overall functionality of the program?"}, {"role": "assistant", "content": "# Content from: #<world_reasoning.py>#\nfrom typing_extensions import List, Tuple, Optional, Union, Dict\n\nimport numpy as np\n\nfrom .external_interfaces.ik import try_to_reach, try_to_reach_with_grasp\nfrom .datastructures.pose import Pose, Transform\nfrom .robot_description import RobotDescription\nfrom .world_concepts.world_object import Object\nfrom .datastructures.world import World, UseProspectionWorld\n\n\ndef stable(obj: Object) -> bool:\n    \"\"\"\n    Checks if an object is stable in the world. Stable meaning that it's position will not change after simulating\n    physics in the World. This will be done by simulating the world for 10 seconds and compare\n    the previous coordinates with the coordinates after the simulation.\n\n    :param obj: The object which should be checked\n    :return: True if the given object is stable in the world False else\n    \"\"\"\n    prospection_obj = World.current_world.get_prospection_object_for_object(obj)\n    with UseProspectionWorld():\n        coords_prev = prospection_obj.get_position_as_list()\n        World.current_world.set_gravity([0, 0, -9.8])\n\n        World.current_world.simulate(2)\n        coords_past = prospection_obj.get_position_as_list()\n\n        coords_prev = list(map(lambda n: round(n, 3), coords_prev))\n        coords_past = list(map(lambda n: round(n, 3), coords_past))\n        return coords_past == coords_prev\n\n\ndef contact(\n        object1: Object,\n        object2: Object,\n        return_links: bool = False) -> Union[bool, Tuple[bool, List]]:\n    \"\"\"\n    Checks if two objects are in contact or not. If the links should be returned then the output will also contain a\n    list of tuples where the first element is the link name of 'object1' and the second element is the link name of\n    'object2'.\n\n    :param object1: The first object\n    :param object2: The second object\n    :param return_links: If the respective links on the objects that are in contact should be returned.\n    :return: True if the two objects are in contact False else. If links should be returned a list of links in contact\n    \"\"\"\n\n    with UseProspectionWorld():\n        prospection_obj1 = World.current_world.get_prospection_object_for_object(object1)\n        prospection_obj2 = World.current_world.get_prospection_object_for_object(object2)\n\n        World.current_world.perform_collision_detection()\n        con_points = World.current_world.get_contact_points_between_two_objects(prospection_obj1, prospection_obj2)\n\n        if return_links:\n            contact_links = []\n            for point in con_points:\n                contact_links.append((prospection_obj1.get_link_by_id(point[3]),\n                                      prospection_obj2.get_link_by_id(point[4])))\n            return con_points != (), contact_links\n\n        else:\n            return con_points != ()\n\n\ndef get_visible_objects(\n        camera_pose: Pose,\n        front_facing_axis: Optional[List[float]] = None) -> Tuple[np.ndarray, Pose]:\n    \"\"\"\n    Returns a segmentation mask of the objects that are visible from the given camera pose and the front facing axis.\n\n    :param camera_pose: The pose of the camera in world coordinate frame.\n    :param front_facing_axis: The axis, of the camera frame, which faces to the front of the robot. Given as list of xyz\n    :return: A segmentation mask of the objects that are visible and the pose of the point at exactly 2 meters in front of the camera in the direction of the front facing axis with respect to the world coordinate frame.\n    \"\"\"\n    front_facing_axis = RobotDescription.current_robot_description.get_default_camera().front_facing_axis\n\n    world_to_cam = camera_pose.to_transform(\"camera\")\n\n    cam_to_point = Transform(list(np.multiply(front_facing_axis, 2)), [0, 0, 0, 1], \"camera\",\n                             \"point\")\n    target_point = (world_to_cam * cam_to_point).to_pose()\n\n    seg_mask = World.current_world.get_images_for_target(target_point, camera_pose)[2]\n\n    return seg_mask, target_point\n\n\ndef visible(\n        obj: Object,\n        camera_pose: Pose,\n        front_facing_axis: Optional[List[float]] = None,\n        threshold: float = 0.8) -> bool:\n    \"\"\"\n    Checks if an object is visible from a given position. This will be achieved by rendering the object\n    alone and counting the visible pixel, then rendering the complete scene and compare the visible pixels with the\n    absolut count of pixels.\n\n    :param obj: The object for which the visibility should be checked\n    :param camera_pose: The pose of the camera in map frame\n    :param front_facing_axis: The axis, of the camera frame, which faces to the front of the robot. Given as list of xyz\n    :param threshold: The minimum percentage of the object that needs to be visible for this method to return true.\n    :return: True if the object is visible from the camera_position False if not\n    \"\"\"\n    with UseProspectionWorld():\n        prospection_obj = World.current_world.get_prospection_object_for_object(obj)\n        if World.robot:\n            prospection_robot = World.current_world.get_prospection_object_for_object(World.robot)\n\n        state_id = World.current_world.save_state()\n        for obj in World.current_world.objects:\n            if obj == prospection_obj or (World.robot and obj == prospection_robot):\n                continue\n            else:\n                obj.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]), set_attachments=False)\n\n        seg_mask, target_point = get_visible_objects(camera_pose, front_facing_axis)\n        max_pixel = np.array(seg_mask == prospection_obj.id).sum()\n\n        World.current_world.restore_state(state_id)\n\n        if max_pixel == 0:\n            # Object is not visible\n            return False\n\n        seg_mask = World.current_world.get_images_for_target(target_point, camera_pose)[2]\n        real_pixel = np.array(seg_mask == prospection_obj.id).sum()\n\n        return real_pixel / max_pixel > threshold > 0\n\n\ndef occluding(\n        obj: Object,\n        camera_pose: Pose,\n        front_facing_axis: Optional[List[float]] = None) -> List[Object]:\n    \"\"\"\n    Lists all objects which are occluding the given object. This works similar to 'visible'.\n    First the object alone will be rendered and the position of the pixels of the object in the picture will be saved.\n    After that the complete scene will be rendered and the previous saved pixel positions will be compared to the\n    actual pixels, if in one pixel another object is visible ot will be saved as occluding.\n\n    :param obj: The object for which occlusion should be checked\n    :param camera_pose: The pose of the camera in world coordinate frame\n    :param front_facing_axis: The axis, of the camera frame, which faces to the front of the robot. Given as list of xyz\n    :return: A list of occluding objects\n    \"\"\"\n\n    with UseProspectionWorld():\n        state_id = World.current_world.save_state()\n        for other_obj in World.current_world.objects:\n            if other_obj.name == World.current_world.robot.name:\n                continue\n            elif obj.get_pose() == other_obj.get_pose():\n                obj = other_obj\n            else:\n                other_obj.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))\n\n        seg_mask, target_point = get_visible_objects(camera_pose, front_facing_axis)\n\n        # All indices where the object that could be occluded is in the image\n        # [0] at the end is to reduce by one dimension because dstack adds an unnecessary dimension\n        pix = np.dstack(np.nonzero(seg_mask == obj.id))[0]\n\n        World.current_world.restore_state(state_id)\n\n        occluding_obj_ids = []\n        seg_mask = World.current_world.get_images_for_target(target_point, camera_pose)[2]\n        for c in pix:\n            if not seg_mask[c[0]][c[1]] == obj.id:\n                occluding_obj_ids.append(seg_mask[c[0]][c[1]])\n\n        occ_objects = list(set(map(World.current_world.get_object_by_id, occluding_obj_ids)))\n        occ_objects = list(map(World.current_world.get_object_for_prospection_object, occ_objects))\n\n        return occ_objects\n\n\ndef reachable(\n        pose_or_object: Union[Object, Pose],\n        robot: Object,\n        gripper_name: str,\n        threshold: float = 0.01) -> bool:\n    \"\"\"\n    Checks if the robot can reach a given position. To determine this the inverse kinematics are\n    calculated and applied. Afterward the distance between the position and the given end effector is calculated, if\n    it is smaller than the threshold the reasoning query returns True, if not it returns False.\n\n    :param pose_or_object: The position and rotation or Object for which reachability should be checked or an Object\n    :param robot: The robot that should reach for the position\n    :param gripper_name: The name of the end effector\n    :param threshold: The threshold between the end effector and the position.\n    :return: True if the end effector is closer than the threshold to the target position, False in every other case\n    \"\"\"\n\n    prospection_robot = World.current_world.get_prospection_object_for_object(robot)\n    with UseProspectionWorld():\n        target_pose = try_to_reach(pose_or_object, prospection_robot, gripper_name)\n\n        if not target_pose:\n            return False\n\n        gripper_pose = prospection_robot.get_link_pose(gripper_name)\n        diff = target_pose.dist(gripper_pose)\n\n    return diff < threshold\n\n\ndef blocking(\n        pose_or_object: Union[Object, Pose],\n        robot: Object,\n        gripper_name: str,\n        grasp: str = None) -> Union[List[Object], None]:\n    \"\"\"\n    Checks if any objects are blocking another object when a robot tries to pick it. This works\n    similar to the reachable predicate. First the inverse kinematics between the robot and the object will be\n    calculated and applied. Then it will be checked if the robot is in contact with any object except the given one.\n    If the given pose or Object is not reachable None will be returned\n\n    :param pose_or_object: The object or pose for which blocking objects should be found\n    :param robot: The robot Object who reaches for the object\n    :param gripper_name: The name of the end effector of the robot\n    :param grasp: The grasp type with which the object should be grasped\n    :return: A list of objects the robot is in collision with when reaching for the specified object or None if the pose or object is not reachable.\n    \"\"\"\n\n    prospection_robot = World.current_world.get_prospection_object_for_object(robot)\n    with UseProspectionWorld():\n        if grasp:\n            try_to_reach_with_grasp(pose_or_object, prospection_robot, gripper_name, grasp)\n        else:\n            try_to_reach(pose_or_object, prospection_robot, gripper_name)\n\n        block = []\n        for obj in World.current_world.objects:\n            if contact(prospection_robot, obj):\n                block.append(World.current_world.get_object_for_prospection_object(obj))\n    return block\n\n\ndef supporting(\n        object1: Object,\n        object2: Object) -> bool:\n    \"\"\"\n    Checks if one object is supporting another object. An object supports another object if they are in\n    contact and the second object is above the first one. (e.g. a Bottle will be supported by a table)\n\n    :param object1: Object that is supported\n    :param object2: Object that supports the first object\n    :return: True if the second object is in contact with the first one and the second is above the first else False\n    \"\"\"\n    return contact(object1, object2) and object2.get_position().z > object1.get_position().z\n\n\ndef link_pose_for_joint_config(\n        obj: Object,\n        joint_config: Dict[str, float],\n        link_name: str) -> Pose:\n    \"\"\"\n    Returns the pose a link would be in if the given joint configuration would be applied to the object.\n    This is done by using the respective object in the prospection world and applying the joint configuration\n    to this one. After applying the joint configuration the link position is taken from there.\n\n    :param obj: Object of which the link is a part\n    :param joint_config: Dict with the goal joint configuration\n    :param link_name: Name of the link for which the pose should be returned\n    :return: The pose of the link after applying the joint configuration\n    \"\"\"\n    prospection_object = World.current_world.get_prospection_object_for_object(obj)\n    with UseProspectionWorld():\n        for joint, pose in joint_config.items():\n            prospection_object.set_joint_position(joint, pose)\n        return prospection_object.get_link_pose(link_name)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the main features and functionalities of the dataclasses module in Python?"}, {"role": "assistant", "content": "# Content from: #<dataclasses.py>#\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing_extensions import List, Optional, Tuple, Callable, Dict, Any, Union, TYPE_CHECKING\nfrom .enums import JointType, Shape\nfrom .pose import Pose, Point\nfrom abc import ABC, abstractmethod\n\nif TYPE_CHECKING:\n    from ..description import Link\n    from ..world_concepts.world_object import Object\n    from ..world_concepts.constraints import Attachment\n\n\ndef get_point_as_list(point: Point) -> List[float]:\n    \"\"\"\n    Returns the point as a list.\n\n    :param point: The point.\n    :return: The point as a list\n    \"\"\"\n    return [point.x, point.y, point.z]\n\n\n@dataclass\nclass Color:\n    \"\"\"\n    Dataclass for storing rgba_color as an RGBA value.\n    The values are stored as floats between 0 and 1.\n    The default rgba_color is white. 'A' stands for the opacity.\n    \"\"\"\n    R: float = 1\n    G: float = 1\n    B: float = 1\n    A: float = 1\n\n    @classmethod\n    def from_list(cls, color: List[float]):\n        \"\"\"\n        Sets the rgba_color from a list of RGBA values.\n\n        :param color: The list of RGBA values\n        \"\"\"\n        if len(color) == 3:\n            return cls.from_rgb(color)\n        elif len(color) == 4:\n            return cls.from_rgba(color)\n        else:\n            raise ValueError(\"Color list must have 3 or 4 elements\")\n\n    @classmethod\n    def from_rgb(cls, rgb: List[float]):\n        \"\"\"\n        Sets the rgba_color from a list of RGB values.\n\n        :param rgb: The list of RGB values\n        \"\"\"\n        return cls(rgb[0], rgb[1], rgb[2], 1)\n\n    @classmethod\n    def from_rgba(cls, rgba: List[float]):\n        \"\"\"\n        Sets the rgba_color from a list of RGBA values.\n\n        :param rgba: The list of RGBA values\n        \"\"\"\n        return cls(rgba[0], rgba[1], rgba[2], rgba[3])\n\n    def get_rgba(self) -> List[float]:\n        \"\"\"\n        Returns the rgba_color as a list of RGBA values.\n\n        :return: The rgba_color as a list of RGBA values\n        \"\"\"\n        return [self.R, self.G, self.B, self.A]\n\n    def get_rgb(self) -> List[float]:\n        \"\"\"\n        Returns the rgba_color as a list of RGB values.\n\n        :return: The rgba_color as a list of RGB values\n        \"\"\"\n        return [self.R, self.G, self.B]\n\n\n@dataclass\nclass AxisAlignedBoundingBox:\n    \"\"\"\n    Dataclass for storing an axis-aligned bounding box.\n    \"\"\"\n    min_x: float\n    min_y: float\n    min_z: float\n    max_x: float\n    max_y: float\n    max_z: float\n\n    @classmethod\n    def from_min_max(cls, min_point: List[float], max_point: List[float]):\n        \"\"\"\n        Sets the axis-aligned bounding box from a minimum and maximum point.\n\n        :param min_point: The minimum point\n        :param max_point: The maximum point\n        \"\"\"\n        return cls(min_point[0], min_point[1], min_point[2], max_point[0], max_point[1], max_point[2])\n\n    def get_min_max_points(self) -> Tuple[Point, Point]:\n        \"\"\"\n        Returns the axis-aligned bounding box as a tuple of minimum and maximum points.\n\n        :return: The axis-aligned bounding box as a tuple of minimum and maximum points\n        \"\"\"\n        return self.get_min_point(), self.get_max_point()\n\n    def get_min_point(self) -> Point:\n        \"\"\"\n        Returns the axis-aligned bounding box as a minimum point.\n\n        :return: The axis-aligned bounding box as a minimum point\n        \"\"\"\n        return Point(self.min_x, self.min_y, self.min_z)\n\n    def get_max_point(self) -> Point:\n        \"\"\"\n        Returns the axis-aligned bounding box as a maximum point.\n\n        :return: The axis-aligned bounding box as a maximum point\n        \"\"\"\n        return Point(self.max_x, self.max_y, self.max_z)\n\n    def get_min_max(self) -> Tuple[List[float], List[float]]:\n        \"\"\"\n        Returns the axis-aligned bounding box as a tuple of minimum and maximum points.\n\n        :return: The axis-aligned bounding box as a tuple of minimum and maximum points\n        \"\"\"\n        return self.get_min(), self.get_max()\n\n    def get_min(self) -> List[float]:\n        \"\"\"\n        Returns the minimum point of the axis-aligned bounding box.\n\n        :return: The minimum point of the axis-aligned bounding box\n        \"\"\"\n        return [self.min_x, self.min_y, self.min_z]\n\n    def get_max(self) -> List[float]:\n        \"\"\"\n        Returns the maximum point of the axis-aligned bounding box.\n\n        :return: The maximum point of the axis-aligned bounding box\n        \"\"\"\n        return [self.max_x, self.max_y, self.max_z]\n\n\n@dataclass\nclass CollisionCallbacks:\n    on_collision_cb: Callable\n    no_collision_cb: Optional[Callable] = None\n\n\n@dataclass\nclass MultiBody:\n    base_visual_shape_index: int\n    base_pose: Pose\n    link_visual_shape_indices: List[int]\n    link_poses: List[Pose]\n    link_masses: List[float]\n    link_inertial_frame_poses: List[Pose]\n    link_parent_indices: List[int]\n    link_joint_types: List[JointType]\n    link_joint_axis: List[Point]\n    link_collision_shape_indices: List[int]\n\n\n@dataclass\nclass VisualShape(ABC):\n    rgba_color: Color\n    visual_frame_position: List[float]\n\n    @abstractmethod\n    def shape_data(self) -> Dict[str, Any]:\n        \"\"\"\n        Returns the shape data of the visual shape (e.g. half extents for a box, radius for a sphere).\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def visual_geometry_type(self) -> Shape:\n        \"\"\"\n        Returns the visual geometry type of the visual shape (e.g. box, sphere).\n        \"\"\"\n        pass\n\n\n@dataclass\nclass BoxVisualShape(VisualShape):\n    half_extents: List[float]\n\n    def shape_data(self) -> Dict[str, List[float]]:\n        return {\"halfExtents\": self.half_extents}\n\n    @property\n    def visual_geometry_type(self) -> Shape:\n        return Shape.BOX\n\n    @property\n    def size(self) -> List[float]:\n        return self.half_extents\n\n\n@dataclass\nclass SphereVisualShape(VisualShape):\n    radius: float\n\n    def shape_data(self) -> Dict[str, float]:\n        return {\"radius\": self.radius}\n\n    @property\n    def visual_geometry_type(self) -> Shape:\n        return Shape.SPHERE\n\n\n@dataclass\nclass CapsuleVisualShape(VisualShape):\n    radius: float\n    length: float\n\n    def shape_data(self) -> Dict[str, float]:\n        return {\"radius\": self.radius, \"length\": self.length}\n\n    @property\n    def visual_geometry_type(self) -> Shape:\n        return Shape.CAPSULE\n\n\n@dataclass\nclass CylinderVisualShape(CapsuleVisualShape):\n\n    @property\n    def visual_geometry_type(self) -> Shape:\n        return Shape.CYLINDER\n\n\n@dataclass\nclass MeshVisualShape(VisualShape):\n    scale: List[float]\n    file_name: str\n\n    def shape_data(self) -> Dict[str, Union[List[float], str]]:\n        return {\"meshScale\": self.scale, \"meshFileName\": self.file_name}\n\n    @property\n    def visual_geometry_type(self) -> Shape:\n        return Shape.MESH\n\n\n@dataclass\nclass PlaneVisualShape(VisualShape):\n    normal: List[float]\n\n    def shape_data(self) -> Dict[str, List[float]]:\n        return {\"normal\": self.normal}\n\n    @property\n    def visual_geometry_type(self) -> Shape:\n        return Shape.PLANE\n\n\n@dataclass\nclass State(ABC):\n    pass\n\n\n@dataclass\nclass LinkState(State):\n    constraint_ids: Dict[Link, int]\n\n\n@dataclass\nclass JointState(State):\n    position: float\n\n\n@dataclass\nclass ObjectState(State):\n    pose: Pose\n    attachments: Dict[Object, Attachment]\n    link_states: Dict[int, LinkState]\n    joint_states: Dict[int, JointState]\n\n\n@dataclass\nclass WorldState(State):\n    simulator_state_id: int\n    object_states: Dict[str, ObjectState]\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the different enumeration values defined in the enums.py file?"}, {"role": "assistant", "content": "# Content from: #<enums.py>#\n\"\"\"Module holding all enums of PyCRAM.\"\"\"\n\nfrom enum import Enum, auto\n\nclass ExecutionType(Enum):\n    \"\"\"Enum for Execution Process Module types.\"\"\"\n    REAL = auto()\n    SIMULATED = auto()\n    SEMI_REAL = auto()\n\nclass Arms(Enum):\n    \"\"\"Enum for Arms.\"\"\"\n    LEFT = auto()\n    RIGHT = auto()\n    BOTH = auto()\n\n\nclass TaskStatus(Enum):\n    \"\"\"\n    Enum for readable descriptions of a tasks' status.\n    \"\"\"\n    CREATED = 0\n    RUNNING = 1\n    SUCCEEDED = 2\n    FAILED = 3\n\n\nclass JointType(Enum):\n    \"\"\"\n    Enum for readable joint types.\n    \"\"\"\n    REVOLUTE = 0\n    PRISMATIC = 1\n    SPHERICAL = 2\n    PLANAR = 3\n    FIXED = 4\n    UNKNOWN = 5\n    CONTINUOUS = 6\n    FLOATING = 7\n\n\nclass Grasp(Enum):\n    \"\"\"\n    Enum for Grasp orientations.\n    \"\"\"\n    FRONT = 0\n    LEFT = 1\n    RIGHT = 2\n    TOP = 3\n\n\nclass ObjectType(Enum):\n    \"\"\"\n    Enum for Object types to easier identify different objects\n    \"\"\"\n    METALMUG = auto()\n    PRINGLES = auto()\n    MILK = auto()\n    SPOON = auto()\n    BOWL = auto()\n    BREAKFAST_CEREAL = auto()\n    JEROEN_CUP = auto()\n    ROBOT = auto()\n    ENVIRONMENT = auto()\n    GENERIC_OBJECT = auto()\n    HUMAN = auto()\n\n\nclass State(Enum):\n    \"\"\"\n    Enumeration which describes the result of a language expression.\n    \"\"\"\n    SUCCEEDED = 1\n    FAILED = 0\n    RUNNING = 2\n    INTERRUPTED = 3\n\n\nclass Shape(Enum):\n    \"\"\"\n    Enum for visual shapes of objects\n    \"\"\"\n    SPHERE = 2\n    BOX = 3\n    CYLINDER = 4\n    MESH = 5\n    PLANE = 6\n    CAPSULE = 7\n\n\nclass WorldMode(Enum):\n    \"\"\"\n    Enum for the different modes of the world.\n    \"\"\"\n    GUI = \"GUI\"\n    DIRECT = \"DIRECT\"\n\n\nclass AxisIdentifier(Enum):\n    \"\"\"\n    Enum for translating the axis name to a vector along that axis.\n    \"\"\"\n    X = (1, 0, 0)\n    Y = (0, 1, 0)\n    Z = (0, 0, 1)\n\n\nclass GripperState(Enum):\n    \"\"\"\n    Enum for the different motions of the gripper.\n    \"\"\"\n    OPEN = auto()\n    CLOSE = auto()\n\n\nclass GripperType(Enum):\n    \"\"\"\n    Enum for the different types of grippers.\n    \"\"\"\n    PARALLEL = auto()\n    SUCTION = auto()\n    FINGER = auto()\n    HYDRAULIC = auto()\n    PNEUMATIC = auto()\n    CUSTOM = auto()\n\n\nclass PerceptionTechniques(Enum):\n    \"\"\"\n    Enum for techniques for perception tasks.\n    \"\"\"\n    ALL = auto()\n    HUMAN = auto()\n    TYPES = auto()\n\n\nclass ImageEnum(Enum):\n    \"\"\"\n    Enum for image switch view on hsrb display.\n    \"\"\"\n    HI = 0\n    TALK = 1\n    DISH = 2\n    DONE = 3\n    DROP = 4\n    HANDOVER = 5\n    ORDER = 6\n    PICKING = 7\n    PLACING = 8\n    REPEAT = 9\n    SEARCH = 10\n    WAVING = 11\n    FOLLOWING = 12\n    DRIVINGBACK = 13\n    PUSHBUTTONS = 14\n    FOLLOWSTOP = 15\n    JREPEAT = 16\n    SOFA = 17\n    INSPECT = 18\n    CHAIR = 37\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the pose.py file and how do they relate to pose estimation?"}, {"role": "assistant", "content": "# Content from: #<pose.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nimport math\nimport datetime\nfrom typing_extensions import List, Union, Optional\n\nimport numpy as np\nimport rospy\nimport sqlalchemy.orm\nfrom geometry_msgs.msg import PoseStamped, TransformStamped, Vector3, Point\nfrom geometry_msgs.msg import (Pose as GeoPose, Quaternion as GeoQuaternion)\nfrom tf import transformations\nfrom ..orm.base import Pose as ORMPose, Position, Quaternion, ProcessMetaData\n\n\ndef get_normalized_quaternion(quaternion: np.ndarray) -> GeoQuaternion:\n    \"\"\"\n    Normalizes a given quaternion such that it has a magnitude of 1.\n\n    :param quaternion: The quaternion that should be normalized\n    :return: The normalized quaternion\n    \"\"\"\n    mag = math.sqrt(sum(v**2 for v in quaternion))\n    normed_rotation = [f / mag for f in quaternion]\n\n    geo_quaternion = GeoQuaternion()\n    geo_quaternion.x = normed_rotation[0]\n    geo_quaternion.y = normed_rotation[1]\n    geo_quaternion.z = normed_rotation[2]\n    geo_quaternion.w = normed_rotation[3]\n\n    return geo_quaternion\n\n\nclass Pose(PoseStamped):\n    \"\"\"\n    Pose representation for PyCRAM, this class extends the PoseStamped ROS message from geometry_msgs. Thus making it\n    compatible with every ROS service and message expecting a PoseStamped message.\n\n    Naming convention for Poses:\n        Pose: Instances of this class, representing a cartesian position and a quaternion for orientation\n\n        Position: Only the cartesian position in xyz\n\n        Orientation: Only the quaternion as xyzw\n    \"\"\"\n\n    def __init__(self, position: Optional[List[float]] = None, orientation: Optional[List[float]] = None,\n                 frame: str = \"map\", time: rospy.Time = None):\n        \"\"\"\n        Poses can be initialized by a position and orientation given as lists, this is optional. By default, Poses are\n        initialized with the position being [0, 0, 0], the orientation being [0, 0, 0, 1] and the frame being 'map'.\n\n        :param position: An optional position of this Pose\n        :param orientation: An optional orientation of this Pose\n        :param frame: An optional frame in which this pose is\n        :param time: The time at which this Pose is valid, as ROS time\n        \"\"\"\n        super().__init__()\n        if position is not None:\n            self.position = position\n\n        if orientation is not None:\n            self.orientation = orientation\n        else:\n            self.pose.orientation.w = 1.0\n\n        self.header.frame_id = frame\n\n        self.header.stamp = time if time else rospy.Time.now()\n\n        self.frame = frame\n\n    @staticmethod\n    def from_pose_stamped(pose_stamped: PoseStamped) -> Pose:\n        \"\"\"\n        Converts a geometry_msgs/PoseStamped message to a Pose object. Should be used for compatability with ROS.\n\n        :param pose_stamped: The pose stamped message which should be converted\n        :return: A Pose object with the same information as the given message\n        \"\"\"\n        p = Pose()\n        p.header = pose_stamped.header\n        p.pose = pose_stamped.pose\n        return p\n\n    @property\n    def frame(self) -> str:\n        \"\"\"\n        Property for the frame_id such that it is easier accessible. Instead of Pose.header.frame_id it is Pose.frame\n\n        :return: The TF frame of this Pose\n        \"\"\"\n        return self.header.frame_id\n\n    @frame.setter\n    def frame(self, value: str) -> None:\n        \"\"\"\n        Sets the TF frame of this pose to the given new frame\n\n        :param value: The new TF frame\n        \"\"\"\n        self.header.frame_id = value\n\n    @property\n    def position(self) -> Point:\n        \"\"\"\n        Property that points to the position of this pose\n        \"\"\"\n        return self.pose.position\n\n    @position.setter\n    def position(self, value) -> None:\n        \"\"\"\n        Sets the position for this Pose, the position can either be a list of xyz or a geometry_msgs/Pose message.\n\n        :param value: List or geometry_msgs/Pose message for the position\n        \"\"\"\n        if (not isinstance(value, list) and not isinstance(value, tuple) and not isinstance(value, GeoPose)\n                and not isinstance(value, Point)):\n            rospy.logerr(\"Position can only be a list or geometry_msgs/Pose\")\n            raise TypeError(\"Position can only be a list/tuple or geometry_msgs/Pose\")\n        if isinstance(value, list) or isinstance(value, tuple) and len(value) == 3:\n            self.pose.position.x = value[0]\n            self.pose.position.y = value[1]\n            self.pose.position.z = value[2]\n        else:\n            # TODO: Check if this is correct or if it should be handled as an error\n            self.pose.position = value\n\n    @property\n    def orientation(self) -> GeoQuaternion:\n        \"\"\"\n        Property that points to the orientation of this pose\n        \"\"\"\n        return self.pose.orientation\n\n    @orientation.setter\n    def orientation(self, value) -> None:\n        \"\"\"\n        Sets the orientation of this Pose, the orientation can either be a list of xyzw or a geometry_msgs/Quaternion\n        message\n\n        :param value: New orientation, either a list or geometry_msgs/Quaternion\n        \"\"\"\n        if not isinstance(value, list) and not isinstance(value, tuple) and not isinstance(value, GeoQuaternion):\n            rospy.logwarn(\"Orientation can only be a list or geometry_msgs/Quaternion\")\n            return\n\n        if isinstance(value, list) or isinstance(value, tuple) and len(value) == 4:\n            orientation = np.array(value)\n        else:\n            orientation = np.array([value.x, value.y, value.z, value.w])\n        # This is used instead of np.linalg.norm since numpy is too slow on small arrays\n        self.pose.orientation = get_normalized_quaternion(orientation)\n\n    def to_list(self) -> List[List[float]]:\n        \"\"\"\n        Returns the position and orientation of this pose as a list containing two list.\n\n        :return: The position and orientation as lists\n        \"\"\"\n        return [[self.pose.position.x, self.pose.position.y, self.pose.position.z],\n                [self.pose.orientation.x, self.pose.orientation.y, self.pose.orientation.z, self.pose.orientation.w]]\n\n    def to_transform(self, child_frame: str) -> Transform:\n        \"\"\"\n        Converts this pose to a Transform from the TF frame of the pose to the given child_frame\n\n        :param child_frame: Child frame id to which the Transform points\n        :return: A new Transform\n        \"\"\"\n        return Transform(self.position_as_list(), self.orientation_as_list(), self.frame, child_frame,\n                         self.header.stamp)\n\n    def copy(self) -> Pose:\n        \"\"\"\n        Creates a deep copy of this pose.\n\n        :return: A copy of this pose\n        \"\"\"\n        p = Pose(self.position_as_list(), self.orientation_as_list(), self.frame, self.header.stamp)\n        p.header.frame_id = self.header.frame_id\n        return p\n\n    def position_as_list(self) -> List[float]:\n        \"\"\"\n        Returns only the position as a list of xyz.\n\n        :return: The position as a list\n        \"\"\"\n        return [self.position.x, self.position.y, self.position.z]\n\n    def orientation_as_list(self) -> List[float]:\n        \"\"\"\n        Returns only the orientation as a list of a quaternion\n\n        :return: The orientation as a quaternion with xyzw\n        \"\"\"\n        return [self.pose.orientation.x, self.pose.orientation.y, self.pose.orientation.z, self.pose.orientation.w]\n\n    def dist(self, other_pose: Pose) -> float:\n        \"\"\"\n        Calculates the euclidian distance between this Pose and the given one. For distance calculation only the\n        position is used.\n\n        :param other_pose: Pose to which the distance should be calculated\n        :return: The distance between the Poses\n        \"\"\"\n        self_position = self.position_as_list()\n        other_position = other_pose.position_as_list()\n        return np.linalg.norm(np.array(self_position) - np.array(other_position))\n\n    def __eq__(self, other: Pose) -> bool:\n        \"\"\"\n        Overloads the '==' operator to check for equality between two Poses. Only compares the position, orientation and\n        frame. Timestamps of Poses are not takes into account.\n\n        :param other: Other pose which should be compared\n        :return: True if both Poses have the same position, orientation and frame. False otherwise\n        \"\"\"\n        if not isinstance(other, Pose):\n            return False\n        self_position = self.position_as_list()\n        other_position = other.position_as_list()\n\n        self_orient = self.orientation_as_list()\n        other_orient = other.orientation_as_list()\n\n        return self_position == other_position and self_orient == other_orient and self.frame == other.frame\n\n    def set_position(self, new_position: List[float]) -> None:\n        \"\"\"\n        Sets the position of this Pose to the given position. Position has to be given as a vector in cartesian space.\n\n        :param new_position: New position as a vector of xyz\n        \"\"\"\n        self.position = new_position\n\n    def set_orientation(self, new_orientation: List[float]) -> None:\n        \"\"\"\n        Sets the orientation to the given quaternion. The new orientation has to be given as a quaternion.\n\n        :param new_orientation: New orientation as a quaternion with xyzw\n        \"\"\"\n        self.orientation = new_orientation\n\n    def to_sql(self) -> ORMPose:\n        return ORMPose(datetime.datetime.utcfromtimestamp(self.header.stamp.to_sec()), self.frame)\n\n    def insert(self, session: sqlalchemy.orm.Session) -> ORMPose:\n\n        metadata = ProcessMetaData().insert(session)\n\n        position = Position(*self.position_as_list())\n        position.process_metadata = metadata\n        orientation = Quaternion(*self.orientation_as_list())\n        orientation.process_metadata = metadata\n        session.add(position)\n        session.add(orientation)\n\n        pose = self.to_sql()\n        pose.process_metadata = metadata\n        pose.orientation = orientation\n        pose.position = position\n        session.add(pose)\n\n        return pose\n\n    def multiply_quaternions(self, quaternion: List) -> None:\n        \"\"\"\n        Multiply the quaternion of this Pose with the given quaternion, the result will be the new orientation of this\n        Pose.\n\n        :param quaternion: The quaternion by which the orientation of this Pose should be multiplied\n        \"\"\"\n        x1, y1, z1, w1 = quaternion\n        x2, y2, z2, w2 = self.orientation_as_list()\n\n        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2\n        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2\n\n        self.orientation = (x, y, z, w)\n\n    def set_orientation_from_euler(self, axis: List, euler_angles: List[float]) -> None:\n        \"\"\"\n        Convert axis-angle to quaternion.\n\n        :param axis: (x, y, z) tuple representing rotation axis.\n        :param angle: rotation angle in degree\n        :return: The quaternion representing the axis angle\n        \"\"\"\n        angle = math.radians(euler_angles)\n        axis_length = math.sqrt(sum([i ** 2 for i in axis]))\n        normalized_axis = tuple(i / axis_length for i in axis)\n\n        x = normalized_axis[0] * math.sin(angle / 2)\n        y = normalized_axis[1] * math.sin(angle / 2)\n        z = normalized_axis[2] * math.sin(angle / 2)\n        w = math.cos(angle / 2)\n\n        return (x, y, z, w)\n\n\nclass Transform(TransformStamped):\n    \"\"\"\n    Represents a Transformation from one TF frame to another in PyCRAM. Like with Poses this class inherits from the ROS\n    message TransformStamped form geometry_msgs and is therefore compatible with ROS services and messages that require\n    a TransformStamped message.\n\n    Naming Convention for Transforms:\n        Transform: Instances of this class, representing a translation and rotation from frame_id to child_frame_id\n\n        Translation: A vector representing the conversion in cartesian space\n\n        Rotation: A quaternion representing the conversion of rotation between both frames\n    \"\"\"\n    def __init__(self, translation: Optional[List[float]] = None, rotation: Optional[List[float]] = None,\n                 frame: Optional[str] = \"map\", child_frame: Optional[str] = \"\", time: rospy.Time = None):\n        \"\"\"\n        Transforms take a translation, rotation, frame and child_frame as optional arguments. If nothing is given the\n        Transform will be initialized with [0, 0, 0] for translation, [0, 0, 0, 1] for rotation, 'map' for frame and an\n        empty string for child_frame\n\n        :param translation: Optional translation from frame to child_frame in cartesian space\n        :param rotation: Optional rotation from frame to child frame given as quaternion\n        :param frame: Origin TF frame of this Transform\n        :param child_frame: Target frame for this Transform\n        :param time: The time at which this Transform is valid, as ROS time\n        \"\"\"\n        super().__init__()\n        if translation:\n            self.translation = translation\n\n        if rotation:\n            self.rotation = rotation\n        else:\n            self.transform.rotation.w = 1.0\n\n        self.header.frame_id = frame\n        self.child_frame_id = child_frame\n        self.header.stamp = time if time else rospy.Time.now()\n\n        self.frame = frame\n\n    @classmethod\n    def from_pose_and_child_frame(cls, pose: Pose, child_frame_name: str) -> Transform:\n        return cls(pose.position_as_list(), pose.orientation_as_list(), pose.frame, child_frame_name,\n                   time=pose.header.stamp)\n\n    @staticmethod\n    def from_transform_stamped(transform_stamped: TransformStamped) -> Transform:\n        \"\"\"\n        Creates a Transform instance from a geometry_msgs/TransformStamped message. Should be used for compatibility with\n        ROS.\n\n        :param transform_stamped: The transform stamped message that should be converted\n        :return: An Transform with the same information as the transform stamped message\n        \"\"\"\n        t = Transform()\n        t.header = transform_stamped.header\n        t.child_frame_id = transform_stamped.child_frame_id\n        t.transform = transform_stamped.transform\n\n        return t\n\n    @property\n    def frame(self) -> str:\n        \"\"\"\n        Property for the frame_id such that it is easier accessible. Instead of Pose.header.frame_id it is Pose.frame\n\n        :return: The TF frame of this Pose\n        \"\"\"\n        return self.header.frame_id\n\n    @frame.setter\n    def frame(self, value: str) -> None:\n        \"\"\"\n        Sets the TF frame of this pose to the given new frame\n\n        :param value: The new TF frame\n        \"\"\"\n        self.header.frame_id = value\n\n    @property\n    def translation(self) -> None:\n        \"\"\"\n        Property that points to the translation of this Transform\n        \"\"\"\n        return self.transform.translation\n\n    @translation.setter\n    def translation(self, value) -> None:\n        \"\"\"\n        Setter for the translation of this Transform, the new value can either be of type list or a\n        geometry_msgs/Vector message.\n\n        :param value: The new value for the translation, either a list or geometry_msgs/Vector3\n        \"\"\"\n        if not isinstance(value, list) and not isinstance(value, Vector3):\n            rospy.logwarn(\"Value of a translation can only be a list of a geometry_msgs/Vector3\")\n            return\n        if isinstance(value, list) and len(value) == 3:\n            self.transform.translation.x = value[0]\n            self.transform.translation.y = value[1]\n            self.transform.translation.z = value[2]\n        else:\n            self.transform.translation = value\n\n    @property\n    def rotation(self) -> None:\n        \"\"\"\n        Property that points to the rotation of this Transform\n        \"\"\"\n        return self.transform.rotation\n\n    @rotation.setter\n    def rotation(self, value):\n        \"\"\"\n        Setter for the rotation of this Transform, the new value can either be a list or a geometry_msgs/Quaternion\n        message\n\n        :param value: The new value for the rotation, either a list or geometry_msgs/Quaternion\n        \"\"\"\n        if not isinstance(value, list) and not isinstance(value, GeoQuaternion):\n            rospy.logwarn(\"Value of the rotation can only be a list or a geometry.msgs/Quaternion\")\n            return\n        if isinstance(value, list) and len(value) == 4:\n            rotation = np.array(value)\n\n        else:\n            rotation = np.array([value.x, value.y, value.z, value.w])\n        # This is used instead of np.linalg.norm since numpy is too slow on small arrays\n        self.transform.rotation = get_normalized_quaternion(rotation)\n\n    def copy(self) -> Transform:\n        \"\"\"\n        Creates a deep copy of this pose.\n\n        :return: A copy of this pose\n        \"\"\"\n        t = Transform(self.translation_as_list(), self.rotation_as_list(), self.frame, self.child_frame_id, self.header.stamp)\n        t.header.frame_id = self.header.frame_id\n        # t.header.stamp = self.header.stamp\n        return t\n\n    def translation_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the translation of this Transform as a list.\n\n        :return: The translation as a list of xyz\n        \"\"\"\n        return [self.transform.translation.x, self.transform.translation.y, self.transform.translation.z]\n\n    def rotation_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the rotation of this Transform as a list representing a quaternion.\n\n        :return: The rotation of this Transform as a list with xyzw\n        \"\"\"\n        return [self.transform.rotation.x, self.transform.rotation.y, self.transform.rotation.z,\n                self.transform.rotation.w]\n\n    def to_pose(self) -> Pose:\n        \"\"\"\n        Converts this Transform to a Pose, in this process the child_frame_id is lost.\n\n        :return: A new pose with same translation as position and rotation as orientation\n        \"\"\"\n        return Pose(self.translation_as_list(), self.rotation_as_list(), self.frame, self.header.stamp)\n\n    def invert(self) -> Transform:\n        \"\"\"\n        Inverts this Transform, the new Transform points from the child_frame_id to the frame_id\n\n        :return: A new inverted Transform\n        \"\"\"\n        transform = transformations.concatenate_matrices(transformations.translation_matrix(self.translation_as_list()),\n                                                         transformations.quaternion_matrix(self.rotation_as_list()))\n        inverse_transform = transformations.inverse_matrix(transform)\n        translation = transformations.translation_from_matrix(inverse_transform)\n        quaternion = transformations.quaternion_from_matrix(inverse_transform)\n        return Transform(list(translation), list(quaternion), self.child_frame_id, self.header.frame_id, self.header.stamp)\n\n    def __mul__(self, other: Transform) -> Union[Transform, None]:\n        \"\"\"\n        Multiplies this Transform with another one. The resulting Transform points from the frame_id of this Transform\n        to the child_frame_id of the other Transform.\n\n        :param other: The Transform which should be multiplied with this one.\n        :return: The resulting Transform from the multiplication\n        \"\"\"\n        if not isinstance(other, Transform):\n            rospy.logerr(f\"Can only multiply two Transforms\")\n            return\n        self_trans = transformations.translation_matrix(self.translation_as_list())\n        self_rot = transformations.quaternion_matrix(self.rotation_as_list())\n        self_mat = np.dot(self_trans, self_rot)\n\n        other_trans = transformations.translation_matrix(other.translation_as_list())\n        other_rot = transformations.quaternion_matrix(other.rotation_as_list())\n        other_mat = np.dot(other_trans, other_rot)\n\n        new_mat = np.dot(self_mat, other_mat)\n        new_trans = transformations.translation_from_matrix(new_mat)\n        new_rot = transformations.quaternion_from_matrix(new_mat)\n        return Transform(list(new_trans), list(new_rot), self.frame, other.child_frame_id)\n\n    def inverse_times(self, other_transform: Transform) -> Transform:\n        \"\"\"\n        Like a 'minus' for Transforms, subtracts the other_transform from this one.\n\n        :param other_transform: Transform which should be subtracted from this one\n        :return: The resulting Transform form the calculation\n        \"\"\"\n        inv = other_transform.invert()\n        return self * inv\n\n    def __eq__(self, other: Transform) -> bool:\n        \"\"\"\n        Overloads the '==' operator to check for equality between two Transforms. Only compares the translation,\n        rotation, frame and child frame. Timestamps of Poses are not takes into account.\n\n        :param other: Other pose which should be compared\n        :return: True if both Transforms have the same translation, rotation, frame and child frame. False otherwise\n        \"\"\"\n        if not isinstance(other, Transform):\n            return False\n        self_position = self.translation_as_list()\n        other_position = other.translation_as_list()\n\n        self_orient = self.rotation_as_list()\n        other_orient = other.rotation_as_list()\n\n        return self_position == other_position and self_orient == other_orient and \\\n            self.frame == other.frame and self.child_frame_id == other.child_frame_id\n\n    def set_translation(self, new_translation: List[float]) -> None:\n        \"\"\"\n        Sets the translation of this Transform to the newly given one. Translation has to be a vector in cartesian space\n\n        :param new_translation: The new translation as a vector with xyz.\n        \"\"\"\n        self.translation = new_translation\n\n    def set_rotation(self, new_rotation: List[float]) -> None:\n        \"\"\"\n        Sets the rotation of this Transform to the newly given one. Rotation has to be a quaternion.\n\n        :param new_rotation: The new rotation as a quaternion with xyzw\n        \"\"\"\n        self.rotation = new_rotation\n\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the world.py file of the PyCRAM Framework?"}, {"role": "assistant", "content": "# Content from: #<world.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nimport os\nimport threading\nimport time\nfrom abc import ABC, abstractmethod\nfrom copy import copy\nfrom queue import Queue\n\n\nimport numpy as np\nimport rospy\nfrom geometry_msgs.msg import Point\nfrom typing_extensions import List, Optional, Dict, Tuple, Callable, TYPE_CHECKING\nfrom typing_extensions import Union\n\nfrom ..cache_manager import CacheManager\nfrom .enums import JointType, ObjectType, WorldMode\nfrom ..world_concepts.event import Event\nfrom ..local_transformer import LocalTransformer\nfrom .pose import Pose, Transform\nfrom ..world_concepts.constraints import Constraint\nfrom .dataclasses import (Color, AxisAlignedBoundingBox, CollisionCallbacks,\n                                               MultiBody, VisualShape, BoxVisualShape, CylinderVisualShape, SphereVisualShape,\n                                               CapsuleVisualShape, PlaneVisualShape, MeshVisualShape,\n                                               ObjectState, State, WorldState)\n\nif TYPE_CHECKING:\n    from ..world_concepts.world_object import Object\n    from ..description import Link, Joint\n\n\nclass StateEntity:\n    \"\"\"\n    The StateEntity class is used to store the state of an object or the physics simulator. This is used to save and\n    restore the state of the World.\n    \"\"\"\n\n    def __init__(self):\n        self._saved_states: Dict[int, State] = {}\n\n    @property\n    def saved_states(self) -> Dict[int, State]:\n        \"\"\"\n        Returns the saved states of this entity.\n        \"\"\"\n        return self._saved_states\n\n    def save_state(self, state_id: int) -> int:\n        \"\"\"\n        Saves the state of this entity with the given state id.\n\n        :param state_id: The unique id of the state.\n        \"\"\"\n        self._saved_states[state_id] = self.current_state\n        return state_id\n\n    @property\n    @abstractmethod\n    def current_state(self) -> State:\n        \"\"\"\n        Returns the current state of this entity.\n\n        :return: The current state of this entity.\n        \"\"\"\n        pass\n\n    @current_state.setter\n    @abstractmethod\n    def current_state(self, state: State) -> None:\n        \"\"\"\n        Sets the current state of this entity.\n\n        :param state: The new state of this entity.\n        \"\"\"\n        pass\n\n    def restore_state(self, state_id: int) -> None:\n        \"\"\"\n        Restores the state of this entity from a saved state using the given state id.\n\n        :param state_id: The unique id of the state.\n        \"\"\"\n        self.current_state = self.saved_states[state_id]\n\n    def remove_saved_states(self) -> None:\n        \"\"\"\n        Removes all saved states of this entity.\n        \"\"\"\n        self._saved_states = {}\n\n\nclass WorldEntity(StateEntity, ABC):\n    \"\"\"\n    A data class that represents an entity of the world, such as an object or a link.\n    \"\"\"\n\n    def __init__(self, _id: int, world: Optional[World] = None):\n        StateEntity.__init__(self)\n        self.id = _id\n        self.world: World = world if world is not None else World.current_world\n\n\nclass World(StateEntity, ABC):\n    \"\"\"\n    The World Class represents the physics Simulation and belief state, it is the main interface for reasoning about\n    the World. This is implemented as a singleton, the current World can be accessed via the static variable\n    current_world which is managed by the World class itself.\n    \"\"\"\n\n    simulation_frequency: float\n    \"\"\"\n    Global reference for the simulation frequency (Hz), used in calculating the equivalent real time in the simulation.\n    \"\"\"\n\n    current_world: Optional[World] = None\n    \"\"\"\n        Global reference to the currently used World, usually this is the\n        graphical one. However, if you are inside a UseProspectionWorld() environment the current_world points to the\n        prospection world. In this way you can comfortably use the current_world, which should point towards the World\n        used at the moment.\n    \"\"\"\n\n    robot: Optional[Object] = None\n    \"\"\"\n    Global reference to the spawned Object that represents the robot. The robot is identified by checking the name in\n     the URDF with the name of the URDF on the parameter server. \n    \"\"\"\n\n    data_directory: List[str] = [os.path.join(os.path.dirname(__file__), '..', '..', '..', 'resources')]\n    \"\"\"\n    Global reference for the data directories, this is used to search for the description files of the robot \n    and the objects.\n    \"\"\"\n\n    cache_dir = data_directory[0] + '/cached/'\n    \"\"\"\n    Global reference for the cache directory, this is used to cache the description files of the robot and the objects.\n    \"\"\"\n\n    def __init__(self, mode: WorldMode, is_prospection_world: bool, simulation_frequency: float):\n        \"\"\"\n       Creates a new simulation, the mode decides if the simulation should be a rendered window or just run in the\n       background. There can only be one rendered simulation.\n       The World object also initializes the Events for attachment, detachment and for manipulating the world.\n\n       :param mode: Can either be \"GUI\" for rendered window or \"DIRECT\" for non-rendered. The default parameter is \"GUI\"\n       :param is_prospection_world: For internal usage, decides if this World should be used as a prospection world.\n        \"\"\"\n\n        StateEntity.__init__(self)\n\n        if World.current_world is None:\n            World.current_world = self\n        World.simulation_frequency = simulation_frequency\n\n        self.cache_manager = CacheManager(self.cache_dir, self.data_directory)\n\n        self.id: Optional[int] = -1\n        # This is used to connect to the physics server (allows multiple clients)\n\n        self._init_world(mode)\n\n        self.is_prospection_world: bool = is_prospection_world\n        self._init_and_sync_prospection_world()\n\n        self.local_transformer = LocalTransformer()\n        self._update_local_transformer_worlds()\n\n        self.objects: List[Object] = []\n        # List of all Objects in the World\n\n\n\n        self.mode: WorldMode = mode\n        # The mode of the simulation, can be \"GUI\" or \"DIRECT\"\n\n        self.coll_callbacks: Dict[Tuple[Object, Object], CollisionCallbacks] = {}\n\n        self._init_events()\n\n        self._current_state: Optional[WorldState] = None\n\n    @abstractmethod\n    def _init_world(self, mode: WorldMode):\n        \"\"\"\n        Initializes the physics simulation.\n        \"\"\"\n        raise NotImplementedError\n\n    def _init_events(self):\n        \"\"\"\n        Initializes dynamic events that can be used to react to changes in the World.\n        \"\"\"\n        self.detachment_event: Event = Event()\n        self.attachment_event: Event = Event()\n        self.manipulation_event: Event = Event()\n\n    def _init_and_sync_prospection_world(self):\n        \"\"\"\n        Initializes the prospection world and the synchronization between the main and the prospection world.\n        \"\"\"\n        self._init_prospection_world()\n        self._sync_prospection_world()\n\n    def _update_local_transformer_worlds(self):\n        \"\"\"\n        Updates the local transformer worlds with the current world and prospection world.\n        \"\"\"\n        self.local_transformer.world = self\n        self.local_transformer.prospection_world = self.prospection_world\n\n    def _init_prospection_world(self):\n        \"\"\"\n        Initializes the prospection world, if this is a prospection world itself it will not create another prospection,\n        world, but instead set the prospection world to None, else it will create a prospection world.\n        \"\"\"\n        if self.is_prospection_world:  # then no need to add another prospection world\n            self.prospection_world = None\n        else:\n            self.prospection_world: World = self.__class__(WorldMode.DIRECT,\n                                                           True,\n                                                           World.simulation_frequency)\n\n    def _sync_prospection_world(self):\n        \"\"\"\n        Synchronizes the prospection world with the main world, this means that every object in the main world will be\n        added to the prospection world and vice versa.\n        \"\"\"\n        if self.is_prospection_world:  # then no need to add another prospection world\n            self.world_sync = None\n        else:\n            self.world_sync: WorldSync = WorldSync(self, self.prospection_world)\n            self.world_sync.start()\n\n    def update_cache_dir_with_object(self, path: str, ignore_cached_files: bool,\n                                     obj: Object) -> str:\n        \"\"\"\n        Updates the cache directory with the given object.\n\n        :param path: The path to the object.\n        :param ignore_cached_files: If the cached files should be ignored.\n        :param obj: The object to be added to the cache directory.\n        \"\"\"\n        return self.cache_manager.update_cache_dir_with_object(path, ignore_cached_files, obj.description, obj.name)\n\n    @property\n    def simulation_time_step(self):\n        \"\"\"\n        The time step of the simulation in seconds.\n        \"\"\"\n        return 1 / World.simulation_frequency\n\n    @abstractmethod\n    def load_object_and_get_id(self, path: Optional[str] = None, pose: Optional[Pose] = None) -> int:\n        \"\"\"\n        Loads a description file (e.g. URDF) at the given pose and returns the id of the loaded object.\n\n        :param path: The path to the description file, if None the description file is assumed to be already loaded.\n        :param pose: The pose at which the object should be loaded.\n        :return: The id of the loaded object.\n        \"\"\"\n        pass\n\n    def get_object_by_name(self, name: str) -> Optional[Object]:\n        \"\"\"\n        Returns the object with the given name. If there is no object with the given name, None is returned.\n\n        :param name: The name of the returned Objects.\n        :return: The object with the given name, if there is one.\n        \"\"\"\n\n        object = list(filter(lambda obj: obj.name == name, self.objects))\n        if len(object) > 0:\n            return object[0]\n        return None\n\n    def get_object_by_type(self, obj_type: ObjectType) -> List[Object]:\n        \"\"\"\n        Returns a list of all Objects which have the type 'obj_type'.\n\n        :param obj_type: The type of the returned Objects.\n        :return: A list of all Objects that have the type 'obj_type'.\n        \"\"\"\n        return list(filter(lambda obj: obj.obj_type == obj_type, self.objects))\n\n    def get_object_by_id(self, obj_id: int) -> Object:\n        \"\"\"\n        Returns the single Object that has the unique id.\n\n        :param obj_id: The unique id for which the Object should be returned.\n        :return: The Object with the id 'id'.\n        \"\"\"\n        return list(filter(lambda obj: obj.id == obj_id, self.objects))[0]\n\n    @abstractmethod\n    def remove_object_by_id(self, obj_id: int) -> None:\n        \"\"\"\n        Removes the object with the given id from the world.\n\n        :param obj_id: The unique id of the object to be removed.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_object_from_simulator(self, obj: Object) -> None:\n        \"\"\"\n        Removes an object from the physics simulator.\n\n        :param obj: The object to be removed.\n        \"\"\"\n        pass\n\n    def remove_object(self, obj: Object) -> None:\n        \"\"\"\n        Removes this object from the current world.\n        For the object to be removed it has to be detached from all objects it\n        is currently attached to. After this is done a call to world remove object is done\n        to remove this Object from the simulation/world.\n\n        :param obj: The object to be removed.\n        \"\"\"\n        obj.detach_all()\n\n        self.objects.remove(obj)\n\n        # This means the current world of the object is not the prospection world, since it\n        # has a reference to the prospection world\n        if self.prospection_world is not None:\n            self.world_sync.remove_obj_queue.put(obj)\n            self.world_sync.remove_obj_queue.join()\n\n        self.remove_object_from_simulator(obj)\n\n        if World.robot == obj:\n            World.robot = None\n\n    def add_fixed_constraint(self, parent_link: Link, child_link: Link,\n                             child_to_parent_transform: Transform) -> int:\n        \"\"\"\n        Creates a fixed joint constraint between the given parent and child links,\n        the joint frame will be at the origin of the child link frame, and would have the same orientation\n        as the child link frame.\n\n        :param parent_link: The constrained link of the parent object.\n        :param child_link: The constrained link of the child object.\n        :param child_to_parent_transform: The transform from the child link frame to the parent link frame.\n        :return: The unique id of the created constraint.\n        \"\"\"\n\n        constraint = Constraint(parent_link=parent_link,\n                                child_link=child_link,\n                                _type=JointType.FIXED,\n                                axis_in_child_frame=Point(0, 0, 0),\n                                constraint_to_parent=child_to_parent_transform,\n                                child_to_constraint=Transform(frame=child_link.tf_frame)\n                                )\n        constraint_id = self.add_constraint(constraint)\n        return constraint_id\n\n    @abstractmethod\n    def add_constraint(self, constraint: Constraint) -> int:\n        \"\"\"\n        Add a constraint between two objects links so that they become attached for example.\n\n        :param constraint: The constraint data used to create the constraint.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_constraint(self, constraint_id) -> None:\n        \"\"\"\n        Remove a constraint by its ID.\n\n        :param constraint_id: The unique id of the constraint to be removed.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_joint_position(self, joint: Joint) -> float:\n        \"\"\"\n        Get the position of a joint of an articulated object\n\n        :param joint: The joint to get the position for.\n        :return: The joint position as a float.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_object_joint_names(self, obj: Object) -> List[str]:\n        \"\"\"\n        Returns the names of all joints of this object.\n\n        :param obj: The object.\n        :return: A list of joint names.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_link_pose(self, link: Link) -> Pose:\n        \"\"\"\n        Get the pose of a link of an articulated object with respect to the world frame.\n\n        :param link: The link as a AbstractLink object.\n        :return: The pose of the link as a Pose object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_object_link_names(self, obj: Object) -> List[str]:\n        \"\"\"\n        Returns the names of all links of this object.\n\n        :param obj: The object.\n        :return: A list of link names.\n        \"\"\"\n        pass\n\n    def simulate(self, seconds: float, real_time: Optional[bool] = False) -> None:\n        \"\"\"\n        Simulates Physics in the World for a given amount of seconds. Usually this simulation is faster than real\n        time. By setting the 'real_time' parameter this simulation is slowed down such that the simulated time is equal\n        to real time.\n\n        :param seconds: The amount of seconds that should be simulated.\n        :param real_time: If the simulation should happen in real time or faster.\n        \"\"\"\n        self.set_realtime(real_time)\n        for i in range(0, int(seconds * self.simulation_frequency)):\n            curr_time = rospy.Time.now()\n            self.step()\n            for objects, callbacks in self.coll_callbacks.items():\n                contact_points = self.get_contact_points_between_two_objects(objects[0], objects[1])\n                if contact_points != ():\n                    callbacks.on_collision_cb()\n                elif callbacks.no_collision_cb is not None:\n                    callbacks.no_collision_cb()\n            if real_time:\n                loop_time = rospy.Time.now() - curr_time\n                time_diff = self.simulation_time_step - loop_time.to_sec()\n                time.sleep(max(0, time_diff))\n        self.update_all_objects_poses()\n\n    def update_all_objects_poses(self) -> None:\n        \"\"\"\n        Updates the positions of all objects in the world.\n        \"\"\"\n        for obj in self.objects:\n            obj.update_pose()\n\n    @abstractmethod\n    def get_object_pose(self, obj: Object) -> Pose:\n        \"\"\"\n        Get the pose of an object in the world frame from the current object pose in the simulator.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def perform_collision_detection(self) -> None:\n        \"\"\"\n        Checks for collisions between all objects in the World and updates the contact points.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_object_contact_points(self, obj: Object) -> List:\n        \"\"\"\n        Returns a list of contact points of this Object with all other Objects.\n\n        :param obj: The object.\n        :return: A list of all contact points with other objects\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_contact_points_between_two_objects(self, obj1: Object, obj2: Object) -> List:\n        \"\"\"\n        Returns a list of contact points between obj1 and obj2.\n\n        :param obj1: The first object.\n        :param obj2: The second object.\n        :return: A list of all contact points between the two objects.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def reset_joint_position(self, joint: Joint, joint_position: float) -> None:\n        \"\"\"\n        Reset the joint position instantly without physics simulation\n\n        :param joint: The joint to reset the position for.\n        :param joint_position: The new joint pose.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def reset_object_base_pose(self, obj: Object, pose: Pose):\n        \"\"\"\n        Reset the world position and orientation of the base of the object instantaneously,\n        not through physics simulation. (x,y,z) position vector and (x,y,z,w) quaternion orientation.\n\n        :param obj: The object.\n        :param pose: The new pose as a Pose object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def step(self):\n        \"\"\"\n        Step the world simulation using forward dynamics\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_link_color(self, link: Link, rgba_color: Color):\n        \"\"\"\n        Changes the rgba_color of a link of this object, the rgba_color has to be given as Color object.\n\n        :param link: The link which should be colored.\n        :param rgba_color: The rgba_color as Color object with RGBA values between 0 and 1.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_link_color(self, link: Link) -> Color:\n        \"\"\"\n        This method returns the rgba_color of this link.\n\n        :param link: The link for which the rgba_color should be returned.\n        :return: The rgba_color as Color object with RGBA values between 0 and 1.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_colors_of_object_links(self, obj: Object) -> Dict[str, Color]:\n        \"\"\"\n        Get the RGBA colors of each link in the object as a dictionary from link name to rgba_color.\n\n        :param obj: The object\n        :return: A dictionary with link names as keys and a Color object for each link as value.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_object_axis_aligned_bounding_box(self, obj: Object) -> AxisAlignedBoundingBox:\n        \"\"\"\n        Returns the axis aligned bounding box of this object. The return of this method are two points in\n        world coordinate frame which define a bounding box.\n\n        :param obj: The object for which the bounding box should be returned.\n        :return: AxisAlignedBoundingBox object containing the min and max points of the bounding box.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_link_axis_aligned_bounding_box(self, link: Link) -> AxisAlignedBoundingBox:\n        \"\"\"\n        Returns the axis aligned bounding box of the link. The return of this method are two points in\n        world coordinate frame which define a bounding box.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_realtime(self, real_time: bool) -> None:\n        \"\"\"\n        Enables the real time simulation of Physics in the World. By default, this is disabled and Physics is only\n        simulated to reason about it.\n\n        :param real_time: Whether the World should simulate Physics in real time.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_gravity(self, gravity_vector: List[float]) -> None:\n        \"\"\"\n        Sets the gravity that is used in the World. By default, it is set to the gravity on earth ([0, 0, -9.8]).\n         Gravity is given as a vector in x,y,z. Gravity is only applied while simulating Physic.\n\n        :param gravity_vector: The gravity vector that should be used in the World.\n        \"\"\"\n        pass\n\n    def set_robot_if_not_set(self, robot: Object) -> None:\n        \"\"\"\n        Sets the robot if it is not set yet.\n\n        :param robot: The Object reference to the Object representing the robot.\n        \"\"\"\n        if not self.robot_is_set():\n            self.set_robot(robot)\n\n    @staticmethod\n    def set_robot(robot: Union[Object, None]) -> None:\n        \"\"\"\n        Sets the global variable for the robot Object This should be set on spawning the robot.\n\n        :param robot: The Object reference to the Object representing the robot.\n        \"\"\"\n        World.robot = robot\n\n    @staticmethod\n    def robot_is_set() -> bool:\n        \"\"\"\n        Returns whether the robot has been set or not.\n\n        :return: True if the robot has been set, False otherwise.\n        \"\"\"\n        return World.robot is not None\n\n    def exit(self) -> None:\n        \"\"\"\n        Closes the World as well as the prospection world, also collects any other thread that is running.\n        \"\"\"\n        self.exit_prospection_world_if_exists()\n        self.disconnect_from_physics_server()\n        self.reset_robot()\n        self.join_threads()\n        if World.current_world == self:\n            World.current_world = None\n\n    def exit_prospection_world_if_exists(self) -> None:\n        \"\"\"\n        Exits the prospection world if it exists.\n        \"\"\"\n        if self.prospection_world:\n            self.terminate_world_sync()\n            self.prospection_world.exit()\n\n    @abstractmethod\n    def disconnect_from_physics_server(self) -> None:\n        \"\"\"\n        Disconnects the world from the physics server.\n        \"\"\"\n        pass\n\n    def reset_current_world(self) -> None:\n        \"\"\"\n        Resets the pose of every object in the World to the pose it was spawned in and sets every joint to 0.\n        \"\"\"\n        for obj in self.objects:\n            obj.set_pose(obj.original_pose)\n            obj.set_joint_positions(dict(zip(list(obj.joint_names), [0] * len(obj.joint_names))))\n\n    def reset_robot(self) -> None:\n        \"\"\"\n        Sets the robot class variable to None.\n        \"\"\"\n        self.set_robot(None)\n\n    @abstractmethod\n    def join_threads(self) -> None:\n        \"\"\"\n        Join any running threads. Useful for example when exiting the world.\n        \"\"\"\n        pass\n\n    def terminate_world_sync(self) -> None:\n        \"\"\"\n        Terminates the world sync thread.\n        \"\"\"\n        self.world_sync.terminate = True\n        self.world_sync.join()\n\n    def save_state(self, state_id: Optional[int] = None) -> int:\n        \"\"\"\n        Returns the id of the saved state of the World. The saved state contains the states of all the objects and\n        the state of the physics simulator.\n\n        :return: A unique id of the state\n        \"\"\"\n        state_id = self.save_physics_simulator_state()\n        self.save_objects_state(state_id)\n        self._current_state = WorldState(state_id, self.object_states)\n        return super().save_state(state_id)\n\n    @property\n    def current_state(self) -> WorldState:\n        if self._current_state is None:\n            self._current_state = WorldState(self.save_physics_simulator_state(), self.object_states)\n        return self._current_state\n\n    @current_state.setter\n    def current_state(self, state: WorldState) -> None:\n        self.restore_physics_simulator_state(state.simulator_state_id)\n        self.object_states = state.object_states\n\n    @property\n    def object_states(self) -> Dict[str, ObjectState]:\n        \"\"\"\n        Returns the states of all objects in the World.\n\n        :return: A dictionary with the object id as key and the object state as value.\n        \"\"\"\n        return {obj.name: obj.current_state for obj in self.objects}\n\n    @object_states.setter\n    def object_states(self, states: Dict[str, ObjectState]) -> None:\n        \"\"\"\n        Sets the states of all objects in the World.\n        \"\"\"\n        for obj_name, obj_state in states.items():\n            self.get_object_by_name(obj_name).current_state = obj_state\n\n    def save_objects_state(self, state_id: int) -> None:\n        \"\"\"\n        Saves the state of all objects in the World according to the given state using the unique state id.\n\n        :param state_id: The unique id representing the state.\n        \"\"\"\n        for obj in self.objects:\n            obj.save_state(state_id)\n\n    @abstractmethod\n    def save_physics_simulator_state(self) -> int:\n        \"\"\"\n        Saves the state of the physics simulator and returns the unique id of the state.\n\n        :return: The unique id representing the state.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_physics_simulator_state(self, state_id: int) -> None:\n        \"\"\"\n        Removes the state of the physics simulator with the given id.\n\n        :param state_id: The unique id representing the state.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def restore_physics_simulator_state(self, state_id: int) -> None:\n        \"\"\"\n        Restores the objects and environment state in the physics simulator according to\n         the given state using the unique state id.\n\n        :param state_id: The unique id representing the state.\n        \"\"\"\n        pass\n\n    def get_images_for_target(self,\n                              target_pose: Pose,\n                              cam_pose: Pose,\n                              size: Optional[int] = 256) -> List[np.ndarray]:\n        \"\"\"\n        Calculates the view and projection Matrix and returns 3 images:\n\n        1. An RGB image\n        2. A depth image\n        3. A segmentation Mask, the segmentation mask indicates for every pixel the visible Object\n\n        :param target_pose: The pose to which the camera should point.\n        :param cam_pose: The pose of the camera.\n        :param size: The height and width of the images in pixels.\n        :return: A list containing an RGB and depth image as well as a segmentation mask, in this order.\n        \"\"\"\n        pass\n\n    def register_two_objects_collision_callbacks(self,\n                                                 object_a: Object,\n                                                 object_b: Object,\n                                                 on_collision_callback: Callable,\n                                                 on_collision_removal_callback: Optional[Callable] = None) -> None:\n        \"\"\"\n        Registers callback methods for contact between two Objects. There can be a callback for when the two Objects\n        get in contact and, optionally, for when they are not in contact anymore.\n\n        :param object_a: An object in the World\n        :param object_b: Another object in the World\n        :param on_collision_callback: A function that should be called if the objects are in contact\n        :param on_collision_removal_callback: A function that should be called if the objects are not in contact\n        \"\"\"\n        self.coll_callbacks[(object_a, object_b)] = CollisionCallbacks(on_collision_callback,\n                                                                       on_collision_removal_callback)\n\n    @classmethod\n    def add_resource_path(cls, path: str) -> None:\n        \"\"\"\n        Adds a resource path in which the World will search for files. This resource directory is searched if an\n        Object is spawned only with a filename.\n\n        :param path: A path in the filesystem in which to search for files.\n        \"\"\"\n        cls.data_directory.append(path)\n\n    def get_prospection_object_for_object(self, obj: Object) -> Object:\n        \"\"\"\n        Returns the corresponding object from the prospection world for a given object in the main world.\n         If the given Object is already in the prospection world, it is returned.\n\n        :param obj: The object for which the corresponding object in the prospection World should be found.\n        :return: The corresponding object in the prospection world.\n        \"\"\"\n        self.world_sync.add_obj_queue.join()\n        try:\n            return self.world_sync.object_mapping[obj]\n        except KeyError:\n            prospection_world = self if self.is_prospection_world else self.prospection_world\n            if obj in prospection_world.objects:\n                return obj\n            else:\n                raise ValueError(\n                    f\"There is no prospection object for the given object: {obj}, this could be the case if\"\n                    f\" the object isn't anymore in the main (graphical) World\"\n                    f\" or if the given object is already a prospection object. \")\n\n    def get_object_for_prospection_object(self, prospection_object: Object) -> Object:\n        \"\"\"\n        Returns the corresponding object from the main World for a given\n        object in the prospection world. If the  given object is not in the prospection\n        world an error will be raised.\n\n        :param prospection_object: The object for which the corresponding object in the main World should be found.\n        :return: The object in the main World.\n        \"\"\"\n        object_map = self.world_sync.object_mapping\n        try:\n            return list(object_map.keys())[list(object_map.values()).index(prospection_object)]\n        except ValueError:\n            raise ValueError(\"The given object is not in the prospection world.\")\n\n    def reset_world(self, remove_saved_states=True) -> None:\n        \"\"\"\n        Resets the World to the state it was first spawned in.\n        All attached objects will be detached, all joints will be set to the\n        default position of 0 and all objects will be set to the position and\n        orientation in which they were spawned.\n\n        :param remove_saved_states: If the saved states should be removed.\n        \"\"\"\n\n        if remove_saved_states:\n            self.remove_saved_states()\n\n        for obj in self.objects:\n            obj.reset(remove_saved_states)\n\n    def remove_saved_states(self) -> None:\n        \"\"\"\n        Removes all saved states of the World.\n        \"\"\"\n        for state_id in self.saved_states:\n            self.remove_physics_simulator_state(state_id)\n        super().remove_saved_states()\n\n    def update_transforms_for_objects_in_current_world(self) -> None:\n        \"\"\"\n        Updates transformations for all objects that are currently in :py:attr:`~pycram.world.World.current_world`.\n        \"\"\"\n        curr_time = rospy.Time.now()\n        for obj in list(self.current_world.objects):\n            obj.update_link_transforms(curr_time)\n\n    @abstractmethod\n    def ray_test(self, from_position: List[float], to_position: List[float]) -> int:\n        \"\"\" Cast a ray and return the first object hit, if any.\n\n        :param from_position: The starting position of the ray in Cartesian world coordinates.\n        :param to_position: The ending position of the ray in Cartesian world coordinates.\n        :return: The object id of the first object hit, or -1 if no object was hit.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def ray_test_batch(self, from_positions: List[List[float]], to_positions: List[List[float]],\n                       num_threads: int = 1) -> List[int]:\n        \"\"\" Cast a batch of rays and return the result for each of the rays (first object hit, if any. or -1)\n         Takes optional argument num_threads to specify the number of threads to use\n           to compute the ray intersections for the batch. Specify 0 to let simulator decide, 1 (default) for single\n            core execution, 2 or more to select the number of threads to use.\n\n        :param from_positions: The starting positions of the rays in Cartesian world coordinates.\n        :param to_positions: The ending positions of the rays in Cartesian world coordinates.\n        :param num_threads: The number of threads to use to compute the ray intersections for the batch.\n        \"\"\"\n        pass\n\n    def create_visual_shape(self, visual_shape: VisualShape) -> int:\n        \"\"\"\n        Creates a visual shape in the physics simulator and returns the unique id of the created shape.\n\n        :param visual_shape: The visual shape to be created, uses the VisualShape dataclass defined in world_dataclasses\n        :return: The unique id of the created shape.\n        \"\"\"\n        raise NotImplementedError\n\n    def create_multi_body_from_visual_shapes(self, visual_shape_ids: List[int], pose: Pose) -> int:\n        \"\"\"\n        Creates a multi body from visual shapes in the physics simulator and returns the unique id of the created\n        multi body.\n\n        :param visual_shape_ids: The ids of the visual shapes that should be used to create the multi body.\n        :param pose: The pose of the origin of the multi body relative to the world frame.\n        :return: The unique id of the created multi body.\n        \"\"\"\n        # Dummy parameter since these are needed to spawn visual shapes as a multibody.\n        num_of_shapes = len(visual_shape_ids)\n        link_poses = [Pose() for _ in range(num_of_shapes)]\n        link_masses = [1.0 for _ in range(num_of_shapes)]\n        link_parent = [0 for _ in range(num_of_shapes)]\n        link_joints = [JointType.FIXED.value for _ in range(num_of_shapes)]\n        link_collision = [-1 for _ in range(num_of_shapes)]\n        link_joint_axis = [Point(1, 0, 0) for _ in range(num_of_shapes)]\n\n        multi_body = MultiBody(base_visual_shape_index=-1, base_pose=pose,\n                               link_visual_shape_indices=visual_shape_ids, link_poses=link_poses,\n                               link_masses=link_masses,\n                               link_inertial_frame_poses=link_poses,\n                               link_parent_indices=link_parent, link_joint_types=link_joints,\n                               link_joint_axis=link_joint_axis,\n                               link_collision_shape_indices=link_collision)\n        return self.create_multi_body(multi_body)\n\n    def create_multi_body(self, multi_body: MultiBody) -> int:\n        \"\"\"\n        Creates a multi body in the physics simulator and returns the unique id of the created multi body. The multibody\n        is created by joining multiple links/shapes together with joints.\n\n        :param multi_body: The multi body to be created, uses the MultiBody dataclass defined in world_dataclasses.\n        :return: The unique id of the created multi body.\n        \"\"\"\n        raise NotImplementedError\n\n    def create_box_visual_shape(self, shape_data: BoxVisualShape) -> int:\n        \"\"\"\n        Creates a box visual shape in the physics simulator and returns the unique id of the created shape.\n\n        :param shape_data: The parameters that define the box visual shape to be created, uses the BoxVisualShape dataclass defined in world_dataclasses.\n        :return: The unique id of the created shape.\n        \"\"\"\n        raise NotImplementedError\n\n    def create_cylinder_visual_shape(self, shape_data: CylinderVisualShape) -> int:\n        \"\"\"\n        Creates a cylinder visual shape in the physics simulator and returns the unique id of the created shape.\n\n        :param shape_data: The parameters that define the cylinder visual shape to be created, uses the CylinderVisualShape dataclass defined in world_dataclasses.\n        :return: The unique id of the created shape.\n        \"\"\"\n        raise NotImplementedError\n\n    def create_sphere_visual_shape(self, shape_data: SphereVisualShape) -> int:\n        \"\"\"\n        Creates a sphere visual shape in the physics simulator and returns the unique id of the created shape.\n\n        :param shape_data: The parameters that define the sphere visual shape to be created, uses the SphereVisualShape dataclass defined in world_dataclasses.\n        :return: The unique id of the created shape.\n        \"\"\"\n        raise NotImplementedError\n\n    def create_capsule_visual_shape(self, shape_data: CapsuleVisualShape) -> int:\n        \"\"\"\n        Creates a capsule visual shape in the physics simulator and returns the unique id of the created shape.\n\n        :param shape_data: The parameters that define the capsule visual shape to be created, uses the CapsuleVisualShape dataclass defined in world_dataclasses.\n        :return: The unique id of the created shape.\n        \"\"\"\n        raise NotImplementedError\n\n    def create_plane_visual_shape(self, shape_data: PlaneVisualShape) -> int:\n        \"\"\"\n        Creates a plane visual shape in the physics simulator and returns the unique id of the created shape.\n\n        :param shape_data: The parameters that define the plane visual shape to be created, uses the PlaneVisualShape dataclass defined in world_dataclasses.\n        :return: The unique id of the created shape.\n        \"\"\"\n        raise NotImplementedError\n\n    def create_mesh_visual_shape(self, shape_data: MeshVisualShape) -> int:\n        \"\"\"\n        Creates a mesh visual shape in the physics simulator and returns the unique id of the created shape.\n\n        :param shape_data: The parameters that define the mesh visual shape to be created,\n        uses the MeshVisualShape dataclass defined in world_dataclasses.\n        :return: The unique id of the created shape.\n        \"\"\"\n        raise NotImplementedError\n\n    def add_text(self, text: str, position: List[float], orientation: Optional[List[float]] = None, size: float = 0.1,\n                 color: Optional[Color] = Color(), life_time: Optional[float] = 0,\n                 parent_object_id: Optional[int] = None, parent_link_id: Optional[int] = None) -> int:\n        \"\"\"\n        Adds text to the world.\n\n        :param text: The text to be added.\n        :param position: The position of the text in the world.\n        :param orientation: By default, debug text will always face the camera, automatically rotation. By specifying a text orientation (quaternion), the orientation will be fixed in world space or local space (when parent is specified).\n        :param size: The size of the text.\n        :param color: The color of the text.\n        :param life_time: The lifetime in seconds of the text to remain in the world, if 0 the text will remain in the world until it is removed manually.\n        :param parent_object_id: The id of the object to which the text should be attached.\n        :param parent_link_id: The id of the link to which the text should be attached.\n        :return: The id of the added text.\n        \"\"\"\n        raise NotImplementedError\n\n    def remove_text(self, text_id: Optional[int] = None) -> None:\n        \"\"\"\n        Removes text from the world using the given id. if no id is given all text will be removed.\n\n        :param text_id: The id of the text to be removed.\n        \"\"\"\n        raise NotImplementedError\n\n    def enable_joint_force_torque_sensor(self, obj: Object, fts_joint_idx: int) -> None:\n        \"\"\"\n        You can enable a joint force/torque sensor in each joint. Once enabled, if you perform\n        a simulation step, the get_joint_reaction_force_torque will report the joint reaction forces in\n        the fixed degrees of freedom: a fixed joint will measure all 6DOF joint forces/torques.\n        A revolute/hinge joint force/torque sensor will measure 5DOF reaction forces along all axis except\n        the hinge axis. The applied force by a joint motor is available through get_applied_joint_motor_torque.\n\n        :param obj: The object in which the joint is located.\n        :param fts_joint_idx: The index of the joint for which the force torque sensor should be enabled.\n        \"\"\"\n        raise NotImplementedError\n\n    def disable_joint_force_torque_sensor(self, obj: Object, joint_id: int) -> None:\n        \"\"\"\n        Disables the force torque sensor of a joint.\n\n        :param obj: The object in which the joint is located.\n        :param joint_id: The id of the joint for which the force torque sensor should be disabled.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_joint_reaction_force_torque(self, obj: Object, joint_id: int) -> List[float]:\n        \"\"\"\n        Returns the joint reaction forces and torques of the specified joint.\n\n        :param obj: The object in which the joint is located.\n        :param joint_id: The id of the joint for which the force torque should be returned.\n        :return: The joint reaction forces and torques of the specified joint.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_applied_joint_motor_torque(self, obj: Object, joint_id: int) -> float:\n        \"\"\"\n        Returns the applied torque by a joint motor.\n\n        :param obj: The object in which the joint is located.\n        :param joint_id: The id of the joint for which the applied motor torque should be returned.\n        :return: The applied torque by a joint motor.\n        \"\"\"\n        raise NotImplementedError\n\n    def __del__(self):\n        self.exit()\n\n\nclass UseProspectionWorld:\n    \"\"\"\n    An environment for using the prospection world, while in this environment the :py:attr:`~World.current_world`\n    variable will point to the prospection world.\n\n    Example:\n        with UseProspectionWorld():\n            NavigateAction.Action([[1, 0, 0], [0, 0, 0, 1]]).perform()\n    \"\"\"\n\n    WAIT_TIME_FOR_ADDING_QUEUE = 20\n    \"\"\"\n    The time in seconds to wait for the adding queue to be ready.\n    \"\"\"\n\n    def __init__(self):\n        self.prev_world: Optional[World] = None\n        # The previous world is saved to restore it after the with block is exited.\n\n    def sync_worlds(self):\n        \"\"\"\n        Synchronizes the state of the prospection world with the main world.\n        \"\"\"\n        for world_obj, prospection_obj in World.current_world.world_sync.object_mapping.items():\n            prospection_obj.current_state = world_obj.current_state\n\n    def __enter__(self):\n        \"\"\"\n        This method is called when entering the with block, it will set the current world to the prospection world\n        \"\"\"\n        if not World.current_world.is_prospection_world:\n            time.sleep(self.WAIT_TIME_FOR_ADDING_QUEUE * World.current_world.simulation_time_step)\n            # blocks until the adding queue is ready\n            World.current_world.world_sync.add_obj_queue.join()\n            self.sync_worlds()\n\n            self.prev_world = World.current_world\n            World.current_world.world_sync.pause_sync = True\n            World.current_world = World.current_world.prospection_world\n\n    def __exit__(self, *args):\n        \"\"\"\n        This method is called when exiting the with block, it will restore the previous world to be the current world.\n        \"\"\"\n        if self.prev_world is not None:\n            World.current_world = self.prev_world\n            World.current_world.world_sync.pause_sync = False\n\n\nclass WorldSync(threading.Thread):\n    \"\"\"\n    Synchronizes the state between the World and its prospection world.\n    Meaning the cartesian and joint position of everything in the prospection world will be\n    synchronized with the main World.\n    Adding and removing objects is done via queues, such that loading times of objects\n    in the prospection world does not affect the World.\n    The class provides the possibility to pause the synchronization, this can be used\n    if reasoning should be done in the prospection world.\n    \"\"\"\n\n    def __init__(self, world: World, prospection_world: World):\n        threading.Thread.__init__(self)\n        self.world: World = world\n        self.prospection_world: World = prospection_world\n        self.prospection_world.world_sync = self\n\n        self.terminate: bool = False\n        self.add_obj_queue: Queue = Queue()\n        self.remove_obj_queue: Queue = Queue()\n        self.pause_sync: bool = False\n        # Maps world to prospection world objects\n        self.object_mapping: Dict[Object, Object] = {}\n        self.equal_states = False\n\n    def run(self, wait_time_as_n_simulation_steps: Optional[int] = 1):\n        \"\"\"\n        Main method of the synchronization, this thread runs in a loop until the\n        terminate flag is set.\n        While this loop runs it continuously checks the cartesian and joint position of\n        every object in the World and updates the corresponding object in the\n        prospection world. When there are entries in the adding or removing queue the corresponding objects will\n        be added or removed in the same iteration.\n\n        :param wait_time_as_n_simulation_steps: The time in simulation steps to wait between each iteration of\n         the syncing loop.\n        \"\"\"\n        while not self.terminate:\n            self.check_for_pause()\n            while not self.add_obj_queue.empty():\n                obj = self.add_obj_queue.get()\n                # Maps the World object to the prospection world object\n                self.object_mapping[obj] = copy(obj)\n                self.add_obj_queue.task_done()\n            while not self.remove_obj_queue.empty():\n                obj = self.remove_obj_queue.get()\n                # Get prospection world object reference from object mapping\n                prospection_obj = self.object_mapping[obj]\n                prospection_obj.remove()\n                del self.object_mapping[obj]\n                self.remove_obj_queue.task_done()\n            self.check_for_pause()\n            time.sleep(wait_time_as_n_simulation_steps * self.world.simulation_time_step)\n\n    def check_for_pause(self) -> None:\n        \"\"\"\n        Checks if :py:attr:`~self.pause_sync` is true and sleeps this thread until it isn't anymore.\n        \"\"\"\n        while self.pause_sync:\n            time.sleep(0.1)\n\n    def check_for_equal(self) -> bool:\n        \"\"\"\n        Checks if both Worlds have the same state, meaning all objects are in the same position.\n        This is currently not used, but might be used in the future if synchronization issues worsen.\n\n        :return: True if both Worlds have the same state, False otherwise.\n        \"\"\"\n        eql = True\n        for obj, prospection_obj in self.object_mapping.items():\n            eql = eql and obj.get_pose().dist(prospection_obj.get_pose()) < 0.001\n        self.equal_states = eql\n        return eql\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the action_designator.py file and how do they interact with other components in the system?"}, {"role": "assistant", "content": "# Content from: #<action_designator.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nimport abc\nimport inspect\nimport itertools\n\nimport numpy as np\nfrom sqlalchemy.orm import Session\nfrom tf import transformations\nfrom typing_extensions import Any, List, Union, Callable, Optional, Type\n\nimport rospy\n\nfrom .location_designator import CostmapLocation\nfrom .motion_designator import MoveJointsMotion, MoveGripperMotion, MoveArmJointsMotion, MoveTCPMotion, MoveMotion, \\\n    LookingMotion, DetectingMotion, OpeningMotion, ClosingMotion\nfrom .object_designator import ObjectDesignatorDescription, BelieveObject, ObjectPart\nfrom ..local_transformer import LocalTransformer\nfrom ..plan_failures import ObjectUnfetchable, ReachabilityFailure\n# from ..robot_descriptions import robot_description\nfrom ..robot_description import RobotDescription\nfrom ..tasktree import with_tree\n\nfrom owlready2 import Thing\n\nfrom ..datastructures.enums import Arms, Grasp, GripperState\nfrom ..designator import ActionDesignatorDescription\nfrom ..datastructures.pose import Pose\nfrom ..datastructures.world import World\nfrom ..ontology.ontology import OntologyConceptHolder\n\nfrom ..orm.action_designator import (ParkArmsAction as ORMParkArmsAction, NavigateAction as ORMNavigateAction,\n                                     PickUpAction as ORMPickUpAction, PlaceAction as ORMPlaceAction,\n                                     MoveTorsoAction as ORMMoveTorsoAction, SetGripperAction as ORMSetGripperAction,\n                                     LookAtAction as ORMLookAtAction, DetectAction as ORMDetectAction,\n                                     TransportAction as ORMTransportAction, OpenAction as ORMOpenAction,\n                                     CloseAction as ORMCloseAction, GraspingAction as ORMGraspingAction, Action,\n                                     FaceAtAction as ORMFaceAtAction)\nfrom ..orm.base import Pose as ORMPose\nfrom ..orm.object_designator import Object as ORMObject\nfrom ..orm.action_designator import Action as ORMAction\nfrom dataclasses import dataclass, field\n\n\nclass MoveTorsoAction(ActionDesignatorDescription):\n    \"\"\"\n    Action Designator for Moving the torso of the robot up and down\n    \"\"\"\n\n    def __init__(self, positions: List[float], resolver=None,\n                 ontology_concept_holders: Optional[List[OntologyConceptHolder]] = None):\n        \"\"\"\n        Create a designator description to move the torso of the robot up and down.\n\n        :param positions: List of possible positions of the robots torso, possible position is a float of height in metres\n        :param resolver: An optional specialized_designators that returns a performable designator for a designator description.\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.positions: List[float] = positions\n\n        if self.soma:\n            self.init_ontology_concepts({\"move_torso\": self.soma.MoveTorso})\n\n    def ground(self) -> MoveTorsoActionPerformable:\n        \"\"\"\n        Creates a performable action designator with the first element from the list of possible torso heights.\n\n        :return: A performable action designator\n        \"\"\"\n        return MoveTorsoActionPerformable(self.positions[0])\n\n    def __iter__(self):\n        \"\"\"\n        Iterates over all possible values for this designator and returns a performable action designator with the value.\n\n        :return: A performable action designator\n        \"\"\"\n        for position in self.positions:\n            yield MoveTorsoActionPerformable(position)\n\n\nclass SetGripperAction(ActionDesignatorDescription):\n    \"\"\"\n    Set the gripper state of the robot\n    \"\"\"\n\n    def __init__(self, grippers: List[Arms], motions: List[GripperState], resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Sets the gripper state, the desired state is given with the motion. Motion can either be 'open' or 'close'.\n\n        :param grippers: A list of possible grippers\n        :param motions: A list of possible motions\n        :param resolver: An alternative specialized_designators that returns a performable designator for a designator description\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.grippers: List[GripperState] = grippers\n        self.motions: List[Arms] = motions\n\n        if self.soma:\n            self.init_ontology_concepts({\"setting_gripper\": self.soma.SettingGripper})\n\n    def ground(self) -> SetGripperActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the first element in the grippers and motions list.\n\n        :return: A performable designator\n        \"\"\"\n        return SetGripperActionPerformable(self.grippers[0], self.motions[0])\n\n    def __iter__(self):\n        \"\"\"\n        Iterates over all possible combinations of grippers and motions\n\n        :return: A performable designator with a combination of gripper and motion\n        \"\"\"\n        for parameter_combination in itertools.product(self.grippers, self.motions):\n            yield SetGripperActionPerformable(*parameter_combination)\n\n\nclass ReleaseAction(ActionDesignatorDescription):\n    \"\"\"\n    Releases an Object from the robot.\n\n    Note: This action can not be used yet.\n    \"\"\"\n\n    def __init__(self, grippers: List[Arms], object_designator_description: ObjectDesignatorDescription,\n                 resolver=None, ontology_concept_holders: Optional[List[Thing]] = None):\n        super().__init__(resolver, ontology_concept_holders)\n        self.grippers: List[Arms] = grippers\n        self.object_designator_description = object_designator_description\n\n        if self.soma:\n            self.init_ontology_concepts({\"releasing\": self.soma.Releasing})\n\n    def ground(self) -> ReleaseActionPerformable:\n        return ReleaseActionPerformable(self.grippers[0], self.object_designator_description.ground())\n\n\nclass GripAction(ActionDesignatorDescription):\n    \"\"\"\n    Grip an object with the robot.\n\n    :ivar grippers: The grippers to consider\n    :ivar object_designator_description: The description of objects to consider\n    :ivar efforts: The efforts to consider\n\n    Note: This action can not be used yet.\n    \"\"\"\n\n    def __init__(self, grippers: List[Arms], object_designator_description: ObjectDesignatorDescription,\n                 efforts: List[float], resolver=None, ontology_concept_holders: Optional[List[Thing]] = None):\n        super().__init__(resolver, ontology_concept_holders)\n        self.grippers: List[Arms] = grippers\n        self.object_designator_description: ObjectDesignatorDescription = object_designator_description\n        self.efforts: List[float] = efforts\n\n        if self.soma:\n            self.init_ontology_concepts({\"holding\": self.soma.Holding})\n\n    def ground(self) -> GripActionPerformable:\n        return GripActionPerformable(self.grippers[0], self.object_designator_description.ground(), self.efforts[0])\n\n\nclass ParkArmsAction(ActionDesignatorDescription):\n    \"\"\"\n    Park the arms of the robot.\n    \"\"\"\n\n    def __init__(self, arms: List[Arms], resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Moves the arms in the pre-defined parking position. Arms are taken from pycram.enum.Arms\n\n        :param arms: A list of possible arms, that could be used\n        :param resolver: An optional specialized_designators that returns a performable designator from the designator description\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.arms: List[Arms] = arms\n\n        if self.soma:\n            self.init_ontology_concepts({\"parking_arms\": self.soma.ParkingArms})\n\n    def ground(self) -> ParkArmsActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the first element of the list of possible arms\n\n        :return: A performable designator\n        \"\"\"\n        return ParkArmsActionPerformable(self.arms[0])\n\n\nclass PickUpAction(ActionDesignatorDescription):\n    \"\"\"\n    Designator to let the robot pick up an object.\n    \"\"\"\n\n    def __init__(self,\n                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],\n                 arms: List[Arms], grasps: List[Grasp], resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Lets the robot pick up an object. The description needs an object designator describing the object that should be\n        picked up, an arm that should be used as well as the grasp from which side the object should be picked up.\n\n        :param object_designator_description: List of possible object designator\n        :param arms: List of possible arms that could be used\n        :param grasps: List of possible grasps for the object\n        :param resolver: An optional specialized_designators that returns a performable designator with elements from the lists of possible paramter\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.object_designator_description: Union[\n            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description\n        self.arms: List[Arms] = arms\n        self.grasps: List[Grasp] = grasps\n\n        if self.soma:\n            self.init_ontology_concepts({\"picking_up\": self.soma.PickingUp})\n\n    def ground(self) -> PickUpActionPerformable:\n        \"\"\"\n        Default specialized_designators, returns a performable designator with the first entries from the lists of possible parameter.\n\n        :return: A performable designator\n        \"\"\"\n        if isinstance(self.object_designator_description, ObjectDesignatorDescription.Object):\n            obj_desig = self.object_designator_description\n        else:\n            obj_desig = self.object_designator_description.resolve()\n\n        return PickUpActionPerformable(obj_desig, self.arms[0], self.grasps[0])\n\n\nclass PlaceAction(ActionDesignatorDescription):\n    \"\"\"\n    Places an Object at a position using an arm.\n    \"\"\"\n\n    def __init__(self,\n                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],\n                 target_locations: List[Pose],\n                 arms: List[Arms], resolver=None, ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Create an Action Description to place an object\n\n        :param object_designator_description: Description of object to place.\n        :param target_locations: List of possible positions/orientations to place the object\n        :param arms: List of possible arms to use\n        :param resolver: Grounding method to resolve this designator\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.object_designator_description: Union[\n            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description\n        self.target_locations: List[Pose] = target_locations\n        self.arms: List[Arms] = arms\n\n        if self.soma:\n            self.init_ontology_concepts({\"placing\": self.soma.Placing})\n\n    def ground(self) -> PlaceActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the first entries from the list of possible entries.\n\n        :return: A performable designator\n        \"\"\"\n        obj_desig = self.object_designator_description if isinstance(self.object_designator_description,\n                                                                     ObjectDesignatorDescription.Object) else self.object_designator_description.resolve()\n\n        return PlaceActionPerformable(obj_desig, self.arms[0], self.target_locations[0])\n\n\nclass NavigateAction(ActionDesignatorDescription):\n    \"\"\"\n    Navigates the Robot to a position.\n    \"\"\"\n\n    def __init__(self, target_locations: List[Pose], resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Navigates the robot to a location.\n\n        :param target_locations: A list of possible target locations for the navigation.\n        :param resolver: An alternative specialized_designators that creates a performable designator from the list of possible parameter\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.target_locations: List[Pose] = target_locations\n\n        if self.soma:\n            self.init_ontology_concepts({\"navigating\": self.soma.Navigating})\n\n    def ground(self) -> NavigateActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the first entry of possible target locations.\n\n        :return: A performable designator\n        \"\"\"\n        return NavigateActionPerformable(self.target_locations[0])\n\n\nclass TransportAction(ActionDesignatorDescription):\n    \"\"\"\n    Transports an object to a position using an arm\n    \"\"\"\n\n    def __init__(self,\n                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],\n                 arms: List[Arms],\n                 target_locations: List[Pose], resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Designator representing a pick and place plan.\n\n        :param object_designator_description: Object designator description or a specified Object designator that should be transported\n        :param arms: A List of possible arms that could be used for transporting\n        :param target_locations: A list of possible target locations for the object to be placed\n        :param resolver: An alternative specialized_designators that returns a performable designator for the list of possible parameter\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.object_designator_description: Union[\n            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description\n        self.arms: List[Arms] = arms\n        self.target_locations: List[Pose] = target_locations\n\n        if self.soma:\n            self.init_ontology_concepts({\"transporting\": self.soma.Transporting})\n\n    def ground(self) -> TransportActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the first entries from the lists of possible parameter.\n\n        :return: A performable designator\n        \"\"\"\n        obj_desig = self.object_designator_description \\\n            if isinstance(self.object_designator_description, ObjectDesignatorDescription.Object) \\\n            else self.object_designator_description.resolve()\n\n        return TransportActionPerformable(obj_desig, self.arms[0], self.target_locations[0])\n\n\nclass LookAtAction(ActionDesignatorDescription):\n    \"\"\"\n    Lets the robot look at a position.\n    \"\"\"\n\n    def __init__(self, targets: List[Pose], resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Moves the head of the robot such that it points towards the given target location.\n\n        :param targets: A list of possible locations to look at\n        :param resolver: An alternative specialized_designators that returns a performable designator for a list of possible target locations\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.targets: List[Pose] = targets\n\n        if self.soma:\n            self.init_ontology_concepts({\"looking_at\": self.soma.LookingAt})\n\n    def ground(self) -> LookAtActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the first entry in the list of possible targets\n\n        :return: A performable designator\n        \"\"\"\n        return LookAtActionPerformable(self.targets[0])\n\n\nclass DetectAction(ActionDesignatorDescription):\n    \"\"\"\n    Detects an object that fits the object description and returns an object designator describing the object.\n    \"\"\"\n\n    def __init__(self, object_designator_description: ObjectDesignatorDescription, resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Tries to detect an object in the field of view (FOV) of the robot.\n\n        :param object_designator_description: Object designator describing the object\n        :param resolver: An alternative specialized_designators\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.object_designator_description: ObjectDesignatorDescription = object_designator_description\n\n        if self.soma:\n            self.init_ontology_concepts({\"looking_for\": self.soma.LookingFor,\n                                         \"checking_object_presence\": self.soma.CheckingObjectPresence})\n\n    def ground(self) -> DetectActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the resolved object description.\n\n        :return: A performable designator\n        \"\"\"\n        return DetectActionPerformable(self.object_designator_description.resolve())\n\n\nclass OpenAction(ActionDesignatorDescription):\n    \"\"\"\n    Opens a container like object\n\n    Can currently not be used\n    \"\"\"\n\n    def __init__(self, object_designator_description: ObjectPart, arms: List[Arms], resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Moves the arm of the robot to open a container.\n\n        :param object_designator_description: Object designator describing the handle that should be used to open\n        :param arms: A list of possible arms that should be used\n        :param resolver: A alternative specialized_designators that returns a performable designator for the lists of possible parameter.\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.object_designator_description: ObjectPart = object_designator_description\n        self.arms: List[Arms] = arms\n\n        if self.soma:\n            self.init_ontology_concepts({\"opening\": self.soma.Opening})\n\n    def ground(self) -> OpenActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the resolved object description and the first entries\n        from the lists of possible parameter.\n\n        :return: A performable designator\n        \"\"\"\n        return OpenActionPerformable(self.object_designator_description.resolve(), self.arms[0])\n\n\nclass CloseAction(ActionDesignatorDescription):\n    \"\"\"\n    Closes a container like object.\n\n    Can currently not be used\n    \"\"\"\n\n    def __init__(self, object_designator_description: ObjectPart, arms: List[Arms],\n                 resolver=None, ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Attempts to close an open container\n\n        :param object_designator_description: Object designator description of the handle that should be used\n        :param arms: A list of possible arms to use\n        :param resolver: An alternative specialized_designators that returns a performable designator for the list of possible parameter\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.object_designator_description: ObjectPart = object_designator_description\n        self.arms: List[Arms] = arms\n\n        if self.soma:\n            self.init_ontology_concepts({\"closing\": self.soma.Closing})\n\n    def ground(self) -> CloseActionPerformable:\n        \"\"\"\n        Default specialized_designators that returns a performable designator with the resolved object designator and the first entry from\n        the list of possible arms.\n\n        :return: A performable designator\n        \"\"\"\n        return CloseActionPerformable(self.object_designator_description.resolve(), self.arms[0])\n\n\nclass GraspingAction(ActionDesignatorDescription):\n    \"\"\"\n    Grasps an object described by the given Object Designator description\n    \"\"\"\n\n    def __init__(self, arms: List[Arms], object_description: Union[ObjectDesignatorDescription, ObjectPart],\n                 resolver: Callable = None, ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Will try to grasp the object described by the given description. Grasping is done by moving into a pre grasp\n        position 10 cm before the object, opening the gripper, moving to the object and then closing the gripper.\n\n        :param arms: List of Arms that should be used for grasping\n        :param object_description: Description of the object that should be grasped\n        :param resolver: An alternative specialized_designators to get a specified designator from the designator description\n        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(resolver, ontology_concept_holders)\n        self.arms: List[Arms] = arms\n        self.object_description: ObjectDesignatorDescription = object_description\n\n        if self.soma:\n            self.init_ontology_concepts({\"grasping\": self.soma.Grasping})\n\n    def ground(self) -> GraspingActionPerformable:\n        \"\"\"\n        Default specialized_designators that takes the first element from the list of arms and the first solution for the object\n        designator description ond returns it.\n\n        :return: A performable action designator that contains specific arguments\n        \"\"\"\n        return GraspingActionPerformable(self.arms[0], self.object_description.resolve())\n\n\n# ----------------------------------------------------------------------------\n# ---------------- Performables ----------------------------------------------\n# ----------------------------------------------------------------------------\n\n\n@dataclass\nclass ActionAbstract(ActionDesignatorDescription.Action, abc.ABC):\n    \"\"\"Base class for performable performables.\"\"\"\n    orm_class: Type[ORMAction] = field(init=False, default=None)\n    \"\"\"\n    The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to\n    be able to insert the action into the database.\n    \"\"\"\n\n    @abc.abstractmethod\n    def perform(self) -> None:\n        \"\"\"\n        Perform the action.\n\n        Will be overwritten by each action.\n        \"\"\"\n        pass\n\n    def to_sql(self) -> Action:\n        \"\"\"\n        Convert this action to its ORM equivalent.\n\n        Needs to be overwritten by an action if it didn't overwrite the orm_class attribute with its ORM equivalent.\n\n        :return: An instance of the ORM equivalent of the action with the parameters set\n        \"\"\"\n        # get all class parameters (ignore inherited ones)\n        class_variables = {key: value for key, value in vars(self).items()\n                           if key in inspect.getfullargspec(self.__init__).args}\n\n        # get all orm class parameters (ignore inherited ones)\n        orm_class_variables = inspect.getfullargspec(self.orm_class.__init__).args\n\n        # list of parameters that will be passed to the ORM class. If the name does not match the orm_class equivalent\n        # or if it is a type that needs to be inserted into the session manually, it will not be added to the list\n        parameters = [value for key, value in class_variables.items() if key in orm_class_variables\n                      and not isinstance(value, (ObjectDesignatorDescription.Object, Pose))]\n\n        return self.orm_class(*parameters)\n\n    def insert(self, session: Session, **kwargs) -> Action:\n        \"\"\"\n        Insert this action into the database.\n\n        Needs to be overwritten by an action if the action has attributes that do not exist in the orm class\n        equivalent. In that case, the attributes need to be inserted into the session manually.\n\n        :param session: Session with a database that is used to add and commit the objects\n        :param kwargs: Possible extra keyword arguments\n        :return: The completely instanced ORM action that was inserted into the database\n        \"\"\"\n\n        action = super().insert(session)\n\n        # get all class parameters (ignore inherited ones)\n        class_variables = {key: value for key, value in vars(self).items()\n                           if key in inspect.getfullargspec(self.__init__).args}\n\n        # get all orm class parameters (ignore inherited ones)\n        orm_class_variables = inspect.getfullargspec(self.orm_class.__init__).args\n\n        # loop through all class parameters and insert them into the session unless they are already added by the ORM\n        for key, value in class_variables.items():\n            if key not in orm_class_variables:\n                variable = value.insert(session)\n                if isinstance(variable, ORMObject):\n                    action.object = variable\n                elif isinstance(variable, ORMPose):\n                    action.pose = variable\n        session.add(action)\n\n        return action\n\n\n@dataclass\nclass MoveTorsoActionPerformable(ActionAbstract):\n    \"\"\"\n    Move the torso of the robot up and down.\n    \"\"\"\n\n    position: float\n    \"\"\"\n    Target position of the torso joint\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMMoveTorsoAction)\n\n    @with_tree\n    def perform(self) -> None:\n        MoveJointsMotion([RobotDescription.current_robot_description.torso_joint], [self.position]).perform()\n\n\n@dataclass\nclass SetGripperActionPerformable(ActionAbstract):\n    \"\"\"\n    Set the gripper state of the robot.\n    \"\"\"\n\n    gripper: Arms\n    \"\"\"\n    The gripper that should be set \n    \"\"\"\n    motion: GripperState\n    \"\"\"\n    The motion that should be set on the gripper\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMSetGripperAction)\n\n    @with_tree\n    def perform(self) -> None:\n        MoveGripperMotion(gripper=self.gripper, motion=self.motion).perform()\n\n\n@dataclass\nclass ReleaseActionPerformable(ActionAbstract):\n    \"\"\"\n    Releases an Object from the robot.\n\n    Note: This action can not ve used yet.\n    \"\"\"\n\n    gripper: Arms\n\n    object_designator: ObjectDesignatorDescription.Object\n\n    def perform(self) -> None:\n        raise NotImplementedError\n\n\n@dataclass\nclass GripActionPerformable(ActionAbstract):\n    \"\"\"\n    Grip an object with the robot.\n\n    Note: This action can not be used yet.\n    \"\"\"\n\n    gripper: Arms\n    object_designator: ObjectDesignatorDescription.Object\n    effort: float\n\n    @with_tree\n    def perform(self) -> None:\n        raise NotImplementedError()\n\n\n@dataclass\nclass ParkArmsActionPerformable(ActionAbstract):\n    \"\"\"\n    Park the arms of the robot.\n    \"\"\"\n\n    arm: Arms\n    \"\"\"\n    Entry from the enum for which arm should be parked\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMParkArmsAction)\n\n    @with_tree\n    def perform(self) -> None:\n        # create the keyword arguments\n        kwargs = dict()\n        left_poses = None\n        right_poses = None\n\n        # add park left arm if wanted\n        if self.arm in [Arms.LEFT, Arms.BOTH]:\n            kwargs[\"left_arm_config\"] = \"park\"\n            left_poses = RobotDescription.current_robot_description.get_arm_chain(Arms.LEFT).get_static_joint_states(kwargs[\"left_arm_config\"])\n\n        # add park right arm if wanted\n        if self.arm in [Arms.RIGHT, Arms.BOTH]:\n            kwargs[\"right_arm_config\"] = \"park\"\n            right_poses = RobotDescription.current_robot_description.get_arm_chain(Arms.RIGHT).get_static_joint_states(kwargs[\"right_arm_config\"])\n\n        MoveArmJointsMotion(left_poses, right_poses).perform()\n\n\n@dataclass\nclass PickUpActionPerformable(ActionAbstract):\n    \"\"\"\n    Let the robot pick up an object.\n    \"\"\"\n\n    object_designator: ObjectDesignatorDescription.Object\n    \"\"\"\n    Object designator describing the object that should be picked up\n    \"\"\"\n\n    arm: Arms\n    \"\"\"\n    The arm that should be used for pick up\n    \"\"\"\n\n    grasp: Grasp\n    \"\"\"\n    The grasp that should be used. For example, 'left' or 'right'\n    \"\"\"\n\n    object_at_execution: Optional[ObjectDesignatorDescription.Object] = field(init=False)\n    \"\"\"\n    The object at the time this Action got created. It is used to be a static, information holding entity. It is\n    not updated when the BulletWorld object is changed.\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMPickUpAction)\n\n    @with_tree\n    def perform(self) -> None:\n        # Store the object's data copy at execution\n        self.object_at_execution = self.object_designator.frozen_copy()\n        robot = World.robot\n        # Retrieve object and robot from designators\n        object = self.object_designator.world_object\n        # Get grasp orientation and target pose\n        grasp = RobotDescription.current_robot_description.grasps[self.grasp]\n        # oTm = Object Pose in Frame map\n        oTm = object.get_pose()\n        # Transform the object pose to the object frame, basically the origin of the object frame\n        mTo = object.local_transformer.transform_to_object_frame(oTm, object)\n        # Adjust the pose according to the special knowledge of the object designator\n        adjusted_pose = self.object_designator.special_knowledge_adjustment_pose(self.grasp, mTo)\n        # Transform the adjusted pose to the map frame\n        adjusted_oTm = object.local_transformer.transform_pose(adjusted_pose, \"map\")\n        # multiplying the orientation therefore \"rotating\" it, to get the correct orientation of the gripper\n\n        adjusted_oTm.multiply_quaternions(grasp)\n\n        # prepose depending on the gripper (its annoying we have to put pr2_1 here tbh\n        # gripper_frame = \"pr2_1/l_gripper_tool_frame\" if self.arm == \"left\" else \"pr2_1/r_gripper_tool_frame\"\n        gripper_frame = robot.get_link_tf_frame(RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame())\n        # First rotate the gripper, so the further calculations makes sense\n        tmp_for_rotate_pose = object.local_transformer.transform_pose(adjusted_oTm, gripper_frame)\n        tmp_for_rotate_pose.pose.position.x = 0\n        tmp_for_rotate_pose.pose.position.y = 0\n        tmp_for_rotate_pose.pose.position.z = -0.1\n        gripper_rotate_pose = object.local_transformer.transform_pose(tmp_for_rotate_pose, \"map\")\n\n        # Perform Gripper Rotate\n        # BulletWorld.current_bullet_world.add_vis_axis(gripper_rotate_pose)\n        # MoveTCPMotion(gripper_rotate_pose, self.arm).resolve().perform()\n\n        oTg = object.local_transformer.transform_pose(adjusted_oTm, gripper_frame)\n        oTg.pose.position.x -= 0.1  # in x since this is how the gripper is oriented\n        prepose = object.local_transformer.transform_pose(oTg, \"map\")\n\n        # Perform the motion with the prepose and open gripper\n        World.current_world.add_vis_axis(prepose)\n        MoveTCPMotion(prepose, self.arm, allow_gripper_collision=True).perform()\n        MoveGripperMotion(motion=GripperState.OPEN, gripper=self.arm).perform()\n\n        # Perform the motion with the adjusted pose -> actual grasp and close gripper\n        World.current_world.add_vis_axis(adjusted_oTm)\n        MoveTCPMotion(adjusted_oTm, self.arm, allow_gripper_collision=True).perform()\n        adjusted_oTm.pose.position.z += 0.03\n        MoveGripperMotion(motion=GripperState.CLOSE, gripper=self.arm).perform()\n        tool_frame = RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame()\n        robot.attach(object, tool_frame)\n\n        # Lift object\n        World.current_world.add_vis_axis(adjusted_oTm)\n        MoveTCPMotion(adjusted_oTm, self.arm, allow_gripper_collision=True).perform()\n\n        # Remove the vis axis from the world\n        World.current_world.remove_vis_axis()\n\n\n@dataclass\nclass PlaceActionPerformable(ActionAbstract):\n    \"\"\"\n    Places an Object at a position using an arm.\n    \"\"\"\n\n    object_designator: ObjectDesignatorDescription.Object\n    \"\"\"\n    Object designator describing the object that should be place\n    \"\"\"\n    arm: Arms\n    \"\"\"\n    Arm that is currently holding the object\n    \"\"\"\n    target_location: Pose\n    \"\"\"\n    Pose in the world at which the object should be placed\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMPlaceAction)\n\n    @with_tree\n    def perform(self) -> None:\n        object_pose = self.object_designator.world_object.get_pose()\n        local_tf = LocalTransformer()\n\n        # Transformations such that the target position is the position of the object and not the tcp\n        tcp_to_object = local_tf.transform_pose(object_pose,\n                                                World.robot.get_link_tf_frame(\n                                                    RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame()))\n        target_diff = self.target_location.to_transform(\"target\").inverse_times(\n            tcp_to_object.to_transform(\"object\")).to_pose()\n\n        MoveTCPMotion(target_diff, self.arm).perform()\n        MoveGripperMotion(GripperState.OPEN, self.arm).perform()\n        World.robot.detach(self.object_designator.world_object)\n        retract_pose = local_tf.transform_pose(target_diff, World.robot.get_link_tf_frame(\n            RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame()))\n        retract_pose.position.x -= 0.07\n        MoveTCPMotion(retract_pose, self.arm).perform()\n\n\n@dataclass\nclass NavigateActionPerformable(ActionAbstract):\n    \"\"\"\n    Navigates the Robot to a position.\n    \"\"\"\n\n    target_location: Pose\n    \"\"\"\n    Location to which the robot should be navigated\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMNavigateAction)\n\n    @with_tree\n    def perform(self) -> None:\n        MoveMotion(self.target_location).perform()\n\n\n@dataclass\nclass TransportActionPerformable(ActionAbstract):\n    \"\"\"\n    Transports an object to a position using an arm\n    \"\"\"\n\n    object_designator: ObjectDesignatorDescription.Object\n    \"\"\"\n    Object designator describing the object that should be transported.\n    \"\"\"\n    arm: Arms\n    \"\"\"\n    Arm that should be used\n    \"\"\"\n    target_location: Pose\n    \"\"\"\n    Target Location to which the object should be transported\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMTransportAction)\n\n    @with_tree\n    def perform(self) -> None:\n        robot_desig = BelieveObject(names=[RobotDescription.current_robot_description.name])\n        ParkArmsActionPerformable(Arms.BOTH).perform()\n        pickup_loc = CostmapLocation(target=self.object_designator, reachable_for=robot_desig.resolve(),\n                                     reachable_arm=self.arm)\n        # Tries to find a pick-up posotion for the robot that uses the given arm\n        pickup_pose = None\n        for pose in pickup_loc:\n            if self.arm in pose.reachable_arms:\n                pickup_pose = pose\n                break\n        if not pickup_pose:\n            raise ObjectUnfetchable(\n                f\"Found no pose for the robot to grasp the object: {self.object_designator} with arm: {self.arm}\")\n\n        NavigateActionPerformable(pickup_pose.pose).perform()\n        PickUpActionPerformable(self.object_designator, self.arm, Grasp.FRONT).perform()\n        ParkArmsActionPerformable(Arms.BOTH).perform()\n        try:\n            place_loc = CostmapLocation(target=self.target_location, reachable_for=robot_desig.resolve(),\n                                        reachable_arm=self.arm).resolve()\n        except StopIteration:\n            raise ReachabilityFailure(\n                f\"No location found from where the robot can reach the target location: {self.target_location}\")\n        NavigateActionPerformable(place_loc.pose).perform()\n        PlaceActionPerformable(self.object_designator, self.arm, self.target_location).perform()\n        ParkArmsActionPerformable(Arms.BOTH).perform()\n\n\n@dataclass\nclass LookAtActionPerformable(ActionAbstract):\n    \"\"\"\n    Lets the robot look at a position.\n    \"\"\"\n\n    target: Pose\n    \"\"\"\n    Position at which the robot should look, given as 6D pose\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMLookAtAction)\n\n    @with_tree\n    def perform(self) -> None:\n        LookingMotion(target=self.target).perform()\n\n\n@dataclass\nclass DetectActionPerformable(ActionAbstract):\n    \"\"\"\n    Detects an object that fits the object description and returns an object designator describing the object.\n    \"\"\"\n\n    object_designator: ObjectDesignatorDescription.Object\n    \"\"\"\n    Object designator loosely describing the object, e.g. only type. \n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMDetectAction)\n\n    @with_tree\n    def perform(self) -> None:\n        return DetectingMotion(object_type=self.object_designator.obj_type).perform()\n\n\n@dataclass\nclass OpenActionPerformable(ActionAbstract):\n    \"\"\"\n    Opens a container like object\n    \"\"\"\n\n    object_designator: ObjectPart.Object\n    \"\"\"\n    Object designator describing the object that should be opened\n    \"\"\"\n    arm: Arms\n    \"\"\"\n    Arm that should be used for opening the container\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMOpenAction)\n\n    @with_tree\n    def perform(self) -> None:\n        GraspingActionPerformable(self.arm, self.object_designator).perform()\n        OpeningMotion(self.object_designator, self.arm).perform()\n\n        MoveGripperMotion(GripperState.OPEN, self.arm, allow_gripper_collision=True).perform()\n\n\n@dataclass\nclass CloseActionPerformable(ActionAbstract):\n    \"\"\"\n    Closes a container like object.\n    \"\"\"\n\n    object_designator: ObjectPart.Object\n    \"\"\"\n    Object designator describing the object that should be closed\n    \"\"\"\n    arm: Arms\n    \"\"\"\n    Arm that should be used for closing\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMCloseAction)\n\n    @with_tree\n    def perform(self) -> None:\n        GraspingActionPerformable(self.arm, self.object_designator).perform()\n        ClosingMotion(self.object_designator, self.arm).perform()\n\n        MoveGripperMotion(GripperState.OPEN, self.arm, allow_gripper_collision=True).perform()\n\n\n@dataclass\nclass GraspingActionPerformable(ActionAbstract):\n    \"\"\"\n    Grasps an object described by the given Object Designator description\n    \"\"\"\n    arm: Arms\n    \"\"\"\n    The arm that should be used to grasp\n    \"\"\"\n    object_desig: Union[ObjectDesignatorDescription.Object, ObjectPart.Object]\n    \"\"\"\n    Object Designator for the object that should be grasped\n    \"\"\"\n    orm_class: Type[ActionAbstract] = field(init=False, default=ORMGraspingAction)\n\n    @with_tree\n    def perform(self) -> None:\n        if isinstance(self.object_desig, ObjectPart.Object):\n            object_pose = self.object_desig.part_pose\n        else:\n            object_pose = self.object_desig.world_object.get_pose()\n        lt = LocalTransformer()\n        gripper_name = RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame()\n\n        object_pose_in_gripper = lt.transform_pose(object_pose,\n                                                   World.robot.get_link_tf_frame(gripper_name))\n\n        pre_grasp = object_pose_in_gripper.copy()\n        pre_grasp.pose.position.x -= 0.1\n\n        MoveTCPMotion(pre_grasp, self.arm).perform()\n        MoveGripperMotion(GripperState.OPEN, self.arm).perform()\n\n        MoveTCPMotion(object_pose, self.arm, allow_gripper_collision=True).perform()\n        MoveGripperMotion(GripperState.CLOSE, self.arm, allow_gripper_collision=True).perform()\n\n\n@dataclass\nclass FaceAtPerformable(ActionAbstract):\n    \"\"\"\n    Turn the robot chassis such that is faces the ``pose`` and after that perform a look at action.\n    \"\"\"\n\n    pose: Pose\n    \"\"\"\n    The pose to face \n    \"\"\"\n\n    orm_class = ORMFaceAtAction\n\n    @with_tree\n    def perform(self) -> None:\n        # get the robot position\n        robot_position = World.robot.pose\n\n        # calculate orientation for robot to face the object\n        angle = np.arctan2(robot_position.position.y - self.pose.position.y,\n                           robot_position.position.x - self.pose.position.x) + np.pi\n        orientation = list(transformations.quaternion_from_euler(0, 0, angle, axes=\"sxyz\"))\n\n        # create new robot pose\n        new_robot_pose = Pose(robot_position.position_as_list(), orientation)\n\n        # turn robot\n        NavigateActionPerformable(new_robot_pose).perform()\n\n        # look at target\n        LookAtActionPerformable(self.pose).perform()\n\n\n@dataclass\nclass MoveAndPickUpPerformable(ActionAbstract):\n    \"\"\"\n    Navigate to `standing_position`, then turn towards the object and pick it up.\n    \"\"\"\n\n    standing_position: Pose\n    \"\"\"\n    The pose to stand before trying to pick up the object\n    \"\"\"\n\n    object_designator: ObjectDesignatorDescription.Object\n    \"\"\"\n    The object to pick up\n    \"\"\"\n\n    arm: Arms\n    \"\"\"\n    The arm to use\n    \"\"\"\n\n    grasp: Grasp\n    \"\"\"\n    The grasp to use\n    \"\"\"\n\n    def perform(self):\n        NavigateActionPerformable(self.standing_position).perform()\n        FaceAtPerformable(self.object_designator.pose).perform()\n        PickUpActionPerformable(self.object_designator, self.arm, self.grasp).perform()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the location_designator.py file and how do they contribute to the overall functionality of the project?"}, {"role": "assistant", "content": "# Content from: #<location_designator.py>#\nimport dataclasses\nimport time\n\nfrom typing_extensions import List, Union, Iterable, Optional, Callable\n\nfrom .object_designator import ObjectDesignatorDescription, ObjectPart\nfrom ..datastructures.world import World, UseProspectionWorld\nfrom ..local_transformer import LocalTransformer\nfrom ..world_reasoning import link_pose_for_joint_config\nfrom ..designator import DesignatorError, LocationDesignatorDescription\nfrom ..costmaps import OccupancyCostmap, VisibilityCostmap, SemanticCostmap, GaussianCostmap\nfrom ..datastructures.enums import JointType, Arms\nfrom ..pose_generator_and_validator import PoseGenerator, visibility_validator, reachability_validator\nfrom ..robot_description import RobotDescription\nfrom ..datastructures.pose import Pose\n\n\nclass Location(LocationDesignatorDescription):\n    \"\"\"\n    Default location designator which only wraps a pose.\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Location(LocationDesignatorDescription.Location):\n        pass\n\n    def __init__(self, pose: Pose, resolver=None):\n        \"\"\"\n        Basic location designator that represents a single pose.\n\n        :param pose: The pose that should be represented by this location designator\n        :param resolver: An alternative specialized_designators that returns a resolved location\n        \"\"\"\n        super().__init__(resolver)\n        self.pose: Pose = pose\n\n    def ground(self) -> Location:\n        \"\"\"\n        Default specialized_designators which returns a resolved designator which contains the pose given in init.\n\n        :return: A resolved designator\n        \"\"\"\n        return self.Location(self.pose)\n\n\n# TODO Maybe delete this\nclass ObjectRelativeLocation(LocationDesignatorDescription):\n    \"\"\"\n    Location relative to an object\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Location(LocationDesignatorDescription.Location):\n        relative_pose: Pose\n        \"\"\"\n        Pose relative to the object\n        \"\"\"\n        reference_object: ObjectDesignatorDescription.Object\n        \"\"\"\n        Object to which the pose is relative\n        \"\"\"\n\n    def __init__(self, relative_pose: Pose = None, reference_object: ObjectDesignatorDescription = None,\n                 resolver=None):\n        \"\"\"\n        Location designator representing a location relative to a given object.\n\n        :param relative_pose: Pose that should be relative, in world coordinate frame\n        :param reference_object: Object to which the pose should be relative\n        :param resolver: An alternative specialized_designators that returns a resolved location for the input parameter\n        \"\"\"\n        super().__init__(resolver)\n        self.relative_pose: Pose = relative_pose\n        self.reference_object: ObjectDesignatorDescription = reference_object\n\n    def ground(self) -> Location:\n        \"\"\"\n        Default specialized_designators which returns a resolved location for description input. Resolved location is the first result\n        of the iteration of this instance.\n\n        :return: A resolved location\n        \"\"\"\n        return next(iter(self))\n\n    def __iter__(self) -> Iterable[Location]:\n        \"\"\"\n        Iterates over all possible solutions for a resolved location that is relative to the given object.\n\n        :yield: An instance of ObjectRelativeLocation.Location with the relative pose\n        \"\"\"\n        if self.relative_pose is None or self.reference_object is None:\n            raise DesignatorError(\n                \"Could not ground ObjectRelativeLocation: (Relative) pose and reference object must be given\")\n        # Fetch the object pose and yield the grounded description\n        obj_grounded = self.reference_object.resolve()\n\n        lt = LocalTransformer()\n        pose = lt.transform_to_object_frame(self.relative_pose, obj_grounded)\n\n        yield self.Location(self.relative_pose, pose, self.reference_object)\n\n\nclass CostmapLocation(LocationDesignatorDescription):\n    \"\"\"\n    Uses Costmaps to create locations for complex constrains\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Location(LocationDesignatorDescription.Location):\n        reachable_arms: List[Arms]\n        \"\"\"\n        List of arms with which the pose can be reached, is only used when the 'rechable_for' parameter is used\n        \"\"\"\n\n    def __init__(self, target: Union[Pose, ObjectDesignatorDescription.Object],\n                 reachable_for: Optional[ObjectDesignatorDescription.Object] = None,\n                 visible_for: Optional[ObjectDesignatorDescription.Object] = None,\n                 reachable_arm: Optional[Arms] = None, resolver: Optional[Callable] = None):\n        \"\"\"\n        Location designator that uses costmaps as base to calculate locations for complex constrains like reachable or\n        visible. In case of reachable the resolved location contains a list of arms with which the location is reachable.\n\n        :param target: Location for which visibility or reachability should be calculated\n        :param reachable_for: Object for which the reachability should be calculated, usually a robot\n        :param visible_for: Object for which the visibility should be calculated, usually a robot\n        :param reachable_arm: An optional arm with which the target should be reached\n        :param resolver: An alternative specialized_designators that returns a resolved location for the given input of this description\n        \"\"\"\n        super().__init__(resolver)\n        self.target: Union[Pose, ObjectDesignatorDescription.Object] = target\n        self.reachable_for: ObjectDesignatorDescription.Object = reachable_for\n        self.visible_for: ObjectDesignatorDescription.Object = visible_for\n        self.reachable_arm: Optional[Arms] = reachable_arm\n\n    def ground(self) -> Location:\n        \"\"\"\n        Default specialized_designators which returns the first result from the iterator of this instance.\n\n        :return: A resolved location\n        \"\"\"\n        return next(iter(self))\n\n    def __iter__(self):\n        \"\"\"\n           Generates positions for a given set of constrains from a costmap and returns\n           them. The generation is based of a costmap which itself is the product of\n           merging costmaps, each for a different purpose. In any case an occupancy costmap\n           is used as the base, then according to the given constrains a visibility or\n           gaussian costmap is also merged with this. Once the costmaps are merged,\n           a generator generates pose candidates from the costmap. Each pose candidate\n           is then validated against the constraints given by the designator if all validators\n           pass the pose is considered valid and yielded.\n\n           :yield: An instance of CostmapLocation.Location with a valid position that satisfies the given constraints\n           \"\"\"\n        min_height = RobotDescription.current_robot_description.get_default_camera().minimal_height\n        max_height = RobotDescription.current_robot_description.get_default_camera().maximal_height\n        # This ensures that the costmaps always get a position as their origin.\n        if isinstance(self.target, ObjectDesignatorDescription.Object):\n            target_pose = self.target.world_object.get_pose()\n        else:\n            target_pose = self.target.copy()\n\n        # ground_pose = [[target_pose[0][0], target_pose[0][1], 0], target_pose[1]]\n        ground_pose = Pose(target_pose.position_as_list())\n        ground_pose.position.z = 0\n\n        occupancy = OccupancyCostmap(0.32, False, 200, 0.02, ground_pose)\n        final_map = occupancy\n\n        if self.reachable_for:\n            gaussian = GaussianCostmap(200, 15, 0.02, ground_pose)\n            final_map += gaussian\n        if self.visible_for:\n            visible = VisibilityCostmap(min_height, max_height, 200, 0.02, Pose(target_pose.position_as_list()))\n            final_map += visible\n\n        if self.visible_for or self.reachable_for:\n            robot_object = self.visible_for.world_object if self.visible_for else self.reachable_for.world_object\n            test_robot = World.current_world.get_prospection_object_for_object(robot_object)\n        with UseProspectionWorld():\n            for maybe_pose in PoseGenerator(final_map, number_of_samples=600):\n                res = True\n                arms = None\n                if self.visible_for:\n                    res = res and visibility_validator(maybe_pose, test_robot, target_pose,\n                                                       World.current_world)\n                if self.reachable_for:\n                    hand_links = []\n                    for description in RobotDescription.current_robot_description.get_manipulator_chains():\n                        hand_links += description.end_effector.links\n                    valid, arms = reachability_validator(maybe_pose, test_robot, target_pose,\n                                                         allowed_collision={test_robot: hand_links})\n                    if self.reachable_arm:\n                        res = res and valid and self.reachable_arm in arms\n                    else:\n                        res = res and valid\n                if res:\n                    yield self.Location(maybe_pose, arms)\n\n\nclass AccessingLocation(LocationDesignatorDescription):\n    \"\"\"\n    Location designator which describes poses used for opening drawers\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Location(LocationDesignatorDescription.Location):\n        arms: List[Arms]\n        \"\"\"\n        List of arms that can be used to for accessing from this pose\n        \"\"\"\n\n    def __init__(self, handle_desig: ObjectPart.Object, robot_desig: ObjectDesignatorDescription.Object, resolver=None):\n        \"\"\"\n        Describes a position from where a drawer can be opened. For now this position should be calculated before the\n        drawer will be opened. Calculating the pose while the drawer is open could lead to problems.\n\n        :param handle_desig: ObjectPart designator for handle of the drawer\n        :param robot: Object designator for the robot which should open the drawer\n        :param resolver: An alternative specialized_designators to create the location\n        \"\"\"\n        super().__init__(resolver)\n        self.handle: ObjectPart.Object = handle_desig\n        self.robot: ObjectDesignatorDescription.Object = robot_desig.world_object\n\n    def ground(self) -> Location:\n        \"\"\"\n        Default specialized_designators for this location designator, just returns the first element from the iteration\n\n        :return: A location designator for a pose from which the drawer can be opened\n        \"\"\"\n        return next(iter(self))\n\n    def __iter__(self) -> Location:\n        \"\"\"\n        Creates poses from which the robot can open the drawer specified by the ObjectPart designator describing the\n        handle. Poses are validated by checking if the robot can grasp the handle while the drawer is closed and if\n        the handle can be grasped if the drawer is open.\n\n        :yield: A location designator containing the pose and the arms that can be used.\n        \"\"\"\n        # ground_pose = [[self.handle.part_pose[0][0], self.handle.part_pose[0][1], 0], self.handle.part_pose[1]]\n        ground_pose = Pose(self.handle.part_pose.position_as_list())\n        ground_pose.position.z = 0\n        occupancy = OccupancyCostmap(distance_to_obstacle=0.4, from_ros=False, size=200, resolution=0.02,\n                                     origin=ground_pose)\n        gaussian = GaussianCostmap(200, 15, 0.02, ground_pose)\n\n        final_map = occupancy + gaussian\n\n\n        test_robot = World.current_world.get_prospection_object_for_object(self.robot)\n\n        # Find a Joint of type prismatic which is above the handle in the URDF tree\n        container_joint = self.handle.world_object.find_joint_above_link(self.handle.name, JointType.PRISMATIC)\n\n        init_pose = link_pose_for_joint_config(self.handle.world_object, {\n            container_joint: self.handle.world_object.get_joint_limits(container_joint)[0]},\n                                               self.handle.name)\n\n        # Calculate the pose the handle would be in if the drawer was to be fully opened\n        goal_pose = link_pose_for_joint_config(self.handle.world_object, {\n            container_joint: self.handle.world_object.get_joint_limits(container_joint)[1] - 0.05},\n                                               self.handle.name)\n\n        # Handle position for calculating rotation of the final pose\n        half_pose = link_pose_for_joint_config(self.handle.world_object, {\n            container_joint: self.handle.world_object.get_joint_limits(container_joint)[1] / 1.5},\n                                               self.handle.name)\n\n        with UseProspectionWorld():\n            for maybe_pose in PoseGenerator(final_map, number_of_samples=600,\n                                             orientation_generator=lambda p, o: PoseGenerator.generate_orientation(p, half_pose)):\n\n                hand_links = []\n                for description in RobotDescription.current_robot_description.get_manipulator_chains():\n                    hand_links += description.links\n\n                valid_init, arms_init = reachability_validator(maybe_pose, test_robot, init_pose,\n                                                               allowed_collision={test_robot: hand_links})\n\n                valid_goal, arms_goal = reachability_validator(maybe_pose, test_robot, goal_pose,\n                                                               allowed_collision={test_robot: hand_links})\n\n                if valid_init and valid_goal:\n                    yield self.Location(maybe_pose, list(set(arms_init).intersection(set(arms_goal))))\n\n\nclass SemanticCostmapLocation(LocationDesignatorDescription):\n    \"\"\"\n    Locations over semantic entities, like a table surface\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Location(LocationDesignatorDescription.Location):\n        pass\n\n    def __init__(self, urdf_link_name, part_of, for_object=None, resolver=None):\n        \"\"\"\n        Creates a distribution over a urdf link to sample poses which are on this link. Can be used, for example, to find\n        poses that are on a table. Optionally an object can be given for which poses should be calculated, in that case\n        the poses are calculated such that the bottom of the object is on the link.\n\n        :param urdf_link_name: Name of the urdf link for which a distribution should be calculated\n        :param part_of: Object of which the urdf link is a part\n        :param for_object: Optional object that should be placed at the found location\n        :param resolver: An alternative specialized_designators that creates a resolved location for the input parameter of this description\n        \"\"\"\n        super().__init__(resolver)\n        self.urdf_link_name: str = urdf_link_name\n        self.part_of: ObjectDesignatorDescription.Object = part_of\n        self.for_object: Optional[ObjectDesignatorDescription.Object] = for_object\n\n    def ground(self) -> Location:\n        \"\"\"\n        Default specialized_designators which returns the first element of the iterator of this instance.\n\n        :return: A resolved location\n        \"\"\"\n        return next(iter(self))\n\n    def __iter__(self):\n        \"\"\"\n        Creates a costmap on top of a link of an Object and creates positions from it. If there is a specific Object for\n        which the position should be found, a height offset will be calculated which ensures that the bottom of the Object\n        is at the position in the Costmap and not the origin of the Object which is usually in the centre of the Object.\n\n        :yield: An instance of SemanticCostmapLocation.Location with the found valid position of the Costmap.\n        \"\"\"\n        sem_costmap = SemanticCostmap(self.part_of.world_object, self.urdf_link_name)\n        height_offset = 0\n        if self.for_object:\n            min_p, max_p = self.for_object.world_object.get_axis_aligned_bounding_box().get_min_max_points()\n            height_offset = (max_p.z - min_p.z) / 2\n        for maybe_pose in PoseGenerator(sem_costmap):\n            maybe_pose.position.z += height_offset\n            yield self.Location(maybe_pose)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the motion_designator.py file and how do they contribute to motion planning?"}, {"role": "assistant", "content": "# Content from: #<motion_designator.py>#\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\nfrom sqlalchemy.orm import Session\nfrom .object_designator import ObjectDesignatorDescription, ObjectPart, RealObject\nfrom ..designator import ResolutionError\nfrom ..orm.base import ProcessMetaData\nfrom ..plan_failures import PerceptionObjectNotFound\nfrom ..process_module import ProcessModuleManager\nfrom ..orm.motion_designator import (MoveMotion as ORMMoveMotion,\n                                     MoveTCPMotion as ORMMoveTCPMotion, LookingMotion as ORMLookingMotion,\n                                     MoveGripperMotion as ORMMoveGripperMotion, DetectingMotion as ORMDetectingMotion,\n                                     OpeningMotion as ORMOpeningMotion, ClosingMotion as ORMClosingMotion,\n                                     Motion as ORMMotionDesignator)\nfrom ..datastructures.enums import ObjectType, Arms, GripperState, ExecutionType\n\nfrom typing_extensions import Dict, Optional, get_type_hints\nfrom ..datastructures.pose import Pose\nfrom ..tasktree import with_tree\nfrom ..designator import BaseMotion\n\n\n@dataclass\nclass MoveMotion(BaseMotion):\n    \"\"\"\n    Moves the robot to a designated location\n    \"\"\"\n\n    target: Pose\n    \"\"\"\n    Location to which the robot should be moved\n    \"\"\"\n\n    @with_tree\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.navigate().execute(self)\n        # return ProcessModule.perform(self)\n\n    def to_sql(self) -> ORMMoveMotion:\n        return ORMMoveMotion()\n\n    def insert(self, session, *args, **kwargs) -> ORMMoveMotion:\n        motion = super().insert(session)\n        pose = self.target.insert(session)\n        motion.pose = pose\n        session.add(motion)\n\n        return motion\n\n\n@dataclass\nclass MoveTCPMotion(BaseMotion):\n    \"\"\"\n    Moves the Tool center point (TCP) of the robot\n    \"\"\"\n\n    target: Pose\n    \"\"\"\n    Target pose to which the TCP should be moved\n    \"\"\"\n    arm: Arms\n    \"\"\"\n    Arm with the TCP that should be moved to the target\n    \"\"\"\n    allow_gripper_collision: Optional[bool] = None\n    \"\"\"\n    If the gripper can collide with something\n    \"\"\"\n\n    @with_tree\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.move_tcp().execute(self)\n\n    def to_sql(self) -> ORMMoveTCPMotion:\n        return ORMMoveTCPMotion(self.arm, self.allow_gripper_collision)\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMMoveTCPMotion:\n        motion = super().insert(session)\n        pose = self.target.insert(session)\n        motion.pose = pose\n        session.add(motion)\n\n        return motion\n\n\n@dataclass\nclass LookingMotion(BaseMotion):\n    \"\"\"\n    Lets the robot look at a point\n    \"\"\"\n    target: Pose\n\n    @with_tree\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.looking().execute(self)\n\n    def to_sql(self) -> ORMLookingMotion:\n        return ORMLookingMotion()\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMLookingMotion:\n        motion = super().insert(session)\n        pose = self.target.insert(session)\n        motion.pose = pose\n        session.add(motion)\n\n        return motion\n\n\n@dataclass\nclass MoveGripperMotion(BaseMotion):\n    \"\"\"\n    Opens or closes the gripper\n    \"\"\"\n\n    motion: GripperState\n    \"\"\"\n    Motion that should be performed, either 'open' or 'close'\n    \"\"\"\n    gripper: Arms\n    \"\"\"\n    Name of the gripper that should be moved\n    \"\"\"\n    allow_gripper_collision: Optional[bool] = None\n    \"\"\"\n    If the gripper is allowed to collide with something\n    \"\"\"\n\n    @with_tree\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.move_gripper().execute(self)\n\n    def to_sql(self) -> ORMMoveGripperMotion:\n        return ORMMoveGripperMotion(self.motion, self.gripper, self.allow_gripper_collision)\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMMoveGripperMotion:\n        motion = super().insert(session)\n        session.add(motion)\n\n        return motion\n\n\n@dataclass\nclass DetectingMotion(BaseMotion):\n    \"\"\"\n    Tries to detect an object in the FOV of the robot\n    \"\"\"\n\n    object_type: ObjectType\n    \"\"\"\n    Type of the object that should be detected\n    \"\"\"\n\n    @with_tree\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        world_object = pm_manager.detecting().execute(self)\n        if not world_object:\n            raise PerceptionObjectNotFound(\n                f\"Could not find an object with the type {self.object_type} in the FOV of the robot\")\n        if ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return RealObject.Object(world_object.name, world_object.obj_type,\n                                     world_object, world_object.get_pose())\n\n        return ObjectDesignatorDescription.Object(world_object.name, world_object.obj_type,\n                                                  world_object)\n\n    def to_sql(self) -> ORMDetectingMotion:\n        return ORMDetectingMotion(self.object_type)\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMDetectingMotion:\n        motion = super().insert(session)\n        session.add(motion)\n\n        return motion\n\n\n@dataclass\nclass MoveArmJointsMotion(BaseMotion):\n    \"\"\"\n    Moves the joints of each arm into the given position\n    \"\"\"\n\n    left_arm_poses: Optional[Dict[str, float]] = None\n    \"\"\"\n    Target positions for the left arm joints\n    \"\"\"\n    right_arm_poses: Optional[Dict[str, float]] = None\n    \"\"\"\n    Target positions for the right arm joints\n    \"\"\"\n\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.move_arm_joints().execute(self)\n\n    def to_sql(self) -> ORMMotionDesignator:\n        pass\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:\n        pass\n\n\n@dataclass\nclass WorldStateDetectingMotion(BaseMotion):\n    \"\"\"\n    Detects an object based on the world state.\n    \"\"\"\n\n    object_type: ObjectType\n    \"\"\"\n    Object type that should be detected\n    \"\"\"\n\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.world_state_detecting().execute(self)\n\n    def to_sql(self) -> ORMMotionDesignator:\n        pass\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:\n        pass\n\n\n@dataclass\nclass MoveJointsMotion(BaseMotion):\n    \"\"\"\n    Moves any joint on the robot\n    \"\"\"\n\n    names: list\n    \"\"\"\n    List of joint names that should be moved \n    \"\"\"\n    positions: list\n    \"\"\"\n    Target positions of joints, should correspond to the list of names\n    \"\"\"\n\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.move_joints().execute(self)\n\n    def to_sql(self) -> ORMMotionDesignator:\n        pass\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:\n        pass\n\n\n@dataclass\nclass OpeningMotion(BaseMotion):\n    \"\"\"\n    Designator for opening container\n    \"\"\"\n\n    object_part: ObjectPart.Object\n    \"\"\"\n    Object designator for the drawer handle\n    \"\"\"\n    arm: Arms\n    \"\"\"\n    Arm that should be used\n    \"\"\"\n\n    @with_tree\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.open().execute(self)\n\n    def to_sql(self) -> ORMOpeningMotion:\n        return ORMOpeningMotion(self.arm)\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMOpeningMotion:\n        motion = super().insert(session)\n        op = self.object_part.insert(session)\n        motion.object = op\n        session.add(motion)\n\n        return motion\n\n\n@dataclass\nclass ClosingMotion(BaseMotion):\n    \"\"\"\n    Designator for closing a container\n    \"\"\"\n\n    object_part: ObjectPart.Object\n    \"\"\"\n    Object designator for the drawer handle\n    \"\"\"\n    arm: Arms\n    \"\"\"\n    Arm that should be used\n    \"\"\"\n\n    @with_tree\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.close().execute(self)\n\n    def to_sql(self) -> ORMClosingMotion:\n        return ORMClosingMotion(self.arm)\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMClosingMotion:\n        motion = super().insert(session)\n        op = self.object_part.insert(session)\n        motion.object = op\n        session.add(motion)\n\n        return motion\n\n\n@dataclass\nclass TalkingMotion(BaseMotion):\n    \"\"\"\n    Talking Motion, lets the robot say a sentence.\n    \"\"\"\n\n    cmd: str\n    \"\"\"\n    Talking Motion, let the robot say a sentence.\n    \"\"\"\n\n    @with_tree\n    def perform(self):\n        pm_manager = ProcessModuleManager.get_manager()\n        return pm_manager.talk().execute(self)\n\n    def to_sql(self) -> ORMMotionDesignator:\n        pass\n\n    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:\n        pass\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the object_designator.py file and how do they interact with other components in the system?"}, {"role": "assistant", "content": "# Content from: #<object_designator.py>#\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing_extensions import List, Optional, Callable, TYPE_CHECKING\nimport sqlalchemy.orm\nfrom ..datastructures.world import World\nfrom ..world_concepts.world_object import Object as WorldObject\nfrom ..designator import ObjectDesignatorDescription\nfrom ..orm.base import ProcessMetaData\nfrom ..orm.object_designator import (BelieveObject as ORMBelieveObject, ObjectPart as ORMObjectPart)\nfrom ..datastructures.pose import Pose\nfrom ..external_interfaces.robokudo import *\n\nif TYPE_CHECKING:\n    import owlready2\n\n\nclass BelieveObject(ObjectDesignatorDescription):\n    \"\"\"\n    Description for Objects that are only believed in.\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Object(ObjectDesignatorDescription.Object):\n        \"\"\"\n        Concrete object that is believed in.\n        \"\"\"\n\n        def to_sql(self) -> ORMBelieveObject:\n            return ORMBelieveObject(self.obj_type, self.name)\n\n        def insert(self, session: sqlalchemy.orm.session.Session) -> ORMBelieveObject:\n            metadata = ProcessMetaData().insert(session)\n            self_ = self.to_sql()\n            self_.process_metadata = metadata\n            session.add(self_)\n\n            return self_\n\n\nclass ObjectPart(ObjectDesignatorDescription):\n    \"\"\"\n    Object Designator Descriptions for Objects that are part of some other object.\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Object(ObjectDesignatorDescription.Object):\n\n        # The rest of attributes is inherited\n        part_pose: Pose\n\n        def to_sql(self) -> ORMObjectPart:\n            return ORMObjectPart(self.obj_type, self.name)\n\n        def insert(self, session: sqlalchemy.orm.session.Session) -> ORMObjectPart:\n            metadata = ProcessMetaData().insert(session)\n            pose = self.part_pose.insert(session)\n            obj = self.to_sql()\n            obj.process_metadata = metadata\n            obj.pose = pose\n            session.add(obj)\n\n            return obj\n\n    def __init__(self, names: List[str],\n                 part_of: ObjectDesignatorDescription.Object,\n                 type: Optional[str] = None,\n                 resolver: Optional[Callable] = None):\n        \"\"\"\n        Describing the relationship between an object and a specific part of it.\n\n        :param names: Possible names for the part\n        :param part_of: Parent object of which the part should be described\n        :param type: Type of the part\n        :param resolver: An alternative specialized_designators to resolve the input parameter to an object designator\n        :param ontology_concept_holders: A list of ontology concepts that the object part is categorized as or associated with\n        \"\"\"\n        super().__init__(names, type, resolver)\n\n        if not part_of:\n            raise AttributeError(\"part_of cannot be None.\")\n\n        self.type: Optional[str] = type\n        self.names: Optional[List[str]] = names\n        self.part_of = part_of\n\n    def ground(self) -> Object:\n        \"\"\"\n        Default specialized_designators, returns the first result of the iterator of this instance.\n\n        :return: A resolved object designator\n        \"\"\"\n        return next(iter(self))\n\n    def __iter__(self):\n        \"\"\"\n        Iterates through every possible solution for the given input parameter.\n\n        :yield: A resolved Object designator\n        \"\"\"\n        for name in self.names:\n            if name in self.part_of.world_object.link_name_to_id.keys():\n                yield self.Object(name, self.type, self.part_of.world_object,\n                                  self.part_of.world_object.get_link_pose(name))\n\n\nclass LocatedObject(ObjectDesignatorDescription):\n    \"\"\"\n    Description for KnowRob located objects.\n    **Currently has no specialized_designators**\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Object(ObjectDesignatorDescription.Object):\n        reference_frame: str\n        \"\"\"\n        Reference frame in which the position is given\n        \"\"\"\n        timestamp: float\n        \"\"\"\n        Timestamp at which the position was valid\n        \"\"\"\n\n    def __init__(self, names: List[str], types: List[str],\n                 reference_frames: List[str], timestamps: List[float], resolver: Optional[Callable] = None,\n                 ontology_concept_holders: Optional[List[owlready2.Thing]] = None):\n        \"\"\"\n        Describing an object resolved through knowrob.\n\n        :param names: List of possible names describing the object\n        :param types: List of possible types describing the object\n        :param reference_frames: Frame of reference in which the object position should be\n        :param timestamps: Timestamps for which positions should be returned\n        :param resolver: An alternative specialized_designators that resolves the input parameter to an object designator.\n        :param ontology_concept_holders: A list of ontology concepts that the object is categorized as\n        \"\"\"\n        super(LocatedObject, self).__init__(names, types, resolver, ontology_concept_holders)\n        self.reference_frames: List[str] = reference_frames\n        self.timestamps: List[float] = timestamps\n\n\n@DeprecationWarning\n# Depricated class this will be done differently\nclass RealObject(ObjectDesignatorDescription):\n    \"\"\"\n    Object designator representing an object in the real world, when resolving this object designator description ]\n    RoboKudo is queried to perceive an object fitting the given criteria. Afterward the specialized_designators tries to match\n    the found object to an Object in the World.\n    \"\"\"\n\n    @dataclasses.dataclass\n    class Object(ObjectDesignatorDescription.Object):\n        pose: Pose\n        \"\"\"\n        Pose of the perceived object\n        \"\"\"\n\n    def __init__(self, names: Optional[List[str]] = None, types: Optional[List[str]] = None,\n                 world_object: WorldObject = None, resolver: Optional[Callable] = None):\n        \"\"\"\n\n        :param names:\n        :param types:\n        :param world_object:\n        :param resolver:\n        \"\"\"\n        super().__init__(resolver)\n        self.types: Optional[List[str]] = types\n        self.names: Optional[List[str]] = names\n        self.world_object: WorldObject = world_object\n\n    def __iter__(self):\n        \"\"\"\n        Queries RoboKudo for objects that fit the description and then iterates over all World objects that have\n        the same type to match a World object to the real object.\n\n        :yield: A resolved object designator with reference world object\n        \"\"\"\n        object_candidates = query(self)\n        for obj_desig in object_candidates:\n            for world_obj in World.get_object_by_type(obj_desig.obj_type):\n                obj_desig.world_object = world_obj\n                yield obj_desig\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the dual_arm_pickup_action.py file and how do they work?"}, {"role": "assistant", "content": "# Content from: #<dual_arm_pickup_action.py>#\nimport rospy\nfrom typing_extensions import List, Union, Optional\nfrom numpy.linalg import norm\nfrom numpy import array\nfrom geometry_msgs.msg import Vector3\n\nfrom owlready2 import Thing\n\nfrom ...action_designator import PickUpAction, PickUpActionPerformable\nfrom ....local_transformer import LocalTransformer\nfrom ....datastructures.world import World\nfrom ....datastructures.pose import Pose, Transform\nfrom ....datastructures.enums import Arms, Grasp\nfrom ....robot_description import RobotDescription, KinematicChainDescription\nfrom ....designator import ObjectDesignatorDescription\n\n\nclass DualArmPickupAction(PickUpAction):\n    \"\"\"\n    Specialization version of the PickUpAction designator which uses heuristics to solve for a dual pickup solution.\n    \"\"\"\n\n    def __init__(self,\n                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],\n                 grasps: List[Grasp], resolver=None,\n                 ontology_concept_holders: Optional[List[Thing]] = None):\n        \"\"\"\n        Specialized version of the PickUpAction designator which uses heuristics to solve for a dual pickup problem. The\n        designator will choose the arm which is closest to the object that is to be picked up.\n\n        :param object_designator_description: List of object designator which should be picked up\n        :param grasps: List of possible grasps which should be used for the pickup\n        :param resolver: Optional specialized_designators that returns a performable designator with elements from the\n                         lists of possible parameter\n        :param ontology_concept_holders: List of ontology concepts that the action is categorized as or associated with\n        \"\"\"\n        super().__init__(object_designator_description,\n                         arms=[Arms.LEFT, Arms.RIGHT],\n                         grasps=grasps,\n                         resolver=resolver,\n                         ontology_concept_holders=ontology_concept_holders)\n\n        self.object_designator_description: Union[\n            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description\n\n        left_gripper = RobotDescription.current_robot_description.get_arm_chain(Arms.LEFT)\n        right_gripper = RobotDescription.current_robot_description.get_arm_chain(Arms.RIGHT)\n        self.gripper_list: List[KinematicChainDescription] = [left_gripper, right_gripper]\n\n\n    def ground(self) -> PickUpActionPerformable:\n        if isinstance(self.object_designator_description, ObjectDesignatorDescription.Object):\n            obj_desig = self.object_designator_description\n        else:\n            obj_desig = self.object_designator_description.resolve()\n\n        rospy.loginfo(\"Calculating closest gripper to object {}\".format(obj_desig.name))\n\n        local_transformer = LocalTransformer()\n\n        object_pose: Pose = obj_desig.world_object.pose\n        distances = []\n        # Iterate over possible grippers\n        for gripper in self.gripper_list:\n            # Object pose in gripper frame\n            gripper_frame = World.robot.get_link_tf_frame(gripper.get_tool_frame())\n\n            object_T_gripper: Pose = local_transformer.transform_pose(object_pose, gripper_frame)\n            object_V_gripper: Vector3 = object_T_gripper.pose.position  # translation vector\n            distance = norm(array([object_V_gripper.x, object_V_gripper.y, object_V_gripper.z]))\n            rospy.loginfo(f\"Distance between {gripper} and {obj_desig.name}: {distance}\")\n            distances.append(distance)\n\n        min_index = distances.index(min(distances))\n        winner = self.gripper_list[min_index]\n        rospy.loginfo(f\"Winner is {winner.arm_type.name} with distance {min(distances):.2f}\")\n\n        return PickUpActionPerformable(object_designator=obj_desig, arm=winner.arm_type, grasp=self.grasps[0])\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the database_location.py file?"}, {"role": "assistant", "content": "# Content from: #<database_location.py>#\nfrom dataclasses import dataclass\n\nimport sqlalchemy.orm\nimport sqlalchemy.sql\nfrom sqlalchemy import select, Select\nfrom typing_extensions import List, Type\nfrom ....costmaps import Rectangle, OccupancyCostmap\nfrom ....designator import LocationDesignatorDescription\nfrom ....designators.location_designator import CostmapLocation\nfrom ....orm.views import PickUpWithContextView\nfrom ....datastructures.pose import Pose\n\n\n@dataclass\nclass Location(LocationDesignatorDescription.Location):\n    \"\"\"\n    A location that is described by a pose, a reachable arm, a torso height and a grasp.\n    \"\"\"\n    pose: Pose\n    reachable_arm: str\n    torso_height: float\n    grasp: str\n\n\nclass AbstractCostmapLocation(CostmapLocation):\n    \"\"\"\n    Abstract Class for JPT and Database costmaps.\n    \"\"\"\n\n    def __init__(self, target, reachable_for=None, reachable_arm=None):\n        \"\"\"\n        Create a new AbstractCostmapLocation instance.\n        :param target: The target object\n        :param reachable_for:\n        :param reachable_arm:\n        \"\"\"\n        super().__init__(target, reachable_for, None, reachable_arm, None)\n\n    def create_occupancy_rectangles(self) -> List[Rectangle]:\n        \"\"\"\n        :return: A list of rectangles that represent the occupied space of the target object.\n        \"\"\"\n        # create Occupancy costmap for the target object\n        ocm = OccupancyCostmap(distance_to_obstacle=0.3, from_ros=False, size=200, resolution=0.02,\n                               origin=self.target.pose)\n        return ocm.partitioning_rectangles()\n\n\nclass DatabaseCostmapLocation(AbstractCostmapLocation):\n    \"\"\"\n    Class that represents costmap locations from a given Database.\n    The database has to have a schema that is compatible with the pycram.orm package.\n    \"\"\"\n\n    def __init__(self, target, session: sqlalchemy.orm.Session = None, reachable_for=None, reachable_arm=None):\n        \"\"\"\n        Create a Database Costmap\n\n        :param target: The target object\n        :param session: A session that can be used to execute queries\n        :param reachable_for: The robot to grab the object with\n        :param reachable_arm: The arm to use\n\n        \"\"\"\n        super().__init__(target, reachable_for, reachable_arm)\n        self.session = session\n\n    @staticmethod\n    def select_statement(view: Type[PickUpWithContextView]) -> Select:\n        return (select(view.arm, view.grasp, view.torso_height, view.relative_x, view.relative_y, view.quaternion_x,\n                       view.quaternion_y, view.quaternion_z, view.quaternion_w).distinct())\n\n    def create_query_from_occupancy_costmap(self) -> Select:\n        \"\"\"\n        Create a query that queries all relative robot positions from an object that are not occluded using an\n        OccupancyCostmap.\n        \"\"\"\n\n        view = PickUpWithContextView\n\n        # get query\n        query = self.select_statement(view)\n\n        # constraint query to correct object type and successful task status\n        query = query.where(view.obj_type == self.target.obj_type).where(view.status == \"SUCCEEDED\")\n\n        filters = []\n\n        # for every rectangle\n        for rectangle in self.create_occupancy_rectangles():\n            # add sql filter\n            filters.append(sqlalchemy.and_(view.relative_x >= rectangle.x_lower,\n                                           view.relative_x < rectangle.x_upper,\n                                           view.relative_y >= rectangle.y_lower,\n                                           view.relative_y < rectangle.y_upper))\n\n        return query.where(sqlalchemy.or_(*filters))\n\n    def sample_to_location(self, sample: sqlalchemy.engine.row.Row) -> Location:\n        \"\"\"\n        Convert a database row to a costmap location.\n\n        :param sample: The database row.\n        :return: The costmap location\n        \"\"\"\n\n        target_x, target_y, target_z = self.target.pose.position_as_list()\n        position = [target_x + sample[3], target_y + sample[4], 0]\n        orientation = [sample[5], sample[6], sample[7], sample[8]]\n\n        result = Location(Pose(position, orientation), sample.arm, sample.torso_height, sample.grasp)\n        return result\n\n    def __iter__(self) -> Location:\n        statement = self.create_query_from_occupancy_costmap().limit(200)\n        samples = self.session.execute(statement).all()\n        if samples:\n            for sample in samples:\n                yield self.sample_to_location(sample)\n        else:\n            raise ValueError(\"No samples found\")\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the giskard_location.py file and how do they interact with the rest of the Giskard framework?"}, {"role": "assistant", "content": "# Content from: #<giskard_location.py>#\nimport tf\n\nfrom ....datastructures.pose import Pose\nfrom ....designators.location_designator import CostmapLocation\nfrom ....external_interfaces.giskard import projection_cartesian_goal_with_approach, projection_joint_goal\nfrom ....robot_description import RobotDescription\nfrom ....datastructures.world import UseProspectionWorld, World\nfrom ....local_transformer import LocalTransformer\nfrom ....costmaps import OccupancyCostmap, GaussianCostmap\nfrom ....pose_generator_and_validator import PoseGenerator\n\n\nclass GiskardLocation(CostmapLocation):\n    \"\"\"'\n    Specialization version of the CostmapLocation which uses Giskard to solve for a full-body IK solution. This\n    designator is especially useful for robots which lack a degree of freedom and therefore need to use the base to\n    manipulate the environment effectively.\n    \"\"\"\n\n    def __iter__(self) -> CostmapLocation.Location:\n        \"\"\"\n        Uses Giskard to perform full body ik solving to get the pose of a robot at which it is able to reach a certain point.\n\n        :yield: An instance of CostmapLocation.Location with a pose from which the robot can reach the target\n        \"\"\"\n        if self.visible_for:\n            raise ValueError(\"GiskardLocation does not support the visible_for parameter\")\n        local_transformer = LocalTransformer()\n        target_map = local_transformer.transform_pose(self.target, \"map\")\n\n        manipulator_descs = RobotDescription.current_robot_description.get_manipulator_chains()\n\n        near_costmap = (OccupancyCostmap(0.35, False, 200, 0.02, target_map)\n                        + GaussianCostmap(200, 15, 0.02, target_map))\n        for maybe_pose in PoseGenerator(near_costmap, 200):\n            for chain in manipulator_descs:\n                projection_joint_goal(chain.get_static_joint_states(\"park\"), allow_collisions=True)\n\n                trajectory = projection_cartesian_goal_with_approach(maybe_pose, target_map, chain.tool_frame,\n                                                                     \"map\", RobotDescription.current_robot_description.base_link)\n                last_point_positions = trajectory.trajectory.points[-1].positions\n                last_point_names = trajectory.trajectory.joint_names\n                last_joint_states = dict(zip(last_point_names, last_point_positions))\n                orientation = list(\n                    tf.transformations.quaternion_from_euler(0, 0, last_joint_states[\"brumbrum_yaw\"], axes=\"sxyz\"))\n                pose = Pose([last_joint_states[\"brumbrum_x\"], last_joint_states[\"brumbrum_y\"], 0], orientation)\n\n                robot_joint_states = {}\n                for joint_name, state in last_joint_states.items():\n                    if joint_name in World.robot.joints.keys():\n                        robot_joint_states[joint_name] = state\n\n                prospection_robot = World.current_world.get_prospection_object_for_object(World.robot)\n\n                with UseProspectionWorld():\n                    prospection_robot.set_joint_positions(robot_joint_states)\n                    prospection_robot.set_pose(pose)\n                    gripper_pose = prospection_robot.get_link_pose(chain.get_tool_frame())\n\n                    if gripper_pose.dist(target_map) <= 0.02:\n                        yield CostmapLocation.Location(pose, [chain.arm_type])\n\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the key functions implemented in the probabilistic_action.py file?"}, {"role": "assistant", "content": "# Content from: #<probabilistic_action.py>#\nimport numpy as np\nimport tqdm\nfrom probabilistic_model.probabilistic_circuit.distributions import GaussianDistribution, SymbolicDistribution\nfrom probabilistic_model.probabilistic_circuit.probabilistic_circuit import ProbabilisticCircuit, \\\n    DecomposableProductUnit\nfrom probabilistic_model.utils import MissingDict\nfrom random_events.interval import *\nfrom random_events.product_algebra import Event, SimpleEvent\nfrom random_events.set import SetElement\nfrom random_events.variable import Symbolic, Continuous\nfrom sqlalchemy import select\nfrom typing_extensions import Optional, List, Iterator\n\nfrom ...action_designator import MoveAndPickUpPerformable, ActionAbstract\nfrom ....costmaps import OccupancyCostmap, VisibilityCostmap\nfrom ....datastructures.enums import Arms as EArms, Grasp as EGrasp, TaskStatus\nfrom ....datastructures.pose import Pose\nfrom ....datastructures.world import World\nfrom ....designator import ActionDesignatorDescription, ObjectDesignatorDescription\nfrom ....local_transformer import LocalTransformer\nfrom ....orm.views import PickUpWithContextView\nfrom ....plan_failures import ObjectUnreachable, PlanFailure\n\n\nclass Grasp(SetElement):\n    EMPTY_SET = -1\n    FRONT = 0\n    LEFT = 1\n    RIGHT = 2\n    TOP = 3\n\n\nclass Arms(SetElement):\n    EMPTY_SET = -1\n    LEFT = 0\n    RIGHT = 1\n\n\nclass ProbabilisticAction:\n    \"\"\"\n    Abstract class for probabilistic performables.\n    \"\"\"\n\n    @dataclass\n    class Variables:\n        \"\"\"\n        Variables for probabilistic performables.\n\n        This inner class serves the purpose to define the variables that are used in a model and make them easily\n        accessible for the user. The user can access the variables by using the dot notation, e.g. `self.variables.x`.\n\n        The members of this class have to be ordered the same way as the variables in the policy.\n        The order of the variables in the policy is most likely alphabetical by name.\n        \"\"\"\n        ...\n\n    policy: ProbabilisticCircuit\n    \"\"\"\n    The policy that is used to determine the parameters.\n    \"\"\"\n\n    variables: Variables\n    \"\"\"\n    The variables of this action.\n    \"\"\"\n\n    def __init__(self, policy: Optional[ProbabilisticCircuit] = None):\n        if policy is None:\n            policy = self.default_policy()\n        self.policy = policy\n        self.variables = self.Variables(*self.policy.variables)\n\n    def default_policy(self) -> ProbabilisticCircuit:\n        \"\"\"\n        Create a default policy for the action.\n\n        :return: The default policy for the action\n        \"\"\"\n        raise NotImplementedError\n\n    def sample_to_action(self, sample: List) -> ActionAbstract:\n        \"\"\"\n        Convert a sample from the policy to a performable action.\n        :param sample: The sample\n        :return: The action\n        \"\"\"\n        raise NotImplementedError\n\n\nclass GaussianCostmapModel:\n    \"\"\"\n    Class that generates a Gaussian Costmap around the center of an object. The costmap cuts out a square in the middle\n    that has side lengths given by ``distance_to_center``.\n    \"\"\"\n\n    distance_to_center: float\n    \"\"\"\n    The side length of the cut out square.\n    \"\"\"\n\n    variance: float\n    \"\"\"\n    The variance of the distributions involved\n    \"\"\"\n\n    relative_x = Continuous(\"relative_x\")\n    relative_y = Continuous(\"relative_y\")\n    grasp = Symbolic(\"grasp\", Grasp)\n    arm = Symbolic(\"arm\", Arms)\n\n    def __init__(self, distance_to_center: float = 0.2, variance: float = 0.5):\n        self.distance_to_center = distance_to_center\n        self.variance = variance\n\n    def center_event(self) -> Event:\n        \"\"\"\n        Create an event that describes the center of the map.\n        \"\"\"\n        return SimpleEvent({self.relative_x: open(-self.distance_to_center, self.distance_to_center),\n                            self.relative_y: open(-self.distance_to_center,\n                                                  self.distance_to_center)}).as_composite_set()\n\n    def create_model_with_center(self) -> ProbabilisticCircuit:\n        \"\"\"\n        Create a fully factorized gaussian at the center of the map.\n        \"\"\"\n        centered_model = DecomposableProductUnit()\n        centered_model.add_subcircuit(GaussianDistribution(self.relative_x, 0., np.sqrt(self.variance)))\n        centered_model.add_subcircuit(GaussianDistribution(self.relative_y, 0., np.sqrt(self.variance)))\n\n        grasp_probabilities = MissingDict(float, {int(element): 1 / len(self.grasp.domain.simple_sets) for element in\n                                                  self.grasp.domain.simple_sets})\n\n        centered_model.add_subcircuit(SymbolicDistribution(self.grasp, grasp_probabilities))\n\n        arm_probabilities = MissingDict(float, {int(element): 1 / len(self.arm.domain.simple_sets) for element in\n                                                self.arm.domain.simple_sets})\n        centered_model.add_subcircuit(SymbolicDistribution(self.arm, arm_probabilities))\n        return centered_model.probabilistic_circuit\n\n    def create_model(self) -> ProbabilisticCircuit:\n        \"\"\"\n        Create a gaussian model that assumes mass everywhere besides the center square.\n\n        :return: The probabilistic circuit\n        \"\"\"\n        centered_model = self.create_model_with_center()\n        outer_event = self.center_event().complement()\n        limiting_event = SimpleEvent({self.relative_x: open(-2, 2),\n                                      self.relative_y: open(-2, 2)}).as_composite_set()\n        event = outer_event & limiting_event\n        # go.Figure(event.plot()).show()\n        result, _ = centered_model.conditional(event)\n        return result\n\n\nclass MoveAndPickUp(ActionDesignatorDescription, ProbabilisticAction):\n    @dataclass\n    class Variables:\n        arm: Symbolic = Symbolic(\"arm\", Arms)\n        grasp: Symbolic = Symbolic(\"grasp\", Grasp)\n        relative_x: Continuous = Continuous(\"relative_x\")\n        relative_y: Continuous = Continuous(\"relative_y\")\n\n    variables: Variables  # Type hint variables\n\n    sample_amount: int = 20\n    \"\"\"\n    The amount of samples that should be drawn from the policy when iterating over it.\n    \"\"\"\n\n    object_designator: ObjectDesignatorDescription.Object\n    \"\"\"\n    The object designator that should be picked up.\n    \"\"\"\n\n    arms: List[Arms]\n    \"\"\"\n    The arms that can be used for the pick up.\n    \"\"\"\n\n    grasps: List[Grasp]\n    \"\"\"\n    The grasps that can be used for the pick up.\n    \"\"\"\n\n    def __init__(self, object_designator: ObjectDesignatorDescription.Object, arms: List[Arms], grasps: List[Grasp],\n                 policy: Optional[ProbabilisticCircuit] = None):\n        ActionDesignatorDescription.__init__(self)\n        ProbabilisticAction.__init__(self, policy)\n        self.object_designator = object_designator\n        self.arms = arms\n        self.grasps = grasps\n\n    def default_policy(self) -> ProbabilisticCircuit:\n        return GaussianCostmapModel().create_model()\n\n    def sample_to_action(self, sample: List) -> MoveAndPickUpPerformable:\n        \"\"\"\n        Convert a sample from the underlying distribution to a performable action.\n        :param sample: The sample\n        :return:  action\n        \"\"\"\n        arm, grasp, relative_x, relative_y = sample\n        position = [relative_x, relative_y, 0.]\n        pose = Pose(position, frame=self.object_designator.world_object.tf_frame)\n        standing_position = LocalTransformer().transform_pose(pose, \"map\")\n        standing_position.position.z = 0\n        action = MoveAndPickUpPerformable(standing_position, self.object_designator, EArms(int(arm)), EGrasp(int(grasp)))\n        return action\n\n    def events_from_occupancy_and_visibility_costmap(self) -> Event:\n        \"\"\"\n        Create events from the occupancy and visibility costmap.\n\n        :return: The events that can be used as evidence for the model.\n        \"\"\"\n\n        # create occupancy and visibility costmap for the target object\n        ocm = OccupancyCostmap(distance_to_obstacle=0.3, from_ros=False, size=200, resolution=0.1,\n                               origin=self.object_designator.pose)\n        vcm = VisibilityCostmap(min_height=1.27, max_height=1.69,\n                                size=200, resolution=0.1, origin=self.object_designator.pose)\n        mcm = ocm + vcm\n\n        # convert rectangles to events\n        events = []\n        for rectangle in mcm.partitioning_rectangles():\n            event = SimpleEvent({self.variables.relative_x: open(rectangle.x_lower, rectangle.x_upper),\n                                 self.variables.relative_y: open(rectangle.y_lower, rectangle.y_upper)})\n            events.append(event)\n        return Event(*events)\n\n    def ground_model(self, model: Optional[ProbabilisticCircuit] = None,\n                     event: Optional[Event] = None) -> ProbabilisticCircuit:\n        \"\"\"\n        Ground the model to the current evidence.\n\n        :param model: The model that should be grounded. If None, the policy is used.\n        :param event: The events that should be used as evidence. If None, the occupancy costmap is used.\n        :return: The grounded model\n        \"\"\"\n\n        if model is None:\n            model = self.policy\n        if event is None:\n            event = self.events_from_occupancy_and_visibility_costmap()\n\n        result, probability = model.conditional(event)\n\n        if probability == 0:\n            raise ObjectUnreachable(\"No possible locations found\")\n\n        return result\n\n    def iter_with_mode(self) -> Iterator[MoveAndPickUpPerformable]:\n        \"\"\"\n        Generate performables by sampling from the mode of the policy conditioned on visibility and occupancy.\n        \"\"\"\n        model = self.ground_model()\n        modes, _ = model.mode()\n        model = self.ground_model(model, modes)\n        samples = model.sample(self.sample_amount)\n\n        for sample in samples:\n            action = self.sample_to_action(sample)\n            yield action\n\n    def __iter__(self) -> Iterator[MoveAndPickUpPerformable]:\n        \"\"\"\n        Generate performables by sampling from the policy conditioned on visibility and occupancy.\n        \"\"\"\n        model = self.ground_model(self.policy, self.events_from_occupancy_and_visibility_costmap())\n        samples = model.sample(self.sample_amount)\n        likelihoods = model.likelihood(samples)\n\n        # sort samples by likelihood\n        samples = [x for _, x in sorted(zip(likelihoods, samples), key=lambda pair: pair[0], reverse=True)]\n\n        for sample in samples:\n            action = self.sample_to_action(sample)\n            yield action\n\n    def iterate_without_occupancy_costmap(self) -> Iterator[MoveAndPickUpPerformable]:\n        \"\"\"\n        Generate performables by sampling from the policy without conditioning on visibility and occupancy.\n        \"\"\"\n        samples = self.policy.sample(self.sample_amount)\n        for sample in samples:\n            action = self.sample_to_action(sample)\n            yield action\n\n    @staticmethod\n    def query_for_database():\n        view = PickUpWithContextView\n        query = (select(view.arm, view.grasp, view.relative_x, view.relative_y)\n                 .where(view.status == TaskStatus.SUCCEEDED))\n        return query\n\n    def batch_rollout(self):\n        \"\"\"\n        Try the policy without conditioning on visibility and occupancy and count the successful tries.\n\n        :amount: The amount of tries\n        \"\"\"\n\n        # initialize statistics\n        successful_tries = 0\n        total_tries = 0\n\n        # create the progress bar\n        progress_bar = tqdm.tqdm(iter(self.iterate_without_occupancy_costmap()), total=self.sample_amount)\n\n        for action in progress_bar:\n            total_tries += 1\n            try:\n                action.perform()\n                successful_tries += 1\n            except PlanFailure as p:\n                pass\n\n            # update progress bar\n            progress_bar.set_postfix({\"Success Probability\": successful_tries / total_tries})\n\n            # reset world\n            World.current_world.reset_world()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the giskard.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<giskard.py>#\nimport json\nimport threading\nimport time\n\nimport rospy\nimport sys\nimport rosnode\n\nfrom ..datastructures.enums import JointType, ObjectType\nfrom ..datastructures.pose import Pose\n# from ..robot_descriptions import robot_description\nfrom ..datastructures.world import World\nfrom ..datastructures.dataclasses import MeshVisualShape\nfrom ..world_concepts.world_object import Object\n# from ..robot_description import ManipulatorDescription\nfrom ..robot_description import RobotDescription\n\nfrom typing_extensions import List, Dict, Callable, Optional\nfrom geometry_msgs.msg import PoseStamped, PointStamped, QuaternionStamped, Vector3Stamped\nfrom threading import Lock, RLock\n\ntry:\n    from giskardpy.python_interface.old_python_interface import OldGiskardWrapper as GiskardWrapper\n    from giskard_msgs.msg import WorldBody, MoveResult, CollisionEntry\n    #from giskard_msgs.srv import UpdateWorldRequest, UpdateWorld, UpdateWorldResponse, RegisterGroupResponse\nexcept ModuleNotFoundError as e:\n    rospy.logwarn(\"Failed to import Giskard messages, the real robot will not be available\")\n\ngiskard_wrapper = None\ngiskard_update_service = None\nis_init = False\n\nnumber_of_par_goals = 0\ngiskard_lock = Lock()\ngiskard_rlock = RLock()\nwith giskard_rlock:\n    par_threads = {}\n    par_motion_goal = {}\n\n\ndef thread_safe(func: Callable) -> Callable:\n    \"\"\"\n    Adds thread safety to a function via a decorator. This uses the giskard_lock\n\n    :param func: Function that should be thread safe\n    :return: A function with thread safety\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        with giskard_rlock:\n            return func(*args, **kwargs)\n\n    return wrapper\n\n\ndef init_giskard_interface(func: Callable) -> Callable:\n    \"\"\"\n    Checks if the ROS messages are available and if giskard is running, if that is the case the interface will be\n    initialized.\n\n    :param func: Function this decorator should be wrapping\n    :return: A callable function which initializes the interface and then calls the wrapped function\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        global giskard_wrapper\n        global giskard_update_service\n        global is_init\n        if is_init and \"/giskard\" in rosnode.get_node_names():\n            return func(*args, **kwargs)\n        elif is_init and \"/giskard\" not in rosnode.get_node_names():\n            rospy.logwarn(\"Giskard node is not available anymore, could not initialize giskard interface\")\n            is_init = False\n            giskard_wrapper = None\n            return\n\n        if \"giskard_msgs\" not in sys.modules:\n            rospy.logwarn(\"Could not initialize the Giskard interface since the giskard_msgs are not imported\")\n            return\n\n        if \"/giskard\" in rosnode.get_node_names():\n            giskard_wrapper = GiskardWrapper()\n            giskard_update_service = rospy.ServiceProxy(\"/giskard/update_world\", UpdateWorld)\n            rospy.loginfo_once(\"Successfully initialized Giskard interface\")\n            is_init = True\n        else:\n            rospy.logwarn(\"Giskard is not running, could not initialize Giskard interface\")\n            return\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\n# Believe state management between pycram and giskard\n\n\n@init_giskard_interface\ndef initial_adding_objects() -> None:\n    \"\"\"\n    Adds object that are loaded in the World to the Giskard belief state, if they are not present at the moment.\n    \"\"\"\n    groups = giskard_wrapper.get_group_names()\n    for obj in World.current_world.objects:\n        if obj is World.robot or obj is World.current_world.get_prospection_object_for_object(World.robot):\n            continue\n        name = obj.name\n        if name not in groups:\n            spawn_object(obj)\n\n\n@init_giskard_interface\ndef removing_of_objects() -> None:\n    \"\"\"\n    Removes objects that are present in the Giskard belief state but not in the World from the Giskard belief state.\n    \"\"\"\n    groups = giskard_wrapper.get_group_names()\n    object_names = list(\n        map(lambda obj: object_names.name, World.current_world.objects))\n    diff = list(set(groups) - set(object_names))\n    for grp in diff:\n        giskard_wrapper.remove_group(grp)\n\n\n@init_giskard_interface\ndef sync_worlds() -> None:\n    \"\"\"\n    Synchronizes the World and the Giskard belief state, this includes adding and removing objects to the Giskard\n    belief state such that it matches the objects present in the World and moving the robot to the position it is\n    currently at in the World.\n    \"\"\"\n    add_gripper_groups()\n    world_object_names = set()\n    for obj in World.current_world.objects:\n        if obj.name != RobotDescription.current_robot_description.name and obj.obj_type != ObjectType.ROBOT and len(obj.link_name_to_id) != 1:\n            world_object_names.add(obj.name)\n        if obj.name == RobotDescription.current_robot_description.name or obj.obj_type == ObjectType.ROBOT:\n            joint_config = obj.get_positions_of_all_joints()\n            non_fixed_joints = list(filter(lambda joint: joint.type != JointType.FIXED, obj.joints.values()))\n            joint_config_filtered = {joint.name: joint_config[joint.name] for joint in non_fixed_joints}\n\n            giskard_wrapper.monitors.add_set_seed_configuration(joint_config_filtered,\n                                                                RobotDescription.current_robot_description.name)\n            giskard_wrapper.monitors.add_set_seed_odometry(_pose_to_pose_stamped(obj.get_pose()),\n                                                           RobotDescription.current_robot_description.name)\n    giskard_object_names = set(giskard_wrapper.get_group_names())\n    robot_name = {RobotDescription.current_robot_description.name}\n    if not world_object_names.union(robot_name).issubset(giskard_object_names):\n        giskard_wrapper.clear_world()\n    initial_adding_objects()\n\n\n@init_giskard_interface\ndef update_pose(object: Object) -> 'UpdateWorldResponse':\n    \"\"\"\n    Sends an update message to giskard to update the object position. Might not work when working on the real robot just\n    in standalone mode.\n\n    :param object: Object that should be updated\n    :return: An UpdateWorldResponse\n    \"\"\"\n    return giskard_wrapper.update_group_pose(object.name)\n\n\n@init_giskard_interface\ndef spawn_object(object: Object) -> None:\n    \"\"\"\n    Spawns a World Object in the giskard belief state.\n\n    :param object: World object that should be spawned\n    \"\"\"\n    if len(object.link_name_to_id) == 1:\n        geometry = object.get_link_geometry(object.root_link_name)\n        if isinstance(geometry, MeshVisualShape):\n            filename = geometry.file_name\n            spawn_mesh(object.name, filename, object.get_pose())\n    else:\n        spawn_urdf(object.name, object.path, object.get_pose())\n\n\n@init_giskard_interface\ndef remove_object(object: Object) -> 'UpdateWorldResponse':\n    \"\"\"\n    Removes an object from the giskard belief state.\n\n    :param object: The World Object that should be removed\n    \"\"\"\n    return giskard_wrapper.remove_group(object.name)\n\n\n@init_giskard_interface\ndef spawn_urdf(name: str, urdf_path: str, pose: Pose) -> 'UpdateWorldResponse':\n    \"\"\"\n    Spawns an URDF in giskard's belief state.\n\n    :param name: Name of the URDF\n    :param urdf_path: Path to the URDF file\n    :param pose: Pose in which the URDF should be spawned\n    :return: An UpdateWorldResponse message\n    \"\"\"\n    urdf_string = \"\"\n    with open(urdf_path) as f:\n        urdf_string = f.read()\n\n    return giskard_wrapper.add_urdf(name, urdf_string, pose)\n\n\n@init_giskard_interface\ndef spawn_mesh(name: str, path: str, pose: Pose) -> 'UpdateWorldResponse':\n    \"\"\"\n    Spawns a mesh into giskard's belief state\n\n    :param name: Name of the mesh\n    :param path: Path to the mesh file\n    :param pose: Pose in which the mesh should be spawned\n    :return: An UpdateWorldResponse message\n    \"\"\"\n    return giskard_wrapper.add_mesh(name, path, pose)\n\n\n# Sending Goals to Giskard\n\n@thread_safe\ndef _manage_par_motion_goals(goal_func, *args) -> Optional['MoveResult']:\n    \"\"\"\n    Manages multiple goals that should be executed in parallel. The current sequence of motion goals is saved and the\n    parallel motion goal is loaded if there is one, then the new motion goal given by ``goal_func`` is added to the\n    parallel motion goal. If this was the last motion goal for the parallel motion goal it is then executed.\n\n    :param goal_func: Function which adds a new motion goal to the giskard_wrapper\n    :param args: Arguments for the ``goal_func`` function\n    :return: MoveResult of the execution if there was an execution, True if a new motion goal was added to the giskard_wrapper and None in any other case\n    \"\"\"\n    # key is the instance of the parallel language element, value is a list of threads that should be executed in\n    # parallel\n    for key, value in par_threads.items():\n        # if the current thread is in the list of threads that should be executed in parallel backup the current list\n        # of motion goals and monitors\n        if threading.get_ident() in value:\n            tmp_goals = giskard_wrapper.motion_goals.get_goals()\n            tmp_monitors = giskard_wrapper.monitors.get_monitors()\n\n            if key in par_motion_goal.keys():\n                # giskard_wrapper.cmd_seq = par_motion_goal[key]\n                giskard_wrapper.motion_goals._goals = par_motion_goal[key][0]\n                giskard_wrapper.monitors._monitors = par_motion_goal[key][1]\n            else:\n                giskard_wrapper.clear_motion_goals_and_monitors()\n\n            goal_func(*args)\n\n            # Check if there are multiple constraints that use the same joint, if this is the case the\n            used_joints = set()\n            for cmd in giskard_wrapper.motion_goals.get_goals():\n                par_value_pair = json.loads(cmd.kwargs)\n                if \"tip_link\" in par_value_pair.keys() and \"root_link\" in par_value_pair.keys():\n                    if par_value_pair[\"tip_link\"] == robot_description.base_link:\n                        continue\n                    chain = World.robot.description.get_chain(par_value_pair[\"root_link\"],\n                                                              par_value_pair[\"tip_link\"])\n                    if set(chain).intersection(used_joints) != set():\n                        giskard_wrapper.motion_goals._goals = tmp_goals\n                        giskard_wrapper.monitors._monitors = tmp_monitors\n                        raise AttributeError(\n                            f\"The joint(s) {set(chain).intersection(used_joints)} is used by multiple Designators\")\n                    else:\n                        [used_joints.add(joint) for joint in chain]\n\n                elif \"goal_state\" in par_value_pair.keys():\n                    if set(par_value_pair[\"goal_state\"].keys()).intersection(used_joints) != set():\n                        giskard_wrapper.motion_goals._goals = tmp_goals\n                        giskard_wrapper.monitors._monitors = tmp_monitors\n                        raise AttributeError(\n                            f\"The joint(s) {set(par_value_pair['goal_state'].keys()).intersection(used_joints)} is used by multiple Designators\")\n                    else:\n                        [used_joints.add(joint) for joint in par_value_pair[\"goal_state\"].keys()]\n\n            par_threads[key].remove(threading.get_ident())\n            # If this is the last thread that should be executed in parallel, execute the complete sequence of motion\n            # goals\n            if len(par_threads[key]) == 0:\n                if key in par_motion_goal.keys():\n                    del par_motion_goal[key]\n                del par_threads[key]\n                # giskard_wrapper.add_default_end_motion_conditions()\n                res = giskard_wrapper.execute()\n                giskard_wrapper.motion_goals._goals = tmp_goals\n                giskard_wrapper.monitors._monitors = tmp_monitors\n                return res\n            # If there are still threads that should be executed in parallel, save the current state of motion goals and\n            # monitors.\n            else:\n                par_motion_goal[key] = [giskard_wrapper.motion_goals.get_goals(),\n                                        giskard_wrapper.monitors.get_monitors()]\n                giskard_wrapper.motion_goals._goals = tmp_goals\n                giskard_wrapper.monitors._monitors = tmp_monitors\n                return True\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_joint_goal(goal_poses: Dict[str, float]) -> 'MoveResult':\n    \"\"\"\n    Takes a dictionary of joint position that should be achieved, the keys in the dictionary are the joint names and\n    values are the goal joint positions.\n\n    :param goal_poses: Dictionary with joint names and position goals\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_joint_goal, goal_poses)\n    if par_return:\n        return par_return\n\n    giskard_wrapper.set_joint_goal(goal_poses)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_cartesian_goal(goal_pose: Pose, tip_link: str, root_link: str) -> 'MoveResult':\n    \"\"\"\n    Takes a cartesian position and tries to move the tip_link to this position using the chain defined by\n    tip_link and root_link.\n\n    :param goal_pose: The position which should be achieved with tip_link\n    :param tip_link: The end link of the chain as well as the link which should achieve the goal_pose\n    :param root_link: The starting link of the chain which should be used to achieve this goal\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_cart_goal, _pose_to_pose_stamped(goal_pose),\n                                          tip_link, root_link)\n    if par_return:\n        return par_return\n\n    giskard_wrapper.set_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_straight_cartesian_goal(goal_pose: Pose, tip_link: str,\n                                    root_link: str) -> 'MoveResult':\n    \"\"\"\n    Takes a cartesian position and tries to move the tip_link to this position in a straight line, using the chain\n    defined by tip_link and root_link.\n\n    :param goal_pose: The position which should be achieved with tip_link\n    :param tip_link: The end link of the chain as well as the link which should achieve the goal_pose\n    :param root_link: The starting link of the chain which should be used to achieve this goal\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_straight_cart_goal, _pose_to_pose_stamped(goal_pose),\n                                          tip_link, root_link)\n    if par_return:\n        return par_return\n\n    giskard_wrapper.set_straight_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_translation_goal(goal_point: List[float], tip_link: str, root_link: str) -> 'MoveResult':\n    \"\"\"\n    Tries to move the tip_link to the position defined by goal_point using the chain defined by root_link and\n    tip_link. Since goal_point only defines the position but no rotation, rotation is not taken into account.\n\n    :param goal_point: The goal position of the tip_link\n    :param tip_link: The link which should be moved to goal_point as well as the end of the used chain\n    :param root_link: The start link of the chain\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_translation_goal, make_point_stamped(goal_point),\n                                          tip_link, root_link)\n    if par_return:\n        return par_return\n\n    giskard_wrapper.set_translation_goal(make_point_stamped(goal_point), tip_link, root_link)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_straight_translation_goal(goal_point: List[float], tip_link: str, root_link: str) -> 'MoveResult':\n    \"\"\"\n    Tries to move the tip_link to the position defined by goal_point in a straight line, using the chain defined by\n    root_link and tip_link. Since goal_point only defines the position but no rotation, rotation is not taken into account.\n\n    :param goal_point: The goal position of the tip_link\n    :param tip_link: The link which should be moved to goal_point as well as the end of the used chain\n    :param root_link: The start link of the chain\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_straight_translation_goal,\n                                          make_point_stamped(goal_point),\n                                          tip_link, root_link)\n    if par_return:\n        return par_return\n\n    giskard_wrapper.set_straight_translation_goal(make_point_stamped(goal_point), tip_link, root_link)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_rotation_goal(quat: List[float], tip_link: str, root_link: str) -> 'MoveResult':\n    \"\"\"\n    Tries to bring the tip link into the rotation defined by quat using the chain defined by root_link and\n    tip_link.\n\n    :param quat: The rotation that should be achieved, given as a quaternion\n    :param tip_link: The link that should be in the rotation defined by quat\n    :param root_link: The start link of the chain\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_rotation_goal, make_quaternion_stamped(quat),\n                                          tip_link, root_link)\n    if par_threads:\n        return par_return\n\n    giskard_wrapper.set_rotation_goal(make_quaternion_stamped(quat), tip_link, root_link)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_align_planes_goal(goal_normal: List[float], tip_link: str, tip_normal: List[float],\n                              root_link: str) -> 'MoveResult':\n    \"\"\"\n    Tries to align the plane defined by tip normal with goal_normal using the chain between root_link and\n    tip_link.\n\n    :param goal_normal: The goal plane, given as a list of XYZ\n    :param tip_link: The end link of the chain that should be used.\n    :param tip_normal: The plane that should be aligned with goal_normal, given as a list of XYZ\n    :param root_link: The starting link of the chain that should be used.\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_align_planes_goal, make_vector_stamped(goal_normal),\n                                          tip_link, make_vector_stamped(tip_normal), root_link)\n    if par_return:\n        return par_return\n\n    giskard_wrapper.set_align_planes_goal(make_vector_stamped(goal_normal), tip_link,\n                                          make_vector_stamped(tip_normal),\n                                          root_link)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_open_container_goal(tip_link: str, environment_link: str) -> 'MoveResult':\n    \"\"\"\n    Tries to open a container in an environment, this only works if the container was added as a URDF. This goal assumes\n    that the handle was already grasped. Can only handle container with 1 DOF\n\n    :param tip_link: The End effector that should open the container\n    :param environment_link: The name of the handle for this container.\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_open_container_goal, tip_link, environment_link)\n    if par_return:\n        return par_return\n    giskard_wrapper.set_open_container_goal(tip_link, environment_link)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n@init_giskard_interface\n@thread_safe\ndef achieve_close_container_goal(tip_link: str, environment_link: str) -> 'MoveResult':\n    \"\"\"\n    Tries to close a container, this only works if the container was added as a URDF. Assumes that the handle of the\n    container was already grasped. Can only handle container with 1 DOF.\n\n    :param tip_link: Link name that should be used to close the container.\n    :param environment_link: Name of the handle\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    par_return = _manage_par_motion_goals(giskard_wrapper.set_close_container_goal, tip_link, environment_link)\n    if par_return:\n        return par_return\n\n    giskard_wrapper.set_close_container_goal(tip_link, environment_link)\n    # giskard_wrapper.add_default_end_motion_conditions()\n    return giskard_wrapper.execute()\n\n\n# Projection Goals\n\n\n@init_giskard_interface\ndef projection_cartesian_goal(goal_pose: Pose, tip_link: str, root_link: str) -> 'MoveResult':\n    \"\"\"\n    Tries to move the tip_link to the position defined by goal_pose using the chain defined by tip_link and root_link.\n    The goal_pose is projected to the closest point on the robot's workspace.\n\n    :param goal_pose: The position which should be achieved with tip_link\n    :param tip_link: The end link of the chain as well as the link which should achieve the goal_pose\n    :param root_link: The starting link of the chain which should be used to achieve this goal\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    giskard_wrapper.set_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)\n    return giskard_wrapper.projection()\n\n\n@init_giskard_interface\ndef projection_cartesian_goal_with_approach(approach_pose: Pose, goal_pose: Pose, tip_link: str, root_link: str,\n                                            robot_base_link: str) -> 'MoveResult':\n    \"\"\"\n    Tries to achieve the goal_pose using the chain defined by tip_link and root_link. The approach_pose is used to drive\n    the robot to a pose close the actual goal pose, the robot_base_link is used to define the base link of the robot.\n\n    :param approach_pose: Pose near the goal_pose\n    :param goal_pose: Pose to which the tip_link should be moved\n    :param tip_link: The link which should be moved to goal_pose, usually the tool frame\n    :param root_link: The start of the link chain which should be used for planning\n    :param robot_base_link: The base link of the robot\n    :return: A trajectory calculated to move the tip_link to the goal_pose\n    \"\"\"\n    sync_worlds()\n    giskard_wrapper.allow_all_collisions()\n    giskard_wrapper.set_cart_goal(_pose_to_pose_stamped(approach_pose), robot_base_link, \"map\")\n    giskard_wrapper.projection()\n    giskard_wrapper.avoid_all_collisions()\n    giskard_wrapper.set_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)\n    return giskard_wrapper.projection()\n\n\n@init_giskard_interface\ndef projection_joint_goal(goal_poses: Dict[str, float], allow_collisions: bool = False) -> 'MoveResult':\n    \"\"\"\n    Tries to achieve the joint goal defined by goal_poses, the goal_poses are projected to the closest point on the\n    robot's workspace.\n\n    :param goal_poses: Dictionary with joint names and position goals\n    :param allow_collisions: If all collisions should be allowed for this goal\n    :return: MoveResult message for this goal\n    \"\"\"\n    sync_worlds()\n    if allow_collisions:\n        giskard_wrapper.allow_all_collisions()\n    giskard_wrapper.set_joint_goal(goal_poses)\n    return giskard_wrapper.projection()\n\n\n# Managing collisions\n\n@init_giskard_interface\ndef allow_gripper_collision(gripper: str) -> None:\n    \"\"\"\n    Allows the specified gripper to collide with anything.\n\n    :param gripper: The gripper which can collide, either 'right', 'left' or 'all'\n    \"\"\"\n    add_gripper_groups()\n    for gripper_group in get_gripper_group_names():\n        if gripper in gripper_group or gripper == \"all\":\n            giskard_wrapper.allow_collision(gripper_group, CollisionEntry.ALL)\n\n\n@init_giskard_interface\ndef get_gripper_group_names() -> List[str]:\n    \"\"\"\n    Returns a list of groups that are registered in giskard which have 'gripper' in their name.\n\n    :return: The list of gripper groups\n    \"\"\"\n    groups = giskard_wrapper.get_group_names()\n    return list(filter(lambda elem: \"gripper\" in elem, groups))\n\n\n@init_giskard_interface\ndef add_gripper_groups() -> None:\n    \"\"\"\n    Adds the gripper links as a group for collision avoidance.\n\n    :return: Response of the RegisterGroup Service\n    \"\"\"\n    with giskard_lock:\n        for name in giskard_wrapper.get_group_names():\n            if \"gripper\" in name:\n                return\n        for description in RobotDescription.current_robot_description.get_manipulator_chains():\n            giskard_wrapper.register_group(description.name + \"_gripper\", description.start_link, RobotDescription.current_robot_description.name)\n\n\n@init_giskard_interface\ndef avoid_all_collisions() -> None:\n    \"\"\"\n    Will avoid all collision for the next goal.\n    \"\"\"\n    giskard_wrapper.avoid_all_collisions()\n\n\n@init_giskard_interface\ndef allow_self_collision() -> None:\n    \"\"\"\n    Will allow the robot collision with itself.\n    \"\"\"\n    giskard_wrapper.allow_self_collision()\n\n\n@init_giskard_interface\ndef avoid_collisions(object1: Object, object2: Object) -> None:\n    \"\"\"\n    Will avoid collision between the two objects for the next goal.\n\n    :param object1: The first World Object\n    :param object2: The second World Object\n    \"\"\"\n    giskard_wrapper.avoid_collision(-1, object1.name, object2.name)\n\n\n# Creating ROS messages\n\n@init_giskard_interface\ndef make_world_body(object: Object) -> 'WorldBody':\n    \"\"\"\n    Creates a WorldBody message for a World Object. The WorldBody will contain the URDF of the World Object\n\n    :param object: The World Object\n    :return: A WorldBody message for the World Object\n    \"\"\"\n    urdf_string = \"\"\n    with open(object.path) as f:\n        urdf_sting = f.read()\n    urdf_body = WorldBody()\n    urdf_body.type = WorldBody.URDF_BODY\n    urdf_body.urdf = urdf_string\n\n    return urdf_body\n\n\ndef make_point_stamped(point: List[float]) -> PointStamped:\n    \"\"\"\n    Creates a PointStamped message for the given position in world coordinate frame.\n\n    :param point: XYZ coordinates of the point\n    :return: A PointStamped message\n    \"\"\"\n    msg = PointStamped()\n    msg.header.stamp = rospy.Time.now()\n    msg.header.frame_id = \"map\"\n\n    msg.point.x = point[0]\n    msg.point.y = point[1]\n    msg.point.z = point[2]\n\n    return msg\n\n\ndef make_quaternion_stamped(quaternion: List[float]) -> QuaternionStamped:\n    \"\"\"\n    Creates a QuaternionStamped message for the given quaternion.\n\n    :param quaternion: The quaternion as a list of xyzw\n    :return: A QuaternionStamped message\n    \"\"\"\n    msg = QuaternionStamped()\n    msg.header.stamp = rospy.Time.now()\n    msg.header.frame_id = \"map\"\n\n    msg.quaternion.x = quaternion[0]\n    msg.quaternion.y = quaternion[1]\n    msg.quaternion.z = quaternion[2]\n    msg.quaternion.w = quaternion[3]\n\n    return msg\n\n\ndef make_vector_stamped(vector: List[float]) -> Vector3Stamped:\n    \"\"\"\n    Creates a Vector3Stamped message, this is similar to PointStamped but represents a vector instead of a point.\n\n    :param vector: The vector given as xyz in world frame\n    :return: A Vector3Stamped message\n    \"\"\"\n    msg = Vector3Stamped()\n    msg.header.stamp = rospy.Time.now()\n    msg.header.frame_id = \"map\"\n\n    msg.vector.x = vector[0]\n    msg.vector.y = vector[1]\n    msg.vector.z = vector[2]\n\n    return msg\n\n\ndef _pose_to_pose_stamped(pose: Pose) -> PoseStamped:\n    \"\"\"\n    Transforms a PyCRAM pose to a PoseStamped message, this is necessary since Giskard NEEDS a PoseStamped message\n    otherwise it will crash.\n\n    :param pose: PyCRAM pose that should be converted\n    :return: An equivalent PoseStamped message\n    \"\"\"\n    ps = PoseStamped()\n    ps.pose = pose.pose\n    ps.header = pose.header\n\n    return ps\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the ik.py file and how do they contribute to the overall functionality of the project?"}, {"role": "assistant", "content": "# Content from: #<ik.py>#\nimport rosnode\nimport tf\nfrom typing_extensions import List, Union, Tuple, Dict\n\nimport rospy\nfrom moveit_msgs.msg import PositionIKRequest\nfrom moveit_msgs.msg import RobotState\nfrom moveit_msgs.srv import GetPositionIK\nfrom sensor_msgs.msg import JointState\n\nfrom ..datastructures.world import World, UseProspectionWorld\nfrom ..world_concepts.world_object import Object\nfrom ..utils import _apply_ik\nfrom ..local_transformer import LocalTransformer\nfrom ..datastructures.pose import Pose\nfrom ..robot_description import RobotDescription\nfrom ..plan_failures import IKError\nfrom ..external_interfaces.giskard import projection_cartesian_goal, allow_gripper_collision\n\n\ndef _make_request_msg(root_link: str, tip_link: str, target_pose: Pose, robot_object: Object,\n                      joints: List[str]) -> PositionIKRequest:\n    \"\"\"\n    Generates an ik request message for the kdl_ik_service. The message is\n    of the type moveit_msgs/PositionIKRequest and contains all information\n    contained in the parameter.\n\n    :param root_link: The first link of the chain of joints to be altered\n    :param tip_link: The last link of the chain of joints to be altered\n    :param target_pose: Target pose for which the message should be created\n    :param robot_object: The robot for which the ik should be generated\n    :param joints: A list of joint names between the root_link and tip_link that should be altered.\n    :return: A moveit_msgs/PositionIKRequest message containing all the information from the parameter\n    \"\"\"\n    local_transformer = LocalTransformer()\n    target_pose = local_transformer.transform_pose(target_pose, robot_object.get_link_tf_frame(root_link))\n\n    robot_state = RobotState()\n    joint_state = JointState()\n    joint_state.name = joints\n    joint_state.position = [robot_object.get_joint_position(joint) for joint in joints]\n    # joint_state.velocity = [0.0 for x in range(len(joints))]\n    # joint_state.effort = [0.0 for x in range(len(joints))]\n    robot_state.joint_state = joint_state\n\n    msg_request = PositionIKRequest()\n    # msg_request.group_name = \"arm\"\n    msg_request.ik_link_name = tip_link\n    msg_request.pose_stamped = target_pose\n    msg_request.avoid_collisions = False\n    msg_request.robot_state = robot_state\n    msg_request.timeout = rospy.Duration(secs=1000)\n    # msg_request.attempts = 1000\n\n    return msg_request\n\n\ndef call_ik(root_link: str, tip_link: str, target_pose: Pose, robot_object: Object, joints: List[str]) -> List[float]:\n    \"\"\"\n   Sends a request to the kdl_ik_service and returns the solution.\n   Note that the robot in robot_object should be identical to the robot description\n   uploaded to the parameter server. Furthermore, note that the root_link and\n   tip_link are the links attached to the first and last joints in the joints list.\n\n   :param root_link: The first link of the chain of joints to be altered\n   :param tip_link: The last link in the chain of joints to be altered\n   :param target_pose: The target pose in frame of root link second is the orientation as quaternion in world coordinate frame\n   :param robot_object: The robot object for which the ik solution should be generated\n   :param joints: A list of joint name that should be altered\n   :return: The solution that was generated as a list of joint values corresponding to the order of joints given\n   \"\"\"\n    if RobotDescription.current_robot_description.name == \"pr2\":\n        ik_service = \"/pr2_right_arm_kinematics/get_ik\" if \"r_wrist\" in tip_link else \"/pr2_left_arm_kinematics/get_ik\"\n    else:\n        ik_service = \"/kdl_ik_service/get_ik\"\n\n    rospy.loginfo_once(f\"Waiting for IK service: {ik_service}\")\n    rospy.wait_for_service(ik_service)\n\n    req = _make_request_msg(root_link, tip_link, target_pose, robot_object, joints)\n    req.pose_stamped.header.frame_id = root_link\n    ik = rospy.ServiceProxy(ik_service, GetPositionIK)\n    try:\n        resp = ik(req)\n    except rospy.ServiceException as e:\n        if RobotDescription.current_robot_description.name == \"pr2\":\n            raise IKError(target_pose, root_link, tip_link)\n        else:\n            raise e\n\n    if resp.error_code.val == -31:\n        raise IKError(target_pose, root_link, tip_link)\n\n    return resp.solution.joint_state.position\n\n\ndef try_to_reach_with_grasp(pose_or_object: Union[Pose, Object],\n                            prospection_robot: Object, gripper_name: str,\n                            grasp: str) -> Union[Pose, None]:\n    \"\"\"\n    Checks if the robot can reach a given position with a specific grasp orientation.\n    To determine this the inverse kinematics are calculated and applied.\n\n    :param pose_or_object: The position and rotation or Object for which reachability should be checked or an Object\n    :param prospection_robot: The robot that should reach for the position\n    :param gripper_name: The name of the end effector\n    :param grasp: The grasp type with which the object should be grasped\n    \"\"\"\n\n    input_pose = pose_or_object.get_pose() if isinstance(pose_or_object, Object) else pose_or_object\n\n    target_pose = apply_grasp_orientation_to_pose(grasp, input_pose)\n\n    return try_to_reach(target_pose, prospection_robot, gripper_name)\n\n\ndef apply_grasp_orientation_to_pose(grasp: str, pose: Pose) -> Pose:\n    \"\"\"\n    Applies the orientation of a grasp to a given pose. This is done by using the grasp orientation\n    of the given grasp and applying it to the given pose.\n\n    :param grasp: The name of the grasp\n    :param pose: The pose to which the grasp orientation should be applied\n    \"\"\"\n    local_transformer = LocalTransformer()\n    target_map = local_transformer.transform_pose(pose, \"map\")\n    grasp_orientation = RobotDescription.current_robot_description.grasps[grasp]\n    target_map.orientation.x = grasp_orientation[0]\n    target_map.orientation.y = grasp_orientation[1]\n    target_map.orientation.z = grasp_orientation[2]\n    target_map.orientation.w = grasp_orientation[3]\n    return target_map\n\n\ndef try_to_reach(pose_or_object: Union[Pose, Object], prospection_robot: Object,\n                 gripper_name: str) -> Union[Pose, None]:\n    \"\"\"\n    Tries to reach a given position with a given robot. This is done by calculating the inverse kinematics.\n\n    :param pose_or_object: The position and rotation or Object for which reachability should be checked.\n    :param prospection_robot: The robot that should be used to check for reachability, should be the one in the prospection world\n    :param gripper_name: Name of the gripper tool frame\n    :return: The pose at which the robot should stand or None if the target is not reachable\n    \"\"\"\n    input_pose = pose_or_object.get_pose() if isinstance(pose_or_object, Object) else pose_or_object\n\n    arm_chain = list(filter(lambda chain: chain.get_tool_frame() == gripper_name, RobotDescription.current_robot_description.get_manipulator_chains()))[0]\n\n    joints = arm_chain.joints\n\n    try:\n        inv = request_ik(input_pose, prospection_robot, joints, gripper_name)\n    except IKError as e:\n        rospy.logerr(f\"Pose is not reachable: {e}\")\n        return None\n    _apply_ik(prospection_robot, inv)\n\n    return input_pose\n\n\ndef request_ik(target_pose: Pose, robot: Object, joints: List[str], gripper: str) -> Tuple[Pose, Dict[str, float]]:\n    \"\"\"\n    Top-level method to request ik solution for a given pose. This method will check if the giskard node is running\n    and if so will call the giskard service. If the giskard node is not running the kdl_ik_service will be called.\n\n    :param target_pose: Pose of the end-effector for which an ik solution should be found\n    :param robot: The robot object which should be used\n    :param joints: A list of joints that should be used in computation, this is only relevant for the kdl_ik_service\n    :param gripper: Name of the tool frame which should grasp, this should be at the end of the given joint chain\n    :return: A Pose at which the robt should stand as well as a dictionary of joint values\n    \"\"\"\n    if \"/giskard\" not in rosnode.get_node_names():\n        return robot.pose, request_kdl_ik(target_pose, robot, joints, gripper)\n    return request_giskard_ik(target_pose, robot, gripper)\n\n\ndef request_kdl_ik(target_pose: Pose, robot: Object, joints: List[str], gripper: str) -> Dict[str, float]:\n    \"\"\"\n    Top-level method to request ik solution for a given pose. Before calling the ik service the links directly before\n    and after the joint chain will be queried and the target_pose will be transformed into the frame of the root_link.\n    Afterward, the offset between the tip_link and end effector will be calculated and taken into account. Lastly the\n    ik service is called and the result returned\n\n    :param target_pose: Pose for which an ik solution should be found\n    :param robot: Robot object which should be used\n    :param joints: List of joints that should be used in computation\n    :param gripper: Name of the gripper which should grasp, this should be at the end of the given joint chain\n    :return: A list of joint values\n    \"\"\"\n    local_transformer = LocalTransformer()\n    base_link = RobotDescription.current_robot_description.get_parent(joints[0])\n    # Get link after last joint in chain\n    end_effector = RobotDescription.current_robot_description.get_child(joints[-1])\n\n    target_torso = local_transformer.transform_pose(target_pose, robot.get_link_tf_frame(base_link))\n\n    wrist_tool_frame_offset = robot.get_transform_between_links(end_effector, gripper)\n    target_diff = target_torso.to_transform(\"target\").inverse_times(wrist_tool_frame_offset).to_pose()\n\n    inv = call_ik(base_link, end_effector, target_diff, robot, joints)\n\n    return dict(zip(joints, inv))\n\n\ndef request_giskard_ik(target_pose: Pose, robot: Object, gripper: str) -> Tuple[Pose, Dict[str, float]]:\n    \"\"\"\n    Calls giskard in projection mode and queries the ik solution for a full body ik solution. This method will\n    try to drive the robot directly to a pose from which the target_pose is reachable for the end effector. If there\n    are obstacles in the way this method will fail. In this case please use the GiskardLocation designator.\n\n    :param target_pose: Pose at which the end effector should be moved.\n    :param robot: Robot object which should be used.\n    :param gripper: Name of the tool frame which should grasp, this should be at the end of the given joint chain.\n    :return: A list of joint values.\n    \"\"\"\n    rospy.loginfo_once(f\"Using Giskard for full body IK\")\n    local_transformer = LocalTransformer()\n    target_map = local_transformer.transform_pose(target_pose, \"map\")\n\n    allow_gripper_collision(\"all\")\n    result = projection_cartesian_goal(target_map, gripper, \"map\")\n    last_point = result.trajectory.points[-1]\n    joint_names = result.trajectory.joint_names\n\n    joint_states = dict(zip(joint_names, last_point.positions))\n    prospection_robot = World.current_world.get_prospection_object_for_object(robot)\n\n    orientation = list(tf.transformations.quaternion_from_euler(0, 0, joint_states[\"brumbrum_yaw\"], axes=\"sxyz\"))\n    pose = Pose([joint_states[\"brumbrum_x\"], joint_states[\"brumbrum_y\"], 0], orientation)\n\n    robot_joint_states = {}\n    for joint_name, state in joint_states.items():\n        if joint_name in robot.joints.keys():\n            robot_joint_states[joint_name] = state\n\n    with UseProspectionWorld():\n        prospection_robot.set_joint_positions(robot_joint_states)\n        prospection_robot.set_pose(pose)\n\n        tip_pose = prospection_robot.get_link_pose(gripper)\n        dist = tip_pose.dist(target_map)\n\n        if dist > 0.01:\n            raise IKError(target_pose, \"map\", gripper)\n        return pose, robot_joint_states\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the knowrob.py file and how do they relate to knowledge representation?"}, {"role": "assistant", "content": "# Content from: #<knowrob.py>#\nimport logging\nimport os\nimport sys\nimport rosservice\n\nfrom typing_extensions import Dict, List, Union\n\nSCRIPT_DIR = os.path.abspath(os.path.dirname(__file__))\nsys.path.append(os.path.join(SCRIPT_DIR, os.pardir, os.pardir, \"neem-interface\", \"src\"))\n\nif 'rosprolog/query' in rosservice.get_service_list():\n    from neem_interface_python.neem_interface import NEEMInterface\n    from neem_interface_python.rosprolog_client import Prolog, PrologException, atom\n\n    neem_interface = NEEMInterface()\n    prolog = Prolog()\n\nelse:\n    logging.warning(\"No KnowRob services found, knowrob is not available\")\n\n\n#logging.setLoggerClass(logging.Logger)\nlogger = logging.getLogger(__name__)\nfrom pycram import ch\n\nlogger.addHandler(ch)\nlogger.setLevel(logging.DEBUG)\n\n\ndef all_solutions(q):\n    logging.info(q)\n    r = prolog.all_solutions(q)\n    return r\n\n\ndef once(q) -> Union[List, Dict]:\n    r = all_solutions(q)\n    if len(r) == 0:\n        return []\n    return r[0]\n\n\ndef load_beliefstate(path: str):\n    logging.info(f\"Restoring beliefstate from {path}\")\n    once(f\"remember('{path}')\")\n\n\ndef clear_beliefstate():\n    logging.info(\"Clearing beliefstate\")\n    once(\"mem_clear_memory\")\n\n\ndef load_owl(path, ns_alias=None, ns_url=None):\n    \"\"\"\n    Example: load_owl(\"package://external_interfaces/owl/maps/iai_room_v1.owl\", \"map\", \"http://knowrob.org/kb/v1/IAI-Kitchen.owl#\")\n    :param str path: path to log folder\n    :rtype: bool\n    \"\"\"\n    if ns_alias is None or ns_url is None:            # Load without namespace\n        q = \"load_owl('{}')\".format(path)\n    else:\n        q = \"load_owl('{0}', [namespace({1},'{2}')])\".format(path, ns_alias, ns_url)\n    try:\n        once(q)\n        return True\n    except PrologException as e:\n        logging.warning(e)\n        return False\n\n\ndef new_iri(owl_class: str):\n    res = once(f\"kb_call(new_iri(IRI, {owl_class}))\")\n    return res[\"IRI\"]\n\n\ndef object_type(object_iri: str) -> str:\n    \"\"\"\n    :param object_iri: The name (identifier) of the object individual in the KnowRob knowledge base\n    \"\"\"\n    res = once(f\"kb_call(instance_of({atom(object_iri)}, Class))\")\n    return res[\"Class\"]\n\n\ndef instances_of(type_: str) -> List[str]:\n    \"\"\"\n    :param type_: An object type (i.e. class)\n    \"\"\"\n    all_sols = all_solutions(f\"kb_call(instance_of(Individual, {atom(type_)}))\")\n    return [sol[\"Individual\"] for sol in all_sols]\n\n\ndef object_pose(object_iri: str, reference_cs: str = \"world\", timestamp=None) -> List[float]:\n    \"\"\"\n    :param object_iri: The name (identifier) of the object individual in the KnowRob knowledge base\n    :param reference_cs: The coordinate system relative to which the pose should be defined\n    \"\"\"\n    if timestamp is None:\n        res = once(f\"mem_tf_get({atom(object_iri)}, {atom(reference_cs)}, Pos, Ori)\")\n    else:\n        res = once(f\"mem_tf_get({atom(object_iri)}, {atom(reference_cs)}, Pos, Ori, {timestamp})\")\n    pos = res[\"Pos\"]\n    ori = res[\"Ori\"]\n    return pos + ori\n\n\ndef grasp_pose(object_iri: str) -> List[float]:\n    query = f\"\"\"\n    kb_call(has_grasp_point({atom(object_iri)}, GraspPointName)),\n    mem_tf_get(GraspPointName, world, Pos, Ori)\n    \"\"\"\n    res = once(query)\n    pos = res[\"Pos\"]\n    ori = res[\"Ori\"]\n    return pos + ori\n\n\ndef knowrob_string_to_pose(pose_as_string: str) -> List[float]:\n    reference_frame = \"\"\n    for i, char in enumerate(pose_as_string[1:-1]):\n        if char == \",\":\n            break\n        reference_frame += char\n    pos, ori = pose_as_string[1+i+2:-2].split(\"],[\")\n    xyz = list(map(float, pos.split(\",\")))\n    qxyzw = list(map(float, ori.split(\",\")))\n    return xyz + qxyzw\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the move_base.py file and how do they contribute to robot navigation?"}, {"role": "assistant", "content": "# Content from: #<move_base.py>#\nimport sys\n\nimport rospy\nimport actionlib\nimport rosnode\nfrom geometry_msgs.msg import PoseStamped\nfrom typing import Callable\n\ntry:\n    from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal\nexcept ModuleNotFoundError as e:\n    rospy.logwarn(f\"Could not import MoveBase messages, Navigation interface could not be initialized\")\n\n\n# Global variables for shared resources\nnav_action_client = None\nis_init = False\n\n\ndef create_nav_action_client() -> actionlib.SimpleActionClient:\n    \"\"\"Creates a new action client for the move_base interface.\"\"\"\n    client = actionlib.SimpleActionClient(\"move_base\", MoveBaseAction)\n    rospy.loginfo(\"Waiting for move_base action server\")\n    client.wait_for_server()\n    return client\n\n\ndef init_nav_interface(func: Callable) -> Callable:\n    \"\"\"Ensures initialization of the navigation interface before function execution.\"\"\"\n\n    def wrapper(*args, **kwargs):\n        global is_init\n        global nav_action_client\n\n        if is_init:\n            return func(*args, **kwargs)\n\n        if \"move_base_msgs\" not in sys.modules:\n            rospy.logwarn(\"Could not initialize the navigation interface: move_base_msgs not imported\")\n            return\n\n        if \"/move_base\" in rosnode.get_node_names():\n            nav_action_client = create_nav_action_client()\n            rospy.loginfo(\"Successfully initialized navigation interface\")\n            is_init = True\n        else:\n            rospy.logwarn(\"Move_base is not running, could not initialize navigation interface\")\n            return\n\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\n@init_nav_interface\ndef query_pose_nav(navpose: PoseStamped):\n    \"\"\"Sends a goal to the move_base service, initiating robot navigation to a given pose.\"\"\"\n    global nav_action_client\n    global query_result\n\n    def active_callback():\n        rospy.loginfo(\"Sent query to move_base\")\n\n    def done_callback(state, result):\n        rospy.loginfo(\"Finished moving\")\n        global query_result\n        query_result = result\n\n    goal_msg = MoveBaseGoal()\n    goal_msg.target_pose = navpose\n    nav_action_client.send_goal(goal_msg, active_cb=active_callback, done_cb=done_callback)\n\n    nav_action_client.wait_for_result()\n\n    return query_result\n\n\ndef cancel_nav():\n    \"\"\"Cancels the current navigation goal.\"\"\"\n    global nav_action_client\n    nav_action_client.cancel_all_goals()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the robokudo.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<robokudo.py>#\nimport sys\nfrom threading import Lock, RLock\nfrom typing import Any\n\nimport actionlib\nimport rosnode\nimport rospy\nfrom geometry_msgs.msg import PointStamped\nfrom typing_extensions import List, Callable, Optional\n\nfrom ..datastructures.pose import Pose\nfrom ..designator import ObjectDesignatorDescription\n\ntry:\n    from robokudo_msgs.msg import ObjectDesignator as robokudo_ObjectDesignator\n    from robokudo_msgs.msg import QueryAction, QueryGoal, QueryResult\nexcept ModuleNotFoundError as e:\n    rospy.logwarn(\"Failed to import Robokudo messages, the real robot will not be available\")\n\nis_init = False\n\nnumber_of_par_goals = 0\nrobokudo_lock = Lock()\nrobokudo_rlock = RLock()\nwith robokudo_rlock:\n    par_threads = {}\n    par_motion_goal = {}\n\n\ndef thread_safe(func: Callable) -> Callable:\n    \"\"\"\n    Adds thread safety to a function via a decorator. This uses the robokudo_lock\n\n    :param func: Function that should be thread safe\n    :return: A function with thread safety\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        with robokudo_rlock:\n            return func(*args, **kwargs)\n\n    return wrapper\n\n\ndef init_robokudo_interface(func: Callable) -> Callable:\n    \"\"\"\n    Checks if the ROS messages are available and if Robokudo is running, if that is the case the interface will be\n    initialized.\n\n    :param func: Function this decorator should be wrapping\n    :return: A callable function which initializes the interface and then calls the wrapped function\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        global is_init\n        if is_init and \"/robokudo\" in rosnode.get_node_names():\n            return func(*args, **kwargs)\n        elif is_init and \"/robokudo\" not in rosnode.get_node_names():\n            rospy.logwarn(\"Robokudo node is not available anymore, could not initialize robokudo interface\")\n            is_init = False\n            giskard_wrapper = None\n            return\n\n        if \"robokudo_msgs\" not in sys.modules:\n            rospy.logwarn(\"Could not initialize the Robokudo interface since the robokudo_msgs are not imported\")\n            return\n\n        if \"/robokudo\" in rosnode.get_node_names():\n            rospy.loginfo_once(\"Successfully initialized Robokudo interface\")\n            is_init = True\n        else:\n            rospy.logwarn(\"Robokudo is not running, could not initialize Robokudo interface\")\n            return\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\n@init_robokudo_interface\ndef send_query(obj_type: Optional[str] = None, region: Optional[str] = None,\n               attributes: Optional[List[str]] = None) -> Any:\n    \"\"\"Generic function to send a query to RoboKudo.\"\"\"\n    goal = QueryGoal()\n\n    if obj_type:\n        goal.obj.type = obj_type\n    if region:\n        goal.obj.location = region\n    if attributes:\n        goal.obj.attribute = attributes\n\n    client = actionlib.SimpleActionClient('robokudo/query', QueryAction)\n    rospy.loginfo(\"Waiting for action server\")\n    client.wait_for_server()\n\n    query_result = None\n\n    def done_callback(state, result):\n        nonlocal query_result\n        query_result = result\n        rospy.loginfo(\"Query completed\")\n\n    client.send_goal(goal, done_cb=done_callback)\n    client.wait_for_result()\n    return query_result\n\n\n@init_robokudo_interface\ndef query_object(obj_desc: ObjectDesignatorDescription) -> dict:\n    \"\"\"Query RoboKudo for an object that fits the description.\"\"\"\n    goal = QueryGoal()\n    goal.obj.uid = str(id(obj_desc))\n    goal.obj.type = str(obj_desc.types[0].name)\n\n    result = send_query(obj_type=goal.obj.type)\n\n    pose_candidates = {}\n    if result and result.res:\n        for i in range(len(result.res[0].pose)):\n            pose = Pose.from_pose_stamped(result.res[0].pose[i])\n            source = result.res[0].pose_source[0]\n            pose_candidates[source] = pose\n    return pose_candidates\n\n\n@init_robokudo_interface\ndef query_human() -> PointStamped:\n    \"\"\"Query RoboKudo for human detection and return the detected human's pose.\"\"\"\n    result = send_query(obj_type='human')\n    if result:\n        return result  # Assuming result is of type PointStamped or similar.\n    return None\n\n\n@init_robokudo_interface\ndef stop_query():\n    \"\"\"Stop any ongoing query to RoboKudo.\"\"\"\n    init_robokudo_interface()\n    client = actionlib.SimpleActionClient('robokudo/query', QueryAction)\n    client.wait_for_server()\n    client.cancel_all_goals()\n    rospy.loginfo(\"Cancelled current RoboKudo query goal\")\n\n\n@init_robokudo_interface\ndef query_specific_region(region: str) -> Any:\n    \"\"\"Query RoboKudo to scan a specific region.\"\"\"\n    return send_query(region=region)\n\n\n@init_robokudo_interface\ndef query_human_attributes() -> Any:\n    \"\"\"Query RoboKudo for human attributes like brightness of clothes, headgear, and gender.\"\"\"\n    return send_query(obj_type='human', attributes=[\"attributes\"])\n\n\n@init_robokudo_interface\ndef query_waving_human() -> Pose:\n    \"\"\"Query RoboKudo for detecting a waving human.\"\"\"\n    result = send_query(obj_type='human')\n    if result and result.res:\n        try:\n            pose = Pose.from_pose_stamped(result.res[0].pose[0])\n            return pose\n        except IndexError:\n            pass\n    return None\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the tmc.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<tmc.py>#\nimport rospy\nfrom typing_extensions import Optional\n\nfrom ..datastructures.enums import GripperState\nfrom ..designators.motion_designator import MoveGripperMotion, TalkingMotion\n\nis_init = False\n\n\ndef init_tmc_interface():\n    global is_init\n    if is_init:\n        return\n    try:\n        from tmc_control_msgs.msg import GripperApplyEffortActionGoal\n        from tmc_msgs.msg import Voice\n        is_init = True\n        rospy.loginfo(\"Successfully initialized tmc interface\")\n    except ModuleNotFoundError as e:\n        rospy.logwarn(f\"Could not import TMC messages, tmc interface could not be initialized\")\n\n\ndef tmc_gripper_control(designator: MoveGripperMotion, topic_name: Optional[str] = '/hsrb/gripper_controller/grasp/goal'):\n    \"\"\"\n    Publishes a message to the gripper controller to open or close the gripper for the HSR.\n\n    :param designator: The designator containing the motion to be executed\n    :param topic_name: The topic name to publish the message to\n    \"\"\"\n    if (designator.motion == GripperState.OPEN):\n        pub_gripper = rospy.Publisher(topic_name, GripperApplyEffortActionGoal,\n                                      queue_size=10)\n        rate = rospy.Rate(10)\n        msg = GripperApplyEffortActionGoal()\n        msg.goal.effort = 0.8\n        pub_gripper.publish(msg)\n\n    elif (designator.motion == GripperState.CLOSE):\n        pub_gripper = rospy.Publisher(topic_name, GripperApplyEffortActionGoal,\n                                      queue_size=10)\n        rate = rospy.Rate(10)\n        msg = GripperApplyEffortActionGoal()\n        msg.goal.effort = -0.8\n        pub_gripper.publish(msg)\n\n\ndef tmc_talk(designator: TalkingMotion, topic_name: Optional[str] = '/talk_request'):\n    \"\"\"\n    Publishes a sentence to the talk_request topic of the HSRB robot\n\n    :param designator: The designator containing the sentence to be spoken\n    :param topic_name: The topic name to publish the sentence to\n    \"\"\"\n    pub = rospy.Publisher(topic_name, Voice, queue_size=10)\n    texttospeech = Voice()\n    # language 1 = english (0 = japanese)\n    texttospeech.language = 1\n    texttospeech.sentence = designator.cmd\n\n    pub.publish(texttospeech)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the generic.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<generic.py>#\nfrom typing_extensions import List, Any, Union, Dict\n\nfrom geometry_msgs.msg import Point\n\nfrom ..datastructures.dataclasses import VisualShape, BoxVisualShape, Color\nfrom ..datastructures.enums import JointType\nfrom ..datastructures.pose import Pose\nfrom ..description import JointDescription as AbstractJointDescription, LinkDescription as AbstractLinkDescription, \\\n    ObjectDescription as AbstractObjectDescription\n\n\nclass LinkDescription(AbstractLinkDescription):\n\n    def __init__(self, name: str, visual_frame_position: List[float], half_extents: List[float], color: Color = Color()):\n        self.parsed_description: BoxVisualShape = BoxVisualShape(color, visual_frame_position, half_extents)\n        self._name: str = name\n\n    @property\n    def geometry(self) -> Union[VisualShape, None]:\n        return self.parsed_description\n\n    @property\n    def origin(self) -> Pose:\n        return Pose(self.parsed_description.visual_frame_position)\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    @property\n    def color(self) -> Color:\n        return self.parsed_description.rgba_color\n\n\nclass JointDescription(AbstractJointDescription):\n\n    @property\n    def type(self) -> JointType:\n        return JointType.UNKNOWN\n\n    @property\n    def axis(self) -> Point:\n        return Point(0, 0, 0)\n\n    @property\n    def has_limits(self) -> bool:\n        return False\n\n    @property\n    def lower_limit(self) -> Union[float, None]:\n        return 0\n\n    @property\n    def upper_limit(self) -> Union[float, None]:\n        return 0\n\n    @property\n    def parent_link_name(self) -> str:\n        raise NotImplementedError\n\n    @property\n    def child_link_name(self) -> str:\n        raise NotImplementedError\n\n    @property\n    def origin(self) -> Pose:\n        raise NotImplementedError\n\n    @property\n    def name(self) -> str:\n        raise NotImplementedError\n\n\nclass ObjectDescription(AbstractObjectDescription):\n    \"\"\"\n    A generic description of an object in the environment. This description can be applied to any object.\n    The current use case involves perceiving objects using RoboKudo and spawning them with specified size and color.\n    \"\"\"\n\n    class Link(AbstractObjectDescription.Link, LinkDescription):\n        ...\n\n    class RootLink(AbstractObjectDescription.RootLink, Link):\n        ...\n\n    class Joint(AbstractObjectDescription.Joint, JointDescription):\n        ...\n\n    def __init__(self, *args, **kwargs):\n        self._links = [LinkDescription(*args, **kwargs)]\n\n    def load_description(self, path: str) -> Any:\n        ...\n\n    @classmethod\n    def generate_from_mesh_file(cls, path: str, name: str) -> str:\n        raise NotImplementedError\n\n    @classmethod\n    def generate_from_description_file(cls, path: str) -> str:\n        raise NotImplementedError\n\n    @classmethod\n    def generate_from_parameter_server(cls, name: str) -> str:\n        raise NotImplementedError\n\n    @property\n    def shape_data(self) -> List[float]:\n        return self._links[0].geometry.shape_data()['halfExtents']\n\n    @property\n    def color(self) -> Color:\n        return self._links[0].color\n\n    @property\n    def links(self) -> List[LinkDescription]:\n        return self._links\n\n    def get_link_by_name(self, link_name: str) -> LinkDescription:\n        if link_name == self._links[0].name:\n            return self._links[0]\n\n    @property\n    def joints(self) -> List[JointDescription]:\n        return []\n\n    def get_joint_by_name(self, joint_name: str) -> JointDescription:\n        ...\n\n    def get_root(self) -> str:\n        return self._links[0].name\n\n    def get_chain(self, start_link_name: str, end_link_name: str) -> List[str]:\n        raise NotImplementedError(\"Do Not Do This on generic objects as they have no chains\")\n\n    @staticmethod\n    def get_file_extension() -> str:\n        raise NotImplementedError(\"Do Not Do This on generic objects as they have no extensions\")\n\n    @property\n    def origin(self) -> Pose:\n        return self._links[0].origin\n\n    @property\n    def name(self) -> str:\n        return self._links[0].name\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the urdf.py file and how do they relate to robot modeling?"}, {"role": "assistant", "content": "# Content from: #<urdf.py>#\nimport pathlib\nfrom xml.etree import ElementTree\n\nimport rospkg\nimport rospy\nfrom geometry_msgs.msg import Point\nfrom tf.transformations import quaternion_from_euler\nfrom typing_extensions import Union, List, Optional\nfrom urdf_parser_py import urdf\nfrom urdf_parser_py.urdf import (URDF, Collision, Box as URDF_Box, Cylinder as URDF_Cylinder,\n                                 Sphere as URDF_Sphere, Mesh as URDF_Mesh)\n\nfrom ..datastructures.enums import JointType\nfrom ..datastructures.pose import Pose\nfrom ..description import JointDescription as AbstractJointDescription, \\\n    LinkDescription as AbstractLinkDescription, ObjectDescription as AbstractObjectDescription\nfrom ..datastructures.dataclasses import Color, VisualShape, BoxVisualShape, CylinderVisualShape, \\\n    SphereVisualShape, MeshVisualShape\nfrom ..utils import suppress_stdout_stderr\n\n\nclass LinkDescription(AbstractLinkDescription):\n    \"\"\"\n    A class that represents a link description of an object.\n    \"\"\"\n\n    def __init__(self, urdf_description: urdf.Link):\n        super().__init__(urdf_description)\n\n    @property\n    def geometry(self) -> Union[VisualShape, None]:\n        \"\"\"\n        Returns the geometry type of the URDF collision element of this link.\n        \"\"\"\n        if self.collision is None:\n            return None\n        urdf_geometry = self.collision.geometry\n        return self._get_visual_shape(urdf_geometry)\n\n    @staticmethod\n    def _get_visual_shape(urdf_geometry) -> Union[VisualShape, None]:\n        \"\"\"\n        Returns the VisualShape of the given URDF geometry.\n        \"\"\"\n        if isinstance(urdf_geometry, URDF_Box):\n            return BoxVisualShape(Color(), [0, 0, 0], urdf_geometry.size)\n        if isinstance(urdf_geometry, URDF_Cylinder):\n            return CylinderVisualShape(Color(), [0, 0, 0], urdf_geometry.radius, urdf_geometry.length)\n        if isinstance(urdf_geometry, URDF_Sphere):\n            return SphereVisualShape(Color(), [0, 0, 0], urdf_geometry.radius)\n        if isinstance(urdf_geometry, URDF_Mesh):\n            return MeshVisualShape(Color(), [0, 0, 0], urdf_geometry.scale, urdf_geometry.filename)\n        return None\n\n    @property\n    def origin(self) -> Union[Pose, None]:\n        if self.collision is None:\n            return None\n        if self.collision.origin is None:\n            return None\n        return Pose(self.collision.origin.xyz,\n                    quaternion_from_euler(*self.collision.origin.rpy).tolist())\n\n    @property\n    def name(self) -> str:\n        return self.parsed_description.name\n\n    @property\n    def collision(self) -> Collision:\n        return self.parsed_description.collision\n\n\nclass JointDescription(AbstractJointDescription):\n    urdf_type_map = {'unknown': JointType.UNKNOWN,\n                     'revolute': JointType.REVOLUTE,\n                     'continuous': JointType.CONTINUOUS,\n                     'prismatic': JointType.PRISMATIC,\n                     'floating': JointType.FLOATING,\n                     'planar': JointType.PLANAR,\n                     'fixed': JointType.FIXED}\n\n    def __init__(self, urdf_description: urdf.Joint):\n        super().__init__(urdf_description)\n\n    @property\n    def origin(self) -> Pose:\n        return Pose(self.parsed_description.origin.xyz,\n                    quaternion_from_euler(*self.parsed_description.origin.rpy))\n\n    @property\n    def name(self) -> str:\n        return self.parsed_description.name\n\n    @property\n    def has_limits(self) -> bool:\n        return bool(self.parsed_description.limit)\n\n    @property\n    def type(self) -> JointType:\n        \"\"\"\n        :return: The type of this joint.\n        \"\"\"\n        return self.urdf_type_map[self.parsed_description.type]\n\n    @property\n    def axis(self) -> Point:\n        \"\"\"\n        :return: The axis of this joint, for example the rotation axis for a revolute joint.\n        \"\"\"\n        return Point(*self.parsed_description.axis)\n\n    @property\n    def lower_limit(self) -> Union[float, None]:\n        \"\"\"\n        :return: The lower limit of this joint, or None if the joint has no limits.\n        \"\"\"\n        if self.has_limits:\n            return self.parsed_description.limit.lower\n        else:\n            return None\n\n    @property\n    def upper_limit(self) -> Union[float, None]:\n        \"\"\"\n        :return: The upper limit of this joint, or None if the joint has no limits.\n        \"\"\"\n        if self.has_limits:\n            return self.parsed_description.limit.upper\n        else:\n            return None\n\n    @property\n    def parent_link_name(self) -> str:\n        \"\"\"\n        :return: The name of the parent link of this joint.\n        \"\"\"\n        return self.parsed_description.parent\n\n    @property\n    def child_link_name(self) -> str:\n        \"\"\"\n        :return: The name of the child link of this joint.\n        \"\"\"\n        return self.parsed_description.child\n\n    @property\n    def damping(self) -> float:\n        \"\"\"\n        :return: The damping of this joint.\n        \"\"\"\n        return self.parsed_description.dynamics.damping\n\n    @property\n    def friction(self) -> float:\n        \"\"\"\n        :return: The friction of this joint.\n        \"\"\"\n        return self.parsed_description.dynamics.friction\n\n\nclass ObjectDescription(AbstractObjectDescription):\n    \"\"\"\n    A class that represents an object description of an object.\n    \"\"\"\n\n    class Link(AbstractObjectDescription.Link, LinkDescription):\n        ...\n\n    class RootLink(AbstractObjectDescription.RootLink, Link):\n        ...\n\n    class Joint(AbstractObjectDescription.Joint, JointDescription):\n        ...\n\n    def load_description(self, path) -> URDF:\n        with open(path, 'r') as file:\n            # Since parsing URDF causes a lot of warning messages which can't be deactivated, we suppress them\n            with suppress_stdout_stderr():\n                return URDF.from_xml_string(file.read())\n\n    def generate_from_mesh_file(self, path: str, name: str, color: Optional[Color] = Color()) -> str:\n        \"\"\"\n        Generates an URDf file with the given .obj or .stl file as mesh. In addition, the given rgba_color will be\n        used to create a material tag in the URDF.\n\n        :param path: The path to the mesh file.\n        :param name: The name of the object.\n        :param color: The color of the object.\n        :return: The absolute path of the created file\n        \"\"\"\n        urdf_template = '<?xml version=\"0.0\" ?> \\n \\\n                        <robot name=\"~a_object\"> \\n \\\n                         <link name=\"~a_main\"> \\n \\\n                            <visual> \\n \\\n                                <geometry>\\n \\\n                                    <mesh filename=\"~b\" scale=\"1 1 1\"/> \\n \\\n                                </geometry>\\n \\\n                                <material name=\"white\">\\n \\\n                                    <rgba_color rgba=\"~c\"/>\\n \\\n                                </material>\\n \\\n                          </visual> \\n \\\n                        <collision> \\n \\\n                        <geometry>\\n \\\n                            <mesh filename=\"~b\" scale=\"1 1 1\"/>\\n \\\n                        </geometry>\\n \\\n                        </collision>\\n \\\n                        </link> \\n \\\n                        </robot>'\n        urdf_template = self.fix_missing_inertial(urdf_template)\n        rgb = \" \".join(list(map(str, color.get_rgba())))\n        pathlib_obj = pathlib.Path(path)\n        path = str(pathlib_obj.resolve())\n        content = urdf_template.replace(\"~a\", name).replace(\"~b\", path).replace(\"~c\", rgb)\n        return content\n\n    def generate_from_description_file(self, path: str) -> str:\n        with open(path, mode=\"r\") as f:\n            urdf_string = self.fix_missing_inertial(f.read())\n            urdf_string = self.remove_error_tags(urdf_string)\n            urdf_string = self.fix_link_attributes(urdf_string)\n            try:\n                urdf_string = self.correct_urdf_string(urdf_string)\n            except rospkg.ResourceNotFound as e:\n                rospy.logerr(f\"Could not find resource package linked in this URDF\")\n                raise e\n        return urdf_string\n\n    def generate_from_parameter_server(self, name: str) -> str:\n        urdf_string = rospy.get_param(name)\n        return self.correct_urdf_string(urdf_string)\n\n    def get_link_by_name(self, link_name: str) -> LinkDescription:\n        \"\"\"\n        :return: The link description with the given name.\n        \"\"\"\n        for link in self.links:\n            if link.name == link_name:\n                return link\n        raise ValueError(f\"Link with name {link_name} not found\")\n\n    @property\n    def links(self) -> List[LinkDescription]:\n        \"\"\"\n        :return: A list of links descriptions of this object.\n        \"\"\"\n        return [LinkDescription(link) for link in self.parsed_description.links]\n\n    def get_joint_by_name(self, joint_name: str) -> JointDescription:\n        \"\"\"\n        :return: The joint description with the given name.\n        \"\"\"\n        for joint in self.joints:\n            if joint.name == joint_name:\n                return joint\n        raise ValueError(f\"Joint with name {joint_name} not found\")\n\n    @property\n    def joints(self) -> List[JointDescription]:\n        \"\"\"\n        :return: A list of joints descriptions of this object.\n        \"\"\"\n        return [JointDescription(joint) for joint in self.parsed_description.joints]\n\n    def get_root(self) -> str:\n        \"\"\"\n        :return: the name of the root link of this object.\n        \"\"\"\n        return self.parsed_description.get_root()\n\n    def get_chain(self, start_link_name: str, end_link_name: str) -> List[str]:\n        \"\"\"\n        :return: the chain of links from 'start_link_name' to 'end_link_name'.\n        \"\"\"\n        return self.parsed_description.get_chain(start_link_name, end_link_name)\n\n    def correct_urdf_string(self, urdf_string: str) -> str:\n        \"\"\"\n        Changes paths for files in the URDF from ROS paths to paths in the file system. Since World (PyBullet legacy)\n        can't deal with ROS package paths.\n\n        :param urdf_string: The name of the URDf on the parameter server\n        :return: The URDF string with paths in the filesystem instead of ROS packages\n        \"\"\"\n        r = rospkg.RosPack()\n        new_urdf_string = \"\"\n        for line in urdf_string.split('\\n'):\n            if \"package://\" in line:\n                s = line.split('//')\n                s1 = s[1].split('/')\n                path = r.get_path(s1[0])\n                line = line.replace(\"package://\" + s1[0], path)\n            new_urdf_string += line + '\\n'\n\n        return self.fix_missing_inertial(new_urdf_string)\n\n    @staticmethod\n    def fix_missing_inertial(urdf_string: str) -> str:\n        \"\"\"\n        Insert inertial tags for every URDF link that has no inertia.\n        This is used to prevent Legacy(PyBullet) from dumping warnings in the terminal\n\n        :param urdf_string: The URDF description as string\n        :returns: The new, corrected URDF description as string.\n        \"\"\"\n\n        inertia_tree = ElementTree.ElementTree(ElementTree.Element(\"inertial\"))\n        inertia_tree.getroot().append(ElementTree.Element(\"mass\", {\"value\": \"0.1\"}))\n        inertia_tree.getroot().append(ElementTree.Element(\"origin\", {\"rpy\": \"0 0 0\", \"xyz\": \"0 0 0\"}))\n        inertia_tree.getroot().append(ElementTree.Element(\"inertia\", {\"ixx\": \"0.01\",\n                                                                      \"ixy\": \"0\",\n                                                                      \"ixz\": \"0\",\n                                                                      \"iyy\": \"0.01\",\n                                                                      \"iyz\": \"0\",\n                                                                      \"izz\": \"0.01\"}))\n\n        # create tree from string\n        tree = ElementTree.ElementTree(ElementTree.fromstring(urdf_string))\n\n        for link_element in tree.iter(\"link\"):\n            inertial = [*link_element.iter(\"inertial\")]\n            if len(inertial) == 0:\n                link_element.append(inertia_tree.getroot())\n\n        return ElementTree.tostring(tree.getroot(), encoding='unicode')\n\n    @staticmethod\n    def remove_error_tags(urdf_string: str) -> str:\n        \"\"\"\n        Removes all tags in the removing_tags list from the URDF since these tags are known to cause errors with the\n        URDF_parser\n\n        :param urdf_string: String of the URDF from which the tags should be removed\n        :return: The URDF string with the tags removed\n        \"\"\"\n        tree = ElementTree.ElementTree(ElementTree.fromstring(urdf_string))\n        removing_tags = [\"gazebo\", \"transmission\"]\n        for tag_name in removing_tags:\n            all_tags = tree.findall(tag_name)\n            for tag in all_tags:\n                tree.getroot().remove(tag)\n\n        return ElementTree.tostring(tree.getroot(), encoding='unicode')\n\n    @staticmethod\n    def fix_link_attributes(urdf_string: str) -> str:\n        \"\"\"\n        Removes the attribute 'type' from links since this is not parsable by the URDF parser.\n\n        :param urdf_string: The string of the URDF from which the attributes should be removed\n        :return: The URDF string with the attributes removed\n        \"\"\"\n        tree = ElementTree.ElementTree(ElementTree.fromstring(urdf_string))\n\n        for link in tree.iter(\"link\"):\n            if \"type\" in link.attrib.keys():\n                del link.attrib[\"type\"]\n\n        return ElementTree.tostring(tree.getroot(), encoding='unicode')\n\n    @staticmethod\n    def get_file_extension() -> str:\n        \"\"\"\n        :return: The file extension of the URDF file.\n        \"\"\"\n        return '.urdf'\n\n    @property\n    def origin(self) -> Pose:\n        return Pose(self.parsed_description.origin.xyz,\n                    quaternion_from_euler(*self.parsed_description.origin.rpy))\n\n    @property\n    def name(self) -> str:\n        return self.parsed_description.name\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the main classes and functions defined in the ontology.py file?"}, {"role": "assistant", "content": "# Content from: #<ontology.py>#\nfrom __future__ import annotations\n\nimport inspect\nimport itertools\nimport logging\nimport os.path\n\nfrom pathlib import Path\nfrom typing import Callable, Dict, List, Optional, Type, Tuple, Union\n\nimport rospy\n\nfrom owlready2 import (Namespace, Ontology, World as OntologyWorld, Thing, EntityClass, Imp,\n                       Property, ObjectProperty, OwlReadyError, types,\n                       onto_path, default_world, get_namespace, get_ontology, destroy_entity,\n                       sync_reasoner_pellet, sync_reasoner_hermit,\n                       OwlReadyOntologyParsingError)\nfrom owlready2.class_construct import GeneralClassAxiom\n\nfrom ..datastructures.enums import ObjectType\nfrom ..helper import Singleton\nfrom ..designator import DesignatorDescription, ObjectDesignatorDescription\n\nfrom ..ontology.ontology_common import (OntologyConceptHolderStore, OntologyConceptHolder,\n                                        ONTOLOGY_SQL_BACKEND_FILE_EXTENSION)\n\nSOMA_HOME_ONTOLOGY_IRI = \"http://www.ease-crc.org/ont/SOMA-HOME.owl\"\nSOMA_ONTOLOGY_IRI = \"http://www.ease-crc.org/ont/SOMA.owl\"\nSOMA_ONTOLOGY_NAMESPACE = \"SOMA\"\nDUL_ONTOLOGY_NAMESPACE = \"DUL\"\n\n\nclass OntologyManager(object, metaclass=Singleton):\n    \"\"\"\n    Singleton class as the adapter accessing data of an OWL ontology, largely based on owlready2.\n    \"\"\"\n\n    def __init__(self, main_ontology_iri: Optional[str] = None, ontology_search_path: Optional[str] = None,\n                 use_global_default_world: bool = True):\n        \"\"\"\n        Create the singleton object of OntologyManager class\n\n        :param main_ontology_iri: Ontology IRI (Internationalized Resource Identifier), either a URL to a remote OWL file or the full name path of a local one\n        :param ontology_search_path: directory path from which a possibly existing ontology is searched. This is appended to `owlready2.onto_path`, a global variable containing a list of directories for searching local copies of ontologies (similarly to python `sys.path` for modules/packages). If not specified, the path is \"$HOME/ontologies\"\n        :param use_global_default_world: whether or not using the owlready2-provided global default persistent world\n        \"\"\"\n        if not ontology_search_path:\n            ontology_search_path = f\"{Path.home()}/ontologies\"\n        Path(ontology_search_path).mkdir(parents=True, exist_ok=True)\n        onto_path.append(ontology_search_path)\n\n        #: A dictionary of OWL ontologies, keyed by ontology name (same as its namespace name), eg. 'SOMA'\n        self.ontologies: Dict[str, Ontology] = {}\n\n        #: The main ontology instance created by Ontology Manager at initialization as the result of loading from `main_ontology_iri`\n        self.main_ontology: Optional[Ontology] = None\n\n        #: The SOMA ontology instance, referencing :attr:`main_ontology` in case of ontology loading from `SOMA.owl`.\n        # Ref: http://www.ease-crc.org/ont/SOMA.owl\n        self.soma: Optional[Ontology] = None\n\n        #: The DUL ontology instance, referencing :attr:`main_ontology` in case of ontology loading from `DUL.owl`.\n        # Ref: http://www.ease-crc.org/ont/DUL.owl\n        self.dul: Optional[Ontology] = None\n\n        #: The main ontology world, the placeholder of triples created in :attr:`main_ontology`.\n        # Ref: https://owlready2.readthedocs.io/en/latest/world.html\n        self.main_ontology_world: Optional[OntologyWorld] = None\n\n        #: Ontology IRI (Internationalized Resource Identifier), either a URL to a remote OWL file or the full name path of a local one\n        # Ref: https://owlready2.readthedocs.io/en/latest/onto.html\n        self.main_ontology_iri: str = main_ontology_iri if main_ontology_iri else SOMA_HOME_ONTOLOGY_IRI\n\n        #: Namespace of the main ontology\n        self.main_ontology_namespace: Optional[Namespace] = None\n\n        # Create the main ontology world holding triples\n        self.create_main_ontology_world(use_global_default_world=use_global_default_world)\n\n        # Create the main ontology & its namespace, fetching :attr:`soma`, :attr:`dul` if loading from SOMA ontology\n        self.create_main_ontology()\n\n    @staticmethod\n    def print_ontology_class(ontology_class: Type[Thing]):\n        \"\"\"\n        Print information (ancestors, super classes, subclasses, properties, etc.) of an ontology class\n\n        :param ontology_class: An ontology class\n        \"\"\"\n        if ontology_class is None:\n            return\n        rospy.loginfo(f\"{ontology_class} {type(ontology_class)}\")\n        rospy.loginfo(f\"Defined class: {ontology_class.get_defined_class()}\")\n        rospy.loginfo(f\"Super classes: {ontology_class.is_a}\")\n        rospy.loginfo(f\"Equivalent to: {EntityClass.get_equivalent_to(ontology_class)}\")\n        rospy.loginfo(f\"Indirectly equivalent to: {ontology_class.get_indirect_equivalent_to()}\")\n        rospy.loginfo(f\"Ancestors: {list(ontology_class.ancestors())}\")\n        rospy.loginfo(f\"Subclasses: {list(ontology_class.subclasses())}\")\n        rospy.loginfo(f\"Disjoint unions: {ontology_class.get_disjoint_unions()}\")\n        rospy.loginfo(f\"Properties: {list(ontology_class.get_class_properties())}\")\n        rospy.loginfo(f\"Indirect Properties: {list(ontology_class.INDIRECT_get_class_properties())}\")\n        rospy.loginfo(f\"Instances: {list(ontology_class.instances())}\")\n        rospy.loginfo(f\"Direct Instances: {list(ontology_class.direct_instances())}\")\n        rospy.loginfo(f\"Inverse Restrictions: {list(ontology_class.inverse_restrictions())}\")\n        rospy.loginfo(\"-------------------\")\n\n    @staticmethod\n    def print_ontology_property(ontology_property: Property):\n        \"\"\"\n        Print information (subjects, objects, relations, etc.) of an ontology property\n\n        :param ontology_property: An ontology property\n        \"\"\"\n        if ontology_property is None:\n            return\n        property_class = type(ontology_property)\n        rospy.loginfo(f\"{ontology_property} {property_class}\")\n        rospy.loginfo(f\"Relations: {list(ontology_property.get_relations())}\")\n        rospy.loginfo(f\"Domain: {ontology_property.get_domain()}\")\n        rospy.loginfo(f\"Range: {ontology_property.get_range()}\")\n        if hasattr(property_class, \"_equivalent_to\"):\n            rospy.loginfo(f\"Equivalent classes: {EntityClass.get_equivalent_to(property_class)}\")\n        if hasattr(property_class, \"_indirect\"):\n            rospy.loginfo(f\"Indirectly equivalent classes: {EntityClass.get_indirect_equivalent_to(property_class)}\")\n        rospy.loginfo(f\"Property chain: {ontology_property.get_property_chain()}\")\n        rospy.loginfo(f\"Class property type: {ontology_property.get_class_property_type()}\")\n        rospy.loginfo(\"-------------------\")\n\n    @staticmethod\n    def get_default_ontology_search_path() -> Optional[str]:\n        \"\"\"\n        Get the first ontology search path from owlready2.onto_path\n\n        :return: the path to the ontology search path if existing, otherwise None\n        \"\"\"\n        if onto_path:\n            return onto_path[0]\n        else:\n            rospy.logerr(\"No ontology search path has been configured!\")\n            return None\n\n    def get_main_ontology_dir(self) -> Optional[str]:\n        \"\"\"\n        Get path to the directory of :attr:`main_ontology_iri` if it is a local absolute path,\n        otherwise path to the default ontology search directory\n\n        :return: the path to the directory of the main ontology IRI\n        \"\"\"\n        return os.path.dirname(self.main_ontology_iri) if os.path.isabs(\n            self.main_ontology_iri) else self.get_default_ontology_search_path()\n\n    def create_main_ontology_world(self, use_global_default_world: bool = True) -> None:\n        \"\"\"\n        Create the main ontology world, either reusing the owlready2-provided global default ontology world or create a new one\n        A backend sqlite3 file of same name with `main_ontology` is also created at the same folder with :attr:`main_ontology_iri`\n        (if it is a local absolute path). The file is automatically registered as cache for the main ontology world.\n\n        :param use_global_default_world: whether or not using the owlready2-provided global default persistent world\n        \"\"\"\n        self.main_ontology_world = self.create_ontology_world(\n            sql_backend_filename=os.path.join(self.get_main_ontology_dir(),\n                                              f\"{Path(self.main_ontology_iri).stem}{ONTOLOGY_SQL_BACKEND_FILE_EXTENSION}\"),\n            use_global_default_world=use_global_default_world)\n\n    @staticmethod\n    def create_ontology_world(use_global_default_world: bool = False,\n                              sql_backend_filename: Optional[str] = None) -> OntologyWorld:\n        \"\"\"\n        Either reuse the owlready2-provided global default ontology world or create a new one\n\n        :param use_global_default_world: whether or not using the owlready2-provided global default persistent world\n        :param sql_backend_filename: a full file path (no need to already exist) being used as SQL backend for the ontology world. If None, memory is used instead\n        :return: owlready2-provided global default ontology world or a newly created ontology world\n        \"\"\"\n        world = default_world\n        sql_backend_path_valid = sql_backend_filename and os.path.isabs(sql_backend_filename)\n        sql_backend_name = sql_backend_filename if sql_backend_path_valid else \"memory\"\n        if use_global_default_world:\n            # Reuse default world\n            if sql_backend_path_valid:\n                world.set_backend(filename=sql_backend_filename, exclusive=False, enable_thread_parallelism=True)\n            else:\n                world.set_backend(exclusive=False, enable_thread_parallelism=True)\n            rospy.loginfo(f\"Using global default ontology world with SQL backend: {sql_backend_name}\")\n        else:\n            # Create a new world with parallelized file parsing enabled\n            if sql_backend_path_valid:\n                world = OntologyWorld(filename=sql_backend_filename, exclusive=False, enable_thread_parallelism=True)\n            else:\n                world = OntologyWorld(exclusive=False, enable_thread_parallelism=True)\n            rospy.loginfo(f\"Created a new ontology world with SQL backend: {sql_backend_name}\")\n        return world\n\n    def create_main_ontology(self) -> bool:\n        \"\"\"\n        Load ontologies from :attr:`main_ontology_iri` to :attr:`main_ontology_world`\n        If `main_ontology_iri` is a remote URL, Owlready2 first searches for a local copy of the OWL file (from `onto_path`),\n        if not found, tries to download it from the Internet.\n\n        :return: True if loading succeeds\n        \"\"\"\n        ontology_info = self.load_ontology(self.main_ontology_iri)\n        if ontology_info:\n            self.main_ontology, self.main_ontology_namespace = ontology_info\n            if self.main_ontology and self.main_ontology.loaded:\n                self.soma = self.ontologies.get(SOMA_ONTOLOGY_NAMESPACE)\n                self.dul = self.ontologies.get(DUL_ONTOLOGY_NAMESPACE)\n        return ontology_info is not None\n\n    def load_ontology(self, ontology_iri: str) -> Optional[Tuple[Ontology, Namespace]]:\n        \"\"\"\n        Load an ontology from an IRI\n\n        :param ontology_iri: An ontology IRI\n        :return: A tuple including an ontology instance & its namespace\n        \"\"\"\n        if not ontology_iri:\n            rospy.logerr(\"Ontology IRI is empty\")\n            return None\n\n        is_local_ontology_iri = not (ontology_iri.startswith(\"http:\") or ontology_iri.startswith(\"https:\"))\n\n        # If `ontology_iri` is a local path\n        if is_local_ontology_iri and not Path(ontology_iri).exists():\n            # -> Create an empty ontology file if not existing\n            with open(ontology_iri, 'w'):\n                pass\n\n        # Load ontology from `ontology_iri`\n        ontology = None\n        try:\n            if self.main_ontology_world:\n                ontology = self.main_ontology_world.get_ontology(ontology_iri).load(reload_if_newer=True)\n            else:\n                ontology = get_ontology(ontology_iri).load(reload_if_newer=True)\n        except OwlReadyOntologyParsingError as error:\n            rospy.logwarn(error)\n            if is_local_ontology_iri:\n                rospy.logerr(f\"Main ontology failed being loaded from {ontology_iri}\")\n            else:\n                rospy.logwarn(f\"Main ontology failed being downloaded from the remote {ontology_iri}\")\n            return None\n\n        # Browse loaded `ontology`, fetching sub-ontologies\n        ontology_namespace = get_namespace(ontology_iri)\n        if ontology and ontology.loaded:\n            rospy.loginfo(\n                f'Ontology [{ontology.base_iri}]\\'s name: {ontology.name} has been loaded')\n            rospy.loginfo(f'- main namespace: {ontology_namespace.name}')\n            rospy.loginfo(f'- loaded ontologies:')\n\n            def fetch_ontology(ontology__):\n                self.ontologies[ontology__.name] = ontology__\n                rospy.loginfo(ontology__.base_iri)\n\n            self.browse_ontologies(ontology, condition=None, func=lambda ontology__: fetch_ontology(ontology__))\n        else:\n            rospy.logerr(f\"Ontology [{ontology.base_iri}]\\'s name: {ontology.name} failed being loaded\")\n        return ontology, ontology_namespace\n\n    def initialized(self) -> bool:\n        \"\"\"\n        Check if the main ontology has been loaded\n\n        :return: True if loaded, otherwise False\n        \"\"\"\n        return hasattr(self, \"main_ontology\") and self.main_ontology and self.main_ontology.loaded\n\n    @staticmethod\n    def browse_ontologies(ontology: Ontology,\n                          condition: Optional[Callable] = None, func: Optional[Callable] = None, **kwargs) -> None:\n        \"\"\"\n        Browse the loaded ontologies (including the main and imported ones), doing operations based on a condition.\n\n        :param ontology: An ontology instance as the result of ontology loading\n        :param condition: a Callable condition that if not None needs to be passed before doing operations, otherwise just always carry the operations\n        :param func: a Callable specifying the operations to perform on all the loaded ontologies if condition is None, otherwise only the first ontology which meets the condition\n        \"\"\"\n        if ontology is None:\n            rospy.logerr(f\"Ontology {ontology=} is None!\")\n            return\n        elif not ontology.loaded:\n            rospy.logerr(f\"Ontology {ontology} was not loaded!\")\n            return\n\n        will_do_func = func is not None\n        # No condition: Do func for all ontologies\n        if condition is None:\n            if will_do_func:\n                func(ontology, **kwargs)\n                for sub_onto in ontology.get_imported_ontologies():\n                    func(sub_onto, **kwargs)\n        # Else: Only do func for the first ontology which meets the condition\n        elif condition(ontology, **kwargs):\n            if will_do_func: func(ontology, **kwargs)\n        else:\n            for sub_onto in ontology.get_imported_ontologies():\n                if condition(sub_onto, **kwargs) and will_do_func:\n                    func(sub_onto, **kwargs)\n                    break\n\n    def save(self, target_filename: Optional[str] = None, overwrite: bool = False) -> bool:\n        \"\"\"\n        Save :attr:`main_ontology` to a file on disk, also caching :attr:`main_ontology_world` to a sqlite3 file\n\n        :param target_filename: full name path of a file which the ontologies are saved into.\n        :param overwrite: overwrite an existing file if it exists. If empty, they are saved to the same original OWL file from which the main ontology was loaded, or a file at the same folder with ontology search path specified at constructor if it was loaded from a remote IRI.\n        :return: True if the ontology was successfully saved, False otherwise\n        \"\"\"\n\n        # Save ontologies to OWL\n        is_current_ontology_local = os.path.isfile(self.main_ontology_iri)\n        current_ontology_filename = self.main_ontology_iri if is_current_ontology_local \\\n            else f\"{self.get_main_ontology_dir()}/{Path(self.main_ontology_iri).name}\"\n        save_to_same_file = is_current_ontology_local and (target_filename == current_ontology_filename)\n        if save_to_same_file and not overwrite:\n            rospy.logerr(\n                f\"Ontologies cannot be saved to the originally loaded [{target_filename}] if not by overwriting\")\n            return False\n        else:\n            save_filename = target_filename if target_filename else current_ontology_filename\n            self.main_ontology.save(save_filename)\n            if save_to_same_file and overwrite:\n                rospy.logwarn(f\"Main ontology {self.main_ontology.name} has been overwritten to {save_filename}\")\n            else:\n                rospy.loginfo(f\"Main ontology {self.main_ontology.name} has been saved to {save_filename}\")\n\n            # Commit the whole graph data of the current ontology world, saving it into SQLite3, to be reused the next time\n            # the ontologies are loaded\n            main_ontology_sql_filename = self.main_ontology_world.filename\n            self.main_ontology_world.save()\n            if os.path.isfile(main_ontology_sql_filename):\n                rospy.loginfo(\n                    f\"Main ontology world for {self.main_ontology.name} has been cached and saved to SQL: {main_ontology_sql_filename}\")\n            #else: it could be using memory cache as SQL backend\n            return True\n\n    def create_ontology_concept_class(self, class_name: str,\n                                      ontology_parent_concept_class: Optional[Thing] = None,\n                                      ontology: Optional[Ontology] = None) \\\n            -> Optional[Type[Thing]]:\n        \"\"\"\n        Create a new concept class in a given ontology\n\n        :param class_name: A given name to the new class\n        :param ontology_parent_concept_class: An optional parent ontology class of the new class\n        :param ontology: an owlready2.Ontology in which the concept class is created\n        :return: The created ontology class\n        \"\"\"\n        ontology = ontology if ontology else self.main_ontology\n        ontology_concept_class = self.get_ontology_class_by_ontology(ontology, class_name)\n        if ontology_concept_class:\n            return ontology_concept_class\n\n        if getattr(ontology, class_name, None):\n            rospy.logerr(f\"Ontology concept class {ontology.name}.{class_name} already exists\")\n            return None\n\n        with ontology:\n            return types.new_class(class_name, (Thing, ontology_parent_concept_class,)\n            if inspect.isclass(ontology_parent_concept_class) else (Thing,))\n\n    def create_ontology_property_class(self, class_name: str,\n                                       ontology_parent_property_class: Optional[Type[Property]] = None,\n                                       ontology: Optional[Ontology] = None) \\\n            -> Optional[Type[Property]]:\n        \"\"\"\n        Create a new property class in a given ontology\n\n        :param class_name: A given name to the new class\n        :param ontology_parent_property_class: An optional parent ontology property class of the new class\n        :param ontology: an owlready2.Ontology in which the concept class is created\n        :return: The created ontology class\n        \"\"\"\n        ontology = ontology if ontology else self.main_ontology\n        parent_class = ontology_parent_property_class if (ontology_parent_property_class and\n                                                          issubclass(ontology_parent_property_class,\n                                                                     Property)) \\\n            else None\n\n        if getattr(ontology, class_name, None):\n            rospy.logerr(f\"Ontology property class {ontology.name}.{class_name} already exists\")\n            return None\n\n        with ontology:\n            return types.new_class(class_name, (parent_class,) if parent_class else (Property,))\n\n    def get_ontology_classes_by_condition(self, condition: Callable, first_match_only=False, **kwargs) \\\n            -> List[Type[Thing]]:\n        \"\"\"\n        Get an ontology class by a given condition\n\n        :param condition: condition of searching\n        :param first_match_only: whether to only fetch the first class matching the given condition\n        :return: The ontology class satisfying the given condition if found else None\n        \"\"\"\n        out_classes = []\n        for ontology_class in list(self.main_ontology.classes()):\n            if condition(ontology_class, **kwargs):\n                out_classes.append(ontology_class)\n                if first_match_only:\n                    return out_classes\n\n        for sub_onto in self.main_ontology.get_imported_ontologies():\n            for sub_ontology_class in list(sub_onto.classes()):\n                if condition(sub_ontology_class, **kwargs):\n                    out_classes.append(sub_ontology_class)\n                    if first_match_only:\n                        return out_classes\n\n        if not out_classes:\n            rospy.loginfo(f\"No class with {kwargs} is found in the ontology {self.main_ontology}\")\n        return out_classes\n\n    @staticmethod\n    def get_ontology_class_by_ontology(ontology: Ontology, class_name: str) -> Optional[Type[Thing]]:\n        \"\"\"\n        Get an ontology class if it exists in a given ontology\n\n        :param ontology: an ontology instance\n        :param class_name: name of the searched-for ontology class\n        :return: The ontology class if it exists under the namespace of the given ontology, None otherwise\n        \"\"\"\n        return getattr(ontology, class_name, None) if ontology else None\n\n    def get_ontology_class(self, class_name: str) -> Optional[Type[Thing]]:\n        \"\"\"\n        Get an ontology class by name\n\n        :param class_name: name of the searched-for ontology class\n        :return: The ontology class of the given name if existing else None\n        \"\"\"\n\n        def is_matching_class_name(ontology_class: Type[Thing], ontology_class_name: str):\n            return ontology_class.name == ontology_class_name\n\n        found_classes = self.get_ontology_classes_by_condition(condition=is_matching_class_name,\n                                                               ontology_class_name=class_name,\n                                                               first_match_only=True)\n        return found_classes[0] if len(found_classes) > 0 else None\n\n    def get_ontology_classes_by_namespace(self, ontology_namespace: str) -> List[Type[Thing]]:\n        \"\"\"\n        Get all ontologies classes by namespace\n\n        :param ontology_namespace: namespace of the searched-for ontology classes\n        :return: A list of the ontology classes under the given namespace\n        \"\"\"\n\n        def is_matching_ontology_namespace(ontology_class: Type[Thing], ontology_namespace_: str):\n            return ontology_class.namespace.name == ontology_namespace_\n\n        return self.get_ontology_classes_by_condition(condition=is_matching_ontology_namespace,\n                                                      ontology_namespace_=ontology_namespace)\n\n    def get_ontology_classes_by_subname(self, class_subname: str) -> List[Type[Thing]]:\n        \"\"\"\n        Get all ontologies classes by subname\n\n        :param class_subname: a string as part of the full names of the searched-for ontology classes\n        :return: A list of the ontology classes of which the name contains the given subname\n        \"\"\"\n\n        def is_matching_class_subname(ontology_class: Type[Thing], ontology_class_subname: str):\n            return ontology_class_subname.lower() in ontology_class.name.lower()\n\n        return self.get_ontology_classes_by_condition(condition=is_matching_class_subname,\n                                                      ontology_class_subname=class_subname)\n\n    def get_ontology_descendant_classes(self, ancestor_class: Type[Thing], class_subname: str = \"\") \\\n            -> List[Type[Thing]]:\n        \"\"\"\n        Get ontology descendant classes of an ancestor class given descendant class subname\n\n        :param class_subname: a string as part of the ancestor class full name\n        :return: A list of the ontology descendant classes\n        \"\"\"\n        return [ontology_class for ontology_class in self.main_ontology.classes()\n                if (class_subname.lower() in ontology_class.name.lower()) and\n                (ancestor_class in ontology_class.ancestors())]\n\n    def get_ontology_general_class_axioms(self, ontology: Optional[Ontology] = None) -> List[GeneralClassAxiom]:\n        \"\"\"\n        Get general class axioms of an ontology\n        Ref: https://owlready2.readthedocs.io/en/latest/general_class_axioms.html\n\n        :param ontology: an ontology instance\n        :return: A list of ontology axioms in the ontology\n        \"\"\"\n        ontology = ontology if ontology else self.main_ontology\n        return list(ontology.general_class_axioms())\n\n    def create_ontology_triple_classes(self, subject_class_name: str, object_class_name: str,\n                                       predicate_class_name: str, inverse_predicate_class_name: Optional[str] = None,\n                                       predicate_python_attribute_name: Optional[str] = None,\n                                       inverse_predicate_python_attribute_name: Optional[str] = None,\n                                       ontology_subject_parent_class: Optional[Type[Thing]] = None,\n                                       ontology_object_parent_class: Optional[Type[Union[Thing, object]]] = None,\n                                       ontology_property_parent_class: Type[Property] = ObjectProperty,\n                                       ontology_inverse_property_parent_class: Type[Property] = ObjectProperty,\n                                       ontology: Optional[Ontology] = None) -> bool:\n        \"\"\"\n        Dynamically create ontology triple classes under same namespace with the main ontology,\n        as known as {subject, predicate, object}, with the relations among them\n\n        :param subject_class_name: name of the subject class\n        :param object_class_name: name of the object class\n        :param predicate_class_name: name of predicate class, also used as a Python attribute of the subject class to query object instances\n        :param predicate_python_attribute_name: python attribute name designated for the predicate instance\n        :param inverse_predicate_class_name: name of inverse predicate\n        :param inverse_predicate_python_attribute_name: python attribute name designated for the inverse predicate instance\n        :param ontology_subject_parent_class: a parent class of the subject class\n        :param ontology_object_parent_class: a parent class of the object class\n        :param ontology_property_parent_class: a parent ontology property class, default: owlready2.ObjectProperty\n        :param ontology_inverse_property_parent_class: a parent ontology inverse property class, default: owlready2.ObjectProperty\n        :param ontology: an owlready2.Ontology in which triples are created\n        :return: True if the ontology triple classes are created successfully\n        \"\"\"\n\n        if not predicate_python_attribute_name:\n            predicate_python_attribute_name = predicate_class_name\n        if not inverse_predicate_python_attribute_name:\n            inverse_predicate_python_attribute_name = inverse_predicate_class_name\n        ontology = ontology if ontology else self.main_ontology\n\n        # This context manager ensures all classes created here-in share the same namepsace with `self.main_ontology`\n        with ontology:\n            # Subject\n            ontology_subject_class = self.create_ontology_concept_class(subject_class_name,\n                                                                        ontology_subject_parent_class,\n                                                                        ontology=ontology)\n            if not ontology_subject_class:\n                rospy.logerr(f\"{ontology.name}: Failed creating ontology subject class named {subject_class_name}\")\n                return False\n\n            # Object\n            if not ontology_object_parent_class or issubclass(ontology_object_parent_class, Thing):\n                ontology_object_class = self.create_ontology_concept_class(object_class_name,\n                                                                           ontology_object_parent_class,\n                                                                           ontology=ontology) \\\n                    if (object_class_name != subject_class_name) else ontology_subject_class\n            else:\n                ontology_object_class = ontology_object_parent_class\n\n            if not ontology_object_class:\n                rospy.logerr(f\"{ontology.name}: Failed creating ontology object class named {object_class_name}\")\n                return False\n\n            # Predicate\n            ontology_predicate_class = self.create_ontology_property_class(predicate_class_name,\n                                                                           ontology_property_parent_class,\n                                                                           ontology=ontology)\n            if not ontology_predicate_class:\n                rospy.logerr(f\"{ontology.name}: Failed creating ontology predicate class named {predicate_class_name}\")\n                return False\n            ontology_predicate_class.domain = [ontology_subject_class]\n            ontology_predicate_class.range = [ontology_object_class]\n            ontology_predicate_class.python_name = predicate_python_attribute_name\n\n            # Inverse Predicate\n            if inverse_predicate_class_name:\n                ontology_inverse_predicate_class = self.create_ontology_property_class(inverse_predicate_class_name,\n                                                                                       ontology_inverse_property_parent_class,\n                                                                                       ontology=ontology)\n                if not ontology_inverse_predicate_class:\n                    rospy.logerr(\n                        f\"{ontology.name}: Failed creating ontology inverse-predicate class named {inverse_predicate_class_name}\")\n                    return False\n                ontology_inverse_predicate_class.inverse_property = ontology_predicate_class\n                ontology_inverse_predicate_class.domain = [ontology_object_class]\n                ontology_inverse_predicate_class.range = [ontology_subject_class]\n                ontology_inverse_predicate_class.python_name = inverse_predicate_python_attribute_name\n        return True\n\n    def create_ontology_linked_designator(self, designator_class: Type[DesignatorDescription],\n                                          ontology_concept_name: str,\n                                          object_name: str,\n                                          ontology_parent_class: Optional[Type[Thing]] = None) \\\n            -> Optional[DesignatorDescription]:\n        \"\"\"\n        Create a designator linked to a given ontology concept\n\n        :param designator_class: A given designator class\n        :param ontology_concept_name: Ontology concept name\n        :param object_name: Name of object in case of the designator to be created is an Object Designator\n        :param ontology_parent_class: Parent ontology class from which the class of designator inherits\n        :return: A designator associated with an ontology concept\n        \"\"\"\n        ontology_concept_class = self.create_ontology_concept_class(ontology_concept_name, ontology_parent_class)\n        return self.create_ontology_linked_designator_by_concept(designator_class=designator_class,\n                                                                 ontology_concept_class=ontology_concept_class,\n                                                                 object_name=object_name)\n\n    def create_ontology_linked_designator_by_concept(self, designator_class: Type[DesignatorDescription],\n                                                     ontology_concept_class: Type[Thing],\n                                                     object_name: str) \\\n            -> Optional[DesignatorDescription]:\n        \"\"\"\n        Create a designator that belongs to a given ontology concept class\n\n        :param designator_class: A given designator class\n        :param ontology_concept_class: An ontology concept class with which the output designator is associated\n        :param object_name: Name of object in case of the designator to be created is an Object Designator\n        :return: An object designator associated with the given ontology concept class if created successfully (not already exists), None otherwise\n        \"\"\"\n        ontology_concept_name = f'{object_name}_concept'\n        if len(OntologyConceptHolderStore().get_designators_of_ontology_concept(ontology_concept_name)) > 0:\n            rospy.logerr(\n                f\"A designator named [{object_name}] is already created for ontology concept [{ontology_concept_name}]\")\n            return None\n\n        # Create a designator of `designator_class`\n        is_object_designator = issubclass(designator_class, ObjectDesignatorDescription)\n        if is_object_designator:\n            if not object_name:\n                rospy.logerr(\n                    f\"An empty object name was given as creating its Object designator for ontology concept class [{ontology_concept_class.name}]\")\n                return None\n            designator = designator_class(names=[object_name])\n        else:\n            designator = designator_class()\n\n        # Link designator with an ontology concept of `ontology_concept_class`\n        ontology_concept_holder = OntologyConceptHolderStore().get_ontology_concept_holder_by_name(\n            ontology_concept_name)\n        if ontology_concept_holder is None:\n            ontology_concept_holder = OntologyConceptHolder(ontology_concept_class(name=ontology_concept_name,\n                                                                                   namespace=self.main_ontology))\n        self.set_ontology_concept_designator_connection(designator, ontology_concept_holder)\n        return designator\n\n    @staticmethod\n    def set_ontology_concept_designator_connection(designator: DesignatorDescription,\n                                                   ontology_concept_holder: OntologyConceptHolder) -> None:\n        \"\"\"\n        Set two-way connection between a designator and an ontology concept\n\n        :param designator: Designator\n        :param ontology_concept_holder: Ontology concept holder\n        \"\"\"\n        if ontology_concept_holder not in designator.ontology_concept_holders:\n            designator.ontology_concept_holders.append(ontology_concept_holder)\n\n        if not ontology_concept_holder.has_designator(designator):\n            ontology_concept_holder.designators.append(designator)\n\n    @staticmethod\n    def set_ontology_relation(subject_designator: DesignatorDescription,\n                              object_designator: DesignatorDescription,\n                              predicate_name: str) -> bool:\n        \"\"\"\n        Set ontology relation between subject and object designators\n\n        :param subject_designator: An object designator as the ontology subject\n        :param object_designator: An object designator as the ontology object\n        :param predicate_name: Name of the predicate\n        :return: True if the relation is set, False otherwise\n        \"\"\"\n        for subject_concept_holder in subject_designator.ontology_concept_holders:\n            subject_concept = subject_concept_holder.ontology_concept\n            if hasattr(subject_concept, predicate_name):\n                object_concepts_list = getattr(subject_concept, predicate_name)\n                object_concepts_names = [concept.name for concept in object_concepts_list]\n                for holder in object_designator.ontology_concept_holders:\n                    if holder.ontology_concept.name not in object_concepts_names:\n                        object_concepts_list.append(holder.ontology_concept)\n                return True\n            else:\n                rospy.logerr(f\"Ontology concept [{subject_concept.name}] has no predicate named [{predicate_name}]\")\n                return False\n\n    @staticmethod\n    def get_designators_by_subject_predicate(subject: DesignatorDescription,\n                                             predicate_name: str) -> List[DesignatorDescription]:\n        \"\"\"\n        Get list of designators of an ontology-object concept given a subject designator and predicate\n\n        :param subject: The ontology-subject designator\n        :param predicate_name: The ontology-predicate name of the relation\n        :return: List of object designators\n        \"\"\"\n        return list(itertools.chain(\n            *[OntologyConceptHolderStore().get_designators_of_ontology_concept(object_concept.name)\n              for subject_concept_holder in subject.ontology_concept_holders\n              for object_concept in getattr(subject_concept_holder.ontology_concept, predicate_name, [])]))\n\n    def create_ontology_object_designator_from_type(self, object_type: ObjectType,\n                                                    ontology_concept_class: Type[Thing]) \\\n            -> Optional[ObjectDesignatorDescription]:\n        \"\"\"\n        Create an object designator associated with an ontology concept class from a given object type\n\n        :param object_type: An enumerated type of object\n        :param ontology_concept_class: An ontology concept class\n        :return: An object designator if created successfully (if not already existing), otherwise None\n        \"\"\"\n        object_type_name = object_type.name.lower()\n        object_designator = \\\n            self.create_ontology_linked_designator_by_concept(designator_class=ObjectDesignatorDescription,\n                                                              ontology_concept_class=ontology_concept_class,\n                                                              object_name=object_type_name)\n        object_designator.types = [object_type_name]\n        return object_designator\n\n    @staticmethod\n    def destroy_ontology_class(ontology_class, destroy_instances: bool = True):\n        \"\"\"\n        Destroy all classes of an ontology\n\n        :param ontology_class: The ontology class to be destroyed\n        :param destroy_instances: Whether to destroy instances of those ontology classes\n        \"\"\"\n        if destroy_instances:\n            for ontology_individual in ontology_class.instances():\n                destroy_entity(ontology_individual)\n            OntologyConceptHolderStore().remove_ontology_concept(ontology_class.name)\n        destroy_entity(ontology_class)\n\n    def create_rule_reflexivity(self, ontology_concept_class_name: str,\n                                predicate_name: str,\n                                ontology: Optional[Ontology] = None) -> Imp:\n        \"\"\"\n        Create the rule of reflexivity for a given ontology concept class.\n        Same effect is obtained by creating a dynamic ontology predicate class, subclassing owlready2.ReflexiveProperty.\n        Ref: https://en.wikipedia.org/wiki/Reflexive_relation\n\n        :param ontology_concept_class_name: Name of the ontology concept class having the relation defined\n        :param predicate_name: Name of the ontology predicate signifying the reflexive relation\n        :param ontology: The ontology for which the rule is created\n        :return: Rule of transitivity\n        \"\"\"\n        ontology = ontology if ontology else self.main_ontology\n        with ontology:\n            rule = Imp()\n            rule.set_as_rule(f\"\"\"{ontology_concept_class_name}(?a)\n                                 -> {predicate_name}(?a, ?a)\"\"\")\n            return rule\n\n    def create_rule_symmetry(self, ontology_concept_class_name: str,\n                             predicate_name: str,\n                             ontology: Optional[Ontology] = None) -> Imp:\n        \"\"\"\n        Create the rule of transitivity for a given ontology concept class.\n        Same effect is obtained by creating a dynamic ontology predicate class, subclassing owlready2.SymmetricProperty.\n        Ref: https://en.wikipedia.org/wiki/Symmetric_relation\n\n        :param ontology_concept_class_name: Name of the ontology concept class having the relation defined\n        :param predicate_name: Name of the ontology predicate signifying the symmetric relation\n        :param ontology: The ontology for which the rule is created\n        :return: Rule of symmetry\n        \"\"\"\n        ontology = ontology if ontology else self.main_ontology\n        with ontology:\n            rule = Imp()\n            rule.set_as_rule(f\"\"\"{ontology_concept_class_name}(?a), {ontology_concept_class_name}(?b),\n                                 {predicate_name}(?a, ?b)\n                                 -> {predicate_name}(?b, ?a)\"\"\")\n            return rule\n\n    def create_rule_transitivity(self, ontology_concept_class_name: str,\n                                 predicate_name: str,\n                                 ontology: Optional[Ontology] = None) -> Imp:\n        \"\"\"\n        Create the rule of transitivity for a given ontology concept class.\n        Same effect is obtained by creating a dynamic ontology predicate class, subclassing owlready2.TransitiveProperty.\n        Ref:\n        - https://en.wikipedia.org/wiki/Transitive_relation\n        - https://owlready2.readthedocs.io/en/latest/properties.html#obtaining-indirect-relations-considering-subproperty-transitivity-etc\n\n        :param ontology_concept_class_name: Name of the ontology concept class having the relation defined\n        :param predicate_name: Name of the ontology predicate signifying the transitive relation\n        :param ontology: The ontology for which the rule is created\n        :return: Rule of transitivity\n        \"\"\"\n        ontology = ontology if ontology else self.main_ontology\n        with ontology:\n            rule = Imp()\n            rule.set_as_rule(\n                f\"\"\"{ontology_concept_class_name}(?a), {ontology_concept_class_name}(?b), {ontology_concept_class_name}(?c),\n                                 {predicate_name}(?a, ?b),\n                                 {predicate_name}(?b, ?c)\n                                 -> {predicate_name}(?a, ?c)\"\"\")\n            return rule\n\n    def reason(self, world: OntologyWorld = None, use_pellet_reasoner: bool = True) -> bool:\n        \"\"\"\n        Run the reasoning on a given ontology world or :attr:`main_ontology_world` with Pellet or HermiT reasoner,\n        the two currently supported by owlready2\n        - By default, the reasoning works on `owlready2.default_world`\n        - The reasoning also automatically save ontologies (to either in-memory cache or a temporary sqlite3 file)\n        Ref:\n        - https://owlready2.readthedocs.io/en/latest/reasoning.html\n        - https://owlready2.readthedocs.io/en/latest/rule.html\n        - https://www.researchgate.net/publication/200758993_Benchmarking_OWL_reasoners\n        - https://www.researchgate.net/publication/345959058_OWL2Bench_A_Benchmark_for_OWL_2_Reasoners\n\n        :param world: An owlready2.World to reason about. If None, use :attr:`main_ontology_world`\n        :param use_pellet_reasoner: Use Pellet reasoner, otherwise HermiT\n        :return: True if the reasoning was successful, otherwise False\n        \"\"\"\n        reasoner_name = None\n        reasoning_world = world if world else self.main_ontology_world\n        try:\n            if use_pellet_reasoner:\n                reasoner_name = \"Pellet\"\n                sync_reasoner_pellet(x=reasoning_world, infer_property_values=True,\n                                     infer_data_property_values=True)\n            else:\n                reasoner_name = \"HermiT\"\n                sync_reasoner_hermit(x=reasoning_world, infer_property_values=True)\n        except OwlReadyError as error:\n            rospy.logerr(f\"{reasoner_name} reasoning failed: {error}\")\n            return False\n        rospy.loginfo(f\"{reasoner_name} reasoning finishes!\")\n        return True\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the ontology_common.py file and how are they used in the project?"}, {"role": "assistant", "content": "# Content from: #<ontology_common.py>#\nfrom __future__ import annotations\n\nimport itertools\nfrom typing import Callable, Dict, List, Optional, Type, TYPE_CHECKING\nimport rospy\n\nfrom ..helper import Singleton\nif TYPE_CHECKING:\n    from ..designator import DesignatorDescription\n\nfrom owlready2 import issubclass, Thing\n\nONTOLOGY_SQL_BACKEND_FILE_EXTENSION = \".sqlite3\"\nONTOLOGY_OWL_FILE_EXTENSION = \".owl\"\n\n\nclass OntologyConceptHolderStore(object, metaclass=Singleton):\n    \"\"\"\n    Singleton class storing all instances of `OntologyConceptHolder`\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the OntologyConceptHolderStore\n        \"\"\"\n        # Dictionary of all ontology concept holders, keyed by concept names\n        self.__all_ontology_concept_holders: Dict[str, OntologyConceptHolder] = {}\n\n    def add_ontology_concept_holder(self, ontology_concept_name: str, ontology_concept_holder: OntologyConceptHolder)\\\n            -> bool:\n        \"\"\"\n        Add an ontology concept to the store\n\n        :param ontology_concept_name: Name of the ontology concept to be removed\n        :return: True if the ontology concept can be added into the concept store (if not already existing), otherwise False\n        \"\"\"\n        if ontology_concept_name in self.__all_ontology_concept_holders:\n            rospy.logerr(f\"OntologyConceptHolder for `{ontology_concept_name}` was already created!\")\n            return False\n        else:\n            self.__all_ontology_concept_holders.setdefault(ontology_concept_name, ontology_concept_holder)\n            return True\n\n    def remove_ontology_concept(self, ontology_concept_name: str) -> bool:\n        \"\"\"\n        Remove an ontology concept from the store\n\n        :param ontology_concept_name: Name of the ontology concept to be removed\n        :return: True if the ontology concept can be removed from the concept store (if existing), otherwise False\n        \"\"\"\n        if ontology_concept_name in self.__all_ontology_concept_holders:\n            del self.__all_ontology_concept_holders[ontology_concept_name]\n            return True\n        return False\n\n    def get_ontology_concepts_by_class(self, ontology_concept_class: Type[Thing]) -> List[Thing]:\n        \"\"\"\n        Get a list of ontology concepts for a given class\n\n        :param ontology_concept_class: An ontology concept class\n        :return: A list of ontology concepts of which the type is either the given class or its subclass\n        \"\"\"\n        return list(itertools.chain(\n            *[concept_holder.ontology_concept\n              for concept_holder in self.__all_ontology_concept_holders.values()\n              if issubclass(concept_holder.ontology_concept, ontology_concept_class)]))\n\n    def get_ontology_concept_by_name(self, ontology_concept_name: str) -> Optional[Thing]:\n        \"\"\"\n        Get the ontology concept of a given name if exists, otherwise None\n\n        :param ontology_concept_name: Name of an ontology concept\n        :return: The ontology concept of a given name if exists or None otherwise\n        \"\"\"\n        concept_holder = self.__all_ontology_concept_holders.get(ontology_concept_name)\n        return concept_holder.ontology_concept if concept_holder else None\n\n    def get_ontology_concept_holders_by_class(self, ontology_concept_class: Type[Thing]) \\\n            -> List[OntologyConceptHolder]:\n        \"\"\"\n        Get a list of ontology concept holders for a given ontology concept class\n\n        :param ontology_concept_class: An ontology concept class\n        :return: A list of ontology concept holders as instances of a given ontology concept class\n        \"\"\"\n        return [concept_holder for concept_holder in self.__all_ontology_concept_holders.values()\n                if isinstance(concept_holder.ontology_concept, ontology_concept_class)]\n\n    def get_ontology_concept_holder_by_name(self, ontology_concept_name: str) -> Optional[OntologyConceptHolder]:\n        \"\"\"\n        Get the ontology concept holder for one of a given name if exists, otherwise None\n\n        :param ontology_concept_name: Name of an ontology concept\n        :return: The ontology concept holder for one of a given name if exists, otherwise None\n        \"\"\"\n        return self.__all_ontology_concept_holders.get(ontology_concept_name)\n\n    @staticmethod\n    def get_ontology_concepts_of_designator(designator: DesignatorDescription) -> List[Thing]:\n        \"\"\"\n        Get the corresponding ontology concepts for a given designator\n\n        :param designator: A designator associated with an ontology concept\n        :return: A list of ontology concepts corresponding with a given designator\n        \"\"\"\n        return [concept_holder.ontology_concept for concept_holder in designator.ontology_concept_holders]\n\n    def get_designators_of_ontology_concept(self, ontology_concept_name: str) -> List[DesignatorDescription]:\n        \"\"\"\n        Get the corresponding designators associated with a given ontology concept\n\n        :param ontology_concept_name: An ontology concept name\n        :return: A list of designators corresponding to a given ontology concept\n        \"\"\"\n        return self.__all_ontology_concept_holders[ontology_concept_name].designators \\\n            if ontology_concept_name in self.__all_ontology_concept_holders else []\n\n\nclass OntologyConceptHolder(object):\n    \"\"\"\n    Wrapper of an ontology concept that is either dynamically created or loaded from an ontology.\n    NOTE: Since an ontology concept class, after being saved into an ontology file, must be reusable in the next time\n    the ontology is loaded, there must be no other attributes of it that should be created aside from ones inherited from `owlready2.Thing`!\n\n    :ivar ontology_concept: An ontology concept, either dynamically created, or loaded from an ontology\n    \"\"\"\n\n    def __init__(self, ontology_concept: Thing):\n        \"\"\"\n        Initialize a holder of a given ontology concept instance\n\n        :param ontology_concept: An ontology concept instance\n        \"\"\"\n\n        #: An ontology concept, either dynamically created, or loaded from an ontology\n        self.ontology_concept: Thing = ontology_concept\n        #: List of designators associated with this ontology concept\n        self.designators: List[DesignatorDescription] = []\n        # A callable used to resolve the designators to whatever of interest, like designators or their resolving results\n        self.resolve: Optional[Callable] = None\n\n        #: The store for all OntologyConceptHolder instances\n        self.concept_holder_store: OntologyConceptHolderStore = OntologyConceptHolderStore()\n        self.concept_holder_store.add_ontology_concept_holder(ontology_concept.name, self)\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Get name of the ontology concept owned by this holder\n\n        :return: Ontology concept name\n        \"\"\"\n        return self.ontology_concept.name if self.ontology_concept else \"\"\n\n    def get_default_designator(self) -> Optional[DesignatorDescription]:\n        \"\"\"\n        Get the first element of designators if there is, else None\n\n        :return: The first designator associated with the ontology concept held by this holder if exists or None\n        \"\"\"\n        return self.designators[0] if len(self.designators) > 0 else None\n\n    def has_designator(self, designator) -> bool:\n        \"\"\"\n        Check whether this ontology concept holder has a given designator registered with its ontology concept\n\n        :return: True if a given designator was registered by this ontology concept holder, either by itself or under another of the same name\n        \"\"\"\n        if designator in self.designators:\n            return True\n        if not hasattr(designator, \"name\"):\n            return False\n        for our_designator in self.designators:\n            if hasattr(our_designator, \"name\") and (getattr(our_designator, \"name\") == getattr(designator, \"name\")):\n                return True\n        return False\n\n    def __eq__(self, other: OntologyConceptHolder) -> bool:\n        \"\"\"\n        Equality check based on name of the ontology concept\n\n        :param other: Other ontology concept instance to check against\n        :return: True if the ontology concept of the other holder has the same name with the current one, otherwise False\n        \"\"\"\n        return ((self.ontology_concept == other.ontology_concept) or\n                (self.ontology_concept.name == other.ontology_concept.name))\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the action_designator.py file and how do they interact with other components in the system?"}, {"role": "assistant", "content": "# Content from: #<action_designator.py>#\nfrom typing_extensions import Optional\n\nfrom .base import RobotState, Designator, MapperArgsMixin, PoseMixin\nfrom .object_designator import ObjectMixin\nfrom ..datastructures.enums import Arms, GripperState, Grasp\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy import ForeignKey\n\n\nclass Action(MapperArgsMixin, Designator):\n    \"\"\"ORM class of pycram.designators.action_designator.ActionDesignator.\n    The purpose of this class is to correctly map the inheritance from the action designator class into the database.\n    Inheritance is implemented as Joined Table Inheritance (see https://docs.sqlalchemy.org/en/20/orm/inheritance.html)\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), primary_key=True, init=False)\n    dtype: Mapped[str] = mapped_column(\"action_dtype\", init=False)\n    robot_state_id: Mapped[int] = mapped_column(ForeignKey(f\"{RobotState.__tablename__}.id\"), init=False)\n    robot_state: Mapped[RobotState] = relationship(init=False)\n\n\nclass ParkArmsAction(Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.ParkArmsDesignator.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms] = mapped_column(default=None)\n\n\nclass NavigateAction(PoseMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.NavigateAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n\n\nclass MoveTorsoAction(Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.MoveTorsoAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    position: Mapped[Optional[float]] = mapped_column(default=None)\n\n\nclass SetGripperAction(Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.SetGripperAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    gripper: Mapped[Arms]\n    motion: Mapped[GripperState]\n\n\nclass Release(ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.Release.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    gripper: Mapped[Arms] = mapped_column(init=False)\n\n\nclass GripAction(ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.GripAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    gripper: Mapped[Arms] = mapped_column(init=False)\n    effort: Mapped[float] = mapped_column(init=False)\n    # TODO grasped_object\n\n\nclass PickUpAction(ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.PickUpAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n    grasp: Mapped[Grasp]\n\n\nclass PlaceAction(PoseMixin, ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.PlaceAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n\n\nclass TransportAction(PoseMixin, ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.TransportAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n\n\nclass LookAtAction(PoseMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.LookAtAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n\n\nclass DetectAction(ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.DetectAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n\n\nclass OpenAction(ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.OpenAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n    # distance: Mapped[float] = mapped_column(init=False)\n\n\nclass CloseAction(ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.CloseAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n\n\nclass GraspingAction(ObjectMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.GraspingAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n\n\nclass FaceAtAction(PoseMixin, Action):\n    \"\"\"ORM Class of pycram.designators.action_designator.FaceAtAction.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the base.py file of the PyCRAM Framework?"}, {"role": "assistant", "content": "# Content from: #<base.py>#\n\"\"\"Implementation of base classes for orm modelling.\"\"\"\nimport datetime\nimport getpass\nimport os\nfrom dataclasses import field\nfrom typing import Optional\n\nimport git\nimport rospkg\nimport sqlalchemy.sql.functions\nfrom sqlalchemy import ForeignKey, String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, MappedAsDataclass, mapped_column, Session, relationship, \\\n    declared_attr\n\nfrom ..datastructures.enums import ObjectType\n\n\ndef get_pycram_version_from_git() -> Optional[str]:\n    \"\"\"\n    Get the PyCRAM commit hash that is used to run this version.\n\n    This assumes that you have gitpython installed and that the PyCRAM git repository on your system can be found\n    with \"roscd pycram\".\n    \"\"\"\n\n    r = rospkg.RosPack()\n    repo = git.Repo(path=r.get_path('pycram'))\n    return repo.head.object.hexsha\n\n\nclass _Base(DeclarativeBase, MappedAsDataclass):\n    \"\"\"Dummy class\"\"\"\n    type_annotation_map = {\n        str: String(255)\n    }\n\n    id: Mapped[int] = mapped_column(autoincrement=True, primary_key=True, init=False, nullable=False)\n    \"\"\"Unique integer ID as auto incremented primary key.\"\"\"\n\n    @declared_attr\n    def __tablename__(self):\n        return self.__name__\n\n\nclass Base(_Base):\n    \"\"\"\n    Base class to add orm functionality to all pycram mappings\n    \"\"\"\n    __abstract__ = True\n\n    @declared_attr\n    def process_metadata_id(self) -> Mapped[int]:\n        return mapped_column(ForeignKey(f'{ProcessMetaData.__tablename__}.id'), default=None, init=False)\n    \"\"\"Related MetaData Object to store information about the context of this experiment.\"\"\"\n\n    @declared_attr\n    def process_metadata(self):\n        return relationship(ProcessMetaData.__tablename__)\n    \"\"\"model relationship between foreign key in ProcessMetaData table and the ids of all inheriting\n    tables\"\"\"\n\n\nclass MapperArgsMixin(MappedAsDataclass):\n    \"\"\"\n    MapperArgsMixin stores __mapper_args__ information for certain subclass-tables.\n    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html\n    \"\"\"\n\n    __abstract__ = True\n\n    @declared_attr\n    def __mapper_args__(self):\n        return {\"polymorphic_identity\": self.__tablename__}\n\n\nclass PositionMixin(MappedAsDataclass):\n    \"\"\"\n    PositionMixin holds a foreign key column and its relationship to the referenced table.\n    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html\n    \"\"\"\n\n    __abstract__ = True\n    position_to_init: bool = field(default=False, init=False)\n\n    @declared_attr\n    def position_id(self) -> Mapped[int]:\n        return mapped_column(ForeignKey(f'{Position.__tablename__}.id'), init=self.position_to_init)\n\n    @declared_attr\n    def position(self):\n        return relationship(Position.__tablename__, init=False)\n\n\nclass QuaternionMixin(MappedAsDataclass):\n    \"\"\"\n    QuaternionMixin holds a foreign key column and its relationship to the referenced table.\n    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html\n    \"\"\"\n\n    __abstract__ = True\n    orientation_to_init: bool = field(default=False, init=False)\n\n    @declared_attr\n    def orientation_id(self) -> Mapped[int]:\n        return mapped_column(ForeignKey(f'{Quaternion.__tablename__}.id'), init=self.orientation_to_init)\n\n    @declared_attr\n    def orientation(self):\n        return relationship(Quaternion.__tablename__, init=False)\n\n\nclass PoseMixin(MappedAsDataclass):\n    \"\"\"\n    PoseMixin holds a foreign key column and its relationship to the referenced table.\n    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html\n    \"\"\"\n\n    __abstract__ = True\n    pose_to_init: bool = field(default=False, init=False)\n\n    @declared_attr\n    def pose_id(self) -> Mapped[int]:\n        return mapped_column(ForeignKey(f'{Pose.__tablename__}.id'), init=self.pose_to_init)\n\n    @declared_attr\n    def pose(self):\n        return relationship(Pose.__tablename__, init=False)\n\n\nclass ProcessMetaData(_Base):\n    \"\"\"\n    ProcessMetaData stores information about the context of this experiment.\n\n    This class is a singleton and only one MetaData can exist per session.\n    \"\"\"\n\n    created_at: Mapped[datetime.datetime] = mapped_column(server_default=sqlalchemy.sql.functions.current_timestamp(),\n                                                          init=False)\n    \"\"\"The timestamp where this row got created. This is an aid for versioning.\"\"\"\n\n    created_by: Mapped[str] = mapped_column(default=getpass.getuser(), init=False)\n    \"\"\"The user that created the experiment.\"\"\"\n\n    description: Mapped[str] = mapped_column(init=False)\n    \"\"\"A description of the purpose (?) of this experiment.\"\"\"\n\n    pycram_version: Mapped[str] = mapped_column(default=get_pycram_version_from_git(),\n                                                nullable=True, init=False)\n    \"\"\"The PyCRAM version used to generate this row.\"\"\"\n\n    _self = None\n    \"\"\"The singleton instance.\"\"\"\n\n    def __new__(cls):\n        if cls._self is None:\n            cls._self = super().__new__(cls)\n        return cls._self\n\n    def committed(self):\n        \"\"\"Return if this object is in the database or not.\"\"\"\n        return self.id is not None\n\n    def insert(self, session: Session):\n        \"\"\"Insert this into the database using the session. Skipped if it already is inserted.\"\"\"\n        if not self.committed():\n            session.add(self)\n        return self\n\n    @classmethod\n    def reset(cls):\n        \"\"\"Reset the singleton instance to None, s. t. next time the class is called a new instance is created.\"\"\"\n        cls._self = None\n\n\nclass Designator(Base):\n    \"\"\"ORM Class holding every performed action and motion serving as every performables and motions root.\"\"\"\n\n    @declared_attr\n    def dtype(self) -> Mapped[str]:\n        return mapped_column(String(255), nullable=False, init=False)\n\n    @declared_attr\n    def __mapper_args__(self):\n        return {\n            \"polymorphic_on\": \"dtype\",\n        }\n\n\nclass Position(Base):\n    \"\"\"ORM Class for 3D positions.\"\"\"\n\n    x: Mapped[float]\n    y: Mapped[float]\n    z: Mapped[float]\n\n\nclass Quaternion(Base):\n    \"\"\"ORM Class for Quaternions.\"\"\"\n\n    x: Mapped[float]\n    y: Mapped[float]\n    z: Mapped[float]\n    w: Mapped[float]\n\n\nclass Pose(PositionMixin, QuaternionMixin, Base):\n    \"\"\"ORM Class for Poses.\"\"\"\n\n    time: Mapped[datetime.datetime]\n    frame: Mapped[str]\n\n\nclass Color(Base):\n    \"\"\"ORM Class for Colors.\"\"\"\n\n    r: Mapped[float]\n    g: Mapped[float]\n    b: Mapped[float]\n    alpha: Mapped[float]\n\n\nclass RobotState(PoseMixin, Base):\n    \"\"\"ORM Representation of a robots state.\"\"\"\n\n    torso_height: Mapped[float]\n    \"\"\"The torso height of the robot.\"\"\"\n\n    type: Mapped[ObjectType]\n    \"\"\"The type of the robot.\"\"\"\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the motion_designator.py file and how do they contribute to motion planning?"}, {"role": "assistant", "content": "# Content from: #<motion_designator.py>#\n\"\"\"\nThis module defines a set of ORM classes related to motion designators in the pycram framework.\n\nEach motion designator class has its own table in the database with columns representing its attributes.\nThe MotionDesignator class is the base class that defines the polymorphic behavior of all other motion designator\nclasses.\n\"\"\"\nfrom typing_extensions import Optional\n\nfrom .base import MapperArgsMixin, Designator, PoseMixin\nfrom .object_designator import Object\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy import ForeignKey\n\nfrom ..datastructures.enums import ObjectType, Arms, GripperState\n\n\nclass Motion(MapperArgsMixin, Designator):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.MotionDesignatorDescription\n\n    :ivar id: (Integer) Auto-incrementing primary key\n    :ivar dtype: (String) Polymorphic discriminator\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), primary_key=True, init=False)\n    dtype: Mapped[str] = mapped_column(\"motion_dtype\", init=False)\n\n\nclass MoveMotion(PoseMixin, Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.MoveMotion\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n\n\nclass AccessingMotion(Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.AccessingMotion\n\n    :ivar arm: (String) Name of the arm used\n    :ivar gripper: (String) Name of the gripper used\n    :ivar distance: (Float) Distance from the drawer to the robot\n    :ivar drawer_joint:\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n    part_of: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=False)\n    object: Mapped[Object] = relationship(init=False)\n    arm: Mapped[Arms] = mapped_column(init=False)\n    gripper: Mapped[str] = mapped_column(init=False)\n    distance: Mapped[float] = mapped_column(init=False)\n    drawer_joint: Mapped[str] = mapped_column(init=False)\n    drawer_handle: Mapped[str] = mapped_column(init=False)\n\n\nclass MoveTCPMotion(PoseMixin, Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.MoveTCPMotion\n\n    :ivar arm: String specifying which arm to move the TCP of\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n    allow_gripper_collision: Mapped[Optional[bool]]\n\n\nclass LookingMotion(PoseMixin, Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.LookingMotion\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n\n\nclass MoveGripperMotion(Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.MoveGripperMotion\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n    motion: Mapped[GripperState]\n    gripper: Mapped[Arms]\n    allow_gripper_collision: Mapped[Optional[bool]]\n\n\nclass DetectingMotion(Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.DetectingMotion\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n    object_type: Mapped[ObjectType]\n\n\nclass WorldStateDetectingMotion(Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.WorldStateDetectingMotion\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n    object_type: Mapped[str] = mapped_column(init=False)\n\n\nclass OpeningMotion(Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.OpeningMotion\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n\n\nclass ClosingMotion(Motion):\n    \"\"\"\n    ORM class of pycram.designators.motion_designator.ClosingMotion\n    \"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)\n    arm: Mapped[Arms]\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the main functions defined in the object_designator.py file?"}, {"role": "assistant", "content": "# Content from: #<object_designator.py>#\nfrom dataclasses import field\nfrom typing import Optional\n\nfrom pycram.orm.base import Base, MapperArgsMixin, PoseMixin, Pose\nfrom sqlalchemy.orm import Mapped, mapped_column, declared_attr, relationship, MappedAsDataclass\nfrom sqlalchemy import ForeignKey\nfrom pycram.datastructures.enums import ObjectType\n\n\nclass ObjectMixin(MappedAsDataclass):\n    \"\"\"\n    ObjectMixin holds a foreign key column and its relationship to the referenced table.\n    For information about Mixins, see https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/mixins.html\n    \"\"\"\n\n    __abstract__ = True\n    object_to_init: bool = field(default=False, init=False)\n\n    @declared_attr\n    def object_id(self) -> Mapped[int]:\n        return mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=self.object_to_init)\n\n    @declared_attr\n    def object(self):\n        return relationship(Object.__tablename__, init=False)\n\n\nclass Object(PoseMixin, Base):\n    \"\"\"ORM class of pycram.designators.object_designator.ObjectDesignator\"\"\"\n\n    dtype: Mapped[str] = mapped_column(init=False)\n    obj_type: Mapped[Optional[ObjectType]]\n    name: Mapped[str]\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"Object\",\n        \"polymorphic_on\": \"dtype\",\n    }\n\n\nclass ObjectPart(Object):\n    \"\"\"ORM Class of pycram.designators.object_designator.LocatedObject.\"\"\"\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), primary_key=True, init=False)\n    # part_of: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=False)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"ObjectPart\",\n        \"inherit_condition\": Object.id == id\n    }\n\n\nclass BelieveObject(MapperArgsMixin, Object):\n\n    id: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), primary_key=True, init=False)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the tasktree.py file and how do they interact with each other?"}, {"role": "assistant", "content": "# Content from: #<tasktree.py>#\n\"\"\"Implementation of ORM classes associated with pycram.task.\"\"\"\nfrom typing_extensions import Optional\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom .base import Base, Designator\nfrom pycram.datastructures.enums import TaskStatus\nimport datetime\n\n\nclass TaskTreeNode(Base):\n    \"\"\"ORM equivalent of pycram.task.TaskTreeNode.\"\"\"\n\n    id: Mapped[int] = mapped_column(autoincrement=True, primary_key=True, init=False)\n\n    action_id: Mapped[Optional[int]] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), init=False)\n    action: Mapped[Optional[Designator]] = relationship(init=False)\n\n    start_time: Mapped[datetime.datetime]\n    end_time: Mapped[Optional[datetime.datetime]]\n\n    status: Mapped[TaskStatus]\n    reason: Mapped[Optional[str]]\n\n    parent_id: Mapped[Optional[int]] = mapped_column(ForeignKey(\"TaskTreeNode.id\"), init=False)\n    parent: Mapped[Optional[\"TaskTreeNode\"]] = relationship(init=False, remote_side=[id])\n\n\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the utils.py file and how are they used in the project?"}, {"role": "assistant", "content": "# Content from: #<utils.py>#\nimport traceback\nimport rospy\nimport sqlalchemy\nimport pycram.orm.base\nfrom pycram.designators.object_designator import *\nimport json\n\nfrom pycram.designators.action_designator import *\nimport pycram.orm\n\n\ndef write_database_to_file(in_sessionmaker: sqlalchemy.orm.sessionmaker, filename: str,\n                           b_write_to_console: bool = False):\n    \"\"\"\n    Writes all Tables stored within the given session into a local file. File will be written in JSON Format\n\n    :param in_sessionmaker: sessionmaker that allows us to access the Database\n    :param filename: Filename of the logfile\n    :param b_write_to_console: enables writing to the console. Default false\n    \"\"\"\n    with in_sessionmaker() as session:\n        with open(\"whatever.txt\", \"w\") as f:\n            to_json_dict = dict()\n            for table in pycram.orm.base.Base.metadata.sorted_tables:\n                list_of_row = list()\n                for column_object in session.query(table).all():\n                    list_of_row.append(column_object)\n                to_json_dict[table.name] = list_of_row\n            json_data_dict = json.dumps(to_json_dict, default=str)\n            f.write(json_data_dict)\n\n\ndef print_database(in_sessionmaker: sqlalchemy.orm.sessionmaker):\n    \"\"\"\n    Prints all ORM Class data within the given Session.\n\n    :param in_sessionmaker: Database Session which should be printed\n    \"\"\"\n    with in_sessionmaker() as session:\n        for table in pycram.orm.base.Base.metadata.sorted_tables:\n            try:\n                smt = sqlalchemy.select('*').select_from(table)\n                result = session.execute(smt).all()\n                rospy.loginfo(\"Table: {}\\tcontent:{}\".format(table, result))\n            except sqlalchemy.exc.ArgumentError as e:\n                rospy.logwarn(e)\n\n\ndef update_primary_key(source_session_maker: sqlalchemy.orm.sessionmaker,\n                       destination_session_maker: sqlalchemy.orm.sessionmaker):\n    \"\"\"\n    Updates all the primary keys of the database associated with the destination engine, so that there will be no\n    problems when merging it into the source database. In order to achieve this the highest id value of the source\n    engine is searched and the primary keys of the destination database will get all the values following that.\n    Cascading triggers in the database will take care of the rest. Careful 2023 this will not work in\n    memory databases as there are no triggers.\n\n    :param source_session_maker: Session maker of the source data_base\n    :param destination_session_maker: Session maker of the destination data_base\n    \"\"\"\n    destination_session = destination_session_maker()\n    source_session = source_session_maker()\n    sortedTables = pycram.orm.base.Base.metadata.sorted_tables\n    for table in sortedTables:\n        try:\n            list_of_primary_keys_of_this_table = table.primary_key.columns.values()\n            for key in list_of_primary_keys_of_this_table:\n                all_source_key_values = []\n                all_destination_key_values = []\n                for key_value_row in source_session.query(key).all():\n                    all_source_key_values.append(key_value_row[0])  # get all values of key from source session\n                for key_value_row in destination_session.query(key).all():\n                    all_destination_key_values.append(key_value_row[0])  # get all values of key from source session\n\n                highest_free_key_value = max(max(all_source_key_values, default=0),\n                                             max(all_destination_key_values, default=0)) + 1\n                results = destination_session.execute(sqlalchemy.select(table))\n                for column_object in results:  # iterate over all columns\n                    if column_object.__getattr__(key.name) in all_source_key_values:\n                        rospy.loginfo(\n                            \"Found primary_key collision in table {} value: {} max value in memory {}\".format(table,\n                                                                                                              column_object.__getattr__(\n                                                                                                                  key.name),\n                                                                                                              highest_free_key_value))\n                        mini_dict = dict()\n                        mini_dict[key.name] = highest_free_key_value\n                        update_statement = sqlalchemy.update(table).where(\n                            table.c.id == column_object.__getattr__(key)).values(mini_dict)\n                        destination_session.execute(update_statement)\n                        highest_free_key_value += 1\n            destination_session.commit()  # commit after every table\n        except AttributeError as e:\n            rospy.logwarn(\"Possible found abstract ORM class {}\".format(e.__name__))\n            rospy.logwarn(e)\n    destination_session.close()\n\n\ndef copy_database(source_session_maker: sqlalchemy.orm.sessionmaker,\n                  destination_session_maker: sqlalchemy.orm.sessionmaker):\n    \"\"\"\n    Iterates through all tables within tht source database and merges them into the destination database. Careful\n    this function does not check if there are any primary key collisions or updates any data.\n\n     .. note::\n        Ignores all previously detached data, could result in loss of information. During testing database objects\n        sometimes had a detached twin. As a possible feature in the future it maybe useful to give the user an\n        opportunity to decide what happens with the detached objects. Careful this could lead to duplicated data in the\n        destination database.\n\n    :param source_session_maker: Sessionmaker of the source database\n    :param destination_session_maker: Sessionmaker of the destination database\n    \"\"\"\n\n    with source_session_maker() as source_session, destination_session_maker() as destination_session:\n        sorted_tables = pycram.orm.base.Base.metadata.sorted_tables\n        for table in sorted_tables:\n            for value in source_session.query(table).all():\n                insert_statement = sqlalchemy.insert(table).values(value)\n                destination_session.execute(insert_statement)\n            destination_session.commit()  # commit after every table\n\n\ndef update_primary_key_constrains(session_maker: sqlalchemy.orm.sessionmaker):\n    '''\n    Iterates through all tables related to any ORM Class and sets in their corresponding foreign keys in the given\n    endpoint to \"ON UPDATE CASCADING\".\n\n        .. note::\n            Careful currently only works on postgres databases.\n\n    :param session_maker:\n    :return: empty\n    '''\n    with session_maker() as session:\n        for table in pycram.orm.base.Base.metadata.sorted_tables:\n            try:\n                foreign_key_statement = sqlalchemy.text(\n                    \"SELECT con.oid, con.conname, con.contype, con.confupdtype, con.confdeltype, con.confmatchtype, pg_get_constraintdef(con.oid) FROM pg_catalog.pg_constraint con INNER JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid INNER JOIN pg_catalog.pg_namespace nsp ON nsp.oid = connamespace WHERE rel.relname = '{}';\".format(\n                        table))\n                response = session.execute(foreign_key_statement)\n                rospy.loginfo(25 * '~' + \"{}\".format(table) + 25 * '~')\n                for line in response:\n                    if line.conname.endswith(\"fkey\"):\n                        if 'a' in line.confupdtype:  # a --> no action | if there is no action we set it to cascading\n                            # Assumes there aren't any other constraints\n                            drop_statement = sqlalchemy.text(\n                                \"alter table \\\"{}\\\" drop constraint \\\"{}\\\";\".format(table,\n                                                                                    line.conname))\n                            drop_response = session.execute(\n                                drop_statement)  # There is no real data coming back for this\n                            alter_statement = sqlalchemy.text(\n                                \"alter table \\\"{}\\\" add constraint {} {} on update cascade;\".format(\n                                    table,\n                                    line.conname,\n                                    line.pg_get_constraintdef))\n                            alter_response = session.execute(\n                                alter_statement)  # There is no real data coming back for this\n                            session.commit()\n            except AttributeError:\n                rospy.loginfo(\"Attribute Error: {} has no attribute __tablename__\".format(table))\n\n\ndef migrate_neems(source_session_maker: sqlalchemy.orm.sessionmaker,\n                  destination_session_maker: sqlalchemy.orm.sessionmaker):\n    \"\"\"\n        Merges the database connected to the source session maker into the database connected to the destination session\n        maker. Will first update the primary constrains inside the destination database (if needed). Afterwards\n        updates the primary keys within the destination database (as there are cascading updates now) and then merges\n        the source database into the destination.\n\n         .. note::\n            Assumes the destination database is a postgres database\n\n        :param source_session_maker: Sessionmaker of the source database\n        :param destination_session_maker: Sessionmaker of the destination database\n        \"\"\"\n\n    update_primary_key_constrains(destination_session_maker)\n    update_primary_key(source_session_maker, destination_session_maker)\n    copy_database(source_session_maker, destination_session_maker)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the views.py file of my Django application?"}, {"role": "assistant", "content": "# Content from: #<views.py>#\nfrom sqlalchemy.orm import declarative_base\nfrom typing_extensions import Union\nimport sqlalchemy.orm\nfrom sqlalchemy import table, inspect, event, select, engine, MetaData, Select, TableClause, ExecutableDDLElement\nfrom sqlalchemy.ext.compiler import compiles\nfrom .action_designator import PickUpAction\nfrom .base import Position, RobotState, Pose, Base, Quaternion\nfrom .object_designator import Object\nfrom .tasktree import TaskTreeNode\n\n\nclass CreateView(ExecutableDDLElement):\n    \"\"\"\n    Class that is used to create a view. Every instance will be compiled into a SQL CREATE VIEW statement.\n    \"\"\"\n\n    def __init__(self, name: str, selectable: Select):\n        self.name = name\n        self.selectable = selectable\n\n\nclass DropView(ExecutableDDLElement):\n    \"\"\"\n    Class that is used to drop a view. Every instance will be compiled into a SQL DROP VIEW statement.\n    \"\"\"\n\n    def __init__(self, name: str):\n        self.name = name\n\n\n@compiles(CreateView)\ndef _create_view(element: CreateView, compiler, **kw) -> str:\n    \"\"\"\n    Compiles a CreateView instance into a SQL CREATE VIEW statement.\n    :param element: CreateView instance\n    :param compiler: compiler\n    :param kw: keyword arguments\n    :return: SQL CREATE VIEW statement\n    \"\"\"\n\n    return \"CREATE VIEW %s AS %s\" % (\n        element.name,\n        compiler.sql_compiler.process(element.selectable, literal_binds=True),\n    )\n\n\n@compiles(DropView)\ndef _drop_view(element: DropView, compiler, **kw) -> str:\n    \"\"\"\n    Compiles a DropView instance into a SQL DROP VIEW statement.\n    :param element: DropView instance\n    :param compiler: compiler\n    :param kw: keyword arguments\n    :return: SQL DROP VIEW statement\n    \"\"\"\n    return \"DROP VIEW %s\" % element.name\n\n\ndef view_exists(ddl: Union[CreateView, DropView], target, connection: engine, **kw) -> bool:\n    \"\"\"\n    Check if a view exists.\n    :param ddl: ddl instance\n    :param target: target object\n    :param connection: connection\n    :param kw: keyword arguments\n    :return: True if the view exists, False otherwise\n    \"\"\"\n\n    return ddl.name in inspect(connection).get_view_names()\n\n\ndef view_doesnt_exist(ddl: Union[CreateView, DropView], target, connection: engine, **kw) -> bool:\n    \"\"\"\n    Check if a view does not exist.\n    :param ddl: ddl instance\n    :param target: target object\n    :param connection: connection\n    :param kw: keyword arguments\n    :return: True if the view does not exist, False otherwise\n    \"\"\"\n\n    return not view_exists(ddl, target, connection, **kw)\n\n\ndef view(name: str, metadata: MetaData, selectable: Select) -> TableClause:\n    \"\"\"\n    Function used to control view creation and deletion. It will listen to the after_create and before_drop events\n    of the metadata object in order to either create or drop the view. The view needs to have a column id.\n    \"\"\"\n    view = table(name)\n\n    view._columns._populate_separate_keys(\n        col._make_proxy(view) for col in selectable.selected_columns\n    )\n\n    event.listen(metadata, \"after_create\", CreateView(name, selectable).execute_if(callable_=view_doesnt_exist))\n    event.listen(metadata, \"before_drop\", DropView(name).execute_if(callable_=view_exists))\n\n    return view\n\n\nbase = declarative_base(metadata=Base.metadata)\n\n\nclass PickUpWithContextView(base):\n    \"\"\"\n    View for pickup performables with context.\n    \"\"\"\n\n    __robot_position: Position = sqlalchemy.orm.aliased(Position, flat=True)\n    \"\"\"\n    3D Vector of robot position\n    \"\"\"\n\n    __robot_pose: Pose = sqlalchemy.orm.aliased(Pose, flat=True)\n    \"\"\"\n    Complete robot pose\n    \"\"\"\n\n    __object_position: Position = sqlalchemy.orm.aliased(Position, flat=True)\n    \"\"\"\n    3D Vector for object position\n    \"\"\"\n\n    __relative_x = (__robot_position.x - __object_position.x)\n    \"\"\"\n    Distance on x axis between robot and object\n    \"\"\"\n\n    __relative_y = (__robot_position.y - __object_position.y)\n    \"\"\"\n    Distance on y axis between robot and object\n    \"\"\"\n\n    __table__ = view(\"PickUpWithContextView\", Base.metadata,\n                     (select(PickUpAction.id.label(\"id\"), PickUpAction.arm.label(\"arm\"),\n                             PickUpAction.grasp.label(\"grasp\"), RobotState.torso_height.label(\"torso_height\"),\n                             __relative_x.label(\"relative_x\"), __relative_y.label(\"relative_y\"),\n                             Quaternion.x.label(\"quaternion_x\"), Quaternion.y.label(\"quaternion_y\"),\n                             Quaternion.z.label(\"quaternion_z\"), Quaternion.w.label(\"quaternion_w\"),\n                             Object.obj_type.label(\"obj_type\"), TaskTreeNode.status.label(\"status\"))\n                      .join(TaskTreeNode.action.of_type(PickUpAction))\n                      .join(PickUpAction.robot_state)\n                      .join(__robot_pose, RobotState.pose)\n                      .join(__robot_position, __robot_pose.position)\n                      .join(Pose.orientation)\n                      .join(PickUpAction.object)\n                      .join(Object.pose)\n                      .join(__object_position, Pose.position)))\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the boxy_process_modules.py file?"}, {"role": "assistant", "content": "# Content from: #<boxy_process_modules.py>#\nfrom threading import Lock\nimport numpy as np\nfrom .. import world_reasoning as btr\nfrom ..utils import _apply_ik\nfrom ..designators.motion_designator import *\nfrom ..datastructures.enums import JointType\nfrom ..external_interfaces.ik import request_ik\n\nfrom ..datastructures.world import World\nfrom ..local_transformer import LocalTransformer\nfrom ..process_module import ProcessModule, ProcessModuleManager\nfrom ..robot_description import RobotDescription\nfrom ..world_concepts.world_object import Object\n\n\nclass BoxyNavigation(ProcessModule):\n    \"\"\"\n    The process module to move the robot from one position to another.\n    \"\"\"\n\n    def _execute(self, desig: MoveMotion):\n        robot = World.robot\n        robot.set_pose(desig.target)\n\n\nclass BoxyOpen(ProcessModule):\n    \"\"\"\n    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.\n    \"\"\"\n\n    def _execute(self, desig: OpeningMotion):\n        part_of_object = desig.object_part.world_object\n\n        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)\n\n        goal_pose = btr.link_pose_for_joint_config(part_of_object, {\n            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)\n\n        _move_arm_tcp(goal_pose, World.robot, desig.arm)\n\n        desig.object_part.world_object.set_joint_position(container_joint,\n                                                              part_of_object.get_joint_limits(\n                                                                  container_joint)[1])\n\n\nclass BoxyClose(ProcessModule):\n    \"\"\"\n    Low-level implementation that lets the robot close a grasped container, in simulation\n    \"\"\"\n    def _execute(self, desig: ClosingMotion):\n        part_of_object = desig.object_part.world_object\n\n        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)\n\n        goal_pose = btr.link_pose_for_joint_config(part_of_object, {\n            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)\n\n        _move_arm_tcp(goal_pose, World.robot, desig.arm)\n\n        desig.object_part.world_object.set_joint_position(container_joint,\n                                                              part_of_object.get_joint_limits(\n                                                                  container_joint)[0])\n\n\nclass BoxyParkArms(ProcessModule):\n    \"\"\"\n    This process module is for moving the arms in a parking position.\n    It is currently not used.\n    \"\"\"\n\n    def _execute(self, desig):\n        solutions = desig.reference()\n        if solutions['cmd'] == 'park':\n            _park_arms()\n\n\nclass BoxyMoveHead(ProcessModule):\n    \"\"\"\n    This process module moves the head to look at a specific point in the world coordinate frame.\n    This point can either be a position or an object.\n    \"\"\"\n\n    def _execute(self, desig):\n        target = desig.target\n        robot = World.robot\n\n        local_transformer = LocalTransformer()\n\n        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"neck_shoulder_link\"))\n\n        if pose_in_shoulder.position.x >= 0 and pose_in_shoulder.position.x >= abs(pose_in_shoulder.position.y):\n            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain(\"neck\", \"front\"))\n        if pose_in_shoulder.position.y >= 0 and pose_in_shoulder.position.y >= abs(pose_in_shoulder.position.x):\n            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain(\"neck\", \"neck_right\"))\n        if pose_in_shoulder.position.x <= 0 and abs(pose_in_shoulder.position.x) > abs(pose_in_shoulder.position.y):\n            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain(\"neck\", \"back\"))\n        if pose_in_shoulder.position.y <= 0 and abs(pose_in_shoulder.position.y) > abs(pose_in_shoulder.position.x):\n            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain(\"neck\", \"neck_left\"))\n\n        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"neck_shoulder_link\"))\n\n        new_pan = np.arctan2(pose_in_shoulder.position.y, pose_in_shoulder.position.x)\n\n        robot.set_joint_position(\"neck_shoulder_pan_joint\",\n                                 new_pan + robot.get_joint_position(\"neck_shoulder_pan_joint\"))\n\n\nclass BoxyMoveGripper(ProcessModule):\n    \"\"\"\n    This process module controls the gripper of the robot. They can either be opened or closed.\n    Furthermore, it can only move one gripper at a time.\n    \"\"\"\n\n    def _execute(self, desig):\n        robot = World.robot\n        gripper = desig.gripper\n        motion = desig.motion\n        robot.set_joint_positions(RobotDescription.current_robot_description.kinematic_chains[gripper].get_static_gripper_state(motion))\n\n\nclass BoxyDetecting(ProcessModule):\n    \"\"\"\n    This process module tries to detect an object with the given type. To be detected the object has to be in\n    the field of view of the robot.\n    \"\"\"\n\n    def _execute(self, desig):\n        robot = World.robot\n        object_type = desig.object_type\n        # Should be \"wide_stereo_optical_frame\"\n        cam_frame_name = RobotDescription.current_robot_description.get_camera_frame()\n        # should be [0, 0, 1]\n        front_facing_axis = RobotDescription.current_robot_description.get_default_camera().front_facing_axis\n\n        objects = World.current_world.get_object_by_type(object_type)\n        for obj in objects:\n            if btr.visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):\n                return obj\n\n\nclass BoxyMoveTCP(ProcessModule):\n    \"\"\"\n    This process moves the tool center point of either the right or the left arm.\n    \"\"\"\n\n    def _execute(self, desig: MoveTCPMotion):\n        target = desig.target\n        robot = World.robot\n\n        _move_arm_tcp(target, robot, desig.arm)\n\n\nclass BoxyMoveArmJoints(ProcessModule):\n    \"\"\"\n    This process modules moves the joints of either the right or the left arm. The joint states can be given as\n    list that should be applied or a pre-defined position can be used, such as \"parking\"\n    \"\"\"\n\n    def _execute(self, desig: MoveArmJointsMotion):\n\n        robot = World.robot\n        if desig.right_arm_poses:\n            robot.set_joint_positions(desig.right_arm_poses)\n        if desig.left_arm_poses:\n            robot.set_joint_positions(desig.left_arm_poses)\n\n\nclass BoxyWorldStateDetecting(ProcessModule):\n    \"\"\"\n    This process module detectes an object even if it is not in the field of view of the robot.\n    \"\"\"\n\n    def _execute(self, desig: WorldStateDetectingMotion):\n        obj_type = desig.object_type\n        return list(filter(lambda obj: obj.type == obj_type, World.current_world.objects))[0]\n\n\ndef _move_arm_tcp(target: Pose, robot: Object, arm: Arms) -> None:\n    gripper = RobotDescription.current_robot_description.get_arm_chain(arm).get_tool_frame()\n\n    joints = RobotDescription.current_robot_description.get_arm_chain(arm).joints\n\n    inv = request_ik(target, robot, joints, gripper)\n    _apply_ik(robot, inv)\n\n\nclass BoxyManager(ProcessModuleManager):\n\n    def __init__(self):\n        super().__init__(\"boxy\")\n        self._navigate_lock = Lock()\n        self._looking_lock = Lock()\n        self._detecting_lock = Lock()\n        self._move_tcp_lock = Lock()\n        self._move_arm_joints_lock = Lock()\n        self._world_state_detecting_lock = Lock()\n        self._move_joints_lock = Lock()\n        self._move_gripper_lock = Lock()\n        self._open_lock = Lock()\n        self._close_lock = Lock()\n\n    def navigate(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return BoxyNavigation(self._navigate_lock)\n\n    def looking(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return BoxyMoveHead(self._looking_lock)\n\n    def detecting(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return BoxyDetecting(self._detecting_lock)\n\n    def move_tcp(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return BoxyMoveTCP(self._move_tcp_lock)\n\n    def move_arm_joints(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return BoxyMoveArmJoints(self._move_arm_joints_lock)\n\n    def world_state_detecting(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return BoxyWorldStateDetecting(self._world_state_detecting_lock)\n\n    def move_gripper(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return BoxyMoveGripper(self._move_gripper_lock)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the default_process_modules.py file?"}, {"role": "assistant", "content": "# Content from: #<default_process_modules.py>#\nfrom threading import Lock\n\nimport numpy as np\n\nfrom ..datastructures.enums import JointType\nfrom ..external_interfaces.ik import request_ik\nfrom ..utils import _apply_ik\nfrom ..process_module import ProcessModule\nfrom ..robot_description import RobotDescription\nfrom ..local_transformer import LocalTransformer\nfrom ..designators.motion_designator import *\nfrom ..world_reasoning import visible, link_pose_for_joint_config\nfrom ..world_concepts.world_object import Object\nfrom ..datastructures.world import World\n\nclass DefaultNavigation(ProcessModule):\n    \"\"\"\n    The process module to move the robot from one position to another.\n    \"\"\"\n\n    def _execute(self, desig: MoveMotion):\n        robot = World.robot\n        robot.set_pose(desig.target)\n\nclass DefaultMoveHead(ProcessModule):\n    \"\"\"\n    This process module moves the head to look at a specific point in the world coordinate frame.\n    This point can either be a position or an object.\n    \"\"\"\n\n    def _execute(self, desig: LookingMotion):\n        target = desig.target\n        robot = World.robot\n\n        local_transformer = LocalTransformer()\n\n        pan_link = RobotDescription.current_robot_description.kinematic_chains[\"neck\"].links[0]\n        tilt_link = RobotDescription.current_robot_description.kinematic_chains[\"neck\"].links[1]\n\n        pan_joint = RobotDescription.current_robot_description.kinematic_chains[\"neck\"].joints[0]\n        tilt_joint = RobotDescription.current_robot_description.kinematic_chains[\"neck\"].joints[1]\n        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame(pan_link))\n        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame(tilt_link))\n\n        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)\n        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1\n\n        current_pan = robot.get_joint_position(pan_joint)\n        current_tilt = robot.get_joint_position(tilt_joint)\n\n        robot.set_joint_position(pan_joint, new_pan + current_pan)\n        robot.set_joint_position(tilt_joint, new_tilt + current_tilt)\n\n\nclass DefaultMoveGripper(ProcessModule):\n    \"\"\"\n    This process module controls the gripper of the robot. They can either be opened or closed.\n    Furthermore, it can only moved one gripper at a time.\n    \"\"\"\n\n    def _execute(self, desig: MoveGripperMotion):\n        robot = World.robot\n        gripper = desig.gripper\n        motion = desig.motion\n        for joint, state in RobotDescription.current_robot_description.get_arm_chain(gripper).get_static_gripper_state(motion).items():\n            robot.set_joint_position(joint, state)\n\n\nclass DefaultDetecting(ProcessModule):\n    \"\"\"\n    This process module tries to detect an object with the given type. To be detected the object has to be in\n    the field of view of the robot.\n    \"\"\"\n\n    def _execute(self, desig: DetectingMotion):\n        robot = World.robot\n        object_type = desig.object_type\n        # Should be \"wide_stereo_optical_frame\"\n        cam_frame_name = RobotDescription.current_robot_description.get_camera_frame()\n        # should be [0, 0, 1]\n        front_facing_axis = RobotDescription.current_robot_description.get_default_camera().front_facing_axis\n\n        objects = World.current_world.get_object_by_type(object_type)\n        for obj in objects:\n            if visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):\n                return obj\n\n\nclass DefaultMoveTCP(ProcessModule):\n    \"\"\"\n    This process moves the tool center point of either the right or the left arm.\n    \"\"\"\n\n    def _execute(self, desig: MoveTCPMotion):\n        target = desig.target\n        robot = World.robot\n\n        _move_arm_tcp(target, robot, desig.arm)\n\n\nclass DefaultMoveArmJoints(ProcessModule):\n    \"\"\"\n    This process modules moves the joints of either the right or the left arm. The joint states can be given as\n    list that should be applied or a pre-defined position can be used, such as \"parking\"\n    \"\"\"\n\n    def _execute(self, desig: MoveArmJointsMotion):\n\n        robot = World.robot\n        if desig.right_arm_poses:\n            for joint, pose in desig.right_arm_poses.items():\n                robot.set_joint_position(joint, pose)\n        if desig.left_arm_poses:\n            for joint, pose in desig.left_arm_poses.items():\n                robot.set_joint_position(joint, pose)\n\n\nclass DefaultMoveJoints(ProcessModule):\n    def _execute(self, desig: MoveJointsMotion):\n        robot = World.robot\n        for joint, pose in zip(desig.names, desig.positions):\n            robot.set_joint_position(joint, pose)\n\n\nclass DefaultWorldStateDetecting(ProcessModule):\n    \"\"\"\n    This process moduledetectes an object even if it is not in the field of view of the robot.\n    \"\"\"\n\n    def _execute(self, desig: WorldStateDetectingMotion):\n        obj_type = desig.object_type\n        return list(filter(lambda obj: obj.type == obj_type, World.current_world.objects))[0]\n\n\nclass DefaultOpen(ProcessModule):\n    \"\"\"\n    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.\n    \"\"\"\n\n    def _execute(self, desig: OpeningMotion):\n        part_of_object = desig.object_part.world_object\n\n        container_joint = part_of_object.find_joint_above_link(desig.object_part.name, JointType.PRISMATIC)\n\n        goal_pose = link_pose_for_joint_config(part_of_object, {\n            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)\n\n        _move_arm_tcp(goal_pose, World.robot, desig.arm)\n\n        desig.object_part.world_object.set_joint_position(container_joint,\n                                                              part_of_object.get_joint_limits(\n                                                                  container_joint)[1])\n\n\nclass DefaultClose(ProcessModule):\n    \"\"\"\n    Low-level implementation that lets the robot close a grasped container, in simulation\n    \"\"\"\n    def _execute(self, desig: ClosingMotion):\n        part_of_object = desig.object_part.world_object\n\n        container_joint = part_of_object.find_joint_above_link(desig.object_part.name, JointType.PRISMATIC)\n\n        goal_pose = link_pose_for_joint_config(part_of_object, {\n            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)\n\n        _move_arm_tcp(goal_pose, World.robot, desig.arm)\n\n        desig.object_part.world_object.set_joint_position(container_joint,\n                                                              part_of_object.get_joint_limits(\n                                                                  container_joint)[0])\n\n\ndef _move_arm_tcp(target: Pose, robot: Object, arm: Arms) -> None:\n    gripper = RobotDescription.current_robot_description.get_arm_chain(arm).get_tool_frame()\n\n    joints = RobotDescription.current_robot_description.get_arm_chain(arm).joints\n\n    inv = request_ik(target, robot, joints, gripper)\n    _apply_ik(robot, inv)\n\n\nclass DefaultManager(ProcessModuleManager):\n\n    def __init__(self):\n        super().__init__(\"default\")\n        self._navigate_lock = Lock()\n        self._looking_lock = Lock()\n        self._detecting_lock = Lock()\n        self._move_tcp_lock = Lock()\n        self._move_arm_joints_lock = Lock()\n        self._world_state_detecting_lock = Lock()\n        self._move_joints_lock = Lock()\n        self._move_gripper_lock = Lock()\n        self._open_lock = Lock()\n        self._close_lock = Lock()\n\n    def navigate(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultNavigation(self._navigate_lock)\n\n    def looking(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultMoveHead(self._looking_lock)\n\n    def detecting(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultDetecting(self._detecting_lock)\n\n    def move_tcp(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultMoveTCP(self._move_tcp_lock)\n\n    def move_arm_joints(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultMoveArmJoints(self._move_arm_joints_lock)\n\n    def world_state_detecting(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultWorldStateDetecting(self._world_state_detecting_lock)\n\n    def move_joints(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultMoveJoints(self._move_joints_lock)\n\n    def move_gripper(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultMoveGripper(self._move_gripper_lock)\n\n    def open(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultOpen(self._open_lock)\n\n    def close(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DefaultClose(self._close_lock)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the donbot_process_modules.py file?"}, {"role": "assistant", "content": "# Content from: #<donbot_process_modules.py>#\nfrom threading import Lock\n\nimport numpy as np\n\nfrom ..worlds.bullet_world import World\nfrom ..designators.motion_designator import MoveArmJointsMotion, WorldStateDetectingMotion\nfrom ..local_transformer import LocalTransformer\nfrom ..process_module import ProcessModule, ProcessModuleManager\nfrom ..robot_description import RobotDescription\nfrom ..process_modules.pr2_process_modules import Pr2Detecting as DonbotDetecting, _move_arm_tcp\nfrom ..datastructures.enums import Arms\n\n\ndef _park_arms(arm):\n    \"\"\"\n    Defines the joint poses for the parking positions of the arm of Donbot and applies them to the\n    in the World defined robot.\n    :return: None\n    \"\"\"\n\n    robot = World.robot\n    if arm == \"left\":\n        for joint, pose in RobotDescription.current_robot_description.get_static_joint_chain(\"left\", \"park\").items():\n            robot.set_joint_position(joint, pose)\n\n\nclass DonbotNavigation(ProcessModule):\n    \"\"\"\n    The process module to move the robot from one position to another.\n    \"\"\"\n\n    def _execute(self, desig):\n        robot = World.robot\n        robot.set_pose(desig.target)\n\n\nclass DonbotPlace(ProcessModule):\n    \"\"\"\n    This process module places an object at the given position in world coordinate frame.\n    \"\"\"\n\n    def _execute(self, desig):\n        obj = desig.object.world_object\n        robot = World.robot\n\n        # Transformations such that the target position is the position of the object and not the tcp\n        object_pose = obj.get_pose()\n        local_tf = LocalTransformer()\n        tcp_to_object = local_tf.transform_pose(object_pose,\n                                                robot.get_link_tf_frame(RobotDescription.current_robot_description.kinematic_chains[\"left\"].get_tool_frame()))\n        target_diff = desig.target.to_transform(\"target\").inverse_times(tcp_to_object.to_transform(\"object\")).to_pose()\n\n        _move_arm_tcp(target_diff, robot, Arms.LEFT)\n        robot.detach(obj)\n\n\nclass DonbotMoveHead(ProcessModule):\n    \"\"\"\n    This process module moves the head to look at a specific point in the world coordinate frame.\n    This point can either be a position or an object.\n    \"\"\"\n\n    def _execute(self, desig):\n        target = desig.target\n        robot = World.robot\n\n        local_transformer = LocalTransformer()\n\n        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"ur5_shoulder_link\"))\n\n        if pose_in_shoulder.position.x >= 0 and pose_in_shoulder.position.x >= abs(pose_in_shoulder.position.y):\n            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain(\"left\", \"front\"))\n        if pose_in_shoulder.position.y >= 0 and pose_in_shoulder.position.y >= abs(pose_in_shoulder.position.x):\n            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain(\"left\", \"arm_right\"))\n        if pose_in_shoulder.position.x <= 0 and abs(pose_in_shoulder.position.x) > abs(pose_in_shoulder.position.y):\n            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain(\"left\", \"back\"))\n        if pose_in_shoulder.position.y <= 0 and abs(pose_in_shoulder.position.y) > abs(pose_in_shoulder.position.x):\n            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain(\"left\", \"arm_left\"))\n\n        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"ur5_shoulder_link\"))\n\n        new_pan = np.arctan2(pose_in_shoulder.position.y, pose_in_shoulder.position.x)\n\n        robot.set_joint_position(\"ur5_shoulder_pan_joint\", new_pan + robot.get_joint_position(\"ur5_shoulder_pan_joint\"))\n\n\nclass DonbotMoveGripper(ProcessModule):\n    \"\"\"\n    This process module controls the gripper of the robot. They can either be opened or closed.\n    Furthermore, it can only move one gripper at a time.\n    \"\"\"\n\n    def _execute(self, desig):\n        robot = World.robot\n        gripper = desig.gripper\n        motion = desig.motion\n        robot.set_joint_positions(RobotDescription.current_robot_description.get_arm_chain(gripper).get_static_gripper_state(motion))\n\n\nclass DonbotMoveTCP(ProcessModule):\n    \"\"\"\n    This process moves the tool center point of either the right or the left arm.\n    \"\"\"\n\n    def _execute(self, desig):\n        target = desig.target\n        robot = World.robot\n\n        _move_arm_tcp(target, robot, desig.arm)\n\n\nclass DonbotMoveJoints(ProcessModule):\n    \"\"\"\n    This process modules moves the joints of either the right or the left arm. The joint states can be given as\n    list that should be applied or a pre-defined position can be used, such as \"parking\"\n    \"\"\"\n\n    def _execute(self, desig: MoveArmJointsMotion):\n        robot = World.robot\n        if desig.left_arm_poses:\n            robot.set_joint_positions(desig.left_arm_poses)\n\n\nclass DonbotWorldStateDetecting(ProcessModule):\n    \"\"\"\n    This process module detectes an object even if it is not in the field of view of the robot.\n    \"\"\"\n\n    def _execute(self, desig: WorldStateDetectingMotion):\n        obj_type = desig.object_type\n        return list(filter(lambda obj: obj.type == obj_type, World.current_world.objects))[0]\n\n\nclass DonbotManager(ProcessModuleManager):\n\n    def __init__(self):\n        super().__init__(\"iai_donbot\")\n        self._navigate_lock = Lock()\n        self._pick_up_lock = Lock()\n        self._place_lock = Lock()\n        self._looking_lock = Lock()\n        self._detecting_lock = Lock()\n        self._move_tcp_lock = Lock()\n        self._move_arm_joints_lock = Lock()\n        self._world_state_detecting_lock = Lock()\n        self._move_joints_lock = Lock()\n        self._move_gripper_lock = Lock()\n        self._open_lock = Lock()\n        self._close_lock = Lock()\n\n    def navigate(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DonbotNavigation(self._navigate_lock)\n\n    def place(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DonbotPlace(self._place_lock)\n\n    def looking(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DonbotMoveHead(self._looking_lock)\n\n    def detecting(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DonbotDetecting(self._detecting_lock)\n\n    def move_tcp(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DonbotMoveTCP(self._move_tcp_lock)\n\n    def move_arm_joints(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DonbotMoveJoints(self._move_arm_joints_lock)\n\n    def world_state_detecting(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DonbotWorldStateDetecting(self._world_state_detecting_lock)\n\n    def move_gripper(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return DonbotMoveGripper(self._move_gripper_lock)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the hsrb_process_modules.py file?"}, {"role": "assistant", "content": "# Content from: #<hsrb_process_modules.py>#\nimport numpy as np\nimport rospy\nfrom threading import Lock\nfrom typing_extensions import Any\n\nfrom ..datastructures.enums import ExecutionType\nfrom ..external_interfaces.tmc import tmc_gripper_control, tmc_talk\nfrom ..robot_description import RobotDescription\nfrom ..process_module import ProcessModule\nfrom ..local_transformer import LocalTransformer\nfrom ..designators.motion_designator import *\nfrom ..external_interfaces import giskard\nfrom ..datastructures.world import World\nfrom pydub import AudioSegment\nfrom pydub.playback import play\nfrom gtts import gTTS\n\nimport io\n\n\nclass HSRBNavigation(ProcessModule):\n    \"\"\"\n    The process module to move the robot from one position to another.\n    \"\"\"\n\n    def _execute(self, desig: MoveMotion):\n        robot = World.robot\n        robot.set_pose(desig.target)\n\n\nclass HSRBDetecting(ProcessModule):\n    \"\"\"\n    This process module tries to detect an object with the given type. To be detected the object has to be in\n    the field of view of the robot.\n    \"\"\"\n   # pass\n    def _execute(self, desig: DetectingMotion) -> Any:\n        pass\n\n\n###########################################################\n########## Process Modules for the Real HSRB ###############\n###########################################################\n\n\nclass HSRBNavigationReal(ProcessModule):\n    \"\"\"\n    Process module for the real HSRB that sends a cartesian goal to giskard to move the robot base\n    \"\"\"\n\n    def _execute(self, designator: MoveMotion) -> Any:\n        rospy.logdebug(f\"Sending goal to giskard to Move the robot\")\n        # giskard.achieve_cartesian_goal(designator.target, robot_description.base_link, \"map\")\n        # todome fix this\n        # queryPoseNav(designator.target)\n\n\nclass HSRBMoveHeadReal(ProcessModule):\n    \"\"\"\n    Process module for the real HSRB that sends a pose goal to giskard to move the robot head\n    \"\"\"\n\n    def _execute(self, desig: LookingMotion):\n        target = desig.target\n        giskard.move_head_to_pose(target)\n\n\nclass HSRBDetectingReal(ProcessModule):\n    \"\"\"\n    Process Module for the real HSRB that tries to detect an object fitting the given object description. Uses Robokudo\n    for perception of the environment.\n    \"\"\"\n\n    def _execute(self, desig: DetectingMotion) -> Any:\n        pass\n\n\nclass HSRBMoveTCPReal(ProcessModule):\n    \"\"\"\n    Moves the tool center point of the real HSRB while avoiding all collisions via giskard\n    \"\"\"\n\n    def _execute(self, designator: MoveTCPMotion) -> Any:\n        lt = LocalTransformer()\n        pose_in_map = lt.transform_pose(designator.target, \"map\")\n        giskard.avoid_all_collisions()\n        if designator.allow_gripper_collision:\n            giskard.allow_gripper_collision(designator.arm)\n        giskard.achieve_cartesian_goal(pose_in_map, RobotDescription.current_robot_description.get_arm_chain(\n            designator.arm).get_tool_frame(), \"map\")\n\n\nclass HSRBMoveArmJointsReal(ProcessModule):\n    \"\"\"\n    Moves the arm joints of the real HSRB to the given configuration while avoiding all collisions via giskard\n    \"\"\"\n\n    def _execute(self, designator: MoveArmJointsMotion) -> Any:\n        joint_goals = {}\n        if designator.left_arm_poses:\n            joint_goals.update(designator.left_arm_poses)\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal(joint_goals)\n\n\nclass HSRBMoveJointsReal(ProcessModule):\n    \"\"\"\n    Moves any joint using giskard, avoids all collisions while doint this.\n    \"\"\"\n\n    def _execute(self, designator: MoveJointsMotion) -> Any:\n        name_to_position = dict(zip(designator.names, designator.positions))\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal(name_to_position)\n\n\nclass HSRBMoveGripperReal(ProcessModule):\n    \"\"\"\n     Opens or closes the gripper of the real HSRB with the help of giskard.\n     \"\"\"\n\n    def _execute(self, designator: MoveGripperMotion) -> Any:\n        tmc_gripper_control(designator)\n\n\nclass HSRBOpenReal(ProcessModule):\n    \"\"\"\n    This process Modules tries to open an already grasped container via giskard\n    \"\"\"\n\n    def _execute(self, designator: OpeningMotion) -> Any:\n        giskard.achieve_open_container_goal(\n            RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),\n            designator.object_part.name)\n\n\nclass HSRBCloseReal(ProcessModule):\n    \"\"\"\n    This process module executes close a an already grasped container via giskard\n    \"\"\"\n\n    def _execute(self, designator: ClosingMotion) -> Any:\n        giskard.achieve_close_container_goal(\n            RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),\n            designator.object_part.name)\n\n\nclass HSRBTalkReal(ProcessModule):\n    \"\"\"\n    Let the robot speak over tmc interface.\n    \"\"\"\n\n    def _execute(self, designator: TalkingMotion) -> Any:\n        tmc_talk(designator)\n\n\n###########################################################\n########## Process Modules for the Semi Real HSRB ###############\n###########################################################\nclass HSRBNavigationSemiReal(ProcessModule):\n    \"\"\"\n    Process module for the real HSRB that sends a cartesian goal to giskard to move the robot base\n    \"\"\"\n\n    def _execute(self, designator: MoveMotion) -> Any:\n        rospy.logdebug(f\"Sending goal to giskard to Move the robot\")\n        giskard.teleport_robot(designator.target)\n\n\nclass HSRBTalkSemiReal(ProcessModule):\n    \"\"\"\n    Low Level implementation to let the robot talk using gTTS and pydub.\n    \"\"\"\n\n    def _execute(self, designator: TalkingMotion) -> Any:\n        \"\"\"\n        Convert text to speech using gTTS, modify the pitch and play it without saving to disk.\n        \"\"\"\n        sentence = designator.cmd\n        # Create a gTTS object\n        tts = gTTS(text=sentence, lang='en', slow=False)\n\n        # Save the speech to an in-memory file\n        mp3_fp = io.BytesIO()\n        tts.write_to_fp(mp3_fp)\n        mp3_fp.seek(0)\n\n        # Load the audio into pydub from the in-memory file\n        audio = AudioSegment.from_file(mp3_fp, format=\"mp3\")\n\n        # Speed up the audio slightly\n        faster_audio = audio.speedup(playback_speed=1.2)\n\n        # Play the modified audio\n        play(faster_audio)\n\n\n###########################################################\n########## HSRB MANAGER ###############\n###########################################################\nclass HSRBManager(ProcessModuleManager):\n\n    def __init__(self):\n        super().__init__(\"hsrb\")\n        self._navigate_lock = Lock()\n        self._pick_up_lock = Lock()\n        self._place_lock = Lock()\n        self._looking_lock = Lock()\n        self._detecting_lock = Lock()\n        self._move_tcp_lock = Lock()\n        self._move_arm_joints_lock = Lock()\n        self._world_state_detecting_lock = Lock()\n        self._move_joints_lock = Lock()\n        self._move_gripper_lock = Lock()\n        self._open_lock = Lock()\n        self._close_lock = Lock()\n        self._talk_lock = Lock()\n\n    def navigate(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return HSRBNavigation(self._navigate_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBNavigationReal(self._navigate_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBNavigationSemiReal(self._navigate_lock)\n\n    def looking(self):\n        if ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBMoveHeadReal(self._looking_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBMoveHeadReal(self._looking_lock)\n\n    def detecting(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return HSRBDetecting(self._detecting_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBDetectingReal(self._detecting_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBDetecting(self._detecting_lock)\n\n    def move_tcp(self):\n        if  ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBMoveTCPReal(self._move_tcp_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBMoveTCPReal(self._move_tcp_lock)\n\n    def move_arm_joints(self):\n        if ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBMoveArmJointsReal(self._move_arm_joints_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBMoveArmJointsReal(self._move_arm_joints_lock)\n\n    def move_joints(self):\n        if ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBMoveJointsReal(self._move_joints_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBMoveJointsReal(self._move_joints_lock)\n\n    def move_gripper(self):\n        if ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBMoveGripperReal(self._move_gripper_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBMoveGripperReal(self._move_gripper_lock)\n\n    def open(self):\n        if ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBOpenReal(self._open_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBOpenReal(self._open_lock)\n\n    def close(self):\n        if ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBCloseReal(self._close_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBCloseReal(self._close_lock)\n\n    def talk(self):\n        if ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return HSRBTalkReal(self._talk_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:\n            return HSRBTalkSemiReal(self._talk_lock)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the pr2_process_modules.py file and how do they interact with the PR2 robot's processes?"}, {"role": "assistant", "content": "# Content from: #<pr2_process_modules.py>#\nfrom threading import Lock\nfrom typing_extensions import Any\n\nimport actionlib\n\nfrom .. import world_reasoning as btr\nimport numpy as np\nimport rospy\n\nfrom ..process_module import ProcessModule, ProcessModuleManager\nfrom ..external_interfaces.ik import request_ik\nfrom ..utils import _apply_ik\nfrom ..local_transformer import LocalTransformer\nfrom ..designators.object_designator import ObjectDesignatorDescription\nfrom ..designators.motion_designator import MoveMotion, LookingMotion, \\\n    DetectingMotion, MoveTCPMotion, MoveArmJointsMotion, WorldStateDetectingMotion, MoveJointsMotion, \\\n    MoveGripperMotion, OpeningMotion, ClosingMotion\nfrom ..robot_description import RobotDescription\nfrom ..datastructures.world import World\nfrom ..world_concepts.world_object import Object\nfrom ..datastructures.pose import Pose\nfrom ..datastructures.enums import JointType, ObjectType, Arms, ExecutionType\nfrom ..external_interfaces import giskard\nfrom ..external_interfaces.robokudo import *\n\ntry:\n    from pr2_controllers_msgs.msg import Pr2GripperCommandGoal, Pr2GripperCommandAction, Pr2\nexcept ImportError:\n    pass\n\n\nclass Pr2Navigation(ProcessModule):\n    \"\"\"\n    The process module to move the robot from one position to another.\n    \"\"\"\n\n    def _execute(self, desig: MoveMotion):\n        robot = World.robot\n        robot.set_pose(desig.target)\n\n\nclass Pr2MoveHead(ProcessModule):\n    \"\"\"\n        This process module moves the head to look at a specific point in the world coordinate frame.\n        This point can either be a position or an object.\n        \"\"\"\n\n    def _execute(self, desig: LookingMotion):\n        target = desig.target\n        robot = World.robot\n\n        local_transformer = LocalTransformer()\n        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"head_pan_link\"))\n        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"head_tilt_link\"))\n\n        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)\n        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1\n\n        current_pan = robot.get_joint_position(\"head_pan_joint\")\n        current_tilt = robot.get_joint_position(\"head_tilt_joint\")\n\n        robot.set_joint_position(\"head_pan_joint\", new_pan + current_pan)\n        robot.set_joint_position(\"head_tilt_joint\", new_tilt + current_tilt)\n\n\nclass Pr2MoveGripper(ProcessModule):\n    \"\"\"\n    This process module controls the gripper of the robot. They can either be opened or closed.\n    Furthermore, it can only moved one gripper at a time.\n    \"\"\"\n\n    def _execute(self, desig: MoveGripperMotion):\n        robot = World.robot\n        motion = desig.motion\n        for joint, state in RobotDescription.current_robot_description.get_arm_chain(\n                desig.gripper).get_static_gripper_state(motion).items():\n            robot.set_joint_position(joint, state)\n\n\nclass Pr2Detecting(ProcessModule):\n    \"\"\"\n    This process module tries to detect an object with the given type. To be detected the object has to be in\n    the field of view of the robot.\n    \"\"\"\n\n    def _execute(self, desig: DetectingMotion):\n        robot = World.robot\n        object_type = desig.object_type\n        # Should be \"wide_stereo_optical_frame\"\n        cam_frame_name = RobotDescription.current_robot_description.get_camera_frame()\n        # should be [0, 0, 1]\n        camera_description = RobotDescription.current_robot_description.cameras[\n            list(RobotDescription.current_robot_description.cameras.keys())[0]]\n        front_facing_axis = camera_description.front_facing_axis\n\n        objects = World.current_world.get_object_by_type(object_type)\n        for obj in objects:\n            if btr.visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):\n                return obj\n\n\nclass Pr2MoveTCP(ProcessModule):\n    \"\"\"\n    This process moves the tool center point of either the right or the left arm.\n    \"\"\"\n\n    def _execute(self, desig: MoveTCPMotion):\n        target = desig.target\n        robot = World.robot\n\n        _move_arm_tcp(target, robot, desig.arm)\n\n\nclass Pr2MoveArmJoints(ProcessModule):\n    \"\"\"\n    This process modules moves the joints of either the right or the left arm. The joint states can be given as\n    list that should be applied or a pre-defined position can be used, such as \"parking\"\n    \"\"\"\n\n    def _execute(self, desig: MoveArmJointsMotion):\n\n        robot = World.robot\n        if desig.right_arm_poses:\n            robot.set_joint_positions(desig.right_arm_poses)\n        if desig.left_arm_poses:\n            robot.set_joint_positions(desig.left_arm_poses)\n\n\nclass PR2MoveJoints(ProcessModule):\n    \"\"\"\n    Process Module for generic joint movements, is not confined to the arms but can move any joint of the robot\n    \"\"\"\n\n    def _execute(self, desig: MoveJointsMotion):\n        robot = World.robot\n        robot.set_joint_positions(dict(zip(desig.names, desig.positions)))\n\n\nclass Pr2WorldStateDetecting(ProcessModule):\n    \"\"\"\n    This process module detectes an object even if it is not in the field of view of the robot.\n    \"\"\"\n\n    def _execute(self, desig: WorldStateDetectingMotion):\n        obj_type = desig.object_type\n        return list(filter(lambda obj: obj.obj_type == obj_type, World.current_world.objects))[0]\n\n\nclass Pr2Open(ProcessModule):\n    \"\"\"\n    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.\n    \"\"\"\n\n    def _execute(self, desig: OpeningMotion):\n        part_of_object = desig.object_part.world_object\n\n        container_joint = part_of_object.find_joint_above_link(desig.object_part.name, JointType.PRISMATIC)\n\n        goal_pose = btr.link_pose_for_joint_config(part_of_object, {\n            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)\n\n        _move_arm_tcp(goal_pose, World.robot, desig.arm)\n\n        desig.object_part.world_object.set_joint_position(container_joint,\n                                                          part_of_object.get_joint_limits(\n                                                              container_joint)[1] - 0.05)\n\n\nclass Pr2Close(ProcessModule):\n    \"\"\"\n    Low-level implementation that lets the robot close a grasped container, in simulation\n    \"\"\"\n\n    def _execute(self, desig: ClosingMotion):\n        part_of_object = desig.object_part.world_object\n\n        container_joint = part_of_object.find_joint_above_link(desig.object_part.name, JointType.PRISMATIC)\n\n        goal_pose = btr.link_pose_for_joint_config(part_of_object, {\n            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)\n\n        _move_arm_tcp(goal_pose, World.robot, desig.arm)\n\n        desig.object_part.world_object.set_joint_position(container_joint,\n                                                          part_of_object.get_joint_limits(\n                                                              container_joint)[0])\n\n\ndef _move_arm_tcp(target: Pose, robot: Object, arm: Arms) -> None:\n    gripper = RobotDescription.current_robot_description.get_arm_chain(arm).get_tool_frame()\n\n    joints = RobotDescription.current_robot_description.get_arm_chain(arm).joints\n\n    inv = request_ik(target, robot, joints, gripper)\n    _apply_ik(robot, inv)\n\n\n###########################################################\n########## Process Modules for the Real PR2 ###############\n###########################################################\n\n\nclass Pr2NavigationReal(ProcessModule):\n    \"\"\"\n    Process module for the real PR2 that sends a cartesian goal to giskard to move the robot base\n    \"\"\"\n\n    def _execute(self, designator: MoveMotion) -> Any:\n        rospy.logdebug(f\"Sending goal to giskard to Move the robot\")\n        giskard.achieve_cartesian_goal(designator.target, RobotDescription.current_robot_description.base_link, \"map\")\n\n\nclass Pr2MoveHeadReal(ProcessModule):\n    \"\"\"\n    Process module for the real robot to move that such that it looks at the given position. Uses the same calculation\n    as the simulated one\n    \"\"\"\n\n    def _execute(self, desig: LookingMotion):\n        target = desig.target\n        robot = World.robot\n\n        local_transformer = LocalTransformer()\n        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"head_pan_link\"))\n        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"head_tilt_link\"))\n\n        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)\n        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1\n\n        current_pan = robot.get_joint_position(\"head_pan_joint\")\n        current_tilt = robot.get_joint_position(\"head_tilt_joint\")\n\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal({\"head_pan_joint\": new_pan + current_pan,\n                                    \"head_tilt_joint\": new_tilt + current_tilt})\n\n\nclass Pr2DetectingReal(ProcessModule):\n    \"\"\"\n    Process Module for the real Pr2 that tries to detect an object fitting the given object description. Uses Robokudo\n    for perception of the environment.\n    \"\"\"\n\n    def _execute(self, designator: DetectingMotion) -> Any:\n        query_result = query(ObjectDesignatorDescription(types=[designator.object_type]))\n        # print(query_result)\n        obj_pose = query_result[\"ClusterPoseBBAnnotator\"]\n\n        lt = LocalTransformer()\n        obj_pose = lt.transform_pose(obj_pose, World.robot.get_link_tf_frame(\"torso_lift_link\"))\n        obj_pose.orientation = [0, 0, 0, 1]\n        obj_pose.position.x += 0.05\n\n        world_obj = World.current_world.get_object_by_type(designator.object_type)\n        if world_obj:\n            world_obj[0].set_pose(obj_pose)\n            return world_obj[0]\n        elif designator.object_type == ObjectType.JEROEN_CUP:\n            cup = Object(\"cup\", ObjectType.JEROEN_CUP, \"jeroen_cup.stl\", pose=obj_pose)\n            return cup\n        elif designator.object_type == ObjectType.BOWL:\n            bowl = Object(\"bowl\", ObjectType.BOWL, \"bowl.stl\", pose=obj_pose)\n            return bowl\n\n        return world_obj[0]\n\n\nclass Pr2MoveTCPReal(ProcessModule):\n    \"\"\"\n    Moves the tool center point of the real PR2 while avoiding all collisions\n    \"\"\"\n\n    def _execute(self, designator: MoveTCPMotion) -> Any:\n        lt = LocalTransformer()\n        pose_in_map = lt.transform_pose(designator.target, \"map\")\n\n        if designator.allow_gripper_collision:\n            giskard.allow_gripper_collision(designator.arm)\n        giskard.achieve_cartesian_goal(pose_in_map, RobotDescription.current_robot_description.get_arm_chain(\n            designator.arm).get_tool_frame(),\n                                       \"torso_lift_link\")\n        # robot_description.base_link)\n\n\nclass Pr2MoveArmJointsReal(ProcessModule):\n    \"\"\"\n    Moves the arm joints of the real PR2 to the given configuration while avoiding all collisions\n    \"\"\"\n\n    def _execute(self, designator: MoveArmJointsMotion) -> Any:\n        joint_goals = {}\n        if designator.left_arm_poses:\n            joint_goals.update(designator.left_arm_poses)\n        if designator.right_arm_poses:\n            joint_goals.update(designator.right_arm_poses)\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal(joint_goals)\n\n\nclass Pr2MoveJointsReal(ProcessModule):\n    \"\"\"\n    Moves any joint using giskard, avoids all collisions while doint this.\n    \"\"\"\n\n    def _execute(self, designator: MoveJointsMotion) -> Any:\n        name_to_position = dict(zip(designator.names, designator.positions))\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal(name_to_position)\n\n\nclass Pr2MoveGripperReal(ProcessModule):\n    \"\"\"\n    Opens or closes the gripper of the real PR2, gripper uses an action server for this instead of giskard \n    \"\"\"\n\n    def _execute(self, designator: MoveGripperMotion) -> Any:\n        def activate_callback():\n            rospy.loginfo(\"Started gripper Movement\")\n\n        def done_callback(state, result):\n            rospy.loginfo(f\"Reached goal {designator.motion}: {result.reached_goal}\")\n\n        def feedback_callback(msg):\n            pass\n\n        goal = Pr2GripperCommandGoal()\n        goal.command.position = 0.0 if designator.motion == \"close\" else 0.1\n        goal.command.max_effort = 50.0\n        if designator.gripper == \"right\":\n            controller_topic = \"r_gripper_controller/gripper_action\"\n        else:\n            controller_topic = \"l_gripper_controller/gripper_action\"\n        client = actionlib.SimpleActionClient(controller_topic, Pr2GripperCommandAction)\n        rospy.loginfo(\"Waiting for action server\")\n        client.wait_for_server()\n        client.send_goal(goal, active_cb=activate_callback, done_cb=done_callback, feedback_cb=feedback_callback)\n        wait = client.wait_for_result()\n\n\nclass Pr2OpenReal(ProcessModule):\n    \"\"\"\n    Tries to open an already grasped container\n    \"\"\"\n\n    def _execute(self, designator: OpeningMotion) -> Any:\n        giskard.achieve_open_container_goal(\n            RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),\n            designator.object_part.name)\n\n\nclass Pr2CloseReal(ProcessModule):\n    \"\"\"\n    Tries to close an already grasped container\n    \"\"\"\n\n    def _execute(self, designator: ClosingMotion) -> Any:\n        giskard.achieve_close_container_goal(\n            RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),\n            designator.object_part.name)\n\n\nclass Pr2Manager(ProcessModuleManager):\n\n    def __init__(self):\n        super().__init__(\"pr2\")\n        self._navigate_lock = Lock()\n        self._looking_lock = Lock()\n        self._detecting_lock = Lock()\n        self._move_tcp_lock = Lock()\n        self._move_arm_joints_lock = Lock()\n        self._world_state_detecting_lock = Lock()\n        self._move_joints_lock = Lock()\n        self._move_gripper_lock = Lock()\n        self._open_lock = Lock()\n        self._close_lock = Lock()\n\n    def navigate(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return Pr2Navigation(self._navigate_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2NavigationReal(self._navigate_lock)\n\n    def looking(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return Pr2MoveHead(self._looking_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2MoveHeadReal(self._looking_lock)\n\n    def detecting(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return Pr2Detecting(self._detecting_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2DetectingReal(self._detecting_lock)\n\n    def move_tcp(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return Pr2MoveTCP(self._move_tcp_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2MoveTCPReal(self._move_tcp_lock)\n\n    def move_arm_joints(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return Pr2MoveArmJoints(self._move_arm_joints_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2MoveArmJointsReal(self._move_arm_joints_lock)\n\n    def world_state_detecting(self):\n        if (ProcessModuleManager.execution_type == ExecutionType.SIMULATED or\n                ProcessModuleManager.execution_type == ExecutionType.REAL):\n            return Pr2WorldStateDetecting(self._world_state_detecting_lock)\n\n    def move_joints(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return PR2MoveJoints(self._move_joints_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2MoveJointsReal(self._move_joints_lock)\n\n    def move_gripper(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return Pr2MoveGripper(self._move_gripper_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2MoveGripperReal(self._move_gripper_lock)\n\n    def open(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return Pr2Open(self._open_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2OpenReal(self._open_lock)\n\n    def close(self):\n        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:\n            return Pr2Close(self._close_lock)\n        elif ProcessModuleManager.execution_type == ExecutionType.REAL:\n            return Pr2CloseReal(self._close_lock)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the stretch_process_modules.py file and how do they contribute to the overall functionality of the program?"}, {"role": "assistant", "content": "# Content from: #<stretch_process_modules.py>#\nfrom typing import Any\n\nimport rospy\n\nfrom ..external_interfaces.robokudo import *\nfrom ..utils import _apply_ik\nfrom ..external_interfaces import giskard\nfrom .default_process_modules import *\nfrom ..datastructures.world import World\nfrom ..designators.motion_designator import *\nfrom ..external_interfaces.ik import request_giskard_ik\nfrom ..robot_description import RobotDescription\n\n\nclass StretchNavigate(DefaultNavigation):\n    \"\"\"\n    Process module for the simulated Stretch that sends a cartesian goal to the robot to move the robot base\n    \"\"\"\n    pass\n\n\nclass StretchMoveHead(ProcessModule):\n    \"\"\"\n    Process module for the simulated Stretch that moves the head such that it looks at the given position\n    \"\"\"\n\n    def _execute(self, designator: MoveMotion) -> Any:\n        target = designator.target\n        robot = World.robot\n\n        local_transformer = LocalTransformer()\n        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"link_head_pan\"))\n\n        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)\n        current_pan = robot.get_joint_position(\"joint_head_pan\")\n\n        robot.set_joint_position(\"joint_head_pan\", new_pan + current_pan)\n\n        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"link_head_tilt\"))\n        new_tilt = np.arctan2(-pose_in_tilt.position.y,\n                              np.sqrt(pose_in_tilt.position.z ** 2 + pose_in_tilt.position.x ** 2)) * -1\n        current_tilt = robot.get_joint_position(\"joint_head_tilt\")\n\n        robot.set_joint_position(\"joint_head_tilt\", new_tilt + current_tilt)\n\n\nclass StretchMoveGripper(DefaultMoveGripper):\n    \"\"\"\n    Process module for the simulated Stretch that opens or closes the gripper\n    \"\"\"\n    pass\n\n\nclass StretchDetecting(DefaultDetecting):\n    \"\"\"\n    Process Module for the simulated Stretch that tries to detect an object fitting the given object description\n    \"\"\"\n    pass\n\n\nclass StretchMoveTCP(DefaultMoveTCP):\n    \"\"\"\n    Process module for the simulated Stretch that moves the tool center point of the robot\n    \"\"\"\n    pass\n\n\nclass StretchMoveArmJoints(DefaultMoveArmJoints):\n    \"\"\"\n    Process module for the simulated Stretch that moves the arm joints of the robot\n    \"\"\"\n    pass\n\n\nclass StretchMoveJoints(DefaultMoveJoints):\n    \"\"\"\n    Process module for the simulated Stretch that moves any joint of the robot\n    \"\"\"\n    pass\n\n\nclass StretchWorldStateDetecting(DefaultWorldStateDetecting):\n    \"\"\"\n    Process Module for the simulated Stretch that tries to detect an object using the world state\n    \"\"\"\n    pass\n\n\nclass StretchOpen(ProcessModule):\n    \"\"\"\n    Process module for the simulated Stretch that opens an already grasped container\n    \"\"\"\n\n    def _execute(self, desig: OpeningMotion):\n        part_of_object = desig.object_part.world_object\n\n        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)\n\n        goal_pose = link_pose_for_joint_config(part_of_object, {\n            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)\n\n        _move_arm_tcp(goal_pose, World.robot, desig.arm)\n\n        desig.object_part.world_object.set_joint_position(container_joint,\n                                                              part_of_object.get_joint_limits(\n                                                                  container_joint)[1] - 0.05)\n\n\nclass StretchClose(ProcessModule):\n    \"\"\"\n    Process module for the simulated Stretch that closes an already grasped container\n    \"\"\"\n\n    def _execute(self, desig: ClosingMotion):\n        part_of_object = desig.object_part.world_object\n\n        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)\n\n        goal_pose = link_pose_for_joint_config(part_of_object, {\n            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)\n\n        _move_arm_tcp(goal_pose, World.robot, desig.arm)\n\n        desig.object_part.world_object.set_joint_position(container_joint,\n                                                       part_of_object.get_joint_limits(\n                                                           container_joint)[0])\n\n\ndef _move_arm_tcp(target: Pose, robot: Object, arm: Arms) -> None:\n    gripper = RobotDescription.current_robot_description.get_arm_chain(arm).get_tool_frame()\n\n    # inv = request_ik(target, robot, joints, gripper)\n    pose, joint_states = request_giskard_ik(target, robot, gripper)\n    robot.set_pose(pose)\n    robot.set_joint_positions(joint_states)\n\n\n###########################################################\n########## Process Modules for the Real Stretch ###########\n###########################################################\n\n\nclass StretchNavigationReal(ProcessModule):\n    \"\"\"\n    Process module for the real Stretch that sends a cartesian goal to giskard to move the robot base\n    \"\"\"\n\n    def _execute(self, designator: MoveMotion) -> Any:\n        rospy.logdebug(f\"Sending goal to giskard to Move the robot\")\n        giskard.achieve_cartesian_goal(designator.target, RobotDescription.current_robot_description.base_link, \"map\")\n\n\nclass StretchMoveHeadReal(ProcessModule):\n    \"\"\"\n    Process module for the real robot to move that such that it looks at the given position. Uses the same calculation\n    as the simulated one\n    \"\"\"\n\n    def _execute(self, desig: LookingMotion):\n        target = desig.target\n        robot = World.robot\n\n        local_transformer = LocalTransformer()\n        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"head_pan_link\"))\n\n        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)\n\n        current_pan = robot.get_joint_position(\"joint_head_pan\")\n        current_tilt = robot.get_joint_position(\"joint_head_tilt\")\n\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal({\"head_pan_joint\": new_pan + current_pan})\n\n        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame(\"head_tilt_link\"))\n        new_tilt = np.arctan2(-pose_in_tilt.position.y,\n                              np.sqrt(pose_in_tilt.position.z ** 2 + pose_in_tilt.position.x ** 2)) * -1\n        current_tilt = robot.get_joint_position(\"joint_head_tilt\")\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal({\"head_tilt_joint\": new_tilt + current_tilt})\n\n\nclass StretchDetectingReal(ProcessModule):\n    \"\"\"\n    Process Module for the real Stretch that tries to detect an object fitting the given object description. Uses Robokudo\n    for perception of the environment.\n    \"\"\"\n\n    def _execute(self, designator: DetectingMotion) -> Any:\n        query_result = query(ObjectDesignatorDescription(types=[designator.object_type]))\n        # print(query_result)\n        obj_pose = query_result[\"ClusterPoseBBAnnotator\"]\n\n        lt = LocalTransformer()\n        obj_pose = lt.transform_pose(obj_pose, World.robot.get_link_tf_frame(\"torso_lift_link\"))\n        obj_pose.orientation = [0, 0, 0, 1]\n        obj_pose.position.x += 0.05\n\n        bullet_obj = World.current_world.get_objects_by_type(designator.object_type)\n        if bullet_obj:\n            bullet_obj[0].set_pose(obj_pose)\n            return bullet_obj[0]\n        elif designator.object_type == ObjectType.JEROEN_CUP:\n            cup = Object(\"cup\", ObjectType.JEROEN_CUP, \"jeroen_cup.stl\", pose=obj_pose)\n            return cup\n        elif designator.object_type == ObjectType.BOWL:\n            bowl = Object(\"bowl\", ObjectType.BOWL, \"bowl.stl\", pose=obj_pose)\n            return bowl\n\n        return bullet_obj[0]\n\n\nclass StretchMoveTCPReal(ProcessModule):\n    \"\"\"\n    Moves the tool center point of the real Stretch while avoiding all collisions\n    \"\"\"\n\n    def _execute(self, designator: MoveTCPMotion) -> Any:\n        lt = LocalTransformer()\n        pose_in_map = lt.transform_pose(designator.target, \"map\")\n\n        if designator.allow_gripper_collision:\n            giskard.allow_gripper_collision(designator.arm)\n        giskard.achieve_cartesian_goal(pose_in_map, RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),\n                                       RobotDescription.current_robot_description.base_link)\n\n\nclass StretchMoveArmJointsReal(ProcessModule):\n    \"\"\"\n    Moves the arm joints of the real Stretch to the given configuration while avoiding all collisions\n    \"\"\"\n\n    def _execute(self, designator: MoveArmJointsMotion) -> Any:\n        joint_goals = {}\n        if designator.left_arm_poses:\n            joint_goals.update(designator.left_arm_poses)\n        if designator.right_arm_poses:\n            joint_goals.update(designator.right_arm_poses)\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal(joint_goals)\n\n\nclass StretchMoveJointsReal(ProcessModule):\n    \"\"\"\n    Moves any joint using giskard, avoids all collisions while doint this.\n    \"\"\"\n\n    def _execute(self, designator: MoveJointsMotion) -> Any:\n        name_to_position = dict(zip(designator.names, designator.positions))\n        giskard.avoid_all_collisions()\n        giskard.achieve_joint_goal(name_to_position)\n\n\nclass StretchMoveGripperReal(ProcessModule):\n    \"\"\"\n    Opens or closes the gripper of the real Stretch, gripper uses an action server for this instead of giskard\n    \"\"\"\n\n    def _execute(self, designator: MoveGripperMotion) -> Any:\n        chain = RobotDescription.current_robot_description.get_arm_chain(designator.gripper).get_static_gripper_state(designator.motion)\n        giskard.achieve_joint_goal(chain)\n\n\nclass StretchOpenReal(ProcessModule):\n    \"\"\"\n    Tries to open an already grasped container\n    \"\"\"\n\n    def _execute(self, designator: OpeningMotion) -> Any:\n        giskard.achieve_open_container_goal(RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),\n                                            designator.object_part.name)\n\n\nclass StretchCloseReal(ProcessModule):\n    \"\"\"\n    Tries to close an already grasped container\n    \"\"\"\n\n    def _execute(self, designator: ClosingMotion) -> Any:\n            giskard.achieve_close_container_goal(RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),\n                                             designator.object_part.name)\n\n\nclass StretchManager(ProcessModuleManager):\n    def __init__(self):\n        super().__init__(\"stretch_description\")\n        self._navigate_lock = Lock()\n        self._looking_lock = Lock()\n        self._detecting_lock = Lock()\n        self._move_tcp_lock = Lock()\n        self._move_arm_joints_lock = Lock()\n        self._world_state_detecting_lock = Lock()\n        self._move_joints_lock = Lock()\n        self._move_gripper_lock = Lock()\n        self._open_lock = Lock()\n        self._close_lock = Lock()\n\n    def navigate(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchNavigate(self._navigate_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchNavigationReal(self._navigate_lock)\n\n    def looking(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchMoveHead(self._looking_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchMoveHeadReal(self._looking_lock)\n\n    def detecting(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchDetecting(self._detecting_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchDetectingReal(self._detecting_lock)\n\n    def move_tcp(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchMoveTCP(self._move_tcp_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchMoveTCPReal(self._move_tcp_lock)\n\n    def move_arm_joints(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchMoveArmJoints(self._move_arm_joints_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchMoveArmJointsReal(self._move_arm_joints_lock)\n\n    def world_state_detecting(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED or ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchWorldStateDetecting(self._world_state_detecting_lock)\n\n    def move_joints(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchMoveJoints(self._move_joints_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchMoveJointsReal(self._move_joints_lock)\n\n    def move_gripper(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchMoveGripper(self._move_gripper_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchMoveGripperReal(self._move_gripper_lock)\n\n    def open(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchOpen(self._open_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchOpenReal(self._open_lock)\n\n    def close(self):\n        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:\n            return StretchClose(self._close_lock)\n        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:\n            return StretchCloseReal(self._close_lock)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the boxy_description.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<boxy_description.py>#\nimport rospkg\nfrom ..robot_description import RobotDescription, CameraDescription, KinematicChainDescription, \\\n    EndEffectorDescription, RobotDescriptionManager\nfrom ..datastructures.enums import Arms, Grasp, GripperState\n\nrospack = rospkg.RosPack()\nfilename = rospack.get_path('pycram') + '/resources/robots/' + \"boxy\" + '.urdf'\n\nboxy_description = RobotDescription(\"boxy\", \"base_link\", \"triangle_base_link\", \"triangle_base_joint\",\n                                    filename)\n\n################################## Right Arm ##################################\nright_arm = KinematicChainDescription(\"right_arm\", \"calib_right_arm_base_link\", \"right_arm_7_link\",\n                                      boxy_description.urdf_object, arm_type=Arms.RIGHT)\n\nright_arm.add_static_joint_states(\"park\", {\"right_arm_0_joint\": 1.858,\n                                           \"right_arm_1_joint\": -0.70571,\n                                           \"right_arm_2_joint\": -0.9614,\n                                           \"right_arm_3_joint\": 0.602,\n                                           \"right_arm_4_joint\": 2.5922,\n                                           \"right_arm_5_joint\": 1.94065,\n                                           \"right_arm_6_joint\": 1.28735})\n\nboxy_description.add_kinematic_chain_description(right_arm)\n\n################################## Right Gripper ##################################\n\nright_gripper = EndEffectorDescription(\"right_gripper\", \"right_gripper_base_link\", \"right_gripper_tool_frame\",\n                                       boxy_description.urdf_object)\n\nright_gripper.add_static_joint_states(GripperState.OPEN, {\"right_gripper_joint\": 0.548})\nright_gripper.add_static_joint_states(GripperState.CLOSE, {\"right_gripper_joint\": 0.0})\n\nright_arm.end_effector = right_gripper\n\n################################## Left Arm ##################################\nleft_arm = KinematicChainDescription(\"left_arm\", \"calib_left_arm_base_link\", \"left_arm_7_link\",\n                                     boxy_description.urdf_object, arm_type=Arms.LEFT)\n\nleft_arm.add_static_joint_states(\"park\", {\"left_arm_0_joint\": -1.858,\n                                          \"left_arm_1_joint\": 0.70571,\n                                          \"left_arm_2_joint\": 0.9614,\n                                          \"left_arm_3_joint\": -0.602,\n                                          \"left_arm_4_joint\": -2.5922,\n                                          \"left_arm_5_joint\": -1.94065,\n                                          \"left_arm_6_joint\": -1.28735})\n\nboxy_description.add_kinematic_chain_description(left_arm)\n\n################################## Left Gripper ##################################\n\nleft_gripper = EndEffectorDescription(\"left_gripper\", \"left_gripper_base_link\", \"left_gripper_tool_frame\",\n                                      boxy_description.urdf_object)\n\nleft_gripper.add_static_joint_states(GripperState.OPEN, {\"left_gripper_joint\": 0.548})\nleft_gripper.add_static_joint_states(GripperState.CLOSE, {\"left_gripper_joint\": 0.0})\n\nleft_arm.end_effector = left_gripper\n\n################################## Camera ##################################\ncamera = CameraDescription(\"head_mount_kinect2_rgb_optical_frame\", \"head_mount_kinect2_rgb_optical_frame\",\n                           2.5, 0.99483, 0.75049)\nboxy_description.add_camera_description(camera)\n\n################################## Neck ##################################\nboxy_description.add_kinematic_chain(\"neck\", \"neck_base_link\", \"neck_wrist_3_link\")\n\n################################# Grasps ##################################\nboxy_description.add_grasp_orientations({Grasp.LEFT: [1, 0, 0, 1],\n                                         Grasp.TOP: [1, 1, 0, 0],\n                                         Grasp.RIGHT: [0, 1, 1, 0],\n                                         Grasp.FRONT: [1, 0, 1, 0]})\n\n# Add to RobotDescriptionManager\nrdm = RobotDescriptionManager()\nrdm.register_description(boxy_description)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functionalities are defined in the donbot_description.py file?"}, {"role": "assistant", "content": "# Content from: #<donbot_description.py>#\nimport rospkg\nfrom ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \\\n    RobotDescriptionManager, CameraDescription\nfrom ..datastructures.enums import Arms, Grasp, GripperState\n\nrospack = rospkg.RosPack()\nfilename = rospack.get_path('pycram') + '/resources/robots/' + \"iai_donbot\" + '.urdf'\n\ndonbot_description = RobotDescription(\"iai_donbot\", \"base_link\", \"ur5_base_link\", \"arm_base_mounting_joint\",\n                                      filename)\n\n################################## Right Arm ##################################\nright_arm = KinematicChainDescription(\"right_arm\", \"ur5_base_link\", \"ur5_wrist_3_link\", donbot_description.urdf_object, arm_type=Arms.RIGHT)\n\nright_arm.add_static_joint_states(\"park\", {'ur5_shoulder_pan_joint': 3.23,\n                                           'ur5_shoulder_lift_joint': -1.51,\n                                           'ur5_elbow_joint': -0.79,\n                                           'ur5_wrist_1_joint': -2.33,\n                                           'ur5_wrist_2_joint': 1.57,\n                                           'ur5_wrist_3_joint': -1.65})\n\ndonbot_description.add_kinematic_chain_description(right_arm)\n\n################################## Right Gripper ##################################\n\nright_gripper = EndEffectorDescription(\"right_gripper\", \"gripper_base_link\", \"gripper_tool_frame\",\n                                       donbot_description.urdf_object)\n\nright_gripper.add_static_joint_states(GripperState.OPEN, {'gripper_joint': 0.0})\nright_gripper.add_static_joint_states(GripperState.CLOSE, {'gripper_joint': 0.2})\n\nright_arm.end_effector = right_gripper\n\n################################## Camera ##################################\ncamera = CameraDescription(\"camera_link\", \"camera_link\", 0.75049, 0.5, 1.2)\ndonbot_description.add_camera_description(camera)\n\n################################## Neck ##################################\ndonbot_description.add_kinematic_chain(\"neck\", \"ur5_base_link\", \"ur5_base_link\")\n\n# Add to RobotDescriptionManager\nrdm = RobotDescriptionManager()\nrdm.register_description(donbot_description)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the main functions defined in the hsrb_description.py file?"}, {"role": "assistant", "content": "# Content from: #<hsrb_description.py>#\nimport rospkg\n\nfrom ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \\\n    RobotDescriptionManager, CameraDescription\nfrom ..datastructures.enums import GripperState, Grasp, Arms\n\nrospack = rospkg.RosPack()\nfilename = rospack.get_path('pycram') + '/resources/robots/' + \"hsrb\" + '.urdf'\n\nhsrb_description = RobotDescription(\"hsrb\", \"base_link\", \"arm_lift_link\", \"arm_lift_joint\",\n                                    filename)\n\n################################## Left Arm ##################################\nleft_arm = KinematicChainDescription(\"left_arm\", \"arm_lift_link\", \"hand_palm_link\",\n                                     hsrb_description.urdf_object, arm_type=Arms.LEFT)\n\nleft_arm.add_static_joint_states(\"park\", {'arm_flex_joint': 0.0,\n                                          'arm_roll_joint': 1.5,\n                                          'wrist_flex_joint': -1.85,\n                                          'wrist_roll_joint': 0.0})\nhsrb_description.add_kinematic_chain_description(left_arm)\n\n################################## Left Gripper ##################################\nleft_gripper = EndEffectorDescription(\"left_gripper\", \"wrist_roll_link\", \"hand_gripper_tool_frame\",\n                                      hsrb_description.urdf_object)\n\nleft_gripper.add_static_joint_states(GripperState.OPEN, {'hand_l_proximal_joint': 0.3,\n                                                         'hand_r_proximal_joint': 0.3,\n                                                         'hand_motor_joint': 0.3})\nleft_gripper.add_static_joint_states(GripperState.CLOSE, {'hand_l_proximal_joint': 0.0,\n                                                          'hand_r_proximal_joint': 0.0,\n                                                          'hand_motor_joint': 0.0})\n\nleft_arm.end_effector = left_gripper\n\n################################## Camera ##################################\n\nhead_center_camera = CameraDescription(\"head_center_camera_frame\", \"head_center_camera_frame\", 0.99483, 0.75049)\nhead_r_camera = CameraDescription(\"head_r_stereo_camera_link\", \"head_r_stereo_camera_link\", 0.99483, 0.75049)\nhead_l_camera = CameraDescription(\"head_l_stereo_camera_link\", \"head_l_stereo_camera_link\", 0.99483, 0.75049)\nhead_rgbd_camera = CameraDescription(\"head_rgbd_sensor_link\", \"head_rgbd_sensor_link\", 0.99483, 0.75049)\nhand_camera = CameraDescription(\"hand_camera_frame\", \"hand_camera_frame\", 0.99483, 0.75049)\n\nhsrb_description.add_camera_description(head_center_camera)\nhsrb_description.add_camera_description(head_r_camera)\nhsrb_description.add_camera_description(head_l_camera)\nhsrb_description.add_camera_description(head_rgbd_camera)\nhsrb_description.add_camera_description(hand_camera)\n\n################################## Neck ##################################\nneck = KinematicChainDescription(\"neck\", \"head_pan_link\", \"head_tilt_link\",\n                                 hsrb_description.urdf_object)\n\n################################## Grasps ##################################\nhsrb_description.add_grasp_orientations(\n    {Grasp.FRONT: [-1, 0, -1, 0],\n     Grasp.LEFT: [0, -1, 1, 0],\n     Grasp.RIGHT: [0, -1, -1, 0.0],\n     Grasp.TOP: [-1, 0, 0, 0]})\n\nhsrb_description.add_kinematic_chain_description(neck)\n\n# Add to RobotDescriptionManager\nrdm = RobotDescriptionManager()\nrdm.register_description(hsrb_description)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the pr2_description.py file and what are their purposes?"}, {"role": "assistant", "content": "# Content from: #<pr2_description.py>#\nfrom ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \\\n    RobotDescriptionManager, CameraDescription\nfrom ..datastructures.enums import Arms, Grasp, GripperState, GripperType\nimport rospkg\n\nrospack = rospkg.RosPack()\nfilename = rospack.get_path('pycram') + '/resources/robots/' + \"pr2\" + '.urdf'\n\npr2_description = RobotDescription(\"pr2\", \"base_link\", \"torso_lift_link\", \"torso_lift_joint\",\n                                   filename)\n\n################################## Left Arm ##################################\nleft_arm = KinematicChainDescription(\"left\", \"torso_lift_link\", \"l_wrist_roll_link\",\n                                     pr2_description.urdf_object, arm_type=Arms.LEFT)\nleft_arm.add_static_joint_states(\"park\", {'l_shoulder_pan_joint': 1.712,\n                                          'l_shoulder_lift_joint': -0.264,\n                                          'l_upper_arm_roll_joint': 1.38,\n                                          'l_elbow_flex_joint': -2.12,\n                                          'l_forearm_roll_joint': 16.996,\n                                          'l_wrist_flex_joint': -0.073,\n                                          'l_wrist_roll_joint': 0.0})\npr2_description.add_kinematic_chain_description(left_arm)\n\n################################## Left Gripper ##################################\nleft_gripper = EndEffectorDescription(\"left_gripper\", \"l_gripper_palm_link\", \"l_gripper_tool_frame\",\n                                      pr2_description.urdf_object)\nleft_gripper.add_static_joint_states(GripperState.OPEN, {'l_gripper_l_finger_joint': 0.548,\n                                              'l_gripper_r_finger_joint': 0.548})\nleft_gripper.add_static_joint_states(GripperState.CLOSE, {'l_gripper_l_finger_joint': 0.0,\n                                               'l_gripper_r_finger_joint': 0.0})\nleft_gripper.end_effector_type = GripperType.PARALLEL\nleft_gripper.opening_distance = 0.548\nleft_arm.end_effector = left_gripper\n\n################################## Right Arm ##################################\nright_arm = KinematicChainDescription(\"right\", \"torso_lift_link\", \"r_wrist_roll_link\",\n                                      pr2_description.urdf_object, arm_type=Arms.RIGHT)\nright_arm.add_static_joint_states(\"park\", {'r_shoulder_pan_joint': -1.712,\n                                           'r_shoulder_lift_joint': -0.256,\n                                           'r_upper_arm_roll_joint': -1.463,\n                                           'r_elbow_flex_joint': -2.12,\n                                           'r_forearm_roll_joint': 1.766,\n                                           'r_wrist_flex_joint': -0.07,\n                                           'r_wrist_roll_joint': 0.051})\npr2_description.add_kinematic_chain_description(right_arm)\n\n################################## Right Gripper ##################################\nright_gripper = EndEffectorDescription(\"right_gripper\", \"r_gripper_palm_link\", \"r_gripper_tool_frame\",\n                                       pr2_description.urdf_object)\nright_gripper.add_static_joint_states(GripperState.OPEN, {'r_gripper_l_finger_joint': 0.548,\n                                               'r_gripper_r_finger_joint': 0.548})\nright_gripper.add_static_joint_states(GripperState.CLOSE, {'r_gripper_l_finger_joint': 0.0,\n                                                'r_gripper_r_finger_joint': 0.0})\nright_gripper.end_effector_type = GripperType.PARALLEL\nright_gripper.opening_distance = 0.548\nright_arm.end_effector = right_gripper\n\n\n################################## Camera ##################################\ncamera = CameraDescription(\"kinect_camera\", \"wide_stereo_optical_frame\", 1.27,\n                           1.60, 0.99483, 0.75049)\npr2_description.add_camera_description(camera)\n\n################################## Neck ##################################\npr2_description.add_kinematic_chain(\"neck\", \"head_pan_link\", \"head_tilt_link\")\n\n################################# Grasps ##################################\npr2_description.add_grasp_orientations({Grasp.FRONT: [0, 0, 0, 1],\n                                        Grasp.LEFT: [0, 0, -1, 1],\n                                        Grasp.RIGHT: [0, 0, 1, 1],\n                                        Grasp.TOP: [0, 1, 0, 1]})\n\n# Add to RobotDescriptionManager\nrdm = RobotDescriptionManager()\nrdm.register_description(pr2_description)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the stretch_description.py file and how do they contribute to the overall functionality of the program?"}, {"role": "assistant", "content": "# Content from: #<stretch_description.py>#\nimport rospkg\n\nfrom ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \\\n    CameraDescription, RobotDescriptionManager\nfrom ..datastructures.enums import GripperState, Arms, Grasp\n\nrospack = rospkg.RosPack()\nfilename = rospack.get_path('pycram') + '/resources/robots/' + \"stretch_description\" + '.urdf'\n\nstretch_description = RobotDescription(\"stretch_description\", \"base_link\", \"link_lift\", \"joint_lift\", filename)\n\n################################## Right Arm ##################################\narm_description = KinematicChainDescription(\"arm\", \"link_mast\", \"link_wrist_roll\", stretch_description.urdf_object,\n                                            arm_type=Arms.RIGHT)\n\narm_description.add_static_joint_states(\"park\", {'joint_lift': 0.0,\n                                                 'joint_arm_l3': 0.0,\n                                                 'joint_arm_l2': 0.0,\n                                                 'joint_arm_l1': 0.0,\n                                                 'joint_arm_l0': 0.0,\n                                                 'joint_wrist_yaw': 0.0,\n                                                 'joint_wrist_pitch': 0.0,\n                                                 'joint_wrist_roll': 0.0})\n\nstretch_description.add_kinematic_chain_description(arm_description)\n\n################################## Right Gripper ##################################\ngripper_description = EndEffectorDescription(\"arm\", \"link_straight_gripper\", \"link_grasp_center\",\n                                             stretch_description.urdf_object)\n\ngripper_description.add_static_joint_states(GripperState.OPEN, {'joint_gripper_finger_left': 0.59,\n                                                                'joint_gripper_finger_right': 0.59})\ngripper_description.add_static_joint_states(GripperState.CLOSE, {'joint_gripper_finger_left': 0.0,\n                                                                 'joint_gripper_finger_right': 0.0})\n\narm_description.end_effector = gripper_description\n\n################################## Neck ##################################\nneck = KinematicChainDescription(\"neck\", \"link_head\", \"link_head_tilt\", stretch_description.urdf_object)\n\nstretch_description.add_kinematic_chain_description(neck)\n\n################################## Camera ##################################\nrealsense_color = CameraDescription(\"camera_color_optical_frame\", \"camera_color_optical_frame\", 1.322, 1.322)\nrealsense_depth = CameraDescription(\"camera_depth_optical_frame\", \"camera_depth_optical_frame\", 1.307, 1.307)\nrealsense_infra1 = CameraDescription(\"camera_infra1_optical_frame\", \"camera_infra1_optical_frame\", 1.307, 1.307)\nrealsense_infra2 = CameraDescription(\"camera_infra2_optical_frame\", \"camera_infra2_optical_frame\", 1.257, 1.257)\n\nstretch_description.add_camera_description(realsense_color)\nstretch_description.add_camera_description(realsense_depth)\nstretch_description.add_camera_description(realsense_infra1)\nstretch_description.add_camera_description(realsense_infra2)\n\n################################## Grasps ##################################\nstretch_description.add_grasp_orientations({Grasp.FRONT: [0, 0, 0, 1],\n                                            Grasp.LEFT: [0, 0, -1, 1],\n                                            Grasp.RIGHT: [0, 0, 1, 1],\n                                            Grasp.TOP: [0, 1, 0, 1]})\n\n# Add to RobotDescriptionManager\nrdm = RobotDescriptionManager()\nrdm.register_description(stretch_description)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functionalities are implemented in the tiago_description.py file?"}, {"role": "assistant", "content": "# Content from: #<tiago_description.py>#\nimport rospkg\nfrom ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \\\n    RobotDescriptionManager, CameraDescription\nfrom ..datastructures.enums import GripperState, Arms, Grasp\n\nrospack = rospkg.RosPack()\nfilename = rospack.get_path('pycram') + '/resources/robots/' + \"tiago_dual\" + '.urdf'\n\ntiago_description = RobotDescription(\"tiago_dual\", \"base_link\", \"torso_lift_link\", \"torso_lift_joint\",\n                                     filename)\n\n################################## Left Arm ##################################\nleft_arm = KinematicChainDescription(\"left_arm\", \"torso_lift_link\", \"arm_left_7_link\",\n                                     tiago_description.urdf_object, arm_type=Arms.LEFT)\n\nleft_arm.add_static_joint_states(\"park\", {'arm_left_1_joint': 0.27,\n                                          'arm_left_2_joint': -1.07,\n                                          'arm_left_3_joint': 1.5,\n                                          'arm_left_4_joint': 1.96,\n                                          'arm_left_5_joint': -2.0,\n                                          'arm_left_6_joint': 1.2,\n                                          'arm_left_7_joint': 0.5})\n\ntiago_description.add_kinematic_chain_description(left_arm)\n\n################################## Left Gripper ##################################\nleft_gripper = EndEffectorDescription(\"left_gripper\", \"gripper_left_link\", \"gripper_left_tool_link\",\n                                      tiago_description.urdf_object)\n\nleft_gripper.add_static_joint_states(GripperState.OPEN, {'gripper_left_left_finger_joint': 0.048,\n                                                         'gripper_left_right_finger_joint': 0.048})\n\nleft_gripper.add_static_joint_states(GripperState.CLOSE, {'gripper_left_left_finger_joint': 0.0,\n                                                          'gripper_left_right_finger_joint': 0.0})\n\nleft_arm.end_effector = left_gripper\n\n################################## Right Arm ##################################\nright_arm = KinematicChainDescription(\"right_arm\", \"torso_lift_link\", \"arm_right_7_link\",\n                                      tiago_description.urdf_object, arm_type=Arms.RIGHT)\n\nright_arm.add_static_joint_states(\"park\", {'arm_right_1_joint': 0.27,\n                                           'arm_right_2_joint': -1.07,\n                                           'arm_right_3_joint': 1.5,\n                                           'arm_right_4_joint': 2.0,\n                                           'arm_right_5_joint': -2.0,\n                                           'arm_right_6_joint': 1.2,\n                                           'arm_right_7_joint': 0.5})\n\ntiago_description.add_kinematic_chain_description(right_arm)\n\n################################## Right Gripper ##################################\nright_gripper = EndEffectorDescription(\"right_gripper\", \"gripper_right_link\", \"gripper_right_tool_link\",\n                                       tiago_description.urdf_object)\n\nright_gripper.add_static_joint_states(GripperState.OPEN, {'gripper_right_left_finger_joint': 0.048,\n                                                          'gripper_right_right_finger_joint': 0.048})\n\nright_gripper.add_static_joint_states(GripperState.CLOSE, {'gripper_right_left_finger_joint': 0.0,\n                                                           'gripper_right_right_finger_joint': 0.0})\n\nright_arm.end_effector = right_gripper\n\n################################## Camera ##################################\ncamera = CameraDescription(\"xtion_optical_frame\", \"xtion_optical_frame\", 0.99483, 0.75049, 1.0665, 1.4165)\ntiago_description.add_camera_description(camera)\n\n################################## Neck ##################################\ntiago_description.add_kinematic_chain(\"neck\", \"torso_lift_link\", \"head_2_link\")\n\n################################# Grasps ##################################\ntiago_description.add_grasp_orientations({Grasp.FRONT: [0, 0, 0, 1],\n                                          Grasp.LEFT: [0, 0, -1, 1],\n                                          Grasp.RIGHT: [0, 0, 1, 1],\n                                          Grasp.TOP: [0, 1, 0, 1]})\n\n# Add to RobotDescriptionManager\nrdm = RobotDescriptionManager()\nrdm.register_description(tiago_description)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the key features and specifications of the TurtleBot as described in the turtlebot_description.py file?"}, {"role": "assistant", "content": "# Content from: #<turtlebot_description.py>#\nimport rospkg\n\nfrom pycram.robot_description import RobotDescriptionManager, RobotDescription\n\n# Description for turtlebot3_waffle_pi\nrospack = rospkg.RosPack()\nfilename = rospack.get_path('pycram') + '/resources/robots/' + \"turtlebot\" + '.urdf'\n\nturtlebot = RobotDescription(\"turtlebot\", \"world\", \"base_link\", \"base_joint\",\n                             filename)\n\n# Add to RobotDescriptionManager\nrdm = RobotDescriptionManager()\nrdm.register_description(turtlebot)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functionalities are defined in the ur5_description.py file for the UR5 robot?"}, {"role": "assistant", "content": "# Content from: #<ur5_description.py>#\nimport rospkg\nfrom ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \\\n    RobotDescriptionManager\nfrom ..datastructures.enums import Arms, Grasp, GripperState\n\nrospack = rospkg.RosPack()\nfilename = rospack.get_path('pycram') + '/resources/robots/' + \"ur5_robotiq\" + '.urdf'\n\nur5_description = RobotDescription(\"ur5_robotiq\", \"world\", \"base_link\", \"ee_link\",\n                                   filename)\n\n################################## Arm ##################################\narm = KinematicChainDescription(\"manipulator\", \"base_link\", \"wrist_3_link\", ur5_description.urdf_object, arm_type=Arms.RIGHT)\n\narm.add_static_joint_states(\"home\", {'shoulder_pan_joint': 0.0,\n                                     'shoulder_lift_joint': 0.0,\n                                     'elbow_joint': 0.0,\n                                     'wrist_1_joint': 0.0,\n                                     'wrist_2_joint': 0.0,\n                                     'wrist_3_joint': 0.0})\n\nur5_description.add_kinematic_chain_description(arm)\n\n################################## Gripper ##################################\ngripper = EndEffectorDescription(\"gripper\", \"robotiq_85_base_link\", \"robotiq_85_right_finger_link\",\n                                 ur5_description.urdf_object)\n\ngripper.add_static_joint_states(GripperState.OPEN, {'robotiq_85_left_finger_joint': 0.0,\n                                         'robotiq_85_right_finger_joint': 0.0,\n                                         'robotiq_85_left_inner_knuckle_joint': 0.0,\n                                         'robotiq_85_right_inner_knuckle_joint': 0.0,\n                                         'robotiq_85_left_finger_tip_joint': 0.0,\n                                         'robotiq_85_right_finger_tip_joint': 0.0})\ngripper.add_static_joint_states(GripperState.CLOSE, {'robotiq_85_left_finger_joint': 1,\n                                          'robotiq_85_right_finger_joint': 1,\n                                          'robotiq_85_left_inner_knuckle_joint': 1.0,\n                                          'robotiq_85_right_inner_knuckle_joint': 1.0,\n                                          'robotiq_85_left_finger_tip_joint': 1.0,\n                                          'robotiq_85_right_finger_tip_joint': 1.0})\n\narm.end_effector = gripper\n\n# Add to RobotDescriptionManager\nrdm = RobotDescriptionManager()\nrdm.register_description(ur5_description)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the force_torque_sensor.py file and how do they interact with sensor data?"}, {"role": "assistant", "content": "# Content from: #<force_torque_sensor.py>#\nimport atexit\nimport time\nimport threading\n\nimport rospy\n\nfrom geometry_msgs.msg import WrenchStamped\nfrom std_msgs.msg import Header\nfrom ..datastructures.world import World\n\n\nclass ForceTorqueSensor:\n    \"\"\"\n    Simulated force-torque sensor for a joint with a given name.\n    Reads simulated forces and torques at that joint from world and publishes geometry_msgs/Wrench messages\n    to the given topic.\n    \"\"\"\n    def __init__(self, joint_name, fts_topic=\"/pycram/fts\", interval=0.1):\n        \"\"\"\n        The given joint_name has to be part of :py:attr:`~pycram.world.World.robot` otherwise a\n        RuntimeError will be raised.\n\n        :param joint_name: Name of the joint for which force-torque should be simulated\n        :param fts_topic: Name of the ROS topic to which should be published\n        :param interval: Interval at which the messages should be published, in seconds\n        \"\"\"\n        self.world = World.current_world\n        self.fts_joint_idx = None\n        self.joint_name = joint_name\n        if joint_name in self.world.robot.joint_name_to_id.keys():\n            self.fts_joint_idx = self.world.robot.joint_name_to_id[joint_name]\n        else:\n            raise RuntimeError(f\"Could not register ForceTorqueSensor: Joint {joint_name}\"\n                               f\" does not exist in robot object\")\n        self.world.enable_joint_force_torque_sensor(self.world.robot, self.fts_joint_idx)\n\n        self.fts_pub = rospy.Publisher(fts_topic, WrenchStamped, queue_size=10)\n        self.interval = interval\n        self.kill_event = threading.Event()\n\n        self.thread = threading.Thread(target=self._publish)\n        self.thread.start()\n\n        atexit.register(self._stop_publishing)\n\n    def _publish(self) -> None:\n        \"\"\"\n        Continuously publishes the force-torque values for the simulated joint. Values are published as long as the\n        kill_event is not set.\n        \"\"\"\n        seq = 0\n        while not self.kill_event.is_set():\n            joint_ft = self.world.get_joint_reaction_force_torque(self.world.robot, self.fts_joint_idx)\n            h = Header()\n            h.seq = seq\n            h.stamp = rospy.Time.now()\n            h.frame_id = self.joint_name\n\n            wrench_msg = WrenchStamped()\n            wrench_msg.header = h\n            wrench_msg.wrench.force.x = joint_ft[0]\n            wrench_msg.wrench.force.y = joint_ft[1]\n            wrench_msg.wrench.force.z = joint_ft[2]\n\n            wrench_msg.wrench.torque.x = joint_ft[3]\n            wrench_msg.wrench.torque.y = joint_ft[4]\n            wrench_msg.wrench.torque.z = joint_ft[5]\n\n            self.fts_pub.publish(wrench_msg)\n            seq += 1\n            time.sleep(self.interval)\n\n    def _stop_publishing(self) -> None:\n        \"\"\"\n        Sets the kill_event and therefore terminates the Thread publishing the force-torque values as well as join the\n        threads.\n        \"\"\"\n        self.kill_event.set()\n        self.thread.join()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the joint_state_publisher.py file and how do they contribute to joint state management?"}, {"role": "assistant", "content": "# Content from: #<joint_state_publisher.py>#\nimport time\nimport threading\nimport atexit\n\nimport rospy\n\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nfrom ..datastructures.world import World\n\n\nclass JointStatePublisher:\n    \"\"\"\n    Joint state publisher for the robot currently loaded in the World\n    \"\"\"\n    def __init__(self, joint_state_topic=\"/pycram/joint_state\", interval=0.1):\n        \"\"\"\n        Robot object is from :py:attr:`~pycram.world.World.robot` and current joint states are published to\n        the given joint_state_topic as a JointState message.\n\n        :param joint_state_topic: Topic name to which the joint states should be published\n        :param interval: Interval at which the joint states should be published, in seconds\n        \"\"\"\n        self.world = World.current_world\n\n        self.joint_state_pub = rospy.Publisher(joint_state_topic, JointState, queue_size=10)\n        self.interval = interval\n        self.kill_event = threading.Event()\n        self.thread = threading.Thread(target=self._publish)\n        self.thread.start()\n\n        atexit.register(self._stop_publishing)\n\n    def _publish(self) -> None:\n        \"\"\"\n        Publishes the current joint states of the :py:attr:`~pycram.world.World.robot` in an infinite loop.\n        The joint states are published as long as the kill_event is not set by :py:meth:`~JointStatePublisher._stop_publishing`\n        \"\"\"\n        robot = World.robot\n        joint_names = [joint_name for joint_name in robot.joint_name_to_id.keys()]\n        seq = 0\n\n        while not self.kill_event.is_set():\n            current_joint_states = [robot.get_joint_position(joint_name) for joint_name in joint_names]\n            h = Header()\n            h.stamp = rospy.Time.now()\n            h.seq = seq\n            h.frame_id = \"\"\n            joint_state_msg = JointState()\n            joint_state_msg.header = h\n            joint_state_msg.name = joint_names\n            joint_state_msg.position = current_joint_states\n            # joint_state_msg.velocity = [joint_state[1] for joint_state in current_joint_states]\n            self.joint_state_pub.publish(joint_state_msg)\n            seq += 1\n            time.sleep(self.interval)\n\n    def _stop_publishing(self) -> None:\n        \"\"\"\n        Sets the kill_event to terminate the publishing thread and joins the thread.\n        \"\"\"\n        self.kill_event.set()\n        self.thread.join()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the robot_state_updater.py file and how do they interact with the robot's state?"}, {"role": "assistant", "content": "# Content from: #<robot_state_updater.py>#\nimport rospy\nimport atexit\nimport tf\nimport time \n\nfrom geometry_msgs.msg import TransformStamped\nfrom sensor_msgs.msg import JointState\nfrom ..datastructures.world import World\nfrom ..robot_descriptions import robot_description\nfrom ..datastructures.pose import Pose\n\n\nclass RobotStateUpdater:\n    \"\"\"\n    Updates the robot in the World with information of the real robot published to ROS topics.\n    Infos used to update the robot are:\n\n        * The current pose of the robot\n        * The current joint state of the robot\n    \"\"\"\n\n    def __init__(self, tf_topic: str, joint_state_topic: str):\n        \"\"\"\n        The robot state updater uses a TF topic and a joint state topic to get the current state of the robot.\n\n        :param tf_topic: Name of the TF topic, needs to publish geometry_msgs/TransformStamped\n        :param joint_state_topic: Name of the joint state topic, needs to publish sensor_msgs/JointState\n        \"\"\"\n        self.tf_listener = tf.TransformListener()\n        time.sleep(1)\n        self.tf_topic = tf_topic\n        self.joint_state_topic = joint_state_topic\n\n        self.tf_timer = rospy.Timer(rospy.Duration.from_sec(0.1), self._subscribe_tf)\n        self.joint_state_timer = rospy.Timer(rospy.Duration.from_sec(0.1), self._subscribe_joint_state)\n\n        atexit.register(self._stop_subscription)\n\n    def _subscribe_tf(self, msg: TransformStamped) -> None:\n        \"\"\"\n        Callback for the TF timer, will do a lookup of the transform between map frame and the robot base frame.\n\n        :param msg: TransformStamped message published to the topic\n        \"\"\"\n        trans, rot = self.tf_listener.lookupTransform(\"/map\", robot_description.base_frame, rospy.Time(0))\n        World.robot.set_pose(Pose(trans, rot))\n\n    def _subscribe_joint_state(self, msg: JointState) -> None:\n        \"\"\"\n        Sets the current joint configuration of the robot in the world to the configuration published on the\n        topic. Since this uses rospy.wait_for_message which can have errors when used with threads there might be an\n        attribute error in the rospy implementation.\n\n        :param msg: JointState message published to the topic.\n        \"\"\"\n        try:\n            msg = rospy.wait_for_message(self.joint_state_topic, JointState)\n            for name, position in zip(msg.name, msg.position):\n                World.robot.set_joint_position(name, position)\n        except AttributeError:\n            pass\n\n    def _stop_subscription(self) -> None:\n        \"\"\"\n        Stops the Timer for TF and joint states and therefore the updating of the robot in the world.\n        \"\"\"\n        self.tf_timer.shutdown()\n        self.joint_state_timer.shutdown()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the tf_broadcaster.py file and how do they work?"}, {"role": "assistant", "content": "# Content from: #<tf_broadcaster.py>#\nimport time\nimport rospy\nimport threading\nimport atexit\n\nfrom ..datastructures.pose import Pose\nfrom ..datastructures.world import World\nfrom tf2_msgs.msg import TFMessage\n\n\nclass TFBroadcaster:\n    \"\"\"\n    Broadcaster that publishes TF frames for every object in the World.\n    \"\"\"\n    def __init__(self, projection_namespace= ExecutionType.SIMULATED, odom_frame=\"odom\", interval=0.1):\n        \"\"\"\n        The broadcaster prefixes all published TF messages with a projection namespace to distinguish between the TF\n        frames from the simulation and the one from the real robot.\n\n        :param projection_namespace: Name with which the TF frames should be prefixed\n        :param odom_frame: Name of the statically published odom frame\n        :param interval: Interval at which the TFs should be published, in seconds\n        \"\"\"\n        self.world = World.current_world\n\n        self.tf_static_publisher = rospy.Publisher(\"/tf_static\", TFMessage, queue_size=10)\n        self.tf_publisher = rospy.Publisher(\"/tf\", TFMessage, queue_size=10)\n        self.thread = threading.Thread(target=self._publish, daemon=True)\n        self.kill_event = threading.Event()\n        self.interval = interval\n\n        # Namespaces\n        self.projection_namespace = projection_namespace\n        self.odom_frame = odom_frame\n\n        self.thread.start()\n\n        atexit.register(self._stop_publishing)\n\n    def update(self):\n        \"\"\"\n        Updates the TFs for the static odom frame and all objects currently in the World.\n        \"\"\"\n        # Update static odom\n        self._update_static_odom()\n        # Update pose of objects which are possibly attached on the robot\n        self._update_objects()\n\n    def _update_objects(self) -> None:\n        \"\"\"\n        Publishes the current pose of all objects in the World. As well as the poses of all links of these objects.\n        \"\"\"\n        for obj in self.world.objects:\n            pose = obj.get_pose()\n            pose.header.stamp = rospy.Time.now()\n            self._publish_pose(obj.tf_frame, pose)\n            for link in obj.link_name_to_id.keys():\n                link_pose = obj.get_link_pose(link)\n                link_pose.header.stamp = rospy.Time.now()\n                self._publish_pose(obj.get_link_tf_frame(link), link_pose)\n\n    def _update_static_odom(self) -> None:\n        \"\"\"\n        Publishes a static odom frame to the tf_static topic.\n        \"\"\"\n        self._publish_pose(self.odom_frame,\n                           Pose([0, 0, 0], [0, 0, 0, 1]), static=True)\n\n    def _publish_pose(self, child_frame_id: str, pose: Pose, static=False) -> None:\n        \"\"\"\n        Publishes the given pose to the ROS TF topic. First the pose is converted to a Transform between pose.frame and\n        the given child_frame_id. Afterward, the frames of the Transform are prefixed with the projection namespace.\n\n        :param child_frame_id: Name of the TF frame which the pose points to\n        :param pose: Pose that should be published\n        :param static: If the pose should be published to the tf_static topic\n        \"\"\"\n        frame_id = pose.frame\n        if frame_id != child_frame_id:\n            tf_stamped = pose.to_transform(child_frame_id)\n            tf_stamped.frame = self.projection_namespace + \"/\" + tf_stamped.frame\n            tf_stamped.child_frame_id = self.projection_namespace + \"/\" + tf_stamped.child_frame_id\n            tf2_msg = TFMessage()\n            tf2_msg.transforms.append(tf_stamped)\n            if static:\n                self.tf_static_publisher.publish(tf2_msg)\n            else:\n                self.tf_publisher.publish(tf2_msg)\n\n    def _publish(self) -> None:\n        \"\"\"\n        Constantly publishes the positions of all objects in the World.\n        \"\"\"\n        while not self.kill_event.is_set():\n            self.update()\n            time.sleep(self.interval)\n\n    def _stop_publishing(self) -> None:\n        \"\"\"\n        Called when the process ends, sets the kill_event which terminates the thread that publishes to the TF topic.\n        \"\"\"\n        self.kill_event.set()\n        self.thread.join()\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the viz_marker_publisher.py file and how do they contribute to visualizing markers?"}, {"role": "assistant", "content": "# Content from: #<viz_marker_publisher.py>#\nimport atexit\nimport threading\nimport time\nfrom typing import List, Optional, Tuple\n\nimport rospy\nfrom geometry_msgs.msg import Vector3\nfrom std_msgs.msg import ColorRGBA\nfrom visualization_msgs.msg import Marker, MarkerArray\n\nfrom ..datastructures.dataclasses import BoxVisualShape, CylinderVisualShape, MeshVisualShape, SphereVisualShape\nfrom ..datastructures.pose import Pose, Transform\nfrom ..designator import ObjectDesignatorDescription\nfrom ..datastructures.world import World\n\n\nclass VizMarkerPublisher:\n    \"\"\"\n    Publishes an Array of visualization marker which represent the situation in the World\n    \"\"\"\n\n    def __init__(self, topic_name=\"/pycram/viz_marker\", interval=0.1):\n        \"\"\"\n        The Publisher creates an Array of Visualization marker with a Marker for each link of each Object in the\n        World. This Array is published with a rate of interval.\n\n        :param topic_name: The name of the topic to which the Visualization Marker should be published.\n        :param interval: The interval at which the visualization marker should be published, in seconds.\n        \"\"\"\n        self.topic_name = topic_name\n        self.interval = interval\n\n        self.pub = rospy.Publisher(self.topic_name, MarkerArray, queue_size=10)\n\n        self.thread = threading.Thread(target=self._publish)\n        self.kill_event = threading.Event()\n        self.main_world = World.current_world if not World.current_world.is_prospection_world else World.current_world.world_sync.world\n\n        self.thread.start()\n        atexit.register(self._stop_publishing)\n\n    def _publish(self) -> None:\n        \"\"\"\n        Constantly publishes the Marker Array. To the given topic name at a fixed rate.\n        \"\"\"\n        while not self.kill_event.is_set():\n            marker_array = self._make_marker_array()\n\n            self.pub.publish(marker_array)\n            time.sleep(self.interval)\n\n    def _make_marker_array(self) -> MarkerArray:\n        \"\"\"\n        Creates the Marker Array to be published. There is one Marker for link for each object in the Array, each Object\n        creates a name space in the visualization Marker. The type of Visualization Marker is decided by the collision\n        tag of the URDF.\n\n        :return: An Array of Visualization Marker\n        \"\"\"\n        marker_array = MarkerArray()\n        for obj in self.main_world.objects:\n            if obj.name == \"floor\":\n                continue\n            for link in obj.link_name_to_id.keys():\n                geom = obj.get_link_geometry(link)\n                if not geom:\n                    continue\n                msg = Marker()\n                msg.header.frame_id = \"map\"\n                msg.ns = obj.name\n                msg.id = obj.link_name_to_id[link]\n                msg.type = Marker.MESH_RESOURCE\n                msg.action = Marker.ADD\n                link_pose = obj.get_link_transform(link)\n                if obj.get_link_origin(link) is not None:\n                    link_origin = obj.get_link_origin_transform(link)\n                else:\n                    link_origin = Transform()\n                link_pose_with_origin = link_pose * link_origin\n                msg.pose = link_pose_with_origin.to_pose().pose\n\n                color = [1, 1, 1, 1] if obj.link_name_to_id[link] == -1 else obj.get_link_color(link).get_rgba()\n\n                msg.color = ColorRGBA(*color)\n                msg.lifetime = rospy.Duration(1)\n\n                if isinstance(geom, MeshVisualShape):\n                    msg.type = Marker.MESH_RESOURCE\n                    msg.mesh_resource = \"file://\" + geom.file_name\n                    msg.scale = Vector3(1, 1, 1)\n                    msg.mesh_use_embedded_materials = True\n                elif isinstance(geom, CylinderVisualShape):\n                    msg.type = Marker.CYLINDER\n                    msg.scale = Vector3(geom.radius * 2, geom.radius * 2, geom.length)\n                elif isinstance(geom, BoxVisualShape):\n                    msg.type = Marker.CUBE\n                    msg.scale = Vector3(*geom.size)\n                elif isinstance(geom, SphereVisualShape):\n                    msg.type = Marker.SPHERE\n                    msg.scale = Vector3(geom.radius * 2, geom.radius * 2, geom.radius * 2)\n\n                marker_array.markers.append(msg)\n        return marker_array\n\n    def _stop_publishing(self) -> None:\n        \"\"\"\n        Stops the publishing of the Visualization Marker update by setting the kill event and collecting the thread.\n        \"\"\"\n        self.kill_event.set()\n        self.thread.join()\n\n\nclass ManualMarkerPublisher:\n    \"\"\"\n    Class to manually add and remove marker of objects and poses.\n    \"\"\"\n\n    def __init__(self, topic_name: str = '/pycram/manual_marker', interval: float = 0.1):\n        \"\"\"\n        The Publisher creates an Array of Visualization marker with a marker for a pose or object.\n        This Array is published with a rate of interval.\n\n        :param topic_name: Name of the marker topic\n        :param interval: Interval at which the marker should be published\n        \"\"\"\n        self.start_time = None\n        self.marker_array_pub = rospy.Publisher(topic_name, MarkerArray, queue_size=10)\n\n        self.marker_array = MarkerArray()\n        self.marker_overview = {}\n        self.current_id = 0\n\n        self.interval = interval\n        self.log_message = None\n\n    def publish(self, pose: Pose, color: Optional[List] = None, bw_object: Optional[ObjectDesignatorDescription] = None,\n                name: Optional[str] = None):\n        \"\"\"\n        Publish a pose or an object into the MarkerArray.\n        Priorities to add an object if possible\n\n        :param pose: Pose of the marker\n        :param color: Color of the marker if no object is given\n        :param bw_object: Object to add as a marker\n        :param name: Name of the marker\n        \"\"\"\n\n        if color is None:\n            color = [1, 0, 1, 1]\n\n        self.start_time = time.time()\n        thread = threading.Thread(target=self._publish, args=(pose, bw_object, name, color))\n        thread.start()\n        rospy.loginfo(self.log_message)\n        thread.join()\n\n    def _publish(self, pose: Pose, bw_object: Optional[ObjectDesignatorDescription] = None, name: Optional[str] = None,\n                 color: Optional[List] = None):\n        \"\"\"\n        Publish the marker into the MarkerArray\n        \"\"\"\n        stop_thread = False\n        duration = 2\n\n        while not stop_thread:\n            if time.time() - self.start_time > duration:\n                stop_thread = True\n            if bw_object is None:\n                self._publish_pose(name=name, pose=pose, color=color)\n            else:\n                self._publish_object(name=name, pose=pose, bw_object=bw_object)\n\n            rospy.sleep(self.interval)\n\n    def _publish_pose(self, name: str, pose: Pose, color: Optional[List] = None):\n        \"\"\"\n        Publish a Pose as a marker\n\n        :param name: Name of the marker\n        :param pose: Pose of the marker\n        :param color: Color of the marker\n        \"\"\"\n\n        if name is None:\n            name = 'pose_marker'\n\n        if name in self.marker_overview.keys():\n            self._update_marker(self.marker_overview[name], new_pose=pose)\n            return\n\n        color_rgba = ColorRGBA(*color)\n        self._make_marker_array(name=name, marker_type=Marker.ARROW, marker_pose=pose,\n                                marker_scales=(0.05, 0.05, 0.05), color_rgba=color_rgba)\n        self.marker_array_pub.publish(self.marker_array)\n        self.log_message = f\"Pose '{name}' published\"\n\n    def _publish_object(self, name: Optional[str], pose: Pose, bw_object: ObjectDesignatorDescription):\n        \"\"\"\n        Publish an Object as a marker\n\n        :param name: Name of the marker\n        :param pose: Pose of the marker\n        :param bw_object: ObjectDesignatorDescription for the marker\n        \"\"\"\n\n        bw_real = bw_object.resolve()\n\n        if name is None:\n            name = bw_real.name\n\n        if name in self.marker_overview.keys():\n            self._update_marker(self.marker_overview[name], new_pose=pose)\n            return\n\n        path = bw_real.world_object.root_link.geometry.file_name\n\n        self._make_marker_array(name=name, marker_type=Marker.MESH_RESOURCE, marker_pose=pose,\n                                path_to_resource=path)\n\n        self.marker_array_pub.publish(self.marker_array)\n        self.log_message = f\"Object '{name}' published\"\n\n    def _make_marker_array(self, name, marker_type: int, marker_pose: Pose, marker_scales: Tuple = (1.0, 1.0, 1.0),\n                           color_rgba: ColorRGBA = ColorRGBA(*[1.0, 1.0, 1.0, 1.0]),\n                           path_to_resource: Optional[str] = None):\n        \"\"\"\n        Create a Marker and add it to the MarkerArray\n\n        :param name: Name of the Marker\n        :param marker_type: Type of the marker to create\n        :param marker_pose: Pose of the marker\n        :param marker_scales: individual scaling of the markers axes\n        :param color_rgba: Color of the marker as RGBA\n        :param path_to_resource: Path to the resource of a Bulletworld object\n        \"\"\"\n\n        frame_id = marker_pose.header.frame_id\n        new_marker = Marker()\n        new_marker.id = self.current_id\n        new_marker.header.frame_id = frame_id\n        new_marker.ns = name\n        new_marker.header.stamp = rospy.Time.now()\n        new_marker.type = marker_type\n        new_marker.action = Marker.ADD\n        new_marker.pose = marker_pose.pose\n        new_marker.scale.x = marker_scales[0]\n        new_marker.scale.y = marker_scales[1]\n        new_marker.scale.z = marker_scales[2]\n        new_marker.color.a = color_rgba.a\n        new_marker.color.r = color_rgba.r\n        new_marker.color.g = color_rgba.g\n        new_marker.color.b = color_rgba.b\n\n        if path_to_resource is not None:\n            new_marker.mesh_resource = 'file://' + path_to_resource\n\n        self.marker_array.markers.append(new_marker)\n        self.marker_overview[name] = new_marker.id\n        self.current_id += 1\n\n    def _update_marker(self, marker_id: int, new_pose: Pose) -> bool:\n        \"\"\"\n        Update an existing marker to a new pose\n\n        :param marker_id: id of the marker that should be updated\n        :param new_pose: Pose where the updated marker is set\n\n        :return: True if update was successful, False otherwise\n        \"\"\"\n\n        # Find the marker with the specified ID\n        for marker in self.marker_array.markers:\n            if marker.id == marker_id:\n                # Update successful\n                marker.pose = new_pose\n                self.log_message = f\"Marker '{marker.ns}' updated\"\n                self.marker_array_pub.publish(self.marker_array)\n                return True\n\n        # Update was not successful\n        rospy.logwarn(f\"Marker {marker_id} not found for update\")\n        return False\n\n    def remove_marker(self, bw_object: Optional[ObjectDesignatorDescription] = None, name: Optional[str] = None):\n        \"\"\"\n        Remove a marker by object or name\n\n        :param bw_object: Object which marker should be removed\n        :param name: Name of object that should be removed\n        \"\"\"\n\n        if bw_object is not None:\n            bw_real = bw_object.resolve()\n            name = bw_real.name\n\n        if name is None:\n            rospy.logerr('No name for object given, cannot remove marker')\n            return\n\n        marker_id = self.marker_overview.pop(name)\n\n        for marker in self.marker_array.markers:\n            if marker.id == marker_id:\n                marker.action = Marker.DELETE\n\n        self.marker_array_pub.publish(self.marker_array)\n        self.marker_array.markers.pop(marker_id)\n\n        rospy.loginfo(f\"Removed Marker '{name}'\")\n\n    def clear_all_marker(self):\n        \"\"\"\n        Clear all existing markers\n        \"\"\"\n        for marker in self.marker_array.markers:\n            marker.action = Marker.DELETE\n\n        self.marker_overview = {}\n        self.marker_array_pub.publish(self.marker_array)\n\n        rospy.loginfo('Removed all markers')\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the bullet_world.py file and how do they interact with the physics simulation?"}, {"role": "assistant", "content": "# Content from: #<bullet_world.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nimport threading\nimport time\n\nimport numpy as np\nimport pybullet as p\nimport rosgraph\nimport rospy\nfrom geometry_msgs.msg import Point\nfrom typing_extensions import List, Optional, Dict\n\nfrom ..datastructures.dataclasses import Color, AxisAlignedBoundingBox, MultiBody, VisualShape, BoxVisualShape\nfrom ..datastructures.enums import ObjectType, WorldMode, JointType\nfrom ..datastructures.pose import Pose\nfrom ..datastructures.world import World\nfrom ..object_descriptors.generic import ObjectDescription as GenericObjectDescription\nfrom ..object_descriptors.urdf import ObjectDescription\nfrom ..world_concepts.constraints import Constraint\nfrom ..world_concepts.world_object import Object\n\nLink = ObjectDescription.Link\nRootLink = ObjectDescription.RootLink\nJoint = ObjectDescription.Joint\n\n\nclass BulletWorld(World):\n    \"\"\"\n    This class represents a BulletWorld, which is a simulation environment that uses the Bullet Physics Engine. This\n    class is the main interface to the Bullet Physics Engine and should be used to spawn Objects, simulate Physic and\n    manipulate the Bullet World.\n    \"\"\"\n\n    extension: str = ObjectDescription.get_file_extension()\n\n    # Check is for sphinx autoAPI to be able to work in a CI workflow\n    if rosgraph.is_master_online():  # and \"/pycram\" not in rosnode.get_node_names():\n        rospy.init_node('pycram')\n\n    def __init__(self, mode: WorldMode = WorldMode.DIRECT, is_prospection_world: bool = False, sim_frequency=240):\n        \"\"\"\n        Creates a new simulation, the type decides of the simulation should be a rendered window or just run in the\n        background. There can only be one rendered simulation.\n        The BulletWorld object also initializes the Events for attachment, detachment and for manipulating the world.\n\n        :param mode: Can either be \"GUI\" for rendered window or \"DIRECT\" for non-rendered. The default is \"GUI\"\n        :param is_prospection_world: For internal usage, decides if this BulletWorld should be used as a shadow world.\n        \"\"\"\n        super().__init__(mode=mode, is_prospection_world=is_prospection_world, simulation_frequency=sim_frequency)\n\n        # This disables file caching from PyBullet, since this would also cache\n        # files that can not be loaded\n        p.setPhysicsEngineParameter(enableFileCaching=0)\n\n        # Needed to let the other thread start the simulation, before Objects are spawned.\n        time.sleep(0.1)\n        self.vis_axis: List[int] = []\n\n        # Some default settings\n        self.set_gravity([0, 0, -9.8])\n\n        if not is_prospection_world:\n            _ = Object(\"floor\", ObjectType.ENVIRONMENT, \"plane\" + self.extension,\n                       world=self)\n\n    def _init_world(self, mode: WorldMode):\n        self._gui_thread: Gui = Gui(self, mode)\n        self._gui_thread.start()\n        time.sleep(0.1)\n\n    def load_generic_object_and_get_id(self, description: GenericObjectDescription) -> int:\n        \"\"\"\n        Creates a visual and collision box in the simulation.\n        \"\"\"\n        # Create visual shape\n        vis_shape = p.createVisualShape(p.GEOM_BOX, halfExtents=description.shape_data,\n                                        rgbaColor=description.color.get_rgba())\n\n        # Create collision shape\n        col_shape = p.createCollisionShape(p.GEOM_BOX, halfExtents=description.shape_data)\n\n        # Create MultiBody with both visual and collision shapes\n        obj_id = p.createMultiBody(baseMass=1.0, baseCollisionShapeIndex=col_shape, baseVisualShapeIndex=vis_shape,\n                                   basePosition=description.origin.position_as_list(),\n                                   baseOrientation=description.origin.orientation_as_list())\n\n        # Assuming you have a list to keep track of created objects\n        return obj_id\n\n    def load_object_and_get_id(self, path: Optional[str] = None, pose: Optional[Pose] = None) -> int:\n        if pose is None:\n            pose = Pose()\n        return self._load_object_and_get_id(path, pose)\n\n    def _load_object_and_get_id(self, path: str, pose: Pose) -> int:\n        if path is None:\n            raise ValueError(\"Path to the object file is required.\")\n        return p.loadURDF(path,\n                          basePosition=pose.position_as_list(),\n                          baseOrientation=pose.orientation_as_list(), physicsClientId=self.id)\n\n    def remove_object_from_simulator(self, obj: Object) -> None:\n        p.removeBody(obj.id, self.id)\n\n    def remove_object_by_id(self, obj_id: int) -> None:\n        p.removeBody(obj_id, self.id)\n\n    def add_constraint(self, constraint: Constraint) -> int:\n\n        constraint_id = p.createConstraint(constraint.parent_object_id,\n                                           constraint.parent_link_id,\n                                           constraint.child_object_id,\n                                           constraint.child_link_id,\n                                           constraint.type.value,\n                                           constraint.axis_as_list,\n                                           constraint.position_wrt_parent_as_list,\n                                           constraint.position_wrt_child_as_list,\n                                           constraint.orientation_wrt_parent_as_list,\n                                           constraint.orientation_wrt_child_as_list,\n                                           physicsClientId=self.id)\n        return constraint_id\n\n    def remove_constraint(self, constraint_id):\n        p.removeConstraint(constraint_id, physicsClientId=self.id)\n\n    def get_joint_position(self, joint: ObjectDescription.Joint) -> float:\n        return p.getJointState(joint.object_id, joint.id, physicsClientId=self.id)[0]\n\n    def get_object_joint_names(self, obj: Object) -> List[str]:\n        return [p.getJointInfo(obj.id, i, physicsClientId=self.id)[1].decode('utf-8')\n                for i in range(self.get_object_number_of_joints(obj))]\n\n    def get_link_pose(self, link: ObjectDescription.Link) -> Pose:\n        bullet_link_state = p.getLinkState(link.object_id, link.id, physicsClientId=self.id)\n        return Pose(*bullet_link_state[4:6])\n\n    def get_object_link_names(self, obj: Object) -> List[str]:\n        num_links = self.get_object_number_of_links(obj)\n        return [p.getJointInfo(obj.id, i, physicsClientId=self.id)[12].decode('utf-8')\n                for i in range(num_links)]\n\n    def get_object_number_of_links(self, obj: Object) -> int:\n        return p.getNumJoints(obj.id, physicsClientId=self.id)\n\n    get_object_number_of_joints = get_object_number_of_links\n\n    def perform_collision_detection(self) -> None:\n        p.performCollisionDetection(physicsClientId=self.id)\n\n    def get_object_contact_points(self, obj: Object) -> List:\n        \"\"\"\n        For a more detailed explanation of the\n         returned list please look at:\n         `PyBullet Doc <https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit#>`_\n        \"\"\"\n        self.perform_collision_detection()\n        return p.getContactPoints(obj.id, physicsClientId=self.id)\n\n    def get_contact_points_between_two_objects(self, obj1: Object, obj2: Object) -> List:\n        self.perform_collision_detection()\n        return p.getContactPoints(obj1.id, obj2.id, physicsClientId=self.id)\n\n    def reset_joint_position(self, joint: ObjectDescription.Joint, joint_position: str) -> None:\n        p.resetJointState(joint.object_id, joint.id, joint_position, physicsClientId=self.id)\n\n    def reset_object_base_pose(self, obj: Object, pose: Pose) -> None:\n        p.resetBasePositionAndOrientation(obj.id, pose.position_as_list(), pose.orientation_as_list(),\n                                          physicsClientId=self.id)\n\n    def step(self):\n        p.stepSimulation(physicsClientId=self.id)\n\n    def get_object_pose(self, obj: Object) -> Pose:\n        return Pose(*p.getBasePositionAndOrientation(obj.id, physicsClientId=self.id))\n\n    def set_link_color(self, link: ObjectDescription.Link, rgba_color: Color):\n        p.changeVisualShape(link.object_id, link.id, rgbaColor=rgba_color.get_rgba(), physicsClientId=self.id)\n\n    def get_link_color(self, link: ObjectDescription.Link) -> Color:\n        return self.get_colors_of_object_links(link.object)[link.name]\n\n    def get_colors_of_object_links(self, obj: Object) -> Dict[str, Color]:\n        visual_data = p.getVisualShapeData(obj.id, physicsClientId=self.id)\n        link_id_to_name = {v: k for k, v in obj.link_name_to_id.items()}\n        links = list(map(lambda x: link_id_to_name[x[1]], visual_data))\n        colors = list(map(lambda x: Color.from_rgba(x[7]), visual_data))\n        link_to_color = dict(zip(links, colors))\n        return link_to_color\n\n    def get_object_axis_aligned_bounding_box(self, obj: Object) -> AxisAlignedBoundingBox:\n        return AxisAlignedBoundingBox.from_min_max(*p.getAABB(obj.id, physicsClientId=self.id))\n\n    def get_link_axis_aligned_bounding_box(self, link: ObjectDescription.Link) -> AxisAlignedBoundingBox:\n        return AxisAlignedBoundingBox.from_min_max(*p.getAABB(link.object_id, link.id, physicsClientId=self.id))\n\n    def set_realtime(self, real_time: bool) -> None:\n        p.setRealTimeSimulation(1 if real_time else 0, physicsClientId=self.id)\n\n    def set_gravity(self, gravity_vector: List[float]) -> None:\n        p.setGravity(gravity_vector[0], gravity_vector[1], gravity_vector[2], physicsClientId=self.id)\n\n    def disconnect_from_physics_server(self):\n        p.disconnect(physicsClientId=self.id)\n\n    def join_threads(self):\n        \"\"\"\n        Joins the GUI thread if it exists.\n        \"\"\"\n        self.join_gui_thread_if_exists()\n\n    def join_gui_thread_if_exists(self):\n        if self._gui_thread:\n            self._gui_thread.join()\n\n    def save_physics_simulator_state(self) -> int:\n        return p.saveState(physicsClientId=self.id)\n\n    def restore_physics_simulator_state(self, state_id):\n        p.restoreState(state_id, physicsClientId=self.id)\n\n    def remove_physics_simulator_state(self, state_id: int):\n        p.removeState(state_id, physicsClientId=self.id)\n\n    def add_vis_axis(self, pose: Pose,\n                     length: Optional[float] = 0.2) -> None:\n        \"\"\"\n        Creates a Visual object which represents the coordinate frame at the given\n        position and orientation. There can be an unlimited amount of vis axis objects.\n\n        :param pose: The pose at which the axis should be spawned\n        :param length: Optional parameter to configure the length of the axes\n        \"\"\"\n\n        pose_in_map = self.local_transformer.transform_pose(pose, \"map\")\n\n        box_vis_shape = BoxVisualShape(Color(1, 0, 0, 0.8), [length, 0.01, 0.01], [length, 0.01, 0.01])\n        vis_x = self.create_visual_shape(box_vis_shape)\n\n        box_vis_shape = BoxVisualShape(Color(0, 1, 0, 0.8), [0.01, length, 0.01], [0.01, length, 0.01])\n        vis_y = self.create_visual_shape(box_vis_shape)\n\n        box_vis_shape = BoxVisualShape(Color(0, 0, 1, 0.8), [0.01, 0.01, length], [0.01, 0.01, length])\n        vis_z = self.create_visual_shape(box_vis_shape)\n\n        multibody = MultiBody(base_visual_shape_index=-1, base_pose=pose_in_map,\n                              link_visual_shape_indices=[vis_x, vis_y, vis_z],\n                              link_poses=[Pose(), Pose(), Pose()], link_masses=[1.0, 1.0, 1.0],\n                              link_inertial_frame_poses=[Pose(), Pose(), Pose()], link_parent_indices=[0, 0, 0],\n                              link_joint_types=[JointType.FIXED.value, JointType.FIXED.value, JointType.FIXED.value],\n                              link_joint_axis=[Point(1, 0, 0), Point(0, 1, 0), Point(0, 0, 1)],\n                              link_collision_shape_indices=[-1, -1, -1])\n\n        self.vis_axis.append(self.create_multi_body(multibody))\n\n    def remove_vis_axis(self) -> None:\n        \"\"\"\n        Removes all spawned vis axis objects that are currently in this BulletWorld.\n        \"\"\"\n        for vis_id in self.vis_axis:\n            p.removeBody(vis_id, physicsClientId=self.id)\n        self.vis_axis = []\n\n    def ray_test(self, from_position: List[float], to_position: List[float]) -> int:\n        res = p.rayTest(from_position, to_position, physicsClientId=self.id)\n        return res[0][0]\n\n    def ray_test_batch(self, from_positions: List[List[float]], to_positions: List[List[float]],\n                       num_threads: int = 1) -> List[int]:\n        return p.rayTestBatch(from_positions, to_positions, numThreads=num_threads,\n                              physicsClientId=self.id)\n\n    def create_visual_shape(self, visual_shape: VisualShape) -> int:\n        return p.createVisualShape(visual_shape.visual_geometry_type.value,\n                                   rgbaColor=visual_shape.rgba_color.get_rgba(),\n                                   visualFramePosition=visual_shape.visual_frame_position,\n                                   physicsClientId=self.id, **visual_shape.shape_data())\n\n    def create_multi_body(self, multi_body: MultiBody) -> int:\n        return p.createMultiBody(baseVisualShapeIndex=-multi_body.base_visual_shape_index,\n                                 linkVisualShapeIndices=multi_body.link_visual_shape_indices,\n                                 basePosition=multi_body.base_pose.position_as_list(),\n                                 baseOrientation=multi_body.base_pose.orientation_as_list(),\n                                 linkPositions=[pose.position_as_list() for pose in multi_body.link_poses],\n                                 linkMasses=multi_body.link_masses,\n                                 linkOrientations=[pose.orientation_as_list() for pose in multi_body.link_poses],\n                                 linkInertialFramePositions=[pose.position_as_list()\n                                                             for pose in multi_body.link_inertial_frame_poses],\n                                 linkInertialFrameOrientations=[pose.orientation_as_list()\n                                                                for pose in multi_body.link_inertial_frame_poses],\n                                 linkParentIndices=multi_body.link_parent_indices,\n                                 linkJointTypes=multi_body.link_joint_types,\n                                 linkJointAxis=[[point.x, point.y, point.z] for point in multi_body.link_joint_axis],\n                                 linkCollisionShapeIndices=multi_body.link_collision_shape_indices)\n\n    def get_images_for_target(self,\n                              target_pose: Pose,\n                              cam_pose: Pose,\n                              size: Optional[int] = 256) -> List[np.ndarray]:\n        # TODO: Might depend on robot cameras, if so please add these camera parameters to RobotDescription object\n        # TODO: of your robot with a CameraDescription object.\n        fov = 90\n        aspect = size / size\n        near = 0.2\n        far = 100\n\n        view_matrix = p.computeViewMatrix(cam_pose.position_as_list(), target_pose.position_as_list(), [0, 0, 1])\n        projection_matrix = p.computeProjectionMatrixFOV(fov, aspect, near, far)\n        return list(p.getCameraImage(size, size, view_matrix, projection_matrix,\n                                     physicsClientId=self.id))[2:5]\n\n    def add_text(self, text: str, position: List[float], orientation: Optional[List[float]] = None,\n                 size: Optional[float] = None, color: Optional[Color] = Color(), life_time: Optional[float] = 0,\n                 parent_object_id: Optional[int] = None, parent_link_id: Optional[int] = None) -> int:\n        args = {}\n        if orientation:\n            args[\"textOrientation\"] = orientation\n        if size:\n            args[\"textSize\"] = size\n        if life_time:\n            args[\"lifeTime\"] = life_time\n        if parent_object_id:\n            args[\"parentObjectUniqueId\"] = parent_object_id\n        if parent_link_id:\n            args[\"parentLinkIndex\"] = parent_link_id\n        return p.addUserDebugText(text, position, color.get_rgb(), physicsClientId=self.id, **args)\n\n    def remove_text(self, text_id: Optional[int] = None) -> None:\n        if text_id is not None:\n            p.removeUserDebugItem(text_id, physicsClientId=self.id)\n        else:\n            p.removeAllUserDebugItems(physicsClientId=self.id)\n\n    def enable_joint_force_torque_sensor(self, obj: Object, fts_joint_idx: int) -> None:\n        p.enableJointForceTorqueSensor(obj.id, fts_joint_idx, enableSensor=1, physicsClientId=self.id)\n\n    def disable_joint_force_torque_sensor(self, obj: Object, joint_id: int) -> None:\n        p.enableJointForceTorqueSensor(obj.id, joint_id, enableSensor=0, physicsClientId=self.id)\n\n    def get_joint_reaction_force_torque(self, obj: Object, joint_id: int) -> List[float]:\n        return p.getJointState(obj.id, joint_id, physicsClientId=self.id)[2]\n\n    def get_applied_joint_motor_torque(self, obj: Object, joint_id: int) -> float:\n        return p.getJointState(obj.id, joint_id, physicsClientId=self.id)[3]\n\n\nclass Gui(threading.Thread):\n    \"\"\"\n    For internal use only. Creates a new thread for the physics simulation that is active until closed by\n    :func:`~World.exit`\n    Also contains the code for controlling the camera.\n    \"\"\"\n\n    def __init__(self, world: World, mode: WorldMode):\n        threading.Thread.__init__(self)\n        self.world = world\n        self.mode: WorldMode = mode\n\n    def run(self):\n        \"\"\"\n        Initializes the new simulation and checks in an endless loop\n        if it is still active. If it is the thread will be suspended for 1/80 seconds, if it is not the method and\n        thus the thread terminates. The loop also checks for mouse and keyboard inputs to control the camera.\n        \"\"\"\n        if self.mode == WorldMode.DIRECT:\n            self.world.id = p.connect(p.DIRECT)\n        else:\n            self.world.id = p.connect(p.GUI)\n\n            # DISCLAIMER\n            # This camera control only works if the WorldMooe.GUI BulletWorld is the first one to be created. This is\n            # due to a bug in the function pybullet.getDebugVisualizerCamera() which only returns the information of\n            # the first created simulation.\n\n            # Disable the side windows of the GUI\n            p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0, physicsClientId=self.world.id)\n            # Change the init camera pose\n            p.resetDebugVisualizerCamera(cameraDistance=1.5, cameraYaw=270.0, cameraPitch=-50,\n                                         cameraTargetPosition=[-2, 0, 1], physicsClientId=self.world.id)\n\n            # Get the initial camera target location\n            camera_target_position = p.getDebugVisualizerCamera(physicsClientId=self.world.id)[11]\n\n            sphere_visual_id = p.createVisualShape(p.GEOM_SPHERE, radius=0.05, rgbaColor=[1, 0, 0, 1],\n                                                   physicsClientId=self.world.id)\n\n            # Create a sphere with a radius of 0.05 and a mass of 0\n            sphere_uid = p.createMultiBody(baseMass=0.0,\n                                           baseInertialFramePosition=[0, 0, 0],\n                                           baseVisualShapeIndex=sphere_visual_id,\n                                           basePosition=camera_target_position,\n                                           physicsClientId=self.world.id)\n\n            # Define the maxSpeed, used in calculations\n            max_speed = 16\n\n            # Set initial Camera Rotation\n            camera_yaw = 50\n            camera_pitch = -35\n\n            # Keep track of the mouse state\n            mouse_state = [0, 0, 0]\n            old_mouse_x, old_mouse_y = 0, 0\n\n            # Determines if the sphere at cameraTargetPosition is visible\n            visible = 1\n\n            # Loop to update the camera position based on keyboard events\n            while p.isConnected(self.world.id):\n                # Monitor user input\n                keys = p.getKeyboardEvents(self.world.id)\n                mouse = p.getMouseEvents(self.world.id)\n\n                # Get infos about the camera\n                width, height, dist = (p.getDebugVisualizerCamera()[0],\n                                       p.getDebugVisualizerCamera()[1],\n                                       p.getDebugVisualizerCamera()[10])\n                #print(\"width: \", width, \"height: \", height, \"dist: \", dist)\n                camera_target_position = p.getDebugVisualizerCamera(self.world.id)[11]\n\n                # Get vectors used for movement on x,y,z Vector\n                x_vec = [p.getDebugVisualizerCamera(self.world.id)[2][i] for i in [0, 4, 8]]\n                y_vec = [p.getDebugVisualizerCamera(self.world.id)[2][i] for i in [2, 6, 10]]\n                z_vec = (0, 0, 1)  # [p.getDebugVisualizerCamera()[2][i] for i in [1, 5, 9]]\n\n                # Check the mouse state\n                if mouse:\n                    for m in mouse:\n\n                        mouse_x = m[2]\n                        mouse_y = m[1]\n\n                        # update mouseState\n                        # Left Mouse button\n                        if m[0] == 2 and m[3] == 0:\n                            mouse_state[0] = m[4]\n                        # Middle mouse button (scroll wheel)\n                        if m[0] == 2 and m[3] == 1:\n                            mouse_state[1] = m[4]\n                        # right mouse button\n                        if m[0] == 2 and m[3] == 2:\n                            mouse_state[2] = m[4]\n\n                        # change visibility by clicking the mousewheel\n                        # if m[4] == 6 and m[3] == 1 and visible == 1:\n                        #     visible = 0\n                        # elif m[4] == 6 and visible == 0:\n                        #     visible = 1\n\n                        # camera movement when the left mouse button is pressed\n                        if mouse_state[0] == 3:\n                            speed_x = abs(old_mouse_x - mouse_x) if (abs(old_mouse_x - mouse_x)) < max_speed \\\n                                else max_speed\n                            speed_y = abs(old_mouse_y - mouse_y) if (abs(old_mouse_y - mouse_y)) < max_speed \\\n                                else max_speed\n\n                            # max angle of 89.5 and -89.5 to make sure the camera does not flip (is annoying)\n                            if mouse_x < old_mouse_x:\n                                if (camera_pitch + speed_x) < 89.5:\n                                    camera_pitch += (speed_x / 4) + 1\n                            elif mouse_x > old_mouse_x:\n                                if (camera_pitch - speed_x) > -89.5:\n                                    camera_pitch -= (speed_x / 4) + 1\n\n                            if mouse_y < old_mouse_y:\n                                camera_yaw += (speed_y / 4) + 1\n                            elif mouse_y > old_mouse_y:\n                                camera_yaw -= (speed_y / 4) + 1\n\n                        # Camera movement when the middle mouse button is pressed\n                        if mouse_state[1] == 3:\n                            speed_x = abs(old_mouse_x - mouse_x)\n                            factor = 0.05\n\n                            if mouse_x < old_mouse_x:\n                                dist = dist - speed_x * factor\n                            elif mouse_x > old_mouse_x:\n                                dist = dist + speed_x * factor\n                            dist = max(dist, 0.1)\n\n                        # camera movement when the right mouse button is pressed\n                        if mouse_state[2] == 3:\n                            speed_x = abs(old_mouse_x - mouse_x) if (abs(old_mouse_x - mouse_x)) < 5 else 5\n                            speed_y = abs(old_mouse_y - mouse_y) if (abs(old_mouse_y - mouse_y)) < 5 else 5\n                            factor = 0.05\n\n                            if mouse_x < old_mouse_x:\n                                camera_target_position = np.subtract(camera_target_position,\n                                                                     np.multiply(np.multiply(z_vec, factor), speed_x))\n                            elif mouse_x > old_mouse_x:\n                                camera_target_position = np.add(camera_target_position,\n                                                                np.multiply(np.multiply(z_vec, factor), speed_x))\n\n                            if mouse_y < old_mouse_y:\n                                camera_target_position = np.add(camera_target_position,\n                                                                np.multiply(np.multiply(x_vec, factor), speed_y))\n                            elif mouse_y > old_mouse_y:\n                                camera_target_position = np.subtract(camera_target_position,\n                                                                     np.multiply(np.multiply(x_vec, factor), speed_y))\n                        # update oldMouse values\n                        old_mouse_y, old_mouse_x = mouse_y, mouse_x\n\n                # check the keyboard state\n                if keys:\n                    # if shift is pressed, double the speed\n                    if p.B3G_SHIFT in keys:\n                        speed_mult = 5\n                    else:\n                        speed_mult = 2.5\n\n                    # if control is pressed, the movements caused by the arrowkeys, the '+' as well as the '-' key\n                    # change\n                    if p.B3G_CONTROL in keys:\n\n                        # the up and down arrowkeys cause the targetPos to move along the z axis of the map\n                        if p.B3G_DOWN_ARROW in keys:\n                            camera_target_position = np.subtract(camera_target_position,\n                                                                 np.multiply(np.multiply(z_vec, 0.03), speed_mult))\n                        elif p.B3G_UP_ARROW in keys:\n                            camera_target_position = np.add(camera_target_position,\n                                                            np.multiply(np.multiply(z_vec, 0.03), speed_mult))\n\n                        # left and right arrowkeys cause the targetPos to move horizontally relative to the camera\n                        if p.B3G_LEFT_ARROW in keys:\n                            camera_target_position = np.subtract(camera_target_position,\n                                                                 np.multiply(np.multiply(x_vec, 0.03), speed_mult))\n                        elif p.B3G_RIGHT_ARROW in keys:\n                            camera_target_position = np.add(camera_target_position,\n                                                            np.multiply(np.multiply(x_vec, 0.03), speed_mult))\n\n                        # the '+' and '-' keys cause the targetpos to move forwards and backwards relative to the camera\n                        # while the camera stays at a constant distance. SHIFT + '=' is for US layout\n                        if ord(\"+\") in keys or p.B3G_SHIFT in keys and ord(\"=\") in keys:\n                            camera_target_position = np.subtract(camera_target_position,\n                                                                 np.multiply(np.multiply(y_vec, 0.03), speed_mult))\n                        elif ord(\"-\") in keys:\n                            camera_target_position = np.add(camera_target_position,\n                                                            np.multiply(np.multiply(y_vec, 0.03), speed_mult))\n\n                    # standard bindings for thearrowkeys, the '+' as well as the '-' key\n                    else:\n\n                        # left and right arrowkeys cause the camera to rotate around the yaw axis\n                        if p.B3G_RIGHT_ARROW in keys:\n                            camera_yaw += (360 / width) * speed_mult\n                        elif p.B3G_LEFT_ARROW in keys:\n                            camera_yaw -= (360 / width) * speed_mult\n\n                        # the up and down arrowkeys cause the camera to rotate around the pitch axis\n                        if p.B3G_DOWN_ARROW in keys:\n                            if (camera_pitch + (360 / height) * speed_mult) < 89.5:\n                                camera_pitch += (360 / height) * speed_mult\n                        elif p.B3G_UP_ARROW in keys:\n                            if (camera_pitch - (360 / height) * speed_mult) > -89.5:\n                                camera_pitch -= (360 / height) * speed_mult\n\n                        # the '+' and '-' keys cause the camera to zoom towards and away from the targetPos without\n                        # moving it. SHIFT + '=' is for US layout since the events can't handle shift plus something\n                        if ord(\"+\") in keys or p.B3G_SHIFT in keys and ord(\"=\") in keys:\n                            if (dist - (dist * 0.02) * speed_mult) > 0.1:\n                                dist -= dist * 0.02 * speed_mult\n                        elif ord(\"-\") in keys:\n                            dist += dist * 0.02 * speed_mult\n                # print(\"dist: \", dist)\n                # print(\"camera_yaw: \", camera_yaw)\n                # print(\"camera_pitch: \", camera_pitch)\n                # print(\"camera_target_position: \", camera_target_position)\n\n                p.resetDebugVisualizerCamera(cameraDistance=dist, cameraYaw=camera_yaw, cameraPitch=camera_pitch,\n                                             cameraTargetPosition=camera_target_position, physicsClientId=self.world.id)\n                if visible == 0:\n                    camera_target_position = (0.0, -50, 50)\n                p.resetBasePositionAndOrientation(sphere_uid, camera_target_position, [0, 0, 0, 1], physicsClientId=self.world.id)\n                time.sleep(1. / 80.)\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What are the main functions defined in the constraints.py file?"}, {"role": "assistant", "content": "# Content from: #<constraints.py>#\nfrom __future__ import annotations\n\nimport numpy as np\nfrom geometry_msgs.msg import Point\nfrom typing_extensions import Union, List, Optional, TYPE_CHECKING\n\nfrom ..datastructures.enums import JointType\nfrom ..datastructures.pose import Transform, Pose\n\nif TYPE_CHECKING:\n    from ..description import Link\n\n\nclass AbstractConstraint:\n    \"\"\"\n    Represents an abstract constraint concept, this could be used to create joints for example or any kind of constraint\n    between two links in the world.\n    \"\"\"\n\n    def __init__(self,\n                 parent_link: Link,\n                 child_link: Link,\n                 _type: JointType,\n                 parent_to_constraint: Transform,\n                 child_to_constraint: Transform):\n        self.parent_link: Link = parent_link\n        self.child_link: Link = child_link\n        self.type: JointType = _type\n        self.parent_to_constraint = parent_to_constraint\n        self.child_to_constraint = child_to_constraint\n        self._parent_to_child = None\n\n    @property\n    def parent_to_child_transform(self) -> Union[Transform, None]:\n        if self._parent_to_child is None:\n            if self.parent_to_constraint is not None and self.child_to_constraint is not None:\n                self._parent_to_child = self.parent_to_constraint * self.child_to_constraint.invert()\n        return self._parent_to_child\n\n    @parent_to_child_transform.setter\n    def parent_to_child_transform(self, transform: Transform) -> None:\n        self._parent_to_child = transform\n\n    @property\n    def parent_object_id(self) -> int:\n        \"\"\"\n        Returns the id of the parent object of the constraint.\n\n        :return: The id of the parent object of the constraint\n        \"\"\"\n        return self.parent_link.object_id\n\n    @property\n    def child_object_id(self) -> int:\n        \"\"\"\n        Returns the id of the child object of the constraint.\n\n        :return: The id of the child object of the constraint\n        \"\"\"\n        return self.child_link.object_id\n\n    @property\n    def parent_link_id(self) -> int:\n        \"\"\"\n        Returns the id of the parent link of the constraint.\n\n        :return: The id of the parent link of the constraint\n        \"\"\"\n        return self.parent_link.id\n\n    @property\n    def child_link_id(self) -> int:\n        \"\"\"\n        Returns the id of the child link of the constraint.\n\n        :return: The id of the child link of the constraint\n        \"\"\"\n        return self.child_link.id\n\n    @property\n    def position_wrt_parent_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the constraint frame pose with respect to the parent origin as a list.\n\n        :return: The constraint frame pose with respect to the parent origin as a list\n        \"\"\"\n        return self.pose_wrt_parent.position_as_list()\n\n    @property\n    def orientation_wrt_parent_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the constraint frame orientation with respect to the parent origin as a list.\n\n        :return: The constraint frame orientation with respect to the parent origin as a list\n        \"\"\"\n        return self.pose_wrt_parent.orientation_as_list()\n\n    @property\n    def pose_wrt_parent(self) -> Pose:\n        \"\"\"\n        Returns the joint frame pose with respect to the parent origin.\n\n        :return: The joint frame pose with respect to the parent origin\n        \"\"\"\n        return self.parent_to_constraint.to_pose()\n\n    @property\n    def position_wrt_child_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the constraint frame pose with respect to the child origin as a list.\n\n        :return: The constraint frame pose with respect to the child origin as a list\n        \"\"\"\n        return self.pose_wrt_child.position_as_list()\n\n    @property\n    def orientation_wrt_child_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the constraint frame orientation with respect to the child origin as a list.\n\n        :return: The constraint frame orientation with respect to the child origin as a list\n        \"\"\"\n        return self.pose_wrt_child.orientation_as_list()\n\n    @property\n    def pose_wrt_child(self) -> Pose:\n        \"\"\"\n        Returns the joint frame pose with respect to the child origin.\n\n        :return: The joint frame pose with respect to the child origin\n        \"\"\"\n        return self.child_to_constraint.to_pose()\n\n\nclass Constraint(AbstractConstraint):\n    \"\"\"\n    Represents a constraint between two links in the World.\n    \"\"\"\n\n    def __init__(self,\n                 parent_link: Link,\n                 child_link: Link,\n                 _type: JointType,\n                 axis_in_child_frame: Point,\n                 constraint_to_parent: Transform,\n                 child_to_constraint: Transform):\n        parent_to_constraint = constraint_to_parent.invert()\n        AbstractConstraint.__init__(self, parent_link, child_link, _type, parent_to_constraint, child_to_constraint)\n        self.axis: Point = axis_in_child_frame\n\n    @property\n    def axis_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the axis of this constraint as a list.\n\n        :return: The axis of this constraint as a list of xyz\n        \"\"\"\n        return [self.axis.x, self.axis.y, self.axis.z]\n\n\nclass Attachment(AbstractConstraint):\n    def __init__(self,\n                 parent_link: Link,\n                 child_link: Link,\n                 bidirectional: Optional[bool] = False,\n                 parent_to_child_transform: Optional[Transform] = None,\n                 constraint_id: Optional[int] = None):\n        \"\"\"\n        Creates an attachment between the parent object link and the child object link.\n        This could be a bidirectional attachment, meaning that both objects will move when one moves.\n\n        :param parent_link: The parent object link.\n        :param child_link: The child object link.\n        :param bidirectional: If true, both objects will move when one moves.\n        :param parent_to_child_transform: The transform from the parent link to the child object link.\n        :param constraint_id: The id of the constraint in the simulator.\n        \"\"\"\n        super().__init__(parent_link, child_link, JointType.FIXED, parent_to_child_transform,\n                         Transform(frame=child_link.tf_frame))\n        self.id = constraint_id\n        self.bidirectional: bool = bidirectional\n        self._loose: bool = False\n\n        if self.parent_to_child_transform is None:\n            self.update_transform()\n\n        if self.id is None:\n            self.add_fixed_constraint()\n\n    def update_transform_and_constraint(self) -> None:\n        \"\"\"\n        Updates the transform and constraint of this attachment.\n        \"\"\"\n        self.update_transform()\n        self.update_constraint()\n\n    def update_transform(self) -> None:\n        \"\"\"\n        Updates the transform of this attachment by calculating the transform from the parent link to the child link.\n        \"\"\"\n        self.parent_to_child_transform = self.calculate_transform()\n\n    def update_constraint(self) -> None:\n        \"\"\"\n        Updates the constraint of this attachment by removing the old constraint if one exists and adding a new one.\n        \"\"\"\n        self.remove_constraint_if_exists()\n        self.add_fixed_constraint()\n\n    def add_fixed_constraint(self) -> None:\n        \"\"\"\n        Adds a fixed constraint between the parent link and the child link.\n        \"\"\"\n        self.id = self.parent_link.add_fixed_constraint_with_link(self.child_link)\n\n    def calculate_transform(self) -> Transform:\n        \"\"\"\n        Calculates the transform from the parent link to the child link.\n        \"\"\"\n        return self.parent_link.get_transform_to_link(self.child_link)\n\n    def remove_constraint_if_exists(self) -> None:\n        \"\"\"\n        Removes the constraint between the parent and the child links if one exists.\n        \"\"\"\n        if self.child_link in self.parent_link.constraint_ids:\n            self.parent_link.remove_constraint_with_link(self.child_link)\n\n    def get_inverse(self) -> 'Attachment':\n        \"\"\"\n        :return: A new Attachment object with the parent and child links swapped.\n        \"\"\"\n        attachment = Attachment(self.child_link, self.parent_link, self.bidirectional,\n                                constraint_id=self.id)\n        attachment.loose = not self._loose\n        return attachment\n\n    @property\n    def loose(self) -> bool:\n        \"\"\"\n        If true, then the child object will not move when parent moves.\n        \"\"\"\n        return self._loose\n\n    @loose.setter\n    def loose(self, loose: bool) -> None:\n        \"\"\"\n        Sets the loose property of this attachment.\n\n        :param loose: If true, then the child object will not move when parent moves.\n        \"\"\"\n        self._loose = loose and not self.bidirectional\n\n    @property\n    def is_reversed(self) -> bool:\n        \"\"\"\n        :return: True if the parent and child links are swapped.\n        \"\"\"\n        return self.loose\n\n    def __del__(self) -> None:\n        \"\"\"\n        Removes the constraint between the parent and the child links if one exists when the attachment is deleted.\n        \"\"\"\n        self.remove_constraint_if_exists()\n\n    def __copy__(self):\n        return Attachment(self.parent_link, self.child_link, self.bidirectional, self.parent_to_child_transform,\n                          self.id)\n\n    def __eq__(self, other):\n        return (self.parent_link.name == other.parent_link.name\n                and self.child_link.name == other.child_link.name\n                and self.bidirectional == other.bidirectional\n                and np.allclose(self.parent_to_child_transform.translation_as_list(),\n                                other.parent_to_child_transform.translation_as_list(), rtol=0, atol=1e-4)\n                and np.allclose(self.parent_to_child_transform.rotation_as_list(),\n                                other.parent_to_child_transform.rotation_as_list(), rtol=0, atol=1e-4))\n\n    def __hash__(self):\n        return hash((self.parent_link.name, self.child_link.name, self.bidirectional, self.parent_to_child_transform))\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the event.py file and how are they used in the application?"}, {"role": "assistant", "content": "# Content from: #<event.py>#\n# used for delayed evaluation of typing until python 3.11 becomes mainstream\nfrom __future__ import annotations\n\nfrom typing_extensions import Callable, List, Optional, Any\n\n\nclass Event:\n    \"\"\"\n    Base implementation of events in PyCRAM.\n    Events allow to attach handler methods to events that fire for specific occurences in the world.\n\n    :ivar handler: List of methods that are called when this event is fired.\n    \"\"\"\n\n    def __init__(self):\n        self.handlers: List[Callable] = []\n\n    def add(self, handler: Callable) -> None:\n        \"\"\"\n        Adds a new handler to the list of handlers. All handler methods are called when this event is fired.\n        Handler have to take the event sender as parameter as well as args* which can contain further parameter.\n\n        :param handler: A method that should be added\n        \"\"\"\n        self.handlers.append(handler)\n\n    def remove(self, handler: Callable) -> None:\n        \"\"\"\n        Removes a method from the list of handlers, the method will not be called when the event is fired.\n\n        :param handler: The method that should be removed.\n        \"\"\"\n        self.handlers.remove(handler)\n\n    def fire(self, sender: Any, earg: Optional[Any] = None) -> None:\n        \"\"\"\n        Fire this event, this causes every method to be called with a sender as well as additional args.\n\n        :param sender: The entity that fired the event.\n        :param earg: Additional arguments.\n        \"\"\"\n        for handler in self.handlers:\n            handler(sender, earg)\n\n    def __iadd__(self, other: Callable) -> Event:\n        \"\"\"\n        Operator overload that allows to add handlers by the '+=' operator.\n\n        :param other: The handler that should be added.\n        :return: This instance\n        \"\"\"\n        self.add(other)\n        return self\n\n    def __isub__(self, other: Callable) -> Event:\n        \"\"\"\n        Operator overload that allows to remove methods as handlers by using the '-=' operator.\n\n        :param other: The method that should be removed as handler.\n        :return: This instance\n        \"\"\"\n        self.remove(other)\n        return self\n\n    __call__ = fire\n    \"\"\"\n    Allows to directly call the reference.\n    \"\"\"\n\n"}]}
{"messages": [{"role": "system", "content": "You are a coding expert and know how to write PyCRAM Plan Code."}, {"role": "user", "content": "What functions are defined in the world_object.py file and how do they interact with other components in the PyCRAM Framework?"}, {"role": "assistant", "content": "# Content from: #<world_object.py>#\nfrom __future__ import annotations\n\nimport logging\nimport os\n\nimport numpy as np\nimport rospy\nfrom geometry_msgs.msg import Point, Quaternion\nfrom typing_extensions import Type, Optional, Dict, Tuple, List, Union\n\nfrom ..description import ObjectDescription, LinkDescription, Joint\nfrom ..object_descriptors.urdf import ObjectDescription as URDFObject\nfrom ..object_descriptors.generic import ObjectDescription as GenericObjectDescription\nfrom ..robot_descriptions import robot_description\nfrom ..datastructures.world import WorldEntity, World\nfrom ..world_concepts.constraints import Attachment\nfrom ..datastructures.dataclasses import (Color, ObjectState, LinkState, JointState,\n                                               AxisAlignedBoundingBox, VisualShape)\nfrom ..datastructures.enums import ObjectType, JointType\nfrom ..local_transformer import LocalTransformer\nfrom ..datastructures.pose import Pose, Transform\nfrom ..robot_description import RobotDescriptionManager\n\nLink = ObjectDescription.Link\n\n\nclass Object(WorldEntity):\n    \"\"\"\n    Represents a spawned Object in the World.\n    \"\"\"\n\n    prospection_world_prefix: str = \"prospection/\"\n    \"\"\"\n    The ObjectDescription of the object, this contains the name and type of the object as well as the path to the source \n    file.\n    \"\"\"\n\n    def __init__(self, name: str, obj_type: ObjectType, path: str,\n                 description: Optional[Type[ObjectDescription]] = URDFObject,\n                 pose: Optional[Pose] = None,\n                 world: Optional[World] = None,\n                 color: Optional[Color] = Color(),\n                 ignore_cached_files: Optional[bool] = False):\n        \"\"\"\n        The constructor loads the description file into the given World, if no World is specified the\n        :py:attr:`~World.current_world` will be used. It is also possible to load .obj and .stl file into the World.\n        The rgba_color parameter is only used when loading .stl or .obj files,\n        for URDFs :func:`~Object.set_color` can be used.\n\n        :param name: The name of the object\n        :param obj_type: The type of the object as an ObjectType enum.\n        :param path: The path to the source file, if only a filename is provided then the resources directories will be searched.\n        :param description: The ObjectDescription of the object, this contains the joints and links of the object.\n        :param pose: The pose at which the Object should be spawned\n        :param world: The World in which the object should be spawned, if no world is specified the :py:attr:`~World.current_world` will be used.\n        :param color: The rgba_color with which the object should be spawned.\n        :param ignore_cached_files: If true the file will be spawned while ignoring cached files.\n        \"\"\"\n\n        super().__init__(-1, world)\n\n        if pose is None:\n            pose = Pose()\n        if name in [obj.name for obj in self.world.objects]:\n            rospy.logerr(f\"An object with the name {name} already exists in the world.\")\n            return None\n        self.name: str = name\n        self.obj_type: ObjectType = obj_type\n        self.color: Color = color\n        self.description = description()\n        self.cache_manager = self.world.cache_manager\n\n        self.local_transformer = LocalTransformer()\n        self.original_pose = self.local_transformer.transform_pose(pose, \"map\")\n        self._current_pose = self.original_pose\n\n        self.id, self.path = self._load_object_and_get_id(path, ignore_cached_files)\n\n        self.description.update_description_from_file(self.path)\n\n        self.tf_frame = ((self.prospection_world_prefix if self.world.is_prospection_world else \"\")\n                         + f\"{self.name}\")\n\n        self._init_joint_name_and_id_map()\n        self._init_link_name_and_id_map()\n\n        self._init_links_and_update_transforms()\n        self._init_joints()\n\n        self.attachments: Dict[Object, Attachment] = {}\n\n        if not self.world.is_prospection_world:\n            self._add_to_world_sync_obj_queue()\n\n        self.world.objects.append(self)\n\n        if self.obj_type == ObjectType.ROBOT and not self.world.is_prospection_world:\n            rdm = RobotDescriptionManager()\n            rdm.load_description(self.description.name)\n            World.robot = self\n\n    @property\n    def pose(self):\n        return self.get_pose()\n\n    @pose.setter\n    def pose(self, pose: Pose):\n        self.set_pose(pose)\n\n    def _load_object_and_get_id(self, path: Optional[str] = None,\n                                ignore_cached_files: Optional[bool] = False) -> Tuple[int, Union[str, None]]:\n        \"\"\"\n        Loads an object to the given World with the given position and orientation. The rgba_color will only be\n        used when an .obj or .stl file is given.\n        If a .obj or .stl file is given, before spawning, an urdf file with the .obj or .stl as mesh will be created\n        and this URDf file will be loaded instead.\n        When spawning a URDf file a new file will be created in the cache directory, if there exists none.\n        This new file will have resolved mesh file paths, meaning there will be no references\n        to ROS packges instead there will be absolute file paths.\n\n        :param path: The path to the description file, if None then no file will be loaded, this is useful when the PyCRAM is not responsible for loading the file but another system is.\n        :param ignore_cached_files: Whether to ignore files in the cache directory.\n        :return: The unique id of the object and the path of the file that was loaded.\n        \"\"\"\n        if isinstance(self.description, GenericObjectDescription):\n            return self.world.load_generic_object_and_get_id(self.description), path\n\n        if path is not None:\n            try:\n                path = self.world.update_cache_dir_with_object(path, ignore_cached_files, self)\n            except FileNotFoundError as e:\n                logging.error(\"Could not generate description from file.\")\n                raise e\n\n        try:\n            simulator_object_path = path\n            if simulator_object_path is None:\n                # This is useful when the object is already loaded in the simulator so it would use its name instead of\n                #  its path\n                simulator_object_path = self.name\n            obj_id = self.world.load_object_and_get_id(simulator_object_path, Pose(self.get_position_as_list(),\n                                                                                   self.get_orientation_as_list()))\n            return obj_id, path\n\n        except Exception as e:\n            logging.error(\n                \"The File could not be loaded. Please note that the path has to be either a URDF, stl or obj file or\"\n                \" the name of an URDF string on the parameter server.\")\n            os.remove(path)\n            raise e\n\n    def _init_joint_name_and_id_map(self) -> None:\n        \"\"\"\n        Creates a dictionary which maps the joint names to their unique ids and vice versa.\n        \"\"\"\n        n_joints = len(self.joint_names)\n        self.joint_name_to_id = dict(zip(self.joint_names, range(n_joints)))\n        self.joint_id_to_name = dict(zip(self.joint_name_to_id.values(), self.joint_name_to_id.keys()))\n\n    def _init_link_name_and_id_map(self) -> None:\n        \"\"\"\n        Creates a dictionary which maps the link names to their unique ids and vice versa.\n        \"\"\"\n        n_links = len(self.link_names)\n        self.link_name_to_id: Dict[str, int] = dict(zip(self.link_names, range(n_links)))\n        self.link_name_to_id[self.description.get_root()] = -1\n        self.link_id_to_name: Dict[int, str] = dict(zip(self.link_name_to_id.values(), self.link_name_to_id.keys()))\n\n    def _init_links_and_update_transforms(self) -> None:\n        \"\"\"\n        Initializes the link objects from the URDF file and creates a dictionary which maps the link names to the\n        corresponding link objects.\n        \"\"\"\n        self.links = {}\n        for link_name, link_id in self.link_name_to_id.items():\n            link_description = self.description.get_link_by_name(link_name)\n            if link_name == self.description.get_root():\n                self.links[link_name] = self.description.RootLink(self)\n            else:\n                self.links[link_name] = self.description.Link(link_id, link_description, self)\n\n        self.update_link_transforms()\n\n    def _init_joints(self):\n        \"\"\"\n        Initialize the joint objects from the URDF file and creates a dictionary which mas the joint names to the\n        corresponding joint objects\n        \"\"\"\n        self.joints = {}\n        for joint_name, joint_id in self.joint_name_to_id.items():\n            joint_description = self.description.get_joint_by_name(joint_name)\n            self.joints[joint_name] = self.description.Joint(joint_id, joint_description, self)\n\n    def _add_to_world_sync_obj_queue(self) -> None:\n        \"\"\"\n        Adds this object to the objects queue of the WorldSync object of the World.\n        \"\"\"\n        self.world.world_sync.add_obj_queue.put(self)\n\n    @property\n    def link_names(self) -> List[str]:\n        \"\"\"\n        :return: The name of each link as a list.\n        \"\"\"\n        return self.world.get_object_link_names(self)\n\n    @property\n    def joint_names(self) -> List[str]:\n        \"\"\"\n        :return: The name of each joint as a list.\n        \"\"\"\n        return self.world.get_object_joint_names(self)\n\n    def get_link(self, link_name: str) -> ObjectDescription.Link:\n        \"\"\"\n        Returns the link object with the given name.\n\n        :param link_name: The name of the link.\n        :return: The link object.\n        \"\"\"\n        return self.links[link_name]\n\n    def get_link_pose(self, link_name: str) -> Pose:\n        \"\"\"\n        Returns the pose of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The pose of the link.\n        \"\"\"\n        return self.links[link_name].pose\n\n    def get_link_position(self, link_name: str) -> Point:\n        \"\"\"\n        Returns the position of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The position of the link.\n        \"\"\"\n        return self.links[link_name].position\n\n    def get_link_position_as_list(self, link_name: str) -> List[float]:\n        \"\"\"\n        Returns the position of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The position of the link.\n        \"\"\"\n        return self.links[link_name].position_as_list\n\n    def get_link_orientation(self, link_name: str) -> Quaternion:\n        \"\"\"\n        Returns the orientation of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The orientation of the link.\n        \"\"\"\n        return self.links[link_name].orientation\n\n    def get_link_orientation_as_list(self, link_name: str) -> List[float]:\n        \"\"\"\n        Returns the orientation of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The orientation of the link.\n        \"\"\"\n        return self.links[link_name].orientation_as_list\n\n    def get_link_tf_frame(self, link_name: str) -> str:\n        \"\"\"\n        Returns the tf frame of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The tf frame of the link.\n        \"\"\"\n        return self.links[link_name].tf_frame\n\n    def get_link_axis_aligned_bounding_box(self, link_name: str) -> AxisAlignedBoundingBox:\n        \"\"\"\n        Returns the axis aligned bounding box of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The axis aligned bounding box of the link.\n        \"\"\"\n        return self.links[link_name].get_axis_aligned_bounding_box()\n\n    def get_transform_between_links(self, from_link: str, to_link: str) -> Transform:\n        \"\"\"\n        Returns the transform between two links.\n\n        :param from_link: The name of the link from which the transform should be calculated.\n        :param to_link: The name of the link to which the transform should be calculated.\n        \"\"\"\n        return self.links[from_link].get_transform_to_link(self.links[to_link])\n\n    def get_link_color(self, link_name: str) -> Color:\n        \"\"\"\n        Returns the color of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The color of the link.\n        \"\"\"\n        return self.links[link_name].color\n\n    def set_link_color(self, link_name: str, color: List[float]) -> None:\n        \"\"\"\n        Sets the color of the link with the given name.\n\n        :param link_name: The name of the link.\n        :param color: The new color of the link.\n        \"\"\"\n        self.links[link_name].color = Color.from_list(color)\n\n    def get_link_geometry(self, link_name: str) -> Union[VisualShape, None]:\n        \"\"\"\n        Returns the geometry of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The geometry of the link.\n        \"\"\"\n        return self.links[link_name].geometry\n\n    def get_link_transform(self, link_name: str) -> Transform:\n        \"\"\"\n        Returns the transform of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The transform of the link.\n        \"\"\"\n        return self.links[link_name].transform\n\n    def get_link_origin(self, link_name: str) -> Pose:\n        \"\"\"\n        Returns the origin of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The origin of the link as a 'Pose'.\n        \"\"\"\n        return self.links[link_name].origin\n\n    def get_link_origin_transform(self, link_name: str) -> Transform:\n        \"\"\"\n        Returns the origin transform of the link with the given name.\n\n        :param link_name: The name of the link.\n        :return: The origin transform of the link.\n        \"\"\"\n        return self.links[link_name].origin_transform\n\n    @property\n    def base_origin_shift(self) -> np.ndarray:\n        \"\"\"\n        The shift between the base of the object and the origin of the object.\n\n        :return: A numpy array with the shift between the base of the object and the origin of the object.\n        \"\"\"\n        return np.array(self.get_position_as_list()) - np.array(self.get_base_position_as_list())\n\n    def __repr__(self):\n        skip_attr = [\"links\", \"joints\", \"description\", \"attachments\"]\n        return self.__class__.__qualname__ + f\"(\" + ', \\n'.join(\n            [f\"{key}={value}\" if key not in skip_attr else f\"{key}: ...\" for key, value in self.__dict__.items()]) + \")\"\n\n    def remove(self) -> None:\n        \"\"\"\n        Removes this object from the World it currently resides in.\n        For the object to be removed it has to be detached from all objects it\n        is currently attached to. After this is done a call to world remove object is done\n        to remove this Object from the simulation/world.\n        \"\"\"\n        self.world.remove_object(self)\n\n    def reset(self, remove_saved_states=True) -> None:\n        \"\"\"\n        Resets the Object to the state it was first spawned in.\n        All attached objects will be detached, all joints will be set to the\n        default position of 0 and the object will be set to the position and\n        orientation in which it was spawned.\n\n        :param remove_saved_states: If True the saved states will be removed.\n        \"\"\"\n        self.detach_all()\n        self.reset_all_joints_positions()\n        self.set_pose(self.original_pose)\n        if remove_saved_states:\n            self.remove_saved_states()\n\n    def attach(self,\n               child_object: Object,\n               parent_link: Optional[str] = None,\n               child_link: Optional[str] = None,\n               bidirectional: Optional[bool] = True) -> None:\n        \"\"\"\n        Attaches another object to this object. This is done by\n        saving the transformation between the given link, if there is one, and\n        the base pose of the other object. Additionally, the name of the link, to\n        which the object is attached, will be saved.\n        Furthermore, a simulator constraint will be created so the attachment\n        also works while simulation.\n        Loose attachments means that the attachment will only be one-directional. For example, if this object moves the\n        other, attached, object will also move but not the other way around.\n\n        :param child_object: The other object that should be attached.\n        :param parent_link: The link name of this object.\n        :param child_link: The link name of the other object.\n        :param bidirectional: If the attachment should be a loose attachment.\n        \"\"\"\n        parent_link = self.links[parent_link] if parent_link else self.root_link\n        child_link = child_object.links[child_link] if child_link else child_object.root_link\n\n        attachment = Attachment(parent_link, child_link, bidirectional)\n\n        self.attachments[child_object] = attachment\n        child_object.attachments[self] = attachment.get_inverse()\n\n        self.world.attachment_event(self, [self, child_object])\n\n    def detach(self, child_object: Object) -> None:\n        \"\"\"\n        Detaches another object from this object. This is done by\n        deleting the attachment from the attachments dictionary of both objects\n        and deleting the constraint of the simulator.\n        Afterward the detachment event of the corresponding World will be fired.\n\n        :param child_object: The object which should be detached\n        \"\"\"\n        del self.attachments[child_object]\n        del child_object.attachments[self]\n\n        self.world.detachment_event(self, [self, child_object])\n\n    def detach_all(self) -> None:\n        \"\"\"\n        Detach all objects attached to this object.\n        \"\"\"\n        attachments = self.attachments.copy()\n        for att in attachments.keys():\n            self.detach(att)\n\n    def update_attachment_with_object(self, child_object: Object):\n        self.attachments[child_object].update_transform_and_constraint()\n\n    def get_position(self) -> Point:\n        \"\"\"\n        Returns the position of this Object as a list of xyz.\n\n        :return: The current position of this object\n        \"\"\"\n        return self.get_pose().position\n\n    def get_orientation(self) -> Pose.orientation:\n        \"\"\"\n        Returns the orientation of this object as a list of xyzw, representing a quaternion.\n\n        :return: A list of xyzw\n        \"\"\"\n        return self.get_pose().orientation\n\n    def get_position_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the position of this Object as a list of xyz.\n\n        :return: The current position of this object\n        \"\"\"\n        return self.get_pose().position_as_list()\n\n    def get_base_position_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the position of this Object as a list of xyz.\n\n        :return: The current position of this object\n        \"\"\"\n        return self.get_base_origin().position_as_list()\n\n    def get_orientation_as_list(self) -> List[float]:\n        \"\"\"\n        Returns the orientation of this object as a list of xyzw, representing a quaternion.\n\n        :return: A list of xyzw\n        \"\"\"\n        return self.get_pose().orientation_as_list()\n\n    def get_pose(self) -> Pose:\n        \"\"\"\n        Returns the position of this object as a list of xyz. Alias for :func:`~Object.get_position`.\n\n        :return: The current pose of this object\n        \"\"\"\n        return self._current_pose\n\n    def set_pose(self, pose: Pose, base: Optional[bool] = False, set_attachments: Optional[bool] = True) -> None:\n        \"\"\"\n        Sets the Pose of the object.\n\n        :param pose: New Pose for the object\n        :param base: If True places the object base instead of origin at the specified position and orientation\n        :param set_attachments: Whether to set the poses of the attached objects to this object or not.\n        \"\"\"\n        pose_in_map = self.local_transformer.transform_pose(pose, \"map\")\n        if base:\n            pose_in_map.position = (np.array(pose_in_map.position_as_list()) + self.base_origin_shift).tolist()\n\n        self.reset_base_pose(pose_in_map)\n\n        if set_attachments:\n            self._set_attached_objects_poses()\n\n    def reset_base_pose(self, pose: Pose):\n        self.world.reset_object_base_pose(self, pose)\n        self.update_pose()\n\n    def update_pose(self):\n        \"\"\"\n        Updates the current pose of this object from the world, and updates the poses of all links.\n        \"\"\"\n        self._current_pose = self.world.get_object_pose(self)\n        self._update_all_links_poses()\n        self.update_link_transforms()\n\n    def _update_all_links_poses(self):\n        \"\"\"\n        Updates the poses of all links by getting them from the simulator.\n        \"\"\"\n        for link in self.links.values():\n            link._update_pose()\n\n    def move_base_to_origin_pose(self) -> None:\n        \"\"\"\n        Move the object such that its base will be at the current origin position.\n        This is useful when placing objects on surfaces where you want the object base in contact with the surface.\n        \"\"\"\n        self.set_pose(self.get_pose(), base=True)\n\n    def save_state(self, state_id) -> None:\n        \"\"\"\n        Saves the state of this object by saving the state of all links and attachments.\n\n        :param state_id: The unique id of the state.\n        \"\"\"\n        self.save_links_states(state_id)\n        self.save_joints_states(state_id)\n        super().save_state(state_id)\n\n    def save_links_states(self, state_id: int) -> None:\n        \"\"\"\n        Saves the state of all links of this object.\n\n        :param state_id: The unique id of the state.\n        \"\"\"\n        for link in self.links.values():\n            link.save_state(state_id)\n\n    def save_joints_states(self, state_id: int) -> None:\n        \"\"\"\n        Saves the state of all joints of this object.\n\n        :param state_id: The unique id of the state.\n        \"\"\"\n        for joint in self.joints.values():\n            joint.save_state(state_id)\n\n    @property\n    def current_state(self) -> ObjectState:\n        return ObjectState(self.get_pose().copy(), self.attachments.copy(), self.link_states.copy(), self.joint_states.copy())\n\n    @current_state.setter\n    def current_state(self, state: ObjectState) -> None:\n        if self.get_pose().dist(state.pose) != 0.0:\n            self.set_pose(state.pose, base=False, set_attachments=False)\n\n        self.set_attachments(state.attachments)\n        self.link_states = state.link_states\n        self.joint_states = state.joint_states\n\n    def set_attachments(self, attachments: Dict[Object, Attachment]) -> None:\n        \"\"\"\n        Sets the attachments of this object to the given attachments.\n\n        :param attachments: A dictionary with the object as key and the attachment as value.\n        \"\"\"\n        for obj, attachment in attachments.items():\n            if self.world.is_prospection_world and not obj.world.is_prospection_world:\n                # In case this object is in the prospection world and the other object is not, the attachment will no\n                # be set.\n                continue\n            if obj in self.attachments:\n                if self.attachments[obj] != attachment:\n                    self.detach(obj)\n                else:\n                    continue\n            self.attach(obj, attachment.parent_link.name, attachment.child_link.name,\n                        attachment.bidirectional)\n\n    @property\n    def link_states(self) -> Dict[int, LinkState]:\n        \"\"\"\n        Returns the current state of all links of this object.\n\n        :return: A dictionary with the link id as key and the current state of the link as value.\n        \"\"\"\n        return {link.id: link.current_state for link in self.links.values()}\n\n    @link_states.setter\n    def link_states(self, link_states: Dict[int, LinkState]) -> None:\n        \"\"\"\n        Sets the current state of all links of this object.\n\n        :param link_states: A dictionary with the link id as key and the current state of the link as value.\n        \"\"\"\n        for link in self.links.values():\n            link.current_state = link_states[link.id]\n\n    @property\n    def joint_states(self) -> Dict[int, JointState]:\n        \"\"\"\n        Returns the current state of all joints of this object.\n\n        :return: A dictionary with the joint id as key and the current state of the joint as value.\n        \"\"\"\n        return {joint.id: joint.current_state for joint in self.joints.values()}\n\n    @joint_states.setter\n    def joint_states(self, joint_states: Dict[int, JointState]) -> None:\n        \"\"\"\n        Sets the current state of all joints of this object.\n\n        :param joint_states: A dictionary with the joint id as key and the current state of the joint as value.\n        \"\"\"\n        for joint in self.joints.values():\n            joint.current_state = joint_states[joint.id]\n\n    def remove_saved_states(self) -> None:\n        \"\"\"\n        Removes all saved states of this object.\n        \"\"\"\n        super().remove_saved_states()\n        self.remove_links_saved_states()\n        self.remove_joints_saved_states()\n\n    def remove_links_saved_states(self) -> None:\n        \"\"\"\n        Removes all saved states of the links of this object.\n        \"\"\"\n        for link in self.links.values():\n            link.remove_saved_states()\n\n    def remove_joints_saved_states(self) -> None:\n        \"\"\"\n        Removes all saved states of the joints of this object.\n        \"\"\"\n        for joint in self.joints.values():\n            joint.remove_saved_states()\n\n    def _set_attached_objects_poses(self, already_moved_objects: Optional[List[Object]] = None) -> None:\n        \"\"\"\n        Updates the positions of all attached objects. This is done\n        by calculating the new pose in world coordinate frame and setting the\n        base pose of the attached objects to this new pose.\n        After this the _set_attached_objects method of all attached objects\n        will be called.\n\n        :param already_moved_objects: A list of Objects that were already moved, these will be excluded to prevent loops in the update.\n        \"\"\"\n\n        if already_moved_objects is None:\n            already_moved_objects = []\n\n        for child in self.attachments:\n\n            if child in already_moved_objects:\n                continue\n\n            attachment = self.attachments[child]\n            if attachment.loose:\n                self.update_attachment_with_object(child)\n                child.update_attachment_with_object(self)\n\n            else:\n                link_to_object = attachment.parent_to_child_transform\n                child.set_pose(link_to_object.to_pose(), set_attachments=False)\n                child._set_attached_objects_poses(already_moved_objects + [self])\n\n    def set_position(self, position: Union[Pose, Point, List], base=False) -> None:\n        \"\"\"\n        Sets this Object to the given position, if base is true the bottom of the Object will be placed at the position\n        instead of the origin in the center of the Object. The given position can either be a Pose,\n        in this case only the position is used or a geometry_msgs.msg/Point which is the position part of a Pose.\n\n        :param position: Target position as xyz.\n        :param base: If the bottom of the Object should be placed or the origin in the center.\n        \"\"\"\n        pose = Pose()\n        if isinstance(position, Pose):\n            target_position = position.position\n            pose.frame = position.frame\n        elif isinstance(position, Point):\n            target_position = position\n        elif isinstance(position, list):\n            target_position = position\n        else:\n            raise TypeError(\"The given position has to be a Pose, Point or a list of xyz.\")\n\n        pose.position = target_position\n        pose.orientation = self.get_orientation()\n        self.set_pose(pose, base=base)\n\n    def set_orientation(self, orientation: Union[Pose, Quaternion, List, Tuple, np.ndarray]) -> None:\n        \"\"\"\n        Sets the orientation of the Object to the given orientation. Orientation can either be a Pose, in this case only\n        the orientation of this pose is used or a geometry_msgs.msg/Quaternion which is the orientation of a Pose.\n\n        :param orientation: Target orientation given as a list of xyzw.\n        \"\"\"\n        pose = Pose()\n        if isinstance(orientation, Pose):\n            target_orientation = orientation.orientation\n            pose.frame = orientation.frame\n        elif isinstance(orientation, Quaternion):\n            target_orientation = orientation\n        elif (isinstance(orientation, list) or isinstance(orientation, np.ndarray) or isinstance(orientation, tuple)) \\\n                and len(orientation) == 4:\n            target_orientation = Quaternion(*orientation)\n        else:\n            raise TypeError(\"The given orientation has to be a Pose, Quaternion or one of list/tuple/ndarray of xyzw.\")\n\n        pose.pose.position = self.get_position()\n        pose.pose.orientation = target_orientation\n        self.set_pose(pose)\n\n    def get_joint_id(self, name: str) -> int:\n        \"\"\"\n        Returns the unique id for a joint name. As used by the world/simulator.\n\n        :param name: The joint name\n        :return: The unique id\n        \"\"\"\n        return self.joint_name_to_id[name]\n\n    def get_root_link_description(self) -> LinkDescription:\n        \"\"\"\n        Returns the root link of the URDF of this object.\n\n        :return: The root link as defined in the URDF of this object.\n        \"\"\"\n        for link_description in self.description.links:\n            if link_description.name == self.root_link_name:\n                return link_description\n\n    @property\n    def root_link(self) -> ObjectDescription.Link:\n        \"\"\"\n        Returns the root link of this object.\n\n        :return: The root link of this object.\n        \"\"\"\n        return self.links[self.description.get_root()]\n\n    @property\n    def root_link_name(self) -> str:\n        \"\"\"\n        Returns the name of the root link of this object.\n\n        :return: The name of the root link of this object.\n        \"\"\"\n        return self.description.get_root()\n\n    def get_root_link_id(self) -> int:\n        \"\"\"\n        Returns the unique id of the root link of this object.\n\n        :return: The unique id of the root link of this object.\n        \"\"\"\n        return self.get_link_id(self.description.get_root())\n\n    def get_link_id(self, link_name: str) -> int:\n        \"\"\"\n        Returns a unique id for a link name.\n\n        :param link_name: The name of the link.\n        :return: The unique id of the link.\n        \"\"\"\n        return self.link_name_to_id[link_name]\n\n    def get_link_by_id(self, link_id: int) -> ObjectDescription.Link:\n        \"\"\"\n        Returns the link for a given unique link id\n\n        :param link_id: The unique id of the link.\n        :return: The link object.\n        \"\"\"\n        return self.links[self.link_id_to_name[link_id]]\n\n    def reset_all_joints_positions(self) -> None:\n        \"\"\"\n        Sets the current position of all joints to 0. This is useful if the joints should be reset to their default\n        \"\"\"\n        joint_names = list(self.joint_name_to_id.keys())\n        joint_positions = [0] * len(joint_names)\n        self.set_joint_positions(dict(zip(joint_names, joint_positions)))\n\n    def set_joint_positions(self, joint_poses: dict) -> None:\n        \"\"\"\n        Sets the current position of multiple joints at once, this method should be preferred when setting\n        multiple joints at once instead of running :func:`~Object.set_joint_position` in a loop.\n\n        :param joint_poses:\n        \"\"\"\n        for joint_name, joint_position in joint_poses.items():\n            self.joints[joint_name].position = joint_position\n        # self.update_pose()\n        self._update_all_links_poses()\n        self.update_link_transforms()\n        self._set_attached_objects_poses()\n\n    def set_joint_position(self, joint_name: str, joint_position: float) -> None:\n        \"\"\"\n        Sets the position of the given joint to the given joint pose and updates the poses of all attached objects.\n\n        :param joint_name: The name of the joint\n        :param joint_position: The target pose for this joint\n        \"\"\"\n        self.joints[joint_name].position = joint_position\n        self._update_all_links_poses()\n        self.update_link_transforms()\n        self._set_attached_objects_poses()\n\n    def get_joint_position(self, joint_name: str) -> float:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The current position of the given joint\n        \"\"\"\n        return self.joints[joint_name].position\n\n    def get_joint_damping(self, joint_name: str) -> float:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The damping of the given joint\n        \"\"\"\n        return self.joints[joint_name].damping\n\n    def get_joint_upper_limit(self, joint_name: str) -> float:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The upper limit of the given joint\n        \"\"\"\n        return self.joints[joint_name].upper_limit\n\n    def get_joint_lower_limit(self, joint_name: str) -> float:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The lower limit of the given joint\n        \"\"\"\n        return self.joints[joint_name].lower_limit\n\n    def get_joint_axis(self, joint_name: str) -> Point:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The axis of the given joint\n        \"\"\"\n        return self.joints[joint_name].axis\n\n    def get_joint_type(self, joint_name: str) -> JointType:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The type of the given joint\n        \"\"\"\n        return self.joints[joint_name].type\n\n    def get_joint_limits(self, joint_name: str) -> Tuple[float, float]:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The lower and upper limits of the given joint\n        \"\"\"\n        return self.joints[joint_name].limits\n\n    def get_joint_child_link(self, joint_name: str) -> ObjectDescription.Link:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The child link of the given joint\n        \"\"\"\n        return self.joints[joint_name].child_link\n\n    def get_joint_parent_link(self, joint_name: str) -> ObjectDescription.Link:\n        \"\"\"\n        :param joint_name: The name of the joint\n        :return: The parent link of the given joint\n        \"\"\"\n        return self.joints[joint_name].parent_link\n\n    def find_joint_above_link(self, link_name: str, joint_type: JointType) -> str:\n        \"\"\"\n        Traverses the chain from 'link' to the URDF origin and returns the first joint that is of type 'joint_type'.\n\n        :param link_name: AbstractLink name above which the joint should be found\n        :param joint_type: Joint type that should be searched for\n        :return: Name of the first joint which has the given type\n        \"\"\"\n        chain = self.description.get_chain(self.description.get_root(), link_name)\n        reversed_chain = reversed(chain)\n        container_joint = None\n        for element in reversed_chain:\n            if element in self.joint_name_to_id and self.get_joint_type(element) == joint_type:\n                container_joint = element\n                break\n        if not container_joint:\n            rospy.logwarn(f\"No joint of type {joint_type} found above link {link_name}\")\n        return container_joint\n\n    def get_positions_of_all_joints(self) -> Dict[str, float]:\n        \"\"\"\n        Returns the positions of all joints of the object as a dictionary of joint names and joint positions.\n\n        :return: A dictionary with all joints positions'.\n        \"\"\"\n        return {j.name: j.position for j in self.joints.values()}\n\n    def update_link_transforms(self, transform_time: Optional[rospy.Time] = None) -> None:\n        \"\"\"\n        Updates the transforms of all links of this object using time 'transform_time' or the current ros time.\n        \"\"\"\n        for link in self.links.values():\n            link.update_transform(transform_time)\n\n    def contact_points(self) -> List:\n        \"\"\"\n        Returns a list of contact points of this Object with other Objects.\n\n        :return: A list of all contact points with other objects\n        \"\"\"\n        return self.world.get_object_contact_points(self)\n\n    def contact_points_simulated(self) -> List:\n        \"\"\"\n        Returns a list of all contact points between this Object and other Objects after stepping the simulation once.\n\n        :return: A list of contact points between this Object and other Objects\n        \"\"\"\n        state_id = self.world.save_state()\n        self.world.step()\n        contact_points = self.contact_points()\n        self.world.restore_state(state_id)\n        return contact_points\n\n    def set_color(self, rgba_color: Color) -> None:\n        \"\"\"\n        Changes the color of this object, the color has to be given as a list\n        of RGBA values.\n\n        :param rgba_color: The color as Color object with RGBA values between 0 and 1\n        \"\"\"\n        # Check if there is only one link, this is the case for primitive\n        # forms or if loaded from an .stl or .obj file\n        if self.links != {}:\n            for link in self.links.values():\n                link.color = rgba_color\n        else:\n            self.root_link.color = rgba_color\n\n    def get_color(self) -> Union[Color, Dict[str, Color]]:\n        \"\"\"\n        This method returns the rgba_color of this object. The return is either:\n\n            1. A Color object with RGBA values, this is the case if the object only has one link (this\n                happens for example if the object is spawned from a .obj or .stl file)\n            2. A dict with the link name as key and the rgba_color as value. The rgba_color is given as a Color Object.\n                Please keep in mind that not every link may have a rgba_color. This is dependent on the URDF from which\n                 the object is spawned.\n\n        :return: The rgba_color as Color object with RGBA values between 0 and 1 or a dict with the link name as key and the rgba_color as value.\n        \"\"\"\n        link_to_color_dict = self.links_colors\n\n        if len(link_to_color_dict) == 1:\n            return list(link_to_color_dict.values())[0]\n        else:\n            return link_to_color_dict\n\n    @property\n    def links_colors(self) -> Dict[str, Color]:\n        \"\"\"\n        The color of each link as a dictionary with link names as keys and RGBA colors as values.\n        \"\"\"\n        return self.world.get_colors_of_object_links(self)\n\n    def get_axis_aligned_bounding_box(self) -> AxisAlignedBoundingBox:\n        \"\"\"\n        :return: The axis aligned bounding box of this object.\n        \"\"\"\n        return self.world.get_object_axis_aligned_bounding_box(self)\n\n    def get_base_origin(self) -> Pose:\n        \"\"\"\n        :return: the origin of the base/bottom of this object.\n        \"\"\"\n        aabb = self.get_axis_aligned_bounding_box()\n        base_width = np.absolute(aabb.min_x - aabb.max_x)\n        base_length = np.absolute(aabb.min_y - aabb.max_y)\n        return Pose([aabb.min_x + base_width / 2, aabb.min_y + base_length / 2, aabb.min_z],\n                    self.get_orientation_as_list())\n\n    def get_joint_by_id(self, joint_id: int) -> Joint:\n        \"\"\"\n        Returns the joint object with the given id.\n\n        :param joint_id: The unique id of the joint.\n        :return: The joint object.\n        \"\"\"\n        return dict([(joint.id, joint) for joint in self.joints.values()])[joint_id]\n\n    def copy_to_prospection(self) -> Object:\n        \"\"\"\n        Copies this object to the prospection world.\n\n        :return: The copied object in the prospection world.\n        \"\"\"\n        obj = Object(self.name, self.obj_type, self.path, type(self.description), self.get_pose(),\n                     self.world.prospection_world, self.color)\n        obj.current_state = self.current_state\n        return obj\n\n    def get_link_for_attached_objects(self) -> Dict[Object, ObjectDescription.Link]:\n        \"\"\"\n        Returns a dictionary which maps attached object to the link of this object to which the given object is attached.\n\n        :return: The link of this object to which the given object is attached.\n        \"\"\"\n        return {obj: attachment.parent_link for obj, attachment in self.attachments.items()}\n\n\n    def __copy__(self) -> Object:\n        \"\"\"\n        Returns a copy of this object. The copy will have the same name, type, path, description, pose, world and color.\n\n        :return: A copy of this object.\n        \"\"\"\n        obj = Object(self.name, self.obj_type, self.path, type(self.description), self.get_pose(),\n                     self.world.prospection_world, self.color)\n        obj.current_state = self.current_state\n        return obj\n\n    def __eq__(self, other):\n        if not isinstance(other, Object):\n            return False\n        return (self.id == other.id and self.world == other.world and self.name == other.name\n                and self.obj_type == other.obj_type)\n\n    def __hash__(self):\n        return hash((self.name, self.obj_type, self.id, self.world.id))\n\n\n"}]}
