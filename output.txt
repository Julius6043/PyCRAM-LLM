##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/bullet_world.py
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import logging
import os
import pathlib
import re
import threading
import time
import xml.etree.ElementTree
from queue import Queue
import tf
from typing import List, Optional, Dict, Tuple, Callable
from typing import Union
import numpy as np
import pybullet as p
import rospkg
import rospy
import rosgraph
import rosnode
import atexit

import urdf_parser_py.urdf
from geometry_msgs.msg import Quaternion, Point, TransformStamped
from urdf_parser_py.urdf import URDF

from . import utils
from .event import Event
from .robot_descriptions import robot_description
from .enums import JointType, ObjectType
from .local_transformer import LocalTransformer
from sensor_msgs.msg import JointState

from .pose import Pose, Transform


class BulletWorld:
    """
    The BulletWorld Class represents the physics Simulation and belief state.
    """

    current_bullet_world: BulletWorld = None
    """
    Global reference to the currently used BulletWorld, usually this is the
    graphical one. However, if you are inside a Use_shadow_world() environment the current_bullet_world points to the
    shadow world. In this way you can comfortably use the current_bullet_world, which should point towards the BulletWorld
    used at the moment.
    """
    robot: Object = None
    """
    Global reference to the spawned Object that represents the robot. The robot is identified by checking the name in the 
    URDF with the name of the URDF on the parameter server. 
    """

    # Check is for sphinx autoAPI to be able to work in a CI workflow
    if rosgraph.is_master_online():  # and "/pycram" not in rosnode.get_node_names():
        rospy.init_node('pycram')

    def __init__(self, type: str = "GUI", is_shadow_world: bool = False):
        """
        Creates a new simulation, the type decides of the simulation should be a rendered window or just run in the
        background. There can only be one rendered simulation.
        The BulletWorld object also initializes the Events for attachment, detachment and for manipulating the world.

        :param type: Can either be "GUI" for rendered window or "DIRECT" for non-rendered. The default parameter is "GUI"
        :param is_shadow_world: For internal usage, decides if this BulletWorld should be used as a shadow world.
        """
        self.objects: List[Object] = []
        self.client_id: int = -1
        self.detachment_event: Event = Event()
        self.attachment_event: Event = Event()
        self.manipulation_event: Event = Event()
        self.type: str = type
        self._gui_thread: Gui = Gui(self, type)
        self._gui_thread.start()
        # This disables file caching from PyBullet, since this would also cache
        # files that can not be loaded
        p.setPhysicsEngineParameter(enableFileCaching=0)
        # Needed to let the other thread start the simulation, before Objects are spawned.
        time.sleep(0.1)
        if BulletWorld.current_bullet_world == None:
            BulletWorld.current_bullet_world = self
        self.vis_axis: Object = []
        self.coll_callbacks: Dict[Tuple[Object, Object], Tuple[Callable, Callable]] = {}
        self.data_directory: List[str] = [os.path.dirname(__file__) + "/../../resources"]
        self.shadow_world: BulletWorld = BulletWorld("DIRECT", True) if not is_shadow_world else None
        self.world_sync: WorldSync = WorldSync(self, self.shadow_world) if not is_shadow_world else None
        self.is_shadow_world: bool = is_shadow_world
        self.local_transformer = LocalTransformer()
        if not is_shadow_world:
            self.world_sync.start()
            self.local_transformer.bullet_world = self
            self.local_transformer.shadow_world = self.shadow_world

        # Some default settings
        self.set_gravity([0, 0, -9.8])
        if not is_shadow_world:
            plane = Object("floor", ObjectType.ENVIRONMENT, "plane.urdf", world=self)
        # atexit.register(self.exit)

    def get_objects_by_name(self, name: str) -> List[Object]:
        """
        Returns a list of all Objects in this BulletWorld with the same name as the given one.

        :param name: The name of the returned Objects.
        :return: A list of all Objects with the name 'name'.
        """
        return list(filter(lambda obj: obj.name == name, self.objects))

    def get_objects_by_type(self, obj_type: str) -> List[Object]:
        """
        Returns a list of all Objects which have the type 'obj_type'.

        :param obj_type: The type of the returned Objects.
        :return: A list of all Objects that have the type 'obj_type'.
        """
        return list(filter(lambda obj: obj.type == obj_type, self.objects))

    def get_object_by_id(self, id: int) -> Object:
        """
        Returns the single Object that has the unique id.

        :param id: The unique id for which the Object should be returned.
        :return: The Object with the id 'id'.
        """
        return list(filter(lambda obj: obj.id == id, self.objects))[0]

    def get_attachment_event(self) -> Event:
        """
        Returns the event reference that is fired if an attachment occurs.

        :return: The reference to the attachment event
        """
        return self.attachment_event

    def get_detachment_event(self) -> Event:
        """
        Returns the event reference that is fired if a detachment occurs.

        :return: The event reference for the detachment event.
        """
        return self.detachment_event

    def get_manipulation_event(self) -> Event:
        """
        Returns the event reference that is fired if any manipulation occurs.

        :return: The event reference for the manipulation event.
        """
        return self.manipulation_event

    def set_realtime(self, real_time: bool) -> None:
        """
        Enables the real time simulation of Physic in the BulletWorld. By default this is disabled and Physic is only
        simulated to reason about it.

        :param real_time: Whether the BulletWorld should simulate Physic in real time.
        """
        p.setRealTimeSimulation(1 if real_time else 0, self.client_id)

    def set_gravity(self, velocity: List[float]) -> None:
        """
        Sets the gravity that is used in the BullteWorld, by default the is the gravity on earth ([0, 0, -9.8]). Gravity
        is given as a vector in x,y,z. Gravity is only applied while simulating Physic.

        :param velocity: The gravity vector that should be used in the BulletWorld.
        """
        p.setGravity(velocity[0], velocity[1], velocity[2], physicsClientId=self.client_id)

    def set_robot(self, robot: Object) -> None:
        """
        Sets the global variable for the robot Object. This should be set on spawning the robot.

        :param robot: The Object reference to the Object representing the robot.
        """
        BulletWorld.robot = robot

    def simulate(self, seconds: float, real_time: Optional[float] = False) -> None:
        """
        Simulates Physic in the BulletWorld for a given amount of seconds. Usually this simulation is faster than real
        time, meaning you can simulate for example 10 seconds of Physic in the BulletWorld in 1 second real time. By
        setting the 'real_time' parameter this simulation is slowed down such that the simulated time is equal to real
        time.

        :param seconds: The amount of seconds that should be simulated.
        :param real_time: If the simulation should happen in real time or faster.
        """
        for i in range(0, int(seconds * 240)):
            p.stepSimulation(self.client_id)
            for objects, callback in self.coll_callbacks.items():
                contact_points = p.getContactPoints(objects[0].id, objects[1].id, physicsClientId=self.client_id)
                # contact_points = p.getClosestPoints(objects[0].id, objects[1].id, 0.02)
                # print(contact_points[0][5])
                if contact_points != ():
                    callback[0]()
                elif callback[1] != None:  # Call no collision callback
                    callback[1]()
            if real_time:
                # Simulation runs at 240 Hz
                time.sleep(0.004167)

    def exit(self) -> None:
        """
        Closes the BulletWorld as well as the shadow world, also collects any other thread that is running. This is the
        preferred method to close the BulletWorld.
        """
        # True if this is NOT the shadow world since it has a reference to the
        # Shadow world
        time.sleep(0.1)
        if self.shadow_world:
            self.world_sync.terminate = True
            self.world_sync.join()
            self.shadow_world.exit()
        p.disconnect(self.client_id)
        if self._gui_thread:
            self._gui_thread.join()
        if BulletWorld.current_bullet_world == self:
            BulletWorld.current_bullet_world = None
        BulletWorld.robot = None

    def save_state(self) -> int:
        """
        Returns the id of the saved state of the BulletWorld. The saved state contains the position, orientation and joint
        position of every Object in the BulletWorld.

        :return: A unique id of the state
        """
        objects2attached = {}
        # ToDo find out what this is for and where it is used
        for o in self.objects:
            objects2attached[o] = (o.attachments.copy(), o.cids.copy())
        return p.saveState(self.client_id), objects2attached

    def restore_state(self, state, objects2attached: Dict = {}) -> None:
        """
        Restores the state of the BulletWorld according to the given state id. This includes position, orientation and
        joint states. However, restore can not respawn objects if there are objects that were deleted between creation of
        the state and restoring they will be skiped.

        :param state: The unique id representing the state, as returned by :func:`~save_state`
        :param objects2attached: A dictionary of attachments, as saved in :py:attr:`~bullet_world.Object.attachments`
        """
        p.restoreState(state, physicsClientId=self.client_id)
        for obj in self.objects:
            try:
                obj.attachments, obj.cids = objects2attached[obj]
            except KeyError:
                continue

    def copy(self) -> BulletWorld:
        """
        Copies this Bullet World into another and returns it. The other BulletWorld
        will be in Direct mode. The shadow world should always be preferred instead of creating a new BulletWorld.
        This method should only be used if necessary since there can be unforeseen problems.

        :return: The reference to the new BulletWorld
        """
        world = BulletWorld("DIRECT")
        for obj in self.objects:
            o = Object(obj.name, obj.type, obj.path, obj.get_position(), obj.get_orientation(),
                       world, obj.color)
            for joint in obj.joints:
                o.set_joint_state(joint, obj.get_joint_state(joint))
        return world

    def add_vis_axis(self, pose: Pose,
                     length: Optional[float] = 0.2) -> None:
        """
        Creates a Visual object which represents the coordinate frame at the given
        position and orientation. There can be an unlimited amount of vis axis objects.

        :param pose: The pose at which the axis should be spawned
        :param length: Optional parameter to configure the length of the axes
        """

        pose_in_map = self.local_transformer.transform_pose(pose, "map")

        position, orientation = pose_in_map.to_list()

        vis_x = p.createVisualShape(p.GEOM_BOX, halfExtents=[length, 0.01, 0.01],
                                    rgbaColor=[1, 0, 0, 0.8], visualFramePosition=[length, 0.01, 0.01])
        vis_y = p.createVisualShape(p.GEOM_BOX, halfExtents=[0.01, length, 0.01],
                                    rgbaColor=[0, 1, 0, 0.8], visualFramePosition=[0.01, length, 0.01])
        vis_z = p.createVisualShape(p.GEOM_BOX, halfExtents=[0.01, 0.01, length],
                                    rgbaColor=[0, 0, 1, 0.8], visualFramePosition=[0.01, 0.01, length])

        obj = p.createMultiBody(baseVisualShapeIndex=-1, linkVisualShapeIndices=[vis_x, vis_y, vis_z],
                                basePosition=position, baseOrientation=orientation,
                                linkPositions=[[0, 0, 0], [0, 0, 0], [0, 0, 0]],
                                linkMasses=[1.0, 1.0, 1.0], linkOrientations=[[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]],
                                linkInertialFramePositions=[[0, 0, 0], [0, 0, 0], [0, 0, 0]],
                                linkInertialFrameOrientations=[[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]],
                                linkParentIndices=[0, 0, 0],
                                linkJointTypes=[p.JOINT_FIXED, p.JOINT_FIXED, p.JOINT_FIXED],
                                linkJointAxis=[[1, 0, 0], [0, 1, 0], [0, 0, 1]],
                                linkCollisionShapeIndices=[-1, -1, -1])

        self.vis_axis.append(obj)

    def remove_vis_axis(self) -> None:
        """
        Removes all spawned vis axis objects that are currently in this BulletWorld.
        """
        for id in self.vis_axis:
            p.removeBody(id)
        self.vis_axis = []

    def register_collision_callback(self, objectA: Object, objectB: Object,
                                    callback_collision: Callable,
                                    callback_no_collision: Optional[Callable] = None) -> None:
        """
        Registers callback methods for contact between two Objects. There can be a callback for when the two Objects
        get in contact and, optionally, for when they are not in contact anymore.

        :param objectA: An object in the BulletWorld
        :param objectB: Another object in the BulletWorld
        :param callback_collision: A function that should be called if the objects are in contact
        :param callback_no_collision: A function that should be called if the objects are not in contact
        """
        self.coll_callbacks[(objectA, objectB)] = (callback_collision, callback_no_collision)

    def add_additional_resource_path(self, path: str) -> None:
        """
        Adds a resource path in which the BulletWorld will search for files. This resource directory is searched if an
        Object is spawned only with a filename.

        :param path: A path in the filesystem in which to search for files.
        """
        self.data_directory.append(path)

    def get_shadow_object(self, object: Object) -> Object:
        """
        Returns the corresponding object from the shadow world for the given object. If the given Object is already in
        the shadow world it is returned.

        :param object: The object for which the shadow worlds object should be returned.
        :return: The corresponding object in the shadow world.
        """
        try:
            return self.world_sync.object_mapping[object]
        except KeyError:
            shadow_world = self if self.is_shadow_world else self.shadow_world
            if object in shadow_world.objects:
                return object
            else:
                raise ValueError(
                    f"There is no shadow object for the given object: {object}, this could be the case if the object isn't anymore in the main (graphical) BulletWorld or if the given object is already a shadow object. ")

    def get_bullet_object_for_shadow(self, object: Object) -> Object:
        """
        Returns the corresponding object from the main Bullet World for a given
        object in the shadow world. If the  given object is not in the shadow
        world an error will be raised.

        :param object: The object for which the corresponding object in the main Bullet World should be found
        :return: The object in the main Bullet World
        """
        map = self.world_sync.object_mapping
        try:
            return list(map.keys())[list(map.values()).index(object)]
        except ValueError:
            raise ValueError("The given object is not in the shadow world.")

    def reset_bullet_world(self) -> None:
        """
        Resets the BulletWorld to the state it was first spawned in.
        All attached objects will be detached, all joints will be set to the
        default position of 0 and all objects will be set to the position and
        orientation in which they were spawned.
        """
        for obj in self.objects:
            if obj.attachments:
                attached_objects = list(obj.attachments.keys())
                for att_obj in attached_objects:
                    obj.detach(att_obj)
            joint_names = list(obj.joints.keys())
            joint_poses = [0 for j in joint_names]
            obj.set_joint_states(dict(zip(joint_names, joint_poses)))
            obj.set_pose(obj.original_pose)


class Use_shadow_world():
    """
    An environment for using the shadow world, while in this environment the :py:attr:`~BulletWorld.current_bullet_world`
    variable will point to the shadow world.

    Example:
        with Use_shadow_world():
            NavigateAction.Action([[1, 0, 0], [0, 0, 0, 1]]).perform()
    """

    def __init__(self):
        self.prev_world: BulletWorld = None

    def __enter__(self):
        if not BulletWorld.current_bullet_world.is_shadow_world:
            time.sleep(20 / 240)
            # blocks until the adding queue is ready
            BulletWorld.current_bullet_world.world_sync.add_obj_queue.join()
            # **This is currently not used since the sleep(20/240) seems to be enough, but on weaker hardware this might
            # not be a feasible solution**
            # while not BulletWorld.current_bullet_world.world_sync.equal_states:
            #     time.sleep(0.1)

            self.prev_world = BulletWorld.current_bullet_world
            BulletWorld.current_bullet_world.world_sync.pause_sync = True
            BulletWorld.current_bullet_world = BulletWorld.current_bullet_world.shadow_world

    def __exit__(self, *args):
        if not self.prev_world == None:
            BulletWorld.current_bullet_world = self.prev_world
        BulletWorld.current_bullet_world.world_sync.pause_sync = False


class WorldSync(threading.Thread):
    """
    Synchronizes the state between the BulletWorld and its shadow world.
    Meaning the cartesian and joint position of everything in the shadow world will be
    synchronized with the main BulletWorld.
    Adding and removing objects is done via queues, such that loading times of objects
    in the shadow world does not affect the BulletWorld.
    The class provides the possibility to pause the synchronization, this can be used
    if reasoning should be done in the shadow world.
    """

    def __init__(self, world: BulletWorld, shadow_world: BulletWorld):
        threading.Thread.__init__(self)
        self.world: BulletWorld = world
        self.shadow_world: BulletWorld = shadow_world
        self.shadow_world.world_sync: WorldSync = self

        self.terminate: bool = False
        self.add_obj_queue: Queue = Queue()
        self.remove_obj_queue: Queue = Queue()
        self.pause_sync: bool = False
        # Maps bullet to shadow world objects
        self.object_mapping: Dict[Object, Object] = {}
        self.equal_states = False

    def run(self):
        """
        Main method of the synchronization, this thread runs in a loop until the
        terminate flag is set.
        While this loop runs it continuously checks the cartesian and joint position of
        every object in the BulletWorld and updates the corresponding object in the
        shadow world. When there are entries in the adding or removing queue the corresponding objects will be added
        or removed in the same iteration.
        """
        while not self.terminate:
            self.check_for_pause()
            # self.equal_states = False
            for i in range(self.add_obj_queue.qsize()):
                obj = self.add_obj_queue.get()
                # [name, type, path, position, orientation, self.world.shadow_world, color, bulletworld object]
                o = Object(obj[0], obj[1], obj[2], Pose(obj[3], obj[4]), obj[5], obj[6])
                # Maps the BulletWorld object to the shadow world object
                self.object_mapping[obj[7]] = o
                self.add_obj_queue.task_done()
            for i in range(self.remove_obj_queue.qsize()):
                obj = self.remove_obj_queue.get()
                # Get shadow world object reference from object mapping
                shadow_obj = self.object_mapping[obj]
                shadow_obj.remove()
                del self.object_mapping[obj]
                self.remove_obj_queue.task_done()

            for bulletworld_obj, shadow_obj in self.object_mapping.items():
                b_pose = bulletworld_obj.get_pose()
                s_pose = shadow_obj.get_pose()
                if b_pose.dist(s_pose) != 0.0:
                    shadow_obj.set_pose(bulletworld_obj.get_pose())

                # Manage joint positions
                if len(bulletworld_obj.joints) > 2:
                    for joint_name in bulletworld_obj.joints.keys():
                        if shadow_obj.get_joint_state(joint_name) != bulletworld_obj.get_joint_state(joint_name):
                            shadow_obj.set_joint_states(bulletworld_obj.get_complete_joint_state())
                            break

            self.check_for_pause()
            # self.check_for_equal()
            time.sleep(1 / 360)

        self.add_obj_queue.join()
        self.remove_obj_queue.join()

    def check_for_pause(self) -> None:
        """
        Checks if :py:attr:`~self.pause_sync` is true and sleeps this thread until it isn't anymore.
        """
        while self.pause_sync:
            time.sleep(0.1)

    def check_for_equal(self) -> None:
        """
        Checks if both BulletWorlds have the same state, meaning all objects are in the same position.
        This is currently not used, but might be used in the future if synchronization issues worsen.
        """
        eql = True
        for obj, shadow_obj in self.object_mapping.items():
            eql = eql and obj.get_pose() == shadow_obj.get_pose()
        self.equal_states = eql


class Gui(threading.Thread):
    """
    For internal use only. Creates a new thread for the physics simulation that is active until closed by :func:`~BulletWorld.exit`
    Also contains the code for controlling the camera.
    """

    def __init__(self, world, type):
        threading.Thread.__init__(self)
        self.world: BulletWorld = world
        self.type: str = type

    def run(self):
        """
        Initializes the new simulation and checks in an endless loop
        if it is still active. If it is the thread will be suspended for 1/80 seconds, if it is not the method and
        thus the thread terminates. The loop also checks for mouse and keyboard inputs to control the camera.
        """
        if self.type != "GUI":
            self.world.client_id = p.connect(p.DIRECT)
        else:
            self.world.client_id = p.connect(p.GUI)

            # Disable the side windows of the GUI
            p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0)
            # Change the init camera pose
            p.resetDebugVisualizerCamera(cameraDistance=1.5, cameraYaw=270.0, cameraPitch=-50,
                                         cameraTargetPosition=[-2, 0, 1])

            # Get the initial camera target location
            cameraTargetPosition = p.getDebugVisualizerCamera()[11]

            sphereVisualId = p.createVisualShape(p.GEOM_SPHERE, radius=0.05, rgbaColor=[1, 0, 0, 1])

            # Create a sphere with a radius of 0.05 and a mass of 0
            sphereUid = p.createMultiBody(baseMass=0.0,
                                          baseInertialFramePosition=[0, 0, 0],
                                          baseVisualShapeIndex=sphereVisualId,
                                          basePosition=cameraTargetPosition)

            # Define the maxSpeed, used in calculations
            maxSpeed = 16

            # Set initial Camera Rotation
            cameraYaw = 50
            cameraPitch = -35

            # Keep track of the mouse state
            mouseState = [0, 0, 0]
            oldMouseX, oldMouseY = 0, 0

            # Determines if the sphere at cameraTargetPosition is visible
            visible = 1

            # Loop to update the camera position based on keyboard events
            while p.isConnected(self.world.client_id):
                # Monitor user input
                keys = p.getKeyboardEvents()
                mouse = p.getMouseEvents()

                # Get infos about the camera
                width, height, dist = p.getDebugVisualizerCamera()[0], p.getDebugVisualizerCamera()[1], \
                    p.getDebugVisualizerCamera()[10]
                cameraTargetPosition = p.getDebugVisualizerCamera()[11]

                # Get vectors used for movement on x,y,z Vector
                xVec = [p.getDebugVisualizerCamera()[2][i] for i in [0, 4, 8]]
                yVec = [p.getDebugVisualizerCamera()[2][i] for i in [2, 6, 10]]
                zVec = (0, 0, 1)  # [p.getDebugVisualizerCamera()[2][i] for i in [1, 5, 9]]

                # Check the mouse state
                if mouse:
                    for m in mouse:

                        mouseX = m[2]
                        mouseY = m[1]

                        # update mouseState
                        # Left Mouse button
                        if m[0] == 2 and m[3] == 0:
                            mouseState[0] = m[4]
                        # Middle mouse butto (scroll wheel)
                        if m[0] == 2 and m[3] == 1:
                            mouseState[1] = m[4]
                        # right mouse button
                        if m[0] == 2 and m[3] == 2:
                            mouseState[2] = m[4]

                        # change visibility by clicking the mousewheel
                        if m[4] == 6 and m[3] == 1 and visible == 1:
                            visible = 0
                        elif m[4] == 6 and visible == 0:
                            visible = 1

                        # camera movement when the left mouse button is pressed
                        if mouseState[0] == 3:
                            speedX = abs(oldMouseX - mouseX) if (abs(oldMouseX - mouseX)) < maxSpeed else maxSpeed
                            speedY = abs(oldMouseY - mouseY) if (abs(oldMouseY - mouseY)) < maxSpeed else maxSpeed

                            # max angle of 89.5 and -89.5 to make sure the camera does not flip (is annoying)
                            if mouseX < oldMouseX:
                                if (cameraPitch + speedX) < 89.5:
                                    cameraPitch += (speedX / 4) + 1
                            elif mouseX > oldMouseX:
                                if (cameraPitch - speedX) > -89.5:
                                    cameraPitch -= (speedX / 4) + 1

                            if mouseY < oldMouseY:
                                cameraYaw += (speedY / 4) + 1
                            elif mouseY > oldMouseY:
                                cameraYaw -= (speedY / 4) + 1

                        if mouseState[1] == 3:
                            speedX = abs(oldMouseX - mouseX)
                            factor = 0.05

                            if mouseX < oldMouseX:
                                dist = dist - speedX * factor
                            elif mouseX > oldMouseX:
                                dist = dist + speedX * factor
                            dist = max(dist, 0.1)

                        # camera movement when the right mouse button is pressed
                        if mouseState[2] == 3:
                            speedX = abs(oldMouseX - mouseX) if (abs(oldMouseX - mouseX)) < 5 else 5
                            speedY = abs(oldMouseY - mouseY) if (abs(oldMouseY - mouseY)) < 5 else 5
                            factor = 0.05

                            if mouseX < oldMouseX:
                                cameraTargetPosition = np.subtract(cameraTargetPosition,
                                                                   np.multiply(np.multiply(zVec, factor), speedX))
                            elif mouseX > oldMouseX:
                                cameraTargetPosition = np.add(cameraTargetPosition,
                                                              np.multiply(np.multiply(zVec, factor), speedX))

                            if mouseY < oldMouseY:
                                cameraTargetPosition = np.add(cameraTargetPosition,
                                                              np.multiply(np.multiply(xVec, factor), speedY))
                            elif mouseY > oldMouseY:
                                cameraTargetPosition = np.subtract(cameraTargetPosition,
                                                                   np.multiply(np.multiply(xVec, factor), speedY))
                        # update oldMouse values
                        oldMouseY, oldMouseX = mouseY, mouseX

                # check the keyboard state
                if keys:
                    # if shift is pressed, double the speed
                    if p.B3G_SHIFT in keys:
                        speedMult = 5
                    else:
                        speedMult = 2.5

                    # if control is pressed, the movements caused by the arrowkeys, the '+' as well as the '-' key
                    # change
                    if p.B3G_CONTROL in keys:

                        # the up and down arrowkeys cause the targetPos to move along the z axis of the map
                        if p.B3G_DOWN_ARROW in keys:
                            cameraTargetPosition = np.subtract(cameraTargetPosition,
                                                               np.multiply(np.multiply(zVec, 0.03), speedMult))
                        elif p.B3G_UP_ARROW in keys:
                            cameraTargetPosition = np.add(cameraTargetPosition,
                                                          np.multiply(np.multiply(zVec, 0.03), speedMult))

                        # left and right arrowkeys cause the targetPos to move horizontally relative to the camera
                        if p.B3G_LEFT_ARROW in keys:
                            cameraTargetPosition = np.subtract(cameraTargetPosition,
                                                               np.multiply(np.multiply(xVec, 0.03), speedMult))
                        elif p.B3G_RIGHT_ARROW in keys:
                            cameraTargetPosition = np.add(cameraTargetPosition,
                                                          np.multiply(np.multiply(xVec, 0.03), speedMult))

                        # the '+' and '-' keys cause the targetpos to move forwards and backwards relative to the camera
                        # while the camera stays at a constant distance. SHIFT + '=' is for US layout
                        if ord("+") in keys or p.B3G_SHIFT in keys and ord("=") in keys:
                            cameraTargetPosition = np.subtract(cameraTargetPosition,
                                                               np.multiply(np.multiply(yVec, 0.03), speedMult))
                        elif ord("-") in keys:
                            cameraTargetPosition = np.add(cameraTargetPosition,
                                                          np.multiply(np.multiply(yVec, 0.03), speedMult))

                    # standard bindings for thearrowkeys, the '+' as well as the '-' key
                    else:

                        # left and right arrowkeys cause the camera to rotate around the yaw axis
                        if p.B3G_RIGHT_ARROW in keys:
                            cameraYaw += (360 / width) * speedMult
                        elif p.B3G_LEFT_ARROW in keys:
                            cameraYaw -= (360 / width) * speedMult

                        # the up and down arrowkeys cause the camera to rotate around the pitch axis
                        if p.B3G_DOWN_ARROW in keys:
                            if (cameraPitch + (360 / height) * speedMult) < 89.5:
                                cameraPitch += (360 / height) * speedMult
                        elif p.B3G_UP_ARROW in keys:
                            if (cameraPitch - (360 / height) * speedMult) > -89.5:
                                cameraPitch -= (360 / height) * speedMult

                        # the '+' and '-' keys cause the camera to zoom towards and away from the targetPos without
                        # moving it. SHIFT + '=' is for US layout since the events can't handle shift plus something
                        if ord("+") in keys or p.B3G_SHIFT in keys and ord("=") in keys:
                            if (dist - (dist * 0.02) * speedMult) > 0.1:
                                dist -= dist * 0.02 * speedMult
                        elif ord("-") in keys:
                            dist += dist * 0.02 * speedMult

                p.resetDebugVisualizerCamera(cameraDistance=dist, cameraYaw=cameraYaw, cameraPitch=cameraPitch,
                                             cameraTargetPosition=cameraTargetPosition)
                if visible == 0:
                    cameraTargetPosition = (0.0, -50, 50)
                p.resetBasePositionAndOrientation(sphereUid, cameraTargetPosition, [0, 0, 0, 1])
                time.sleep(1. / 80.)


class Object:
    """
    Represents a spawned Object in the BulletWorld.
    """

    def __init__(self, name: str, type: Union[str, ObjectType], path: str,
                 pose: Pose = None,
                 world: BulletWorld = None,
                 color: Optional[List[float]] = [1, 1, 1, 1],
                 ignoreCachedFiles: Optional[bool] = False):
        """
        The constructor loads the urdf file into the given BulletWorld, if no BulletWorld is specified the
        :py:attr:`~BulletWorld.current_bullet_world` will be used. It is also possible to load .obj and .stl file into the BulletWorld.
        The color parameter is only used when loading .stl or .obj files, for URDFs :func:`~Object.set_color` can be used.

        :param name: The name of the object
        :param type: The type of the object
        :param path: The path to the source file, if only a filename is provided then the resourcer directories will be searched
        :param pose: The pose at which the Object should be spawned
        :param world: The BulletWorld in which the object should be spawned, if no world is specified the :py:attr:`~BulletWorld.current_bullet_world` will be used
        :param color: The color with which the object should be spawned.
        :param ignoreCachedFiles: If true the file will be spawned while ignoring cached files.
        """
        if not pose:
            pose = Pose()
        self.world: BulletWorld = world if world is not None else BulletWorld.current_bullet_world
        self.local_transformer = LocalTransformer()
        self.name: str = name
        self.type: str = type
        self.color: List[float] = color
        pose_in_map = self.local_transformer.transform_pose(pose, "map")
        position, orientation = pose_in_map.to_list()
        self.id, self.path = _load_object(name, path, position, orientation, self.world, color, ignoreCachedFiles)
        self.joints: Dict[str, int] = self._joint_or_link_name_to_id("joint")
        self.links: Dict[str, int] = self._joint_or_link_name_to_id("link")
        self.attachments: Dict[Object, List] = {}
        self.cids: Dict[Object, int] = {}
        self.original_pose = pose_in_map

        self.tf_frame = ("shadow/" if self.world.is_shadow_world else "") + self.name + "_" + str(self.id)

        # This means "world" is not the shadow world since it has a reference to a shadow world
        if self.world.shadow_world != None:
            self.world.world_sync.add_obj_queue.put(
                [name, type, path, position, orientation, self.world.shadow_world, color, self])

        with open(self.path) as f:
            self.urdf_object = URDF.from_xml_string(f.read())
            if self.urdf_object.name == robot_description.name and not BulletWorld.robot:
                BulletWorld.robot = self

        self.links[self.urdf_object.get_root()] = -1

        self._current_pose = pose_in_map
        self._current_link_poses = {}
        self._current_link_transforms = {}
        self._current_joint_states = {}
        self._init_current_joint_states()
        self._update_link_poses()

        self.base_origin_shift = np.array(position) - np.array(self.get_base_origin().position_as_list())
        self.local_transformer.update_transforms_for_object(self)
        self.link_to_geometry = self._get_geometry_for_link()

        self.world.objects.append(self)

    def __repr__(self):
        skip_attr = ["links", "joints", "urdf_object", "attachments", "cids", "_current_link_poses",
                     "_current_link_transforms", "link_to_geometry"]
        return self.__class__.__qualname__ + f"(" + ', \n'.join(
            [f"{key}={value}" if key not in skip_attr else f"{key}: ..." for key, value in self.__dict__.items()]) + ")"

    def remove(self) -> None:
        """
        Removes this object from the BulletWorld it currently resides in.
        For the object to be removed it has to be detached from all objects it
        is currently attached to. After this is done a call to PyBullet is done
        to remove this Object from the simulation.
        """
        for obj in self.attachments.keys():
            self.detach(obj)
        self.world.objects.remove(self)
        # This means the current world of the object is not the shaow world, since it
        # has a reference to the shadow world
        if self.world.shadow_world != None:
            self.world.world_sync.remove_obj_queue.put(self)
            self.world.world_sync.remove_obj_queue.join()
        p.removeBody(self.id, physicsClientId=self.world.client_id)
        if BulletWorld.robot == self:
            BulletWorld.robot = None

    def attach(self, object: Object, link: Optional[str] = None, loose: Optional[bool] = False) -> None:
        """
        Attaches another object to this object. This is done by
        saving the transformation between the given link, if there is one, and
        the base pose of the other object. Additionally, the name of the link, to
        which the object is attached, will be saved.
        Furthermore, a constraint of pybullet will be created so the attachment
        also works while simulation.
        Loose attachments means that the attachment will only be one-directional. For example, if this object moves the
        other, attached, object will also move but not the other way around.

        :param object: The other object that should be attached
        :param link: The link of this object to which the other object should be
        :param loose: If the attachment should be a loose attachment.
        """
        link_id = self.get_link_id(link) if link else -1
        link_to_object = self._calculate_transform(object, link)
        self.attachments[object] = [link_to_object, link, loose]
        object.attachments[self] = [link_to_object.invert(), None, False]

        cid = p.createConstraint(self.id, link_id, object.id, -1, p.JOINT_FIXED,
                                 [0, 1, 0], link_to_object.translation_as_list(), [0, 0, 0],
                                 link_to_object.rotation_as_list(),
                                 physicsClientId=self.world.client_id)
        self.cids[object] = cid
        object.cids[self] = cid
        self.world.attachment_event(self, [self, object])

    def detach(self, object: Object) -> None:
        """
        Detaches another object from this object. This is done by
        deleting the attachment from the attachments dictionary of both objects
        and deleting the constraint of pybullet.
        Afterward the detachment event of the corresponding BulletWorld will be fired.

        :param object: The object which should be detached
        """
        del self.attachments[object]
        del object.attachments[self]

        p.removeConstraint(self.cids[object], physicsClientId=self.world.client_id)

        del self.cids[object]
        del object.cids[self]
        self.world.detachment_event(self, [self, object])

    def detach_all(self) -> None:
        """
        Detach all objects attached to this object.
        """
        attachments = self.attachments.copy()
        for att in attachments.keys():
            self.detach(att)

    def get_position(self) -> Point:
        """
        Returns the position of this Object as a list of xyz.

        :return: The current position of this object
        """
        return self.get_pose().position

    def get_orientation(self) -> Quaternion:
        """
        Returns the orientation of this object as a list of xyzw, representing a quaternion.

        :return: A list of xyzw
        """
        return self.get_pose().orientation

    def get_pose(self) -> Pose:
        """
        Returns the position of this object as a list of xyz. Alias for :func:`~Object.get_position`.

        :return: The current pose of this object
        """
        return self._current_pose

    def set_pose(self, pose: Pose, base: bool = False) -> None:
        """
        Sets the Pose of the object.

        :param pose: New Pose for the object
        :param base: If True places the object base instead of origin at the specified position and orientation
        """
        pose_in_map = self.local_transformer.transform_pose(pose, "map")
        position, orientation = pose_in_map.to_list()
        if base:
            position = np.array(position) + self.base_origin_shift
        p.resetBasePositionAndOrientation(self.id, position, orientation, self.world.client_id)
        self._current_pose = pose_in_map
        self._update_link_poses()
        self._set_attached_objects([self])

    @property
    def pose(self) -> Pose:
        """
        Property that returns the current position of this Object.

        :return: The position as a list of xyz
        """
        return self.get_pose()

    @pose.setter
    def pose(self, value: Pose) -> None:
        """
        Sets the Pose of the Object to the given value. Function for attribute use.

        :param value: New Pose of the Object
        """
        self.set_pose(value)

    def move_base_to_origin_pos(self) -> None:
        """
        Move the object such that its base will be at the current origin position.
        This is useful when placing objects on surfaces where you want the object base in contact with the surface.
        """
        self.set_pose(self.get_pose(), base=True)

    def _set_attached_objects(self, prev_object: List[Object]) -> None:
        """
        Updates the positions of all attached objects. This is done
        by calculating the new pose in world coordinate frame and setting the
        base pose of the attached objects to this new pose.
        After this the _set_attached_objects method of all attached objects
        will be called.

        :param prev_object: A list of Objects that were already moved, these will be excluded to prevent loops in the update.
        """
        for obj in self.attachments:
            if obj in prev_object:
                continue
            if self.attachments[obj][2]:
                # Updates the attachment transformation and contraint if the
                # attachment is loos, instead of updating the position of all attached objects
                link_to_object = self._calculate_transform(obj, self.attachments[obj][1])
                link_id = self.get_link_id(self.attachments[obj][1]) if self.attachments[obj][1] else -1
                self.attachments[obj][0] = link_to_object
                obj.attachments[self][0] = link_to_object.invert()
                p.removeConstraint(self.cids[obj], physicsClientId=self.world.client_id)
                cid = p.createConstraint(self.id, link_id, obj.id, -1, p.JOINT_FIXED, [0, 0, 0],
                                         link_to_object.translation_as_list(),
                                         [0, 0, 0], link_to_object.rotation_as_list(),
                                         physicsClientId=self.world.client_id)
                self.cids[obj] = cid
                obj.cids[self] = cid
            else:
                link_to_object = self.attachments[obj][0]

                world_to_object = self.local_transformer.transform_pose(link_to_object.to_pose(), "map")
                p.resetBasePositionAndOrientation(obj.id, world_to_object.position_as_list(),
                                                  world_to_object.orientation_as_list(),
                                                  physicsClientId=self.world.client_id)
                obj._current_pose = world_to_object
                obj._set_attached_objects(prev_object + [self])

    def _calculate_transform(self, obj: Object, link: str = None) -> Transform:
        """
        Calculates the transformation between another object and the given
        link of this object. If no link is provided then the base position will be used.

        :param obj: The other object for which the transformation should be calculated
        :param link: The optional link name
        :return: The transformation from the link (or base position) to the other objects base position
        """
        transform = self.local_transformer.transform_to_object_frame(obj.pose, self, link)

        return Transform(transform.position_as_list(), transform.orientation_as_list(), transform.frame, obj.tf_frame)

    def set_position(self, position: Union[Pose, Point], base=False) -> None:
        """
        Sets this Object to the given position, if base is true the bottom of the Object will be placed at the position
        instead of the origin in the center of the Object. The given position can either be a Pose, in this case only the
        position is used or a geometry_msgs.msg/Point which is the position part of a Pose.

        :param position: Target position as xyz.
        :param base: If the bottom of the Object should be placed or the origin in the center.
        """
        pose = Pose()
        if type(position) == Pose:
            target_position = position.position
            pose.frame = position.frame
        else:
            target_position = position

        pose.pose.position = target_position
        pose.pose.orientation = self.get_orientation()
        self.set_pose(pose, base=base)

    def set_orientation(self, orientation: Union[Pose, Quaternion]) -> None:
        """
        Sets the orientation of the Object to the given orientation. Orientation can either be a Pose, in this case only
        the orientation of this pose is used or a geometry_msgs.msg/Quaternion which is the orientation of a Pose.

        :param orientation: Target orientation given as a list of xyzw.
        """
        pose = Pose()
        if type(orientation) == Pose:
            target_orientation = orientation.orientation
            pose.frame = orientation.frame
        else:
            target_orientation = orientation

        pose.pose.position = self.get_position()
        pose.pose.orientation = target_orientation
        self.set_pose(pose)

    def _joint_or_link_name_to_id(self, type: str) -> Dict[str, int]:
        """
        Creates a dictionary which maps the link or joint name to the unique ids used by pybullet.

        :param type: Determines if the dictionary should be for joints or links
        :return: A dictionary that maps joint or link names to unique ids
        """
        nJoints = p.getNumJoints(self.id, self.world.client_id)
        joint_name_to_id = {}
        info = 1 if type == "joint" else 12
        for i in range(0, nJoints):
            joint_info = p.getJointInfo(self.id, i, self.world.client_id)
            joint_name_to_id[joint_info[info].decode('utf-8')] = joint_info[0]
        return joint_name_to_id

    def get_joint_id(self, name: str) -> int:
        """
        Returns the unique id for a joint name. As used by PyBullet.

        :param name: The joint name
        :return: The unique id
        """
        return self.joints[name]

    def get_link_id(self, name: str) -> int:
        """
        Returns a unique id for a link name. As used by PyBullet.

        :param name: The link name
        :return: The unique id
        """
        return self.links[name]

    def get_link_by_id(self, id: int) -> str:
        """
        Returns the name of a link for a given unique PyBullet id

        :param id: PyBullet id for link
        :return: The link name
        """
        return dict(zip(self.links.values(), self.links.keys()))[id]

    def get_joint_by_id(self, id: int) -> str:
        """
        Returns the joint name for a unique PyBullet id

        :param id: The Pybullet id of for joint
        :return: The joint name
        """
        return dict(zip(self.joints.values(), self.joints.keys()))[id]

    def get_link_relative_to_other_link(self, source_frame: str, target_frame: str) -> Pose:
        """
        Calculates the position of a link in the coordinate frame of another link.

        :param source_frame: The name of the source frame
        :param target_frame: The name of the target frame
        :return: The pose of the source frame in the target frame
        """
        source_pose = self.get_link_pose(source_frame)
        return self.local_transformer.transform_to_object_frame(source_pose, self, target_frame)

    def get_link_position(self, name: str) -> Point:
        """
        Returns the position of a link of this Object. Position is returned as a list of xyz.

        :param name: The link name
        :return: The link position as xyz
        """
        return self.get_link_pose(name).position

    def get_link_orientation(self, name: str) -> Quaternion:
        """
        Returns the orientation of a link of this Object. Orientation is returned as a quaternion.

        :param name: The name of the link
        :return: The orientation of the link as a quaternion
        """
        return self.get_link_pose(name).orientation

    def get_link_pose(self, name: str) -> Pose:
        """
        Returns a Pose of the link corresponding to the given name. The returned Pose will be in world coordinate frame.

        :param name: Link name for which a Pose should returned
        :return: The pose of the link
        """
        if name in self.links.keys() and self.links[name] == -1:
            return self.get_pose()
        return self._current_link_poses[name]
        # return Pose(*p.getLinkState(self.id, self.links[name], physicsClientId=self.world.client_id)[4:6])

    def set_joint_state(self, joint_name: str, joint_pose: float) -> None:
        """
        Sets the state of the given joint to the given joint pose. If the pose is outside the joint limits, as stated
        in the URDF, an error will be printed. However, the joint will be set either way.

        :param joint_name: The name of the joint
        :param joint_pose: The target pose for this joint
        """
        # TODO Limits for rotational (infinitie) joints are 0 and 1, they should be considered seperatly
        up_lim, low_lim = p.getJointInfo(self.id, self.joints[joint_name], physicsClientId=self.world.client_id)[
                          8:10]
        if low_lim > up_lim:
            low_lim, up_lim = up_lim, low_lim
        if not low_lim <= joint_pose <= up_lim:
            logging.error(
                f"The joint position has to be within the limits of the joint. The joint limits for {joint_name} are {low_lim} and {up_lim}")
            logging.error(f"The given joint position was: {joint_pose}")
            # Temporarily disabled because kdl outputs values exciting joint limits
            # return
        p.resetJointState(self.id, self.joints[joint_name], joint_pose, physicsClientId=self.world.client_id)
        self._current_joint_states[joint_name] = joint_pose
        # self.local_transformer.update_transforms_for_object(self)
        self._update_link_poses()
        self._set_attached_objects([self])

    def set_joint_states(self, joint_poses: dict) -> None:
        """
        Sets the current state of multiple joints at once, this method should be preferred when setting multiple joints
        at once instead of running :func:`~Object.set_joint_state` in a loop.

        :param joint_poses:
        :return:
        """
        for joint_name, joint_pose in joint_poses.items():
            p.resetJointState(self.id, self.joints[joint_name], joint_pose, physicsClientId=self.world.client_id)
            self._current_joint_states[joint_name] = joint_pose
        self._update_link_poses()
        self._set_attached_objects([self])

    def get_joint_state(self, joint_name: str) -> float:
        """
        Returns the joint state for the given joint name.

        :param joint_name: The name of the joint
        :return: The current pose of the joint
        """
        return self._current_joint_states[joint_name]

    def contact_points(self) -> List:
        """
        Returns a list of contact points of this Object with other Objects. For a more detailed explanation of the returned
        list please look at `PyBullet Doc <https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit#>`_

        :return: A list of all contact points with other objects
        """
        return p.getContactPoints(self.id)

    def contact_points_simulated(self) -> List:
        """
        Returns a list of all contact points between this Object and other Objects after stepping the simulation once.
        For a more detailed explanation of the returned
        list please look at `PyBullet Doc <https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit#>`_

        :return: A list of contact points between this Object and other Objects
        """
        s = self.world.save_state()
        p.stepSimulation(self.world.client_id)
        contact_points = self.contact_points()
        self.world.restore_state(*s)
        return contact_points

    def update_joints_from_topic(self, topic_name: str) -> None:
        """
        Updates the joints of this object with positions obtained from a topic with the message type JointState.
        Joint names on the topic have to correspond to the joints of this object otherwise an error message will be logged.

        :param topic_name: Name of the topic with the joint states
        """
        msg = rospy.wait_for_message(topic_name, JointState)
        joint_names = msg.name
        joint_positions = msg.position
        if set(joint_names).issubset(self.joints.keys()):
            for i in range(len(joint_names)):
                self.set_joint_state(joint_names[i], joint_positions[i])
        else:
            add_joints = set(joint_names) - set(self.joints.keys())
            rospy.logerr(f"There are joints in the published joint state which are not in this model: /n \
                    The following joint{'s' if len(add_joints) != 1 else ''}: {add_joints}")

    def update_pose_from_tf(self, frame: str) -> None:
        """
        Updates the pose of this object from a TF message.

        :param frame: Name of the TF frame from which the position should be taken
        """
        tf_listener = tf.TransformListener()
        time.sleep(0.5)
        position, orientation = tf_listener.lookupTransform(frame, "map", rospy.Time(0))
        position = [position[0][0] * -1,
                    position[0][1] * -1,
                    position[0][2]]
        self.set_position(Pose(position, orientation))

    def set_color(self, color: List[float], link: Optional[str] = "") -> None:
        """
        Changes the color of this object, the color has to be given as a list
        of RGBA values. Optionally a link name can can be provided, if no link
        name is provided all links of this object will be colored.

        :param color: The color as RGBA values between 0 and 1
        :param link: The link name of the link which should be colored
        """
        if link == "":
            # Check if there is only one link, this is the case for primitive
            # forms or if loaded from an .stl or .obj file
            if self.links != {}:
                for link_id in self.links.values():
                    p.changeVisualShape(self.id, link_id, rgbaColor=color, physicsClientId=self.world.client_id)
            else:
                p.changeVisualShape(self.id, -1, rgbaColor=color, physicsClientId=self.world.client_id)
        else:
            p.changeVisualShape(self.id, self.links[link], rgbaColor=color, physicsClientId=self.world.client_id)

    def get_color(self, link: Optional[str] = None) -> Union[List[float], Dict[str, List[float]], None]:
        """
        This method returns the color of this object or a link of this object. If no link is given then the
        return is either:

            1. A list with the color as RGBA values, this is the case if the object only has one link (this
                happens for example if the object is spawned from a .obj or .stl file)
            2. A dict with the link name as key and the color as value. The color is given as RGBA values.
                Please keep in mind that not every link may have a color. This is dependent on the URDF from which the
                object is spawned.

        If a link is specified then the return is a list with RGBA values representing the color of this link.
        It may be that this link has no color, in this case the return is None as well as an error message.

        :param link: the link name for which the color should be returned.
        :return: The color of the object or link, or a dictionary containing every colored link with its color
        """
        visual_data = p.getVisualShapeData(self.id, physicsClientId=self.world.client_id)
        swap = {v: k for k, v in self.links.items()}
        links = list(map(lambda x: swap[x[1]] if x[1] != -1 else "base", visual_data))
        colors = list(map(lambda x: x[7], visual_data))
        link_to_color = dict(zip(links, colors))

        if link:
            if link in link_to_color.keys():
                return link_to_color[link]
            elif link not in self.links.keys():
                rospy.logerr(f"The link '{link}' is not part of this obejct")
                return None
            else:
                rospy.logerr(f"The link '{link}' has no color")
                return None

        if len(visual_data) == 1:
            return list(visual_data[0][7])
        else:
            return link_to_color

    def get_AABB(self, link_name: Optional[str] = None) -> Tuple[List[float], List[float]]:
        """
        Returns the axis aligned bounding box of this object, optionally a link name can be provided in this case
        the axis aligned bounding box of the link will be returned. The return of this method are two points in
        world coordinate frame which define a bounding box.

        :param link_name: The Optional name of a link of this object.
        :return: Two lists of x,y,z which define the bounding box.
        """
        if link_name:
            return p.getAABB(self.id, self.links[link_name], self.world.client_id)
        else:
            return p.getAABB(self.id, physicsClientId=self.world.client_id)

    def get_base_origin(self, link_name: Optional[str] = None) -> Pose:
        """
        Returns the origin of the base/bottom of an object/link

        :param link_name: The link name for which the bottom position should be returned
        :return: The position of the bottom of this Object or link
        """
        aabb = self.get_AABB(link_name=link_name)
        base_width = np.absolute(aabb[0][0] - aabb[1][0])
        base_length = np.absolute(aabb[0][1] - aabb[1][1])
        return Pose([aabb[0][0] + base_width / 2, aabb[0][1] + base_length / 2, aabb[0][2]],
                    self.get_pose().orientation_as_list())

    def get_joint_limits(self, joint: str) -> Tuple[float, float]:
        """
        Returns the lower and upper limit of a joint, if the lower limit is higher
        than the upper they are swapped to ensure the lower limit is always the smaller one.

        :param joint: The name of the joint for which the limits should be found.
        :return: The lower and upper limit of the joint.
        """
        if joint not in self.joints.keys():
            raise KeyError(f"The given Joint: {joint} is not part of this object")
        lower, upper = p.getJointInfo(self.id, self.joints[joint], self.world.client_id)[8: 10]
        if lower > upper:
            lower, upper = upper, lower
        return lower, upper

    def get_joint_axis(self, joint_name: str) -> Tuple[float]:
        """
        Returns the axis along which a joint is moving. The given joint_name has to be part of this object.

        :param joint_name: Name of the joint for which the axis should be returned.
        :return: The axis a vector of xyz
        """
        return p.getJointInfo(self.id, self.joints[joint_name], self.world.client_id)[13]

    def get_joint_type(self, joint_name: str) -> JointType:
        """
        Returns the type of the joint as element of the Enum :mod:`~pycram.enums.JointType`.

        :param joint_name: Joint name for which the type should be returned
        :return: The type of  the joint
        """
        joint_type = p.getJointInfo(self.id, self.joints[joint_name], self.world.client_id)[2]
        return JointType(joint_type)

    def find_joint_above(self, link_name: str, joint_type: JointType) -> str:
        """
        Traverses the chain from 'link_name' to the URDF origin and returns the first joint that is of type 'joint_type'.

        :param link_name: Link name above which the joint should be found
        :param joint_type: Joint type that should be searched for
        :return: Name of the first joint which has the given type
        """
        chain = self.urdf_object.get_chain(self.urdf_object.get_root(), link_name)
        reversed_chain = reversed(chain)
        container_joint = None
        for element in reversed_chain:
            if element in self.joints and self.get_joint_type(element) == joint_type:
                container_joint = element
                break
        if not container_joint:
            rospy.logwarn(f"No joint of type {joint_type} found above link {link_name}")
        return container_joint

    def get_complete_joint_state(self) -> Dict[str: float]:
        """
        Returns the complete joint state of the object as a dictionary of joint names and joint values.

        :return: A dictionary with the complete joint state
        """
        return self._current_joint_states

    def get_link_tf_frame(self, link_name: str) -> str:
        """
        Returns the name of the tf frame for the given link name. This method does not check if the given name is
        actually a link of this object.

        :param link_name: Name of a link for which the tf frame should be returned
        :return: A TF frame name for a specific link
        """
        return self.tf_frame + "/" + link_name

    def _get_geometry_for_link(self) -> Dict[str, urdf_parser_py.urdf.Geometry]:
        """
        Extracts the geometry information for each collision of each link and links them to the respective link.

        :return: A dictionary with link name as key and geometry information as value
        """
        link_to_geometry = {}
        for link in self.links.keys():
            link_obj = self.urdf_object.link_map[link]
            if not link_obj.collision:
                link_to_geometry[link] = None
            else:
                link_to_geometry[link] = link_obj.collision.geometry
        return link_to_geometry

    def _update_link_poses(self) -> None:
        """
        Updates the cached poses and transforms for each link of this Object
        """
        for link_name in self.links.keys():
            if link_name == self.urdf_object.get_root():
                self._current_link_poses[link_name] = self._current_pose
                self._current_link_transforms[link_name] = self._current_pose.to_transform(self.tf_frame)
            else:
                self._current_link_poses[link_name] = Pose(*p.getLinkState(self.id, self.links[link_name],
                                                                           physicsClientId=self.world.client_id)[4:6])
                self._current_link_transforms[link_name] = self._current_link_poses[link_name].to_transform(
                    self.get_link_tf_frame(link_name))

    def _init_current_joint_states(self) -> None:
        """
        Initialize the cached joint position for each joint.
        """
        for joint_name in self.joints.keys():
            self._current_joint_states[joint_name] = \
                p.getJointState(self.id, self.joints[joint_name], physicsClientId=self.world.client_id)[0]


def filter_contact_points(contact_points, exclude_ids) -> List:
    """
    Returns a list of contact points where Objects that are in the 'exclude_ids' list are removed.

    :param contact_points: A list of contact points
    :param exclude_ids: A list of unique ids of Objects that should be removed from the list
    :return: A list containing 'contact_points' without Objects that are in 'exclude_ids'
    """
    return list(filter(lambda cp: cp[2] not in exclude_ids, contact_points))


def get_path_from_data_dir(file_name: str, data_directory: str) -> str:
    """
    Returns the full path for a given file name in the given directory. If there is no file with the given filename
    this method returns None.

    :param file_name: The filename of the searched file.
    :param data_directory: The directory in which to search for the file.
    :return: The full path in the filesystem or None if there is no file with the filename in the directory
    """
    dir = pathlib.Path(data_directory)
    for file in os.listdir(data_directory):
        if file == file_name:
            return data_directory + f"/{file_name}"


def _get_robot_name_from_urdf(urdf_string: str) -> str:
    """
    Extracts the robot name from the 'robot_name' tag of a URDF.

    :param urdf_string: The URDF as string.
    :return: The name of the robot described by the URDF.
    """
    res = re.findall(r"robot\ *name\ *=\ *\"\ *[a-zA-Z_0-9]*\ *\"", urdf_string)
    if len(res) == 1:
        begin = res[0].find("\"")
        end = res[0][begin + 1:].find("\"")
        robot = res[0][begin + 1:begin + 1 + end].lower()
    return robot


def _load_object(name: str,
                 path: str,
                 position: List[float],
                 orientation: List[float],
                 world: BulletWorld,
                 color: List[float],
                 ignoreCachedFiles: bool) -> Tuple[int, str]:
    """
    Loads an object to the given BulletWorld with the given position and orientation. The color will only be
    used when an .obj or .stl file is given.
    If a .obj or .stl file is given, before spawning, an urdf file with the .obj or .stl as mesh will be created
    and this URDf file will be loaded instead.
    When spawning a URDf file a new file will be created in the cache directory, if there exists none.
    This new file will have resolved mesh file paths, meaning there will be no references
    to ROS packges instead there will be absolute file paths.

    :param name: The name of the object which should be spawned
    :param path: The path to the source file or the name on the ROS parameter server
    :param position: The position in which the object should be spawned
    :param orientation: The orientation in which the object should be spawned
    :param world: The BulletWorld to which the Object should be spawned
    :param color: The color of the object, only used when .obj or .stl file is given
    :param ignoreCachedFiles: Whether to ignore files in the cache directory.
    :return: The unique id of the object and the path to the file used for spawning
    """
    pa = pathlib.Path(path)
    extension = pa.suffix
    world, world_id = _world_and_id(world)
    if re.match("[a-zA-Z_0-9].[a-zA-Z0-9]", path):
        for dir in world.data_directory:
            path = get_path_from_data_dir(path, dir)
            if path: break

    if not path:
        raise FileNotFoundError(
            f"File {pa.name} could not be found in the resource directory {world.data_directory}")
    # rospack = rospkg.RosPack()
    # cach_dir = rospack.get_path('pycram') + '/resources/cached/'
    cach_dir = world.data_directory[0] + '/cached/'
    if not pathlib.Path(cach_dir).exists():
        os.mkdir(cach_dir)

    # if file is not yet cached corrcet the urdf and save if in the cache directory
    if not _is_cached(path, name, cach_dir) or ignoreCachedFiles:
        if extension == ".obj" or extension == ".stl":
            path = _generate_urdf_file(name, path, color, cach_dir)
        elif extension == ".urdf":
            with open(path, mode="r") as f:
                urdf_string = fix_missing_inertial(f.read())
                urdf_string = remove_error_tags(urdf_string)
                urdf_string = fix_link_attributes(urdf_string)
                try:
                    urdf_string = _correct_urdf_string(urdf_string)
                except rospkg.ResourceNotFound as e:
                    rospy.logerr(f"Could not find resource package linked in this URDF")
                    raise e
            path = cach_dir + pa.name
            with open(path, mode="w") as f:
                f.write(urdf_string)
        else:  # Using the urdf from the parameter server
            urdf_string = rospy.get_param(path)
            path = cach_dir + name + ".urdf"
            with open(path, mode="w") as f:
                f.write(_correct_urdf_string(urdf_string))
    # save correct path in case the file is already in the cache directory
    elif extension == ".obj" or extension == ".stl":
        path = cach_dir + pa.stem + ".urdf"
    elif extension == ".urdf":
        path = cach_dir + pa.name
    else:
        path = cach_dir + name + ".urdf"

    try:
        obj = p.loadURDF(path, basePosition=position, baseOrientation=orientation, physicsClientId=world_id)
        return obj, path
    except p.error as e:
        logging.error(
            "The File could not be loaded. Plese note that the path has to be either a URDF, stl or obj file or the name of an URDF string on the parameter server.")
        os.remove(path)
        raise (e)
        # print(f"{bcolors.BOLD}{bcolors.WARNING}The path has to be either a path to a URDf file, stl file, obj file or the name of a URDF on the parameter server.{bcolors.ENDC}")


def _is_cached(path: str, name: str, cach_dir: str) -> bool:
    """
    Checks if the file in the given path is already cached or if
    there is already a cached file with the given name, this is the case if a .stl, .obj file or a description from
    the parameter server is used.

    :param path: The path given by the user to the source file.
    :param name: The name for this object.
    :param cach_dir: The absolute path the cach directory in the pycram package.
    :return: True if there already exists a chached file, False in any other case.
    """
    file_name = pathlib.Path(path).name
    p = pathlib.Path(cach_dir + file_name)
    if p.exists():
        return True
    # Returns filename without the filetype, e.g. returns "test" for "test.txt"
    file_stem = pathlib.Path(path).stem
    p = pathlib.Path(cach_dir + file_stem + ".urdf")
    if p.exists():
        return True
    return False


def _correct_urdf_string(urdf_string: str) -> str:
    """
    Changes paths for files in the URDF from ROS paths to paths in the file system. Since PyBullet can't deal with ROS
    package paths.

    :param urdf_name: The name of the URDf on the parameter server
    :return: The URDF string with paths in the filesystem instead of ROS packages
    """
    r = rospkg.RosPack()
    new_urdf_string = ""
    for line in urdf_string.split('\n'):
        if "package://" in line:
            s = line.split('//')
            s1 = s[1].split('/')
            path = r.get_path(s1[0])
            line = line.replace("package://" + s1[0], path)
        new_urdf_string += line + '\n'

    return fix_missing_inertial(new_urdf_string)


def fix_missing_inertial(urdf_string: str) -> str:
    """
    Insert inertial tags for every URDF link that has no inertia.
    This is used to prevent PyBullet from dumping warnings in the terminal

    :param urdf_string: The URDF description as string
    :returns: The new, corrected URDF description as string.
    """

    inertia_tree = xml.etree.ElementTree.ElementTree(xml.etree.ElementTree.Element("inertial"))
    inertia_tree.getroot().append(xml.etree.ElementTree.Element("mass", {"value": "0.1"}))
    inertia_tree.getroot().append(xml.etree.ElementTree.Element("origin", {"rpy": "0 0 0", "xyz": "0 0 0"}))
    inertia_tree.getroot().append(xml.etree.ElementTree.Element("inertia", {"ixx": "0.01",
                                                                            "ixy": "0",
                                                                            "ixz": "0",
                                                                            "iyy": "0.01",
                                                                            "iyz": "0",
                                                                            "izz": "0.01"}))

    # create tree from string
    tree = xml.etree.ElementTree.ElementTree(xml.etree.ElementTree.fromstring(urdf_string))

    for link_element in tree.iter("link"):
        inertial = [*link_element.iter("inertial")]
        if len(inertial) == 0:
            link_element.append(inertia_tree.getroot())

    return xml.etree.ElementTree.tostring(tree.getroot(), encoding='unicode')


def remove_error_tags(urdf_string: str) -> str:
    """
    Removes all tags in the removing_tags list from the URDF since these tags are known to cause errors with the
    URDF_parser

    :param urdf_string: String of the URDF from which the tags should be removed
    :return: The URDF string with the tags removed
    """
    tree = xml.etree.ElementTree.ElementTree(xml.etree.ElementTree.fromstring(urdf_string))
    removing_tags = ["gazebo", "transmission"]
    for tag_name in removing_tags:
        all_tags = tree.findall(tag_name)
        for tag in all_tags:
            tree.getroot().remove(tag)

    return xml.etree.ElementTree.tostring(tree.getroot(), encoding='unicode')


def fix_link_attributes(urdf_string: str) -> str:
    """
    Removes the attribute 'type' from links since this is not parsable by the URDF parser.

    :param urdf_string: The string of the URDF from which the attributes should be removed
    :return: The URDF string with the attributes removed
    """
    tree = xml.etree.ElementTree.ElementTree(xml.etree.ElementTree.fromstring(urdf_string))

    for link in tree.iter("link"):
        if "type" in link.attrib.keys():
            del link.attrib["type"]

    return xml.etree.ElementTree.tostring(tree.getroot(), encoding='unicode')


def _generate_urdf_file(name: str, path: str, color: List[float], cach_dir: str) -> str:
    """
    Generates an URDf file with the given .obj or .stl file as mesh. In addition, the given color will be
    used to crate a material tag in the URDF. The resulting file will then be saved in the cach_dir path with the name
    as filename.

    :param name: The name of the object
    :param path: The path to the .obj or .stl file
    :param color: The color which should be used for the material tag
    :param cach_dir The absolute file path to the cach directory in the pycram package
    :return: The absolute path of the created file
    """
    urdf_template = '<?xml version="0.0" ?> \n \
                    <robot name="~a_object"> \n \
                     <link name="~a_main"> \n \
                        <visual> \n \
                            <geometry>\n \
                                <mesh filename="~b" scale="1 1 1"/> \n \
                            </geometry>\n \
                            <material name="white">\n \
                                <color rgba="~c"/>\n \
                            </material>\n \
                      </visual> \n \
                    <collision> \n \
                    <geometry>\n \
                        <mesh filename="~b" scale="1 1 1"/>\n \
                    </geometry>\n \
                    </collision>\n \
                    </link> \n \
                    </robot>'
    urdf_template = fix_missing_inertial(urdf_template)
    rgb = " ".join(list(map(str, color)))
    pathlib_obj = pathlib.Path(path)
    path = str(pathlib_obj.resolve())
    content = urdf_template.replace("~a", name).replace("~b", path).replace("~c", rgb)
    with open(cach_dir + pathlib_obj.stem + ".urdf", "w", encoding="utf-8") as file:
        file.write(content)
    return cach_dir + pathlib_obj.stem + ".urdf"


def _world_and_id(world: BulletWorld) -> Tuple[BulletWorld, int]:
    """
    Selects the world to be used. If the given world is None the 'current_bullet_world' is used.

    :param world: The world which should be used or None if 'current_bullet_world' should be used
    :return: The BulletWorld object and the id of this BulletWorld
    """
    world = world if world is not None else BulletWorld.current_bullet_world
    id = world.client_id if world is not None else BulletWorld.current_bullet_world.client_id
    return world, id


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/designator.py
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

from dataclasses import dataclass, field, fields
from abc import ABC, abstractmethod
from inspect import isgenerator, isgeneratorfunction

from sqlalchemy.orm.session import Session
import rospy

from .bullet_world import (Object as BulletWorldObject, BulletWorld)
from .enums import ObjectType
from .helper import GeneratorList, bcolors
from threading import Lock
from time import time
from typing import List, Dict, Any, Type, Optional, Union, get_type_hints, Callable, Tuple, Iterable

from .local_transformer import LocalTransformer
from .language import Language
from .pose import Pose
from .robot_descriptions import robot_description

import logging

from .orm.action_designator import (Action as ORMAction)
from .orm.object_designator import (Object as ORMObjectDesignator)

from .orm.base import Quaternion, Position, Base, RobotState, ProcessMetaData
from .task import with_tree


class DesignatorError(Exception):
    """Implementation of designator errors."""

    def __init__(self, *args, **kwargs):
        """Create a new designator error."""
        Exception.__init__(self, *args, **kwargs)


class ResolutionError(Exception):
    def __init__(self, missing_properties: List[str], wrong_type: Dict, current_type: Any, designator: Designator):
        self.error = f"\nSome requiered properties where missing or had the wrong type when grounding the Designator: {designator}.\n"
        self.missing = f"The missing properties where: {missing_properties}\n"
        self.wrong = f"The properties with the wrong type along with the currrent -and right type :\n"
        self.head = "Property   |   Current Type    |     Right Type\n-------------------------------------------------------------\n"
        self.tab = ""
        for prop in wrong_type.keys():
            self.tab += prop + "     " + str(current_type[prop]) + "      " + str(wrong_type[prop]) + "\n"
        self.message = self.error
        if missing_properties != []:
            self.message += self.missing
        if wrong_type != {}:
            self.message += self.wrong + self.head + self.tab
        self.message = f"{bcolors.BOLD}{bcolors.FAIL}" + self.message + f"{bcolors.ENDC}"
        super(ResolutionError, self).__init__(self.message)


class Designator(ABC):
    """
    Implementation of designators. DEPRECTAED SINCE DESIGNATOR DESCRIPTIONS ARE USED AS BASE CLASS

    Designators are objects containing sequences of key-value pairs. They can be resolved which means to generate real
    parameters for executing actions from these pairs of key and value.

    :ivar timestamp: The timestamp of creation of reference or None if still not referencing an object.
    """


    resolvers = {}
    """
    List of all designator resolvers. Designator resolvers are functions which take a designator as
    argument and return a list of solutions. A solution can also be a generator. 
    """

    def __init__(self, description: Type[DesignatorDescription], parent: Optional[Designator] = None):
        """Create a new desginator.

        Arguments:
        :param properties: A list of tuples (key-value pairs) describing this designator.
        :param parent: The parent to equate with (default is None).
        """
        self._mutex: Lock = Lock()
        self._parent: Union[Designator, None] = None
        self._successor: Union[Designator, None] = None
        self._effective: bool = False
        self._data: Any = None
        self._solutions = None
        self._index: int = 0
        self.timestamp = None
        self._description: Type[DesignatorDescription] = description

        if parent is not None:
            self.equate(parent)

    def equate(self, parent: Designator) -> None:
        """Equate the designator with the given parent.

        Arguments:
        parent -- the parent to equate with.
        """
        if self.equal(parent):
            return

        youngest_parent = parent.current()
        first_parent = parent.first()

        if self._parent is not None:
            first_parent._parent = self._parent
            first_parent._parent._successor = first_parent

        self._parent = youngest_parent
        youngest_parent._successor = self

    def equal(self, other: Designator) -> bool:
        """Check if the designator describes the same entity as another designator, i.e. if they are equated.

        Arguments:
        other -- the other designator.
        """
        return other.first() is self.first()

    def first(self) -> Designator:
        """Return the first ancestor in the chain of equated designators."""
        if self._parent is None:
            return self

        return self._parent.first()

    def current(self) -> Designator:
        """Return the newest designator, i.e. that one that has been equated last to the designator or one of its
        equated designators."""
        if self._successor is None:
            return self

        return self._successor.current()

    def _reference(self) -> Any:
        """This is a helper method for internal usage only.

        This method is to be overwritten instead of the reference method.
        """
        resolver = self.resolvers[self._description.resolver]
        if self._solutions is None:
            def generator():
                solution = resolver(self)
                if isgeneratorfunction(solution):
                    solution = solution()

                if isgenerator(solution):
                    while True:
                        try:
                            yield next(solution)
                        except StopIteration:
                            break
                else:
                    yield solution

            self._solutions = GeneratorList(generator)

        if self._data is not None:
            return self._data

        try:
            self._data = self._solutions.get(self._index)
            return self._data
        except StopIteration:
            raise DesignatorError('There was no Solution for this Designator')

    def reference(self) -> Any:
        """Try to dereference the designator and return its data object or raise DesignatorError if it is not an
        effective designator. """
        with self._mutex:
            ret = self._reference()

        self._effective = True

        if self.timestamp is None:
            self.timestamp = time()

        return ret

    @abstractmethod
    def next_solution(self):
        """Return another solution for the effective designator or None if none exists. The next solution is a newly
        constructed designator with identical properties that is equated to the designator since it describes the same
        entity. """
        pass

    def solutions(self, from_root: Optional[Designator] = None):
        """Return a generator for all solutions of the designator.

        Arguments:
        from_root -- if not None, the generator for all solutions beginning from with the original designator is returned (default is None).
        """
        if from_root is not None:
            desig = self.first()
        else:
            desig = self

        def generator(desig):
            while desig is not None:
                try:
                    yield desig.reference()
                except DesignatorError:
                    pass

                desig = desig.next_solution()

        return generator(desig)

    def copy(self, new_properties: Optional[List] = None) -> Designator:
        """Construct a new designator with the same properties as this one. If new properties are specified, these will
        be merged with the old ones while the new properties are dominant in this relation.

        Arguments:
        new_properties -- a list of new properties to merge into the old ones (default is None).
        """
        description = self._description.copy()

        if new_properties:
            for key, value in new_properties:
                description.__dict__[key] = value

        return self.__class__(description)

    def make_effective(self, properties: Optional[List] = None,
                       data: Optional[Any] = None,
                       timestamp: Optional[float] = None) -> Designator:
        """Create a new effective designator of the same type as this one. If no properties are specified, this ones are used.

        Arguments:
        new_properties -- a list of properties (default is None).
        data -- the low-level data structure the new designator describes (default is None).
        timestamp -- the timestamp of creation of reference (default is the current).
        """
        if properties is None:
            properties = self._description

        desig = self.__class__(properties)
        desig._effective = True
        desig._data = data

        if timestamp is None:
            desig.timestamp = time()
        else:
            desig.timestamp = timestamp

        return desig

    def newest_effective(self) -> Designator:
        """Return the newest effective designator."""

        def find_effective(desig):
            if desig is None or desig._effective:
                return desig

            return find_effective(desig._parent)

        return find_effective(self.current())

    def prop_value(self, key: str) -> Any:
        """Return the first value matching the specified property key.

        Arguments:
        key -- the key to return the value of.
        """
        try:
            return self._description.__dict__[key]
        except KeyError:
            logging.error(f"The given key '{key}' is not in this Designator")
            return None

    def check_constraints(self, properties: List) -> bool:
        """Return True if all the given properties match, False otherwise.

        Arguments:
        properties -- the properties which have to match. A property can be a tuple in which case its first value is the
        key of a property which must equal the second value. Otherwise it's simply the key of a property which must be
        not None.
        """
        for prop in properties:
            if type(prop) == tuple:
                key, value = prop

                if self.prop_value(key) != value:
                    return False
            else:
                if self.prop_value(prop) is None:
                    return False

        return True

    def make_dictionary(self, properties: List) -> Dict:
        """ DEPRECATED, Moved to the description. Function only keept because of
        backward compatability.
        Return the given properties as dictionary.

        Arguments:
        properties -- the properties to create a dictionary of. A property can be a tuple in which case its first value
        is the dictionary key and the second value is the dictionary value. Otherwise it's simply the dictionary key
        and the key of a property which is the dictionary value.
        """

        return self._description.make_dictionary(properties)

    def rename_prop(self, old: str, new: str) -> Designator:
        old_value = self.prop_value(old)
        if old_value is not None:
            self._description.__dict__[new] = old_value
            del self._description.__dict__[old]
        else:
            raise DesignatorError("Old property does not exists.")
        return self.current()


class DesignatorDescription(ABC):
    """
    :ivar resolve: The resolver function to use for this designator, defaults to self.ground
    """

    def __init__(self, resolver: Optional[Callable] = None):
        """
        Create a Designator description.

        :param resolver: The grounding method used for the description. The grounding method creates a location instance that matches the description.
        """

        if resolver is None:
            self.resolve = self.ground

    def make_dictionary(self, properties: List[str]):
        """
        Creates a dictionary of this description with only the given properties
        included.

        :param properties: A list of properties that should be included in the dictionary.
                            The given properties have to be an attribute of this description.
        :return: A dictionary with the properties as keys.
        """
        attributes = self.__dict__
        ret = {}
        for att in attributes.keys():
            if att in properties:
                ret[att] = attributes[att]
        return ret

    def ground(self) -> Any:
        """
        Should be overwritten with an actual grounding function which infers missing properties.
        """
        return self

    def get_slots(self) -> List[str]:
        """
        Returns a list of all slots of this description. Can be used for inspecting different descriptions and debugging.

        :return: A list of all slots.
        """
        return list(self.__dict__.keys())

    def copy(self) -> Type[DesignatorDescription]:
        return self


class ActionDesignatorDescription(DesignatorDescription, Language):
    """
    Abstract class for action designator descriptions.
    Descriptions hold possible parameter ranges for action designators.
    """

    @dataclass
    class Action:
        """
        The performable designator with a single element for each list of possible parameter.
        """
        robot_position: Pose = field(init=False)
        """
        The position of the robot at the start of the action.
        """
        robot_torso_height: float = field(init=False)
        """
        The torso height of the robot at the start of the action.
        """

        robot_type: str = field(init=False)
        """
        The type of the robot at the start of the action.
        """

        def __post_init__(self):
            self.robot_position = BulletWorld.robot.get_pose()
            self.robot_torso_height = BulletWorld.robot.get_joint_state(robot_description.torso_joint)
            self.robot_type = BulletWorld.robot.type

        @with_tree
        def perform(self) -> Any:
            """
            Executes the action with the single parameters from the description.
            """
            raise NotImplementedError()

        def to_sql(self) -> ORMAction:
            """
            Create an ORM object that corresponds to this description.

            :return: The created ORM object.
            """
            raise NotImplementedError(f"{type(self)} has no implementation of to_sql. Feel free to implement it.")

        def insert(self, session: Session, *args, **kwargs) -> ORMAction:
            """
            Add and commit this and all related objects to the session.
            Auto-Incrementing primary keys and foreign keys have to be filled by this method.

            :param session: Session with a database that is used to add and commit the objects
            :param args: Possible extra arguments
            :param kwargs: Possible extra keyword arguments
            :return: The completely instanced ORM object
            """

            pose = self.robot_position.insert(session)

            # get or create metadata
            metadata = ProcessMetaData().insert(session)

            # create robot-state object
            robot_state = RobotState(self.robot_torso_height, self.robot_type, pose.id)
            robot_state.process_metadata_id = metadata.id
            session.add(robot_state)
            session.commit()

            # create action
            action = self.to_sql()
            action.process_metadata_id = metadata.id
            action.robot_state_id = robot_state.id

            return action

    def __init__(self, resolver=None):
        super().__init__(resolver)
        Language.__init__(self)

    def ground(self) -> Action:
        """Fill all missing parameters and chose plan to execute. """
        raise NotImplementedError(f"{type(self)}.ground() is not implemented.")

    def __iter__(self):
        """
        Iterate through all possible actions fitting this description

        :yield: A resolved action designator
        """
        yield self.ground()


class LocationDesignatorDescription(DesignatorDescription):
    """
    Parent class of location designator descriptions.
    """

    @dataclass
    class Location:
        """
        Resolved location that represents a specific point in the world which satisfies the constraints of the location
        designator description.
        """
        pose: Pose
        """
        The resolved pose of the location designator. Pose is inherited by all location designator.
        """

    def __init__(self, resolver=None):
        super().__init__(resolver)

    def ground(self) -> Location:
        """
        Find a location that satisfies all constrains.
        """
        raise NotImplementedError(f"{type(self)}.ground() is not implemented.")


#this knowledge should be somewhere else i guess
SPECIAL_KNOWLEDGE = {
    'bigknife':
        [("top", [-0.08, 0, 0])],
    'whisk':
        [("top", [-0.08, 0, 0])],
    'bowl':
        [("front", [1.0, 2.0, 3.0]),
         ("key2", [4.0, 5.0, 6.0])]
}


class ObjectDesignatorDescription(DesignatorDescription):
    """
    Class for object designator descriptions.
    Descriptions hold possible parameter ranges for object designators.
    """

    @dataclass
    class Object:
        """
        A single element that fits the description.
        """

        name: str
        """
        Name of the object
        """

        type: str
        """
        Type of the object
        """

        bullet_world_object: Optional[BulletWorldObject]
        """
        Reference to the BulletWorld object
        """

        _pose: Optional[Callable] = field(init=False)
        """
        A callable returning the pose of this object. The _pose member is used overwritten for data copies
        which will not update when the original bullet_world_object is moved.
        """

        def __post_init__(self):
            if self.bullet_world_object:
                self._pose = self.bullet_world_object.get_pose

        def to_sql(self) -> ORMObjectDesignator:
            """
            Create an ORM object that corresponds to this description.

            :return: The created ORM object.
            """
            return ORMObjectDesignator(self.type, self.name)

        def insert(self, session: Session) -> ORMObjectDesignator:
            """
            Add and commit this and all related objects to the session.
            Auto-Incrementing primary keys and foreign keys have to be filled by this method.

            :param session: Session with a database that is used to add and commit the objects
            :return: The completely instanced ORM object
            """
            metadata = ProcessMetaData().insert(session)

            # create object orm designator
            obj = self.to_sql()
            obj.process_metadata_id = metadata.id

            pose = self.pose.insert(session)
            obj.pose_id = pose.id

            session.add(obj)
            session.commit()
            return obj

        def frozen_copy(self) -> 'ObjectDesignatorDescription.Object':
            """
            :return: A copy containing only the fields of this class. The BulletWorldObject attached to this pycram
            object is not copied. The _pose gets set to a method that statically returns the pose of the object when
            this method was called.
            """
            result = ObjectDesignatorDescription.Object(self.name, self.type, None)
            # get current object pose and set resulting pose to always be that
            pose = self.pose
            result.pose = lambda: pose
            return result

        @property
        def pose(self):
            """
            Property of the current position and orientation of the object.
            Evaluate the _pose function.

            :return: Position and orientation
            """
            return self._pose()

        @pose.setter
        def pose(self, value: Callable):
            """
            Set the pose to a new method that returns the current pose.

            :param value: A callable that returns a pose.
            """
            self._pose = value

        def __repr__(self):
            return self.__class__.__qualname__ + f"(" + ', '.join(
                [f"{f.name}={self.__getattribute__(f.name)}" for f in fields(self)] + [
                    f"pose={self.pose}"]) + ')'

        def special_knowledge_adjustment_pose(self, grasp: str, pose: Pose) -> Pose:
            """
            Returns the adjusted target pose based on special knowledge for "grasp front".

            :param grasp: From which side the object should be grasped
            :param pose: Pose at which the object should be grasped, before adjustment
            :return: The adjusted grasp pose
            """
            lt = LocalTransformer()
            pose_in_object = lt.transform_to_object_frame(pose, self.bullet_world_object)

            special_knowledge = []  # Initialize as an empty list
            if self.type in SPECIAL_KNOWLEDGE:
                special_knowledge = SPECIAL_KNOWLEDGE[self.type]

            for key, value in special_knowledge:
                if key == grasp:
                    # Adjust target pose based on special knowledge
                    pose_in_object.pose.position.x += value[0]
                    pose_in_object.pose.position.y += value[1]
                    pose_in_object.pose.position.z += value[2]
                    rospy.loginfo("Adjusted target pose based on special knowledge for grasp: ", grasp)
                    return pose_in_object
            return pose

        # def special_knowledge(self, grasp, pose):
        #     """
        #     Returns t special knowledge for "grasp front".
        #     """
        #
        #     special_knowledge = []  # Initialize as an empty list
        #     if self.type in SPECIAL_KNOWLEDGE:
        #         special_knowledge = SPECIAL_KNOWLEDGE[self.type]
        #
        #     for key, value in special_knowledge:
        #         if key == grasp:
        #             # Adjust target pose based on special knowledge
        #             pose.pose.position.x += value[0]
        #             pose.pose.position.y += value[1]
        #             pose.pose.position.z += value[2]
        #             print("Adjusted target pose based on special knowledge for grasp: ", grasp)
        #             return pose
        #     return pose

    def __init__(self, names: Optional[List[str]] = None, types: Optional[List[str]] = None,
                 resolver: Optional[Callable] = None):
        """
        Base of all object designator descriptions. Every object designator has the name and type of the object.

        :param names: A list of names that could describe the object
        :param types: A list of types that could represent the object
        :param resolver: An alternative resolver that returns an object designator for the list of names and types
        """
        super().__init__(resolver)
        self.types: Optional[List[str]] = types
        self.names: Optional[List[str]] = names

    def ground(self) -> Union[Object, bool]:
        """
        Return the first object from the bullet world that fits the description.

        :return: A resolved object designator
        """
        return next(iter(self))

    def __iter__(self) -> Iterable[Object]:
        """
        Iterate through all possible objects fitting this description

        :yield: A resolved object designator
        """
        # for every bullet world object
        for obj in BulletWorld.current_bullet_world.objects:

            # skip if name does not match specification
            if self.names and obj.name not in self.names:
                continue

            # skip if type does not match specification
            if self.types and obj.type not in self.types:
                continue

            yield self.Object(obj.name, obj.type, obj)

##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/utils.py
"""Module for utility functions. This module must not import any pycram module (due to potential circular imports)."""

import os


class suppress_stdout_stderr(object):
    """
    A context manager for doing a "deep suppression" of stdout and stderr in
    Python, i.e. will suppress all prints, even if the print originates in a
    compiled C/Fortran sub-function.

    This will not suppress raised exceptions, since exceptions are printed
    to stderr just before a script exits, and after the context manager has
    exited (at least, I think that is why it lets exceptions through).
    Copied from https://stackoverflow.com/questions/11130156/suppress-stdout-stderr-print-from-python-functions
    """

    def __init__(self):
        # Open a pair of null files
        self.null_fds = [os.open(os.devnull, os.O_RDWR) for x in range(2)]
        # Save the actual stdout (1) and stderr (2) file descriptors.
        self.save_fds = [os.dup(1), os.dup(2)]

    def __enter__(self):
        # Assign the null pointers to stdout and stderr.
        os.dup2(self.null_fds[0], 1)
        os.dup2(self.null_fds[1], 2)

    def __exit__(self, *_):
        # Re-assign the real stdout/stderr back to (1) and (2)
        os.dup2(self.save_fds[0], 1)
        os.dup2(self.save_fds[1], 2)
        # Close all file descriptors
        for fd in self.null_fds + self.save_fds:
            os.close(fd)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/robot_description.py
import logging
import rospy
import rospkg
from copy import deepcopy
from numbers import Number
from typing import List, Optional, Dict, Union, Type
from urdf_parser_py.urdf import URDF
from . import utils


logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


class ChainDescription:
    """
    This class saves a kinematic chain by saving the links and the joints.
    Moreover, this class offers to set a base_link and specify static joint states
    (e. g. the "park" state of the right arm).

        chain of links: link1 <-> joint1 <-> link2 <-> joint2 <-> ... <-> link6
    """

    def __init__(self, name: str,
                 joints: List[str],
                 links: List[str],
                 base_link: Optional[str] = None,
                 static_joint_states: Optional[Dict[str, List[float]]] = None):
        """
        :param name: str
        :param joints: list[str]
        :param links: list[str]
        :param static_joint_states: dict[str: list[float]]
        """
        self.name: str = name
        self.base_link: str = base_link
        self.joints: List[str] = joints
        self.links: List[str] = links
        self.static_joint_states: Dict[str: List[float]] = static_joint_states if static_joint_states else {}

    def add_static_joint_chains(self, static_joint_states: Dict[str, List[float]]) -> None:
        """
        This function adds static joints chains, which are given in a dictionary.

        :type static_joint_states: dict[str: list[float]]
        :param static_joint_states: Static joint chains, where keys hold the configuration name
                                    and values hold a list of floats/joint configurations.
        """
        for configuration, joint_states in static_joint_states.items():
            if not self.add_static_joint_chain(configuration, joint_states):
                logger.error("(robot_description) Could not add all static_joint_states for the chain %s.", self.name)
                break

    def add_static_joint_chain(self, configuration: str, static_joint_states: List[float]) -> Union[None, bool]:
        """
        This function adds one static joints chain with the given configuration name.

        :param configuration: Configuration name of the static joint configuration
        :type configuration: str
        :param static_joint_states: List of floats/joint configurations
        :type static_joint_states: list[float]
        """
        if all(map(lambda n: isinstance(n, Number), static_joint_states)):
            if len(static_joint_states) == len(self.joints):
                configurations = list(self.static_joint_states.keys())
                if configuration not in configurations:
                    self.static_joint_states = self.static_joint_states
                    self.static_joint_states[configuration] = static_joint_states
                    return True
                else:
                    logger.warning("(robot_description) The chain %s already has static joint values "
                            "for the config %s.", self.name, configuration)
            else:
                logger.error("(robot_description) The number of the joint values does not equal the amount of the joints"
                       "for the chain %s.", self.name)

    def get_static_joint_chain(self, configuration: str) -> Union[None, Dict[str, float]]:
        """
        Gets a static joint chain as dictionary of its joint names and values.

        :param configuration: Name of the configuration
        :type configuration: str
        :return: dict[str: float]
        """
        try:
            joint_values = self.static_joint_states[configuration]
        except KeyError:
            logger.error("(robot_description) Configuration %s is unknown for the chain %s.", configuration, self.name)
            return None
        return dict(zip(self.joints, joint_values))


class GripperDescription(ChainDescription):
    """
    This class represents a gripper of a robot. It allows to specify more parameters
    for the robots gripper and set static gripper configurations (since it inherits
    from ChainDescription).
    """

    def __init__(self, name: str,
                 gripper_links: Optional[List[str]] = None,
                 gripper_joints: Optional[List[str]] = None,
                 static_gripper_joint_states: Optional[Dict[str, List[float]]] = None,
                 gripper_meter_to_jnt_multiplier: Optional[float] = 1.0,
                 gripper_minimal_position: Optional[float] = 0.0,
                 gripper_convergence_delta: Optional[float] = 0.001):
        """
        :type gripper_links: list[str]
        :type gripper_joints: list[str]
        :type static_gripper_joint_states: dict[str: list[float]]
        """
        super().__init__(name, gripper_joints, gripper_links, base_link=None,
                         static_joint_states=static_gripper_joint_states)
        # static params
        self.gripper_meter_to_jnt_multiplier: float = gripper_meter_to_jnt_multiplier
        self.gripper_minimal_position: float = gripper_minimal_position
        self.gripper_convergence_delta: float = gripper_convergence_delta


class InteractionDescription(ChainDescription):
    """
    This class allows to put on the end of an chain another link, which is saved
    as an end effector. Therefore, chains can be defined which specify the interaction
    frame for the robot. An example could be a storage place for grasped objects on the robot.

        chain of links: chain_description <-> eef_link
    """

    def __init__(self, chain_description: ChainDescription, eef_link: str):
        tmp = deepcopy(chain_description)
        super().__init__(tmp.name, tmp.joints, tmp.links, base_link=tmp.base_link,
                         static_joint_states=tmp.static_joint_states)
        self.chain_description: ChainDescription = tmp
        self.eef_link: str = eef_link


class ManipulatorDescription(InteractionDescription):
    """
    This class allows with the given interaction description to include a gripper
    description which is placed between the last link of the interaction description
    and the rest of it.
    Independently from that a tool frame can be saved, which allows to use objects
    to manipulate the environment::

                                                                           |--> (tool_frame)
        chain of links: interaction_description <-> (gripper_description) -|
                                                                           |--> eef_link
    """

    def __init__(self, interaction_description: InteractionDescription,
                 tool_frame: str = None,
                 gripper_description: GripperDescription = None):
        tmp = deepcopy(interaction_description)
        super().__init__(tmp.chain_description, tmp.eef_link)
        self.interaction_description: InteractionDescription = tmp
        self.tool_frame: str = tool_frame
        self.gripper: GripperDescription = gripper_description


class CameraDescription:
    """
    This class represents a camera by saving the camera link from the URDF and other
    parameters specifically for that camera.
    """

    def __init__(self, frame: str,
                 minimal_height=0.0, maximal_height=0.0,
                 vertical_angle=0.0, horizontal_angle=0.0,
                 other_params: Optional[Dict[str, float]] = None):
        """
        :type other_params: dict[str: float]
        """
        self.frame: str = frame
        self.min_height: float = minimal_height
        self.max_height: float = maximal_height
        self.vertical_angle: float = vertical_angle
        self.horizontal_angle:float = horizontal_angle
        # static, but flexible params
        self.params: Dict[str, float] = other_params if other_params else {}


class GraspingDescription:
    """
    This class represents all possible grasp a robot can perform and the grasps
    the robot can perform for a specific object.
    """
    def __init__(self, grasp_dir: Optional[Dict] = None):
        self.grasps: Dict[str, List[float]] = grasp_dir if grasp_dir else {}
        self.grasps_for_object: Dict['bullet_world.Object', List[str]] = {}

    def add_grasp(self, grasp: str, orientation: List[float]) -> None:
        """
        Adds a Grasping side like "top", "left", "front" and the corresponding orientation
        of the gripper to this description.

        :param grasp: The type of grasp like "top" or "left"
        :param orientation: The orientation the Gripper has to have in order to achive this grasp. In world coordinate frame
        """
        self.grasps[grasp] = orientation

    def add_graspings_for_object(self, grasps: List[str], object: 'bullet_world.Object') -> None:
        """
        Adds all possible Grasps for the specified object. The used grasps have to
        be registered beforehand via the add_grasp method.

        :param grasps: A list of all graps for this object.
        :param object: The object for which the grasps should be specified
        """
        self.grasps_for_object[object] = grasps

    def get_all_grasps(self) -> List[str]:
        return list(self.grasps.keys())

    def get_orientation_for_grasp(self, grasp: str) -> List[float]:
        return self.grasps[grasp]

    def get_grasps_for_object(self, object: 'bullet_world.Object') -> List[str]:
        return self.grasps_for_object[object]


class RobotDescription:
    """
    The RobotDescription as an abstract class which needs to be inherited from to implement
    a robot description for specific object. It implements different functions to add and get
    chains of different objects types which inherit of the class ChainDescription. Moreover,
    it allows to model the robot with its odom_frame, base_frame, base_link and torso links
    and joints. Different cameras can be added and static transforms and poses can be added too.
    """

    def __init__(self, name: str,
                 base_frame: str,
                 base_link: str,
                 torso_link: Optional[str] = None,
                 torso_joint: Optional[str] = None,
                 odom_frame: Optional[str] = None,
                 odom_joints: Optional[List[str]] = None):
        """
        Initialises the robot description with the given frames.

        :type name: str
        :type odom_frame: str
        :type odom_frame: [str]
        :type base_frame: str
        :type base_link: str
        :type torso_link: str
        :type torso_joint: str
        """
        self.name: str = name
        self.chains: Dict[str, Type[ChainDescription]] = {}  # dict{str: ChainDescription}
        self.cameras: Dict[str, CameraDescription] = {}  # dict{str: CameraDescription}
        self.static_transforms: List = []  # list[tf]
        self.static_poses: List = []  # list[pose]
        self.odom_frame: str = odom_frame
        self.odom_joints: List[str] = odom_joints if odom_joints else []  # list[str]
        self.base_frame: str = base_frame
        self.base_link: str = base_link
        self.torso_link: str = torso_link
        self.torso_joint: str = torso_joint

        rospack = rospkg.RosPack()
        filename = rospack.get_path('pycram') + '/resources/' + name + '.urdf'
        with open(filename) as f:
            with utils.suppress_stdout_stderr():
                self.robot_urdf = URDF.from_xml_string(f.read())

    def _safely_access_chains(self, chain_name: str, verbose: Optional[bool] = True) -> Union[None, ChainDescription]:
        """
        This function returns the chain_description of the name chain_name or None, if there
        exists no chain description with the name chain_name.
        """
        try:
            chain_description = self.chains[chain_name]
        except KeyError:
            if verbose:
                logger.warning("(robot_description) Chain name %s is unknown.", chain_name)
            return None
        return chain_description

    def _get_chain_description(self, chain_name: str,
                               description_type: Optional[Type[ChainDescription]] = ChainDescription,
                               is_same_description_type: Optional[bool] = True) -> Union[None, Type[ChainDescription]]:
        """
        This function checks if there is a chain saved in self.chains with the chain name chain_name.
        Moreover, if is_same_description_type is True it will be checked if the found chain is of the given
        object class description_type. If is_same_description_type is False, it will be just checked if
        the found chain is a subclass of description_type.

        :return: subclass of ChainDescription or None
        """
        if issubclass(description_type, ChainDescription):
            chain_description = self._safely_access_chains(chain_name)
            if not is_same_description_type:
                return chain_description
            else:
                if type(chain_description) is description_type:
                    return chain_description
                else:
                    logger.error("(robot_description) The chain %s is not of type %s, but of type %s.",
                           chain_name, description_type, type(chain_description))
        else:
            logger.warning("(robot_description) Only subclasses of ChainDescription are allowed.")

    def get_tool_frame(self, manipulator_name: str) -> Union[None, str]:
        """
        Returns the tool frame of the manipulator description with the name manipulator name.

        :return: str
        """
        manipulator_description = self._get_chain_description(manipulator_name, description_type=ManipulatorDescription)
        if manipulator_description:
            return manipulator_description.tool_frame
        else:
            logger.error("(robot_description) Could not get the tool frame of the manipulator %s.", manipulator_name)

    def get_static_joint_chain(self, chain_name: str, configuration: str) -> Union[None, Dict[str, float]]:
        """
        Returns the static joint chain given the chains name chain_name and the configurations name configuration.

        :return: dict[str: float]
        """
        chain_description = self._get_chain_description(chain_name, is_same_description_type=False)
        if chain_description:
            return chain_description.get_static_joint_chain(configuration)
        else:
            logger.error("(robot_description) Could not get static joint chain called %s of the chain %s.",
                   configuration, chain_name)

    def get_static_tf(self, base_link: str, target_link: str):
        pass

    def get_static_pose(self, frame: str):
        pass

    def add_chain(self, name: str, chain_description: ChainDescription) -> Union[None, bool]:
        """
        This functions adds the chain description chain_description with the name name and
        overwrites the existing chain description of name name, if it already exists in self.chains.
        """
        if issubclass(type(chain_description), ChainDescription):
            if self._safely_access_chains(name, verbose=False):
                logger.warning("(robot_description) Replacing the chain description of the name %s.", name)
            self.chains[name] = chain_description
            return True
        else:
            logger.error("(robot_description) Given chain_description object is no subclass of ChainDescription.")

    def add_chains(self, chains_dict: Dict[str, ChainDescription]) -> None:
        """
        This function calls recursively the self.add_chain function and adds therefore the chain description
        saved in the values part of the dictionary chains_dict with the names saved in the key part of the
        dictionary chains_dict.

        :type chains_dict: dict[str: ChainDescription]
        """
        for name, chain in chains_dict.items():
            if not self.add_chain(name, chain):
                logger.error("(robot_description) Could not add the chain object of name %s.", name)
                break

    def add_camera(self, name: str, camera_description: CameraDescription) -> Union[None, bool]:
        """
        This functions adds the camera description camera_description with the name name and
        overwrites the existing camera description of name name, if it already exists in self.cameras.
        """
        if type(camera_description) is CameraDescription:
            found = True
            try:
                self.cameras[name]
            except KeyError:
                found = False
            if found:
                logger.warning("(robot_description) Replacing the camera description of the name %s.", name)
            self.cameras[name] = camera_description
            return True
        else:
            logger.error("(robot_description) Given camera_description object is not of type CameraDescription.")

    def add_cameras(self, cameras_dict: Dict[str, CameraDescription]) -> None:
        """
        This function calls recursively the self.add_camera function and adds therefore the camera description
        saved in the values part of the dictionary cameras_dict with the names saved in the key part of the
        dictionary cameras_dict.

        :type cameras_dict: dict[str: CamerasDescription]
        """
        for name, camera in cameras_dict.items():
            if not self.add_camera(name, camera):
                logger.error("(robot_description) Could not add the camera object of name %s.", name)
                break

    def get_camera_frame(self, camera_name: str) -> Union[None, str]:
        """
        Returns the camera frame of the given camera with the name camera_name.

        :return: str
        """
        try:
            camera_description = self.cameras[camera_name]
        except KeyError:
            logger.error("(robot_description) Camera name %s is unknown.", camera_name)
            return None
        return camera_description.frame

    def add_static_joint_chain(self,
                               chain_name: str,
                               configuration: str,
                               static_joint_states: List[float]) -> Union[None, bool]:
        """
        This function calls the add_static_joint_chain function on the chain object with the name chain_name.
        For more information see the add_static_joint_chain in ChainDescription.

        :param chain_name: The name of the new static joint chain
        :param configuration: The name of the configuration of this joint chain
        :type static_joint_states: list[float]
        """
        return self.chains[chain_name].add_static_joint_chain(configuration, static_joint_states)

    def add_static_joint_chains(self, chain_name: str, static_joint_states: Dict[str, List[float]]) -> None:
        """
        This function calls recursively the self.add_static_joint_chain function with the name chain_name
        and adds therefore the static joint values saved in the values part of the dictionary static_joint_states
        with the configuration names saved in the key part of the dictionary static_joint_states.

        :param chain_name: The name for the new chain
        :type static_joint_states: dict[str: list[float]]
        """
        for configuration, joint_states in static_joint_states.items():
            if not self.add_static_joint_chain(chain_name, configuration, joint_states):
                logger.error("(robot_description) Could not add the static joint chain called %s for chain %s.",
                       configuration, chain_name)
                break

    def add_static_gripper_chain(self,
                                 manipulator_name: str,
                                 configuration: str,
                                 static_joint_states: Dict[str, List[float]]) -> Union[None, bool]:
        """
        This function adds a static gripper chain to a gripper description if there exists a manipulator description
        with the name manipulator_name. The static gripper joint vales in static_joint_states are then saved
        with the configuration name configuration in the manipulator description object.
        For more information see the add_static_joint_chain in ChainDescription.

        :type static_joint_states: dict[str: list[float]]
        """
        manipulator_description = self._get_chain_description(manipulator_name, ManipulatorDescription)
        if manipulator_description and manipulator_description.gripper:
            return manipulator_description.gripper.add_static_joint_chain(configuration, static_joint_states)

    def add_static_gripper_chains(self, manipulator_name: str, static_joint_states: Dict[str, List[float]]) -> None:
        """
        This function calls recursively the self.add_static_gripper_chain function with the name manipulator_name
        and adds therefore the static joint values saved in the values part of the dictionary static_joint_states
        with the configuration names saved in the key part of the dictionary static_joint_states.

        :type static_joint_states: dict[str: list[float]]
        """
        for configuration, joint_states in static_joint_states.items():
            if not self.add_static_gripper_chain(manipulator_name, configuration, joint_states):
                logger.error("(robot_description) Could not add static gripper chain called %s for manipulator chain %s.",
                       configuration, manipulator_name)
                break

    def get_static_gripper_chain(self, manipulator_name: str, configuration: str) -> Dict[str, float]:
        """
        Returns the static gripper joint chain given the manipulator name manipulator_name and the configuration name configuration.

        For more information see the function get_static_joint_chain in ChainDescription.

        :return: dict[str: list[float]] or None
        """
        manipulator_description = self._get_chain_description(manipulator_name, ManipulatorDescription)
        if manipulator_description and manipulator_description.gripper:
            return manipulator_description.gripper.get_static_joint_chain(configuration)

    def get_child(self, name):
        """
        Returns the child of a Joint or Link in the URDF. If 'name' is a Joint a
        Link will be returned and vice versa.

        :param name: The name of the Joint/Link for which the child will be returned.
        :return: The child Joint/Link
        """
        if name in self.robot_urdf.joint_map.keys():
            return self.robot_urdf.joint_map[name].child
        elif name in self.robot_urdf.link_map.keys():
            return self.robot_urdf.link_map[name].child
        else:
            rospy.logerr(f"The name: {name} is not part of this robot URDF")

    def get_parent(self, name):
        """
        Returns the parent of a Joint or Link in the URDF. If 'name' is a Joint a
        Link will be returned and vice versa.

        :param name: The name of the Joint/Link for which the parent will be returned.
        :return: The parent Joint/Link
        """
        if name in self.robot_urdf.joint_map.keys():
            return self.robot_urdf.joint_map[name].parent
        elif name in self.robot_urdf.link_map.keys():
            return self.robot_urdf.link_map[name].parent
        else:
            rospy.logerr(f"The name: {name} is not part of this robot URDF")

    # @staticmethod
    # def from_urdf(urdf_path: str):
    #     # URDF Python library does not like ROS package paths --> replace
    #     with tempfile.NamedTemporaryFile(suffix=".urdf") as temp_urdf_file:
    #         with open(urdf_path) as urdf_file:
    #             urdf_resolved = replace_package_urls(urdf_file.read())
    #         temp_urdf_file.write(urdf_resolved)
    #         urdf = URDF.load(temp_urdf_file)
    #     ik_joints = [joint.name for joint in urdf.actuated_joints]


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/fluent.py
"""Implementation of fluents and the whenever macro.

Macros:
whenever -- macro to repeat a body as long as the value of a fluent is not None or whenever a pulsed fluent changes its value or gets pulsed.

Classes:
Behavior -- enumeration to describe how to handle missed pulses in the whenever macro.
Fluent -- implementation of fluents.
"""

# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import operator

from enum import Enum
from threading import Condition, Lock
from uuid import uuid4
from typing import Any, Optional, List, Callable


class Behavior(Enum):
    """Enumeration which can be passed as argument to the pulsed method of fluents to describe how to handle missed pulses in the whenever macro.

    Fields:
    NEVER -- ignore missed pulses.
    ONCE -- if pulses were missed, execute the body once more in total.
    ALWAYS -- if pulses were missed, execute the body once more for each.
    """
    NEVER = 1
    ONCE = 2
    ALWAYS = 3


class Fluent:
    """Implementation of fluents.

    Fluents are thread-safe proxy objects which are used as variables with changing value. This allows threads to
    observe them and wait for (specific) changes.
    One can also observe fluents created by the pulsed method of a fluent. These change their value from None to True
    whenever the parent gets pulsed (or changes its value and thus gets pulsed).

    Fluents can be combined to fluent networks which allows to express complex conditions. A network updates its value
    whenever one of the fluents it is constructed from changes its value.
    The most important comparison and math operators (<, <=, ==, !=, >, >=, +, -, *, /) are overloaded to construct a
    fluent network whenever they are called with at least one fluent as parameter. In addition the comparison operators
    IS and IS_NOT as well as the logical operators AND, OR and NOT are defined as methods. This is necessary because
    these operators can't be overloaded. Fluents constructed by comparison or logical operators have the value True or
    None instead of False, so that they can be used with the wait_for method because it blocks until a value is not None.
    User defined operators can be created by passing a function as the fluents value.
    """

    def __init__(self, value: Optional[Any] = None, name: str = None):
        """Create a new fluent.

        :param value:  the value of the fluent which can also be a function to create user defined operators (default is None).
        :param name: the name of the fluent (default is a random string).
        """
        self._cv: Condition = Condition()
        self._mutex: Lock = Lock()
        self._pulses: int = 0
        self._children: List[Fluent] = []
        self._handle_missed = Behavior.NEVER
        self._value: Any = value
        self._whenever_cbs = []

        if name is not None:
            self.name: str = name
        else:
            self.name: str = str(uuid4())

    def pulsed(self, handle_missed: Behavior = 2) -> Fluent:
        """Create a fluent which changes its value from None to True whenever the parent gets pulsed.

        :param handle_missed: see the docstring of the Behavior enumeration to find out more (default is Behavior.ONCE).
        """
        fluent = Fluent()

        def value():
            if fluent._pulses != 0:
                return True
            else:
                return None

        fluent.set_value(value)
        fluent._handle_missed = handle_missed
        self.add_child(fluent)
        return fluent

    def pulse(self) -> None:
        """Pulse a fluent without changing its value."""
        for child in self._children:
            with child._mutex:
                child._pulses += 1

            child.pulse()
        for callback in self._whenever_cbs:
            callback(self.get_value())
            with self._mutex:
                self._pulses -= 1
            if self._handle_missed == Behavior.NEVER:
                with self._mutex:
                    self._pulses = 0
            elif self._handle_missed == Behavior.ONCE:
                callback(self.get_value())
                with self._mutex:
                    self._pulses = 0
            elif self._handle_missed == Behavior.ALWAYS:
                with self._mutex:
                    for i in range(self._pulses):
                        callback(self.get_value())
        with self._cv:
            self._cv.notify()

    def whenever(self, callback: Callable) -> None:
        """
        Registers a callback which is called everytime this Fluent is pulsed. The callback should be a Callable. When
        the callback is called it gets the current value of this Fluent as an argument. `1

        :param callback: The callback which should be called when pulsed as a Callable.
        """
        self._whenever_cbs.append(callback)

    def add_child(self, child: Fluent) -> None:
        """Add a child to the fluent which gets pulsed whenever this fluent gets pulsed, too.

        :param child: the child to add.
        """
        self._children.append(child)

    def get_value(self) -> Any:
        """Return the value of the fluent."""
        with self._mutex:
            if callable(self._value):
                return self._value()

            return self._value

    def set_value(self, value: Any) -> None:
        """Change the value of the fluent.

        Changing the value will also pulse the fluent.

        :param value: the new value of the fluent.
        """
        with self._mutex:
            self._value = value

        self.pulse()

    def wait_for(self, timeout: Optional[float] = None):
        """Block the current thread if the value of the fluent is None, until it is not None or until it timed out.

        If the fluent was created by the pulsed method of a fluent, the method blocks until the parent gets pulsed.

        The return value is the last return value of the predicate (value is not None) and will evaluate to False if the method timed out.

        :param timeout: the maximum time to wait (default is None).
        """
        with self._cv:
            return self._cv.wait_for(lambda: self.get_value() is not None, timeout)

    def _compare(self, operator, other: Fluent) -> Fluent:
        """This is a helper method for internal usage only.

        Create a fluent which value is a function returning True or None depending on the given comparison operator applied to the operands.

        :param operator: the comparison operator to apply.
        :param other: the other operand.
        """
        fluent = Fluent()

        if type(other) == Fluent:
            def value():
                if operator(self.get_value(), other.get_value()):
                    return True
                else:
                    return None

            other.add_child(fluent)
        else:
            def value():
                if operator(self.get_value(), other):
                    return True
                else:
                    return None

        self.add_child(fluent)
        fluent.set_value(value)
        return fluent

    def __lt__(self, other: Fluent) -> Fluent:
        """Overload the < comparsion operator.

        :param other: -- the other operand.
        """
        return self._compare(operator.lt, other)

    def __leq__(self, other: Fluent) -> Fluent:
        """Overload the <= comparsion operator.

        :param other: the other operand.
        """
        return self._compare(operator.leq, other)

    def __eq__(self, other: Fluent) -> Fluent:
        """Overload the == comparsion operator.

        :param other: the other operand.
        """
        return self._compare(operator.eq, other)

    def __ne__(self, other: Fluent) -> Fluent:
        """Overload the != comparsion operator.

        :param other: the other operand.
        """
        return self._compare(operator.ne, other)

    def IS(self, other: Fluent) -> Fluent:
        """Create a fluent which value is True if the value of its parent is the value of the given operand, None otherwise.

        :param other: -- the other operand which can also be a fluent.
        """
        return self._compare(operator.is_, other)

    def IS_NOT(self, other: Fluent) -> Fluent:
        """Create a fluent which value is True if the value of its parent is not the value of the given operand, None otherwise.

        :param other: -- the other operand which can also be a fluent.
        """
        return self._compare(operator.is_not, other)

    def __gt__(self, other: Fluent) -> Fluent:
        """Overload the > comparison operator.

        :param other: the other operand.
        """
        return self._compare(operator.gt, other)

    def __geq__(self, other: Fluent) -> Fluent:
        """Overload the >= comparison operator.

        :param other: the other operand.
        """
        return self._compare(operator.geq, other)

    def _math(self, operator: Callable, operand: Fluent, other: Fluent) -> Fluent:
        """This is a helper method for internal usage only.

        Create a fluent which value is a function returning the value of the given math operator applied to the operands.

        :param operator: the math operator to apply.
        :param operand: the first operand.
        :param other: the other operand.
        """
        fluent = Fluent()

        if type(operand) == Fluent:
            if type(other) == Fluent:
                value = lambda: operator(operand.get_value(), other.get_value())
                other.add_child(fluent)
            else:
                value = lambda: operator(operand.get_value(), other)

            operand.add_child(fluent)
        else:
            value = lambda: operator(operand, other.get_value())
            other.add_child(fluent)

        fluent.set_value(value)
        return fluent

    def __add__(self, other: Fluent) -> Fluent:
        """Overload the + math operator.

        :parm other: the other operand.
        """
        return self._math(operator.add, self, other)

    def __radd__(self, other: Fluent) -> Fluent:
        """Overload the + math operator with the first operand not being a fluent.

        :param other: the other operand.
        """
        return self._math(operator.add, other, self)

    def __sub__(self, other: Fluent) -> Fluent:
        """Overload the - math operator.

        :param other: the other operand.
        """
        return self._math(operator.sub, self, other)

    def __rsub__(self, other: Fluent) -> Fluent:
        """Overload the - math operator with the first operand not being a fluent.

        :param other: the other operand.
        """
        return self._math(operator.sub, other, self)

    def __mul__(self, other: Fluent) -> Fluent:
        """Overload the * math operator.

        :param other: the other operand.
        """
        return self._math(operator.mul, self, other)

    def __rmul__(self, other: Fluent) -> Fluent:
        """Overload the * math operator with the first operand not being a fluent.

        :param other: the other operand.
        """
        return self._math(operator.mul, other, self)

    def __truediv__(self, other: Fluent) -> Fluent:
        """Overload the / math operator.

        :param other: the other operand.
        """
        return self._math(operator.truediv, self, other)

    def __rtruediv__(self, other) -> Fluent:
        """Overload the / math operator with the first operand not being a fluent.

        :param other: the other operand.
        """
        return self._math(operator.truediv, other, self)

    def AND(self, other: Fluent) -> Fluent:
        """Create a fluent which value is True if both, the value of its parent and the other operand express True, None otherwise.

        :param other: the other operand which can also be a fluent.
        """
        fluent = Fluent()

        if type(other) == Fluent:
            def value():
                if self.get_value() and other.get_value():
                    return True
                else:
                    return None

            other.add_child(fluent)
        else:
            def value():
                if self.get_value() and other:
                    return True
                else:
                    return None

        self.add_child(fluent)
        fluent.set_value(value)
        return fluent

    def OR(self, other: Fluent) -> Fluent:
        """Create a fluent which value is True if either the value of its parent or the other operand express True, None otherwise.

        :param other: the other operand which can also be a fluent.
        """
        fluent = Fluent()

        if type(other) == Fluent:
            def value():
                if self.get_value() or other.get_value():
                    return True
                else:
                    return None

            other.add_child(fluent)
        else:
            def value():
                if self.get_value() or other:
                    return True
                else:
                    return None

        self.add_child(fluent)
        fluent.set_value(value)
        return fluent

    def NOT(self) -> Fluent:
        """Create a fluent which value is True if the value of its parent expresses False, None otherwise."""
        def value():
            if not self.get_value():
                return True
            else:
                return None

        fluent = Fluent(value)
        self.add_child(fluent)
        return fluent


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/failure_handling.py
from .designator import DesignatorDescription
from .plan_failures import PlanFailure

class FailureHandling:
    """
    Base class for failure handling mechanisms in automated systems or workflows.

    This class provides a structure for implementing different strategies to handle
    failures that may occur during the execution of a plan or process. It is designed
    to be extended by subclasses that implement specific failure handling behaviors.

    Attributes:
        designator_description (DesignatorDescription): An instance of DesignatorDescription.

    Methods:
        perform(): Abstract method
    """

    def __init__(self, designator_description:DesignatorDescription):
        """
        Initializes a new instance of the FailureHandling class.

        Args:
            designator_description (DesignatorDescription): The description or context
            of the task or process for which the failure handling is being set up.
        """
        self.designator_description = designator_description

    def perform(self):
        """
        Abstract method to perform the failure handling mechanism.

        This method should be overridden in subclasses to implement the specific
        behavior for handling failures.

        Raises:
            NotImplementedError: If the method is not implemented in a subclass.
        """
        raise NotImplementedError()

class Retry(FailureHandling):
    """
    A subclass of FailureHandling that implements a retry mechanism.

    This class represents a specific failure handling strategy where the system
    attempts to retry a failed action a certain number of times before giving up.

    Attributes:
        max_tries (int): The maximum number of attempts to retry the action.

    Inherits:
        All attributes and methods from the FailureHandling class.

    Overrides:
        perform(): Implements the retry logic.
    """

    def __init__(self, designator_description:DesignatorDescription, max_tries:int=3):
        """
        Initializes a new instance of the Retry class.

        Args:
            designator_description (DesignatorDescription): The description or context
            of the task or process for which the retry mechanism is being set up.
            max_tries (int, optional): The maximum number of attempts to retry. Defaults to 3.
        """
        super().__init__(designator_description)
        self.max_tries = max_tries

    def perform(self):
        """
        Implementation of the retry mechanism.

        This method attempts to perform the action specified in the designator_description.
        If the action fails, it is retried up to max_tries times. If all attempts fail,
        the last exception is raised.

        Raises:
            PlanFailure: If all retry attempts fail.
        """
        tries = 0
        for action in iter(self.designator_description):
            tries += 1
            try:
                action.perform()
                break
            except PlanFailure as e:
                if tries >= self.max_tries:
                    raise e






##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/pose_generator_and_validator.py
import tf
import numpy as np
import rospy
import pybullet as p

from .bullet_world import Object, BulletWorld, Use_shadow_world
from .bullet_world_reasoning import contact
from .costmaps import Costmap
from .pose import Pose, Transform
from .robot_descriptions import robot_description
from .external_interfaces.ik import request_ik
from .plan_failures import IKError
from .helper import _apply_ik
from typing import Type, Tuple, List, Union, Dict, Iterable


def pose_generator(costmap: Costmap, number_of_samples=100, orientation_generator=None) -> Iterable:
    """
    A generator that crates pose candidates from a given costmap. The generator
    selects the highest 100 values and returns the corresponding positions.
    Orientations are calculated such that the Robot faces the center of the costmap.

    :param costmap: The costmap from which poses should be sampled.
    :param number_of_samples: The number of samples from the costmap that should be returned at max
    :param orientation_generator: function that generates an orientation given a position and the origin of the costmap
    :Yield: A tuple of position and orientation
    """
    if not orientation_generator:
        orientation_generator = generate_orientation

    # Determines how many positions should be sampled from the costmap
    if number_of_samples == -1:
        number_of_samples = costmap.map.flatten().shape[0]
    indices = np.argpartition(costmap.map.flatten(), -number_of_samples)[-number_of_samples:]
    indices = np.dstack(np.unravel_index(indices, costmap.map.shape)).reshape(number_of_samples, 2)

    height = costmap.map.shape[0]
    width = costmap.map.shape[1]
    center = np.array([height // 2, width // 2])
    for ind in indices:
        if costmap.map[ind[0]][ind[1]] == 0:
            continue
        # The position is calculated by creating a vector from the 2D position in the costmap (given by x and y)
        # and the center of the costmap (since this is the origin). This vector is then turned into a transformation
        # and muiltiplied with the transformation of the origin.
        vector_to_origin = (center - ind) * costmap.resolution
        point_to_origin = Transform([*vector_to_origin, 0], frame="point", child_frame="origin")
        origin_to_map = costmap.origin.to_transform("origin").invert()
        point_to_map = point_to_origin * origin_to_map
        map_to_point = point_to_map.invert()

        orientation = orientation_generator(map_to_point.translation_as_list(), costmap.origin)
        yield Pose(map_to_point.translation_as_list(), orientation)


def height_generator() -> float:
    pass


def generate_orientation(position: List[float], origin: Pose) -> List[float]:
    """
    This method generates the orientation for a given position in a costmap. The
    orientation is calculated such that the robot faces the origin of the costmap.
    This generation is done by simply calculating the arctan between the position,
    in the costmap, and the origin of the costmap.

    :param position: The position in the costmap. This position is already converted
        to the world coordinate frame.
    :param origin: The origin of the costmap. This is also the point which the
        robot should face.
    :return: A quaternion of the calculated orientation
    """
    angle = np.arctan2(position[1]-origin.position.y, position[0]-origin.position.x) + np.pi
    quaternion = list(tf.transformations.quaternion_from_euler(0, 0, angle, axes="sxyz"))
    return quaternion


def visibility_validator(pose: Pose,
                         robot: Object,
                         object_or_pose: Union[Object, Pose],
                         world: BulletWorld) -> bool:
    """
    This method validates if the robot can see the target position from a given
    pose candidate. The target position can either be a position, in world coordinate
    system, or an object in the BulletWorld. The validation is done by shooting a
    ray from the camera to the target position and checking that it does not collide
    with anything else.

    :param pose: The pose candidate that should be validated
    :param robot: The robot object for which this should be validated
    :param object_or_pose: The target position or object for which the pose
        candidate should be validated.
    :param world: The BulletWorld instance in which this should be validated.
    :return: True if the target is visible for the robot, None in any other case.
    """
    robot_pose = robot.get_pose()
    if type(object_or_pose) == Object:
        robot.set_pose(pose)
        camera_pose = robot.get_link_pose(robot_description.get_camera_frame())
        robot.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))
        ray = p.rayTest(camera_pose.position_as_list(), object_or_pose.get_pose().position_as_list(),
                        physicsClientId=world.client_id)
        res = ray[0][0] == object_or_pose.id
    else:
        robot.set_pose(pose)
        camera_pose = robot.get_link_pose(robot_description.get_camera_frame())
        robot.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))
        ray = p.rayTest(camera_pose.position_as_list(), object_or_pose, physicsClientId=world.client_id)
        res = ray[0][0] == -1
    robot.set_pose(robot_pose)
    return res


def reachability_validator(pose: Pose,
                           robot: Object,
                           target: Union[Object, Pose],
                           allowed_collision: Dict[Object, List] = None) -> Tuple[bool, List]:
    """
    This method validates if a target position is reachable for a pose candidate.
    This is done by asking the ik solver if there is a valid solution if the
    robot stands at the position of the pose candidate. if there is a solution
    the validator returns True and False in any other case.

    :param pose: The pose candidate for which the reachability should be validated
    :param robot: The robot object in the BulletWorld for which the reachability
        should be validated.
    :param target: The target position or object instance which should be the
        target for reachability.
    :param allowed_collision:
    :return: True if the target is reachable for the robot and False in any other
        case.
    """
    if type(target) == Object:
        target = target.get_pose()

    robot.set_pose(pose)

    left_gripper = robot_description.get_tool_frame('left')
    right_gripper = robot_description.get_tool_frame('right')

    # left_joints = robot_description._safely_access_chains('left').joints
    left_joints = robot_description.chains['left'].joints
    # right_joints = robot_description._safely_access_chains('right').joints
    right_joints = robot_description.chains['right'].joints
    # TODO Make orientation adhere to grasping orientation
    res = False
    arms = []
    in_contact = False

    allowed_robot_links = []
    if robot in allowed_collision.keys():
        allowed_robot_links = allowed_collision[robot]

    joint_state_before_ik=robot._current_joint_states
    try:
        # resp = request_ik(base_link, end_effector, target_diff, robot, left_joints)
        resp = request_ik(target, robot, left_joints, left_gripper)

        _apply_ik(robot, resp, left_joints)

        for obj in BulletWorld.current_bullet_world.objects:
            if obj.name == "floor":
                continue
            in_contact, contact_links = contact(robot, obj, return_links=True)
            allowed_links = allowed_collision[obj] if obj in allowed_collision.keys() else []

            if in_contact:
                for link in contact_links:

                    if link[0] in allowed_robot_links or link[1] in allowed_links:
                        in_contact = False

        if not in_contact:
            arms.append("left")
            res = True
    except IKError:
        pass
    finally:
        robot.set_joint_states(joint_state_before_ik)

    try:
        # resp = request_ik(base_link, end_effector, target_diff, robot, right_joints)
        resp = request_ik(target, robot, right_joints, right_gripper)

        _apply_ik(robot, resp, right_joints)

        for obj in BulletWorld.current_bullet_world.objects:
            if obj.name == "floor":
                continue
            in_contact, contact_links = contact(robot, obj, return_links=True)
            allowed_links = allowed_collision[obj] if obj in allowed_collision.keys() else []

            if in_contact:
                for link in contact_links:

                    if link[0] in allowed_robot_links or link[1] in allowed_links:
                        in_contact = False

        if not in_contact:
            arms.append("right")
            res = True
    except IKError:
        pass
    finally:
        robot.set_joint_states(joint_state_before_ik)

    return res, arms


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/enums.py
"""Module holding all enums of PyCRAM."""

from enum import Enum, auto


class Arms(Enum):
    """Enum for Arms."""
    LEFT = auto()
    RIGHT = auto()
    BOTH = auto()


class TaskStatus(Enum):
    """
    Enum for readable descriptions of a tasks' status.
    """
    CREATED = 0
    RUNNING = 1
    SUCCEEDED = 2
    FAILED = 3


class JointType(Enum):
    """
    Enum for readable joint types.
    """
    REVOLUTE = 0
    PRISMATIC = 1
    SPHERICAL = 2
    PLANAR = 3
    FIXED = 4


class Grasp(Enum):
    """
    Enum for Grasp orientations.
    """
    FRONT = 0
    LEFT = 1
    RIGHT = 2
    TOP = 3


class ObjectType(Enum):
    """
    Enum for Object types to easier identify different objects
    """
    MILK = auto()
    SPOON = auto()
    BOWL = auto()
    BREAKFAST_CEREAL = auto()
    JEROEN_CUP = auto()
    ROBOT = auto()
    ENVIRONMENT = auto()
    GENERIC_OBJECT = auto()


class State(Enum):
    """
    Enumeration which describes the result of a language expression.
    """
    SUCCEEDED = 1
    FAILED = 0
    RUNNING = 2
    INTERRUPTED = 3



##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/process_module.py
"""Implementation of process modules.

Classes:
ProcessModule -- implementation of process modules.
"""
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations
import inspect
import threading
import time
from abc import ABC
import rospy
from typing import Callable, List, Type, Any, Union
from .language import Language

from .robot_descriptions import robot_description


class ProcessModule:
    """
    Implementation of process modules. Process modules are the part that communicate with the outer world to execute designators.
    """
    execution_delay = True
    """
    Adds a delay of 0.5 seconds after executing a process module, to make the execution in simulation more realistic
    """
    block_list = []
    """
    List of thread ids for which no Process Modules should be executed. This is used as an interrupt mechanism for 
    Designators
    """

    def __init__(self, lock):
        """Create a new process module."""
        self._lock = lock

    def _execute(self, designator) -> Any:
        """
        Helper method for internal usage only.
        This method is to be overwritten instead of the execute method.
        """
        pass

    def execute(self, designator) -> Any:
        """
        Execute the given designator. If there is already another process module of the same kind the `self._lock` will
        lock this thread until the execution of that process module is finished. This implicitly queues the execution of
        process modules.

        :param designator: The designator to execute.
        :return: Return of the Process Module if there is any
        """
        if threading.get_ident() in Language.block_list:
            return None
        with self._lock:
            ret = self._execute(designator)
            if ProcessModule.execution_delay:
                time.sleep(0.5)

        return ret


class RealRobot:
    """
    Management class for executing designators on the real robot. This is intended to be used in a with environment.
    When importing this class an instance is imported instead.

    Example:

    .. code-block:: python

        with real_robot:
            some designators
    """
    def __init__(self):
        self.pre: str = ""

    def __enter__(self):
        """
        Entering function for 'with' scope, saves the previously set :py:attr:`~ProcessModuleManager.execution_type` and
        sets it to 'real'
        """
        self.pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = "real"

    def __exit__(self, type, value, traceback):
        """
        Exit method for the 'with' scope, sets the :py:attr:`~ProcessModuleManager.execution_type` to the previously
        used one.
        """
        ProcessModuleManager.execution_type = self.pre

    def __call__(self):
        return self


class SimulatedRobot:
    """
    Management class for executing designators on the simulated robot. This is intended to be used in a with environment.
    When importing this class an instance is imported instead.

    Example:

    .. code-block:: python

        with simulated_robot:
            some designators
    """
    def __init__(self):
        self.pre: str = ""

    def __enter__(self):
        """
        Entering function for 'with' scope, saves the previously set :py:attr:`~ProcessModuleManager.execution_type` and
        sets it to 'simulated'
        """
        self.pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = "simulated"

    def __exit__(self, type, value, traceback):
        """
        Exit method for the 'with' scope, sets the :py:attr:`~ProcessModuleManager.execution_type` to the previously
        used one.
        """
        ProcessModuleManager.execution_type = self.pre

    def __call__(self):
        return self


def with_real_robot(func: Callable) -> Callable:
    """
    Decorator to execute designators in the decorated class on the real robot.

    Example:

    .. code-block:: python

        @with_real_robot
        def plan():
            some designators

    :param func: Function this decorator is annotating
    :return: The decorated function wrapped into the decorator
    """
    def wrapper(*args, **kwargs):
        pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = "real"
        ret = func(*args, **kwargs)
        ProcessModuleManager.execution_type = pre
        return ret

    return wrapper


def with_simulated_robot(func: Callable) -> Callable:
    """
    Decorator to execute designators in the decorated class on the simulated robot.

    Example:

    .. code-block:: python

        @with_simulated_robot
        def plan():
            some designators

    :param func: Function this decorator is annotating
    :return: The decorated function wrapped into the decorator
    """
    def wrapper(*args, **kwargs):
        pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = "simulated"
        ret = func(*args, **kwargs)
        ProcessModuleManager.execution_type = pre
        return ret

    return wrapper


# These are imported, so they don't have to be initialized when executing with
simulated_robot = SimulatedRobot()
real_robot = RealRobot()


class ProcessModuleManager(ABC):
    """
    Base class for managing process modules, any new process modules have to implement this class to register the
    Process Modules
    """
    execution_type = None
    """
    Whether the robot for which the process module is intended for is real or a simulated one
    """
    available_pms = []
    """
    List of all available Process Module Managers
    """
    _instance = None
    """
    Singelton instance of this Process Module Manager
    """

    def __new__(cls, *args, **kwargs):
        """
        Creates a new instance if :py:attr:`~ProcessModuleManager._instance` is None, otherwise the instance
        in :py:attr:`~ProcessModuleManager._instance` is returned.
        :return: Singelton instance of this Process Module Manager
        """
        if not cls._instance:
            cls._instance = super(ProcessModuleManager, cls).__new__(cls)
            return cls._instance
        else:
            return cls._instance

    def __init__(self, robot_name):
        """
        Registers the Process modules for this robot. The name of the robot has to match the name given in the robot
        description.

        :param robot_name: Name of the robot for which these Process Modules are intended
        """
        self.robot_name = robot_name
        ProcessModuleManager.available_pms.append(self)

    @staticmethod
    def get_manager() -> Union[ProcessModuleManager, None]:
        """
        Returns the Process Module manager for the currently loaded robot or None if there is no Manager.

        :return: ProcessModuleManager instance of the current robot
        """
        manager = None
        if not ProcessModuleManager.execution_type:
            rospy.logerr(
                f"No execution_type is set, did you use the with_simulated_robot or with_real_robot decorator?")
            return

        for pm_manager in ProcessModuleManager.available_pms:
            if pm_manager.robot_name == robot_description.name:
                manager = pm_manager
            if pm_manager.robot_name == "default":
                default_manager = pm_manager

        if manager:
            return manager
        else:
            rospy.logwarn_once(f"No Process Module Manager found for robot: '{robot_description.name}', using default process modules")
            return default_manager

    def navigate(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for navigating the robot with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for navigating
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def pick_up(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for picking up with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for picking up an object
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def place(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for placing with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for placing an Object
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def looking(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for looking at a point with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for looking at a specific point
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def detecting(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for detecting an object with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for detecting an object
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def move_tcp(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for moving the Tool Center Point with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for moving the TCP
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def move_arm_joints(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for moving the joints of the robot arm
        with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for moving the arm joints
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def world_state_detecting(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for detecting an object using the world state with respect to the
        :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for world state detecting
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def move_joints(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for moving any joint of the robot with respect to the
        :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for moving joints
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def move_gripper(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for moving the gripper with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for moving the gripper
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def open(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for opening drawers with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for opening drawers
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def close(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for closing drawers with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for closing drawers
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/helper.py
"""Implementation of helper functions and classes for internal usage only.

Functions:
_block -- wrap multiple statements into a single block.

Classes:
GeneratorList -- implementation of generator list wrappers.
"""
from inspect import isgeneratorfunction
from typing import List
from typing import Tuple, Callable

import numpy as np
import pybullet as p
from pytransform3d.rotations import quaternion_wxyz_from_xyzw, quaternion_xyzw_from_wxyz
from pytransform3d.transformations import transform_from_pq, transform_from, pq_from_transform

from .bullet_world import Object as BulletWorldObject
from .local_transformer import LocalTransformer
from .pose import Transform, Pose
from .robot_descriptions import robot_description
import os
import math


class bcolors:
    """
    Color codes which can be used to highlight Text in the Terminal. For example,
    for warnings.
    Usage:
    Firstly import the class into the file.
    print(f'{bcolors.WARNING} Some Text {bcolors.ENDC}')
    """
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def _apply_ik(robot: BulletWorldObject, joint_poses: List[float], joints: List[str]) -> None:
    """
    Apllies a list of joint poses calculated by an inverse kinematics solver to a robot

    :param robot: The robot the joint poses should be applied on
    :param joint_poses: The joint poses to be applied
    :param gripper: specifies the gripper for which the ik solution should be applied
    :return: None
    """
    # arm ="left" if gripper == robot_description.get_tool_frame("left") else "right"
    # ik_joints = [robot_description.torso_joint] + robot_description._safely_access_chains(arm).joints
    # ik_joints = robot_description._safely_access_chains(arm).joints
    robot.set_joint_states(dict(zip(joints, joint_poses)))
    # for i in range(0, len(joints)):
    #     robot.set_joint_state(joints[i], joint_poses[i])


def _transform_to_torso(pose_and_rotation: Tuple[List[float], List[float]], robot: BulletWorldObject) -> Tuple[
    List[float], List[float]]:
    # map_T_torso = robot.get_link_position_and_orientation("base_footprint")
    # map_T_torso = robot.get_position_and_orientation()
    map_T_torso = robot.get_link_pose(robot_description.torso_link).to_list()
    torso_T_map = p.invertTransform(map_T_torso[0], map_T_torso[1])
    map_T_target = pose_and_rotation
    torso_T_target = p.multiplyTransforms(torso_T_map[0], torso_T_map[1], map_T_target[0], map_T_target[1])
    return torso_T_target


def calculate_wrist_tool_offset(wrist_frame: str, tool_frame: str, robot: BulletWorldObject) -> Transform:
    local_transformer = LocalTransformer()
    tool_pose = robot.get_link_pose(tool_frame)
    wrist_to_tool = local_transformer.transform_pose(tool_pose, robot.get_link_tf_frame(wrist_frame))
    return wrist_to_tool.to_transform(robot.get_link_tf_frame(tool_frame))


def inverseTimes(transform1: Tuple[List[float], List[float]], transform2: Tuple[List[float], List[float]]) -> Tuple[
    List[float], List[float]]:
    """
    Like a Minus for Transforms, this subtracts the second transform from the first.
    """
    inv = p.invertTransform(transform2[0], transform2[1])
    return p.multiplyTransforms(transform1[0], transform1[1], inv[0], inv[1])


def transform(pose: List[float],
              transformation: List[float],
              local_coords=False):  # TODO: if pose is a list of position and orientation calculate new pose w/ orientation too
    input_has_rotation = len(pose) == 7
    transformation_has_rotation = len(transformation) == 7
    pose_tf = transform_from_pq(
        np.concatenate((pose[:3], quaternion_wxyz_from_xyzw(pose[3:])))) if input_has_rotation else transform_from(
        np.eye(3), pose)
    transformation_tf = transform_from_pq(np.concatenate((transformation[:3], quaternion_wxyz_from_xyzw(
        transformation[3:])))) if transformation_has_rotation else transform_from(np.eye(3), transformation)
    if local_coords:
        res = pose_tf @ transformation_tf
    else:
        res = transformation_tf @ pose_tf
    res = pq_from_transform(res)
    res[3:] = quaternion_xyzw_from_wxyz(res[3:])
    if not input_has_rotation:
        return res[:3].tolist()
    return res.tolist()


class GeneratorList:
    """Implementation of generator list wrappers.

    Generator lists store the elements of a generator, so these can be fetched multiple times.

    Methods:
    get -- get the element at a specific index.
    has -- check if an element at a specific index exists.
    """

    def __init__(self, generator: Callable):
        """Create a new generator list.

        Arguments:
        generator -- the generator to use.
        """
        if isgeneratorfunction(generator):
            self._generator = generator()
        else:
            self._generator = generator

        self._generated = []

    def get(self, index: int = 0):
        """Get the element at a specific index or raise StopIteration if it doesn't exist.

        Arguments:
        index -- the index to get the element of.
        """
        while len(self._generated) <= index:
            self._generated.append(next(self._generator))

        return self._generated[index]

    def has(self, index: int) -> bool:
        """Check if an element at a specific index exists and return True or False.

        Arguments:
        index -- the index to check for.
        """
        try:
            self.get(index)
            return True
        except StopIteration:
            return False


def axis_angle_to_quaternion(axis: List, angle: float) -> Tuple:
    """
    Convert axis-angle to quaternion.

    :param axis: (x, y, z) tuple representing rotation axis.
    :param angle: rotation angle in degree
    :return: The quaternion representing the axis angle
    """
    angle = math.radians(angle)
    axis_length = math.sqrt(sum([i ** 2 for i in axis]))
    normalized_axis = tuple(i / axis_length for i in axis)

    x = normalized_axis[0] * math.sin(angle / 2)
    y = normalized_axis[1] * math.sin(angle / 2)
    z = normalized_axis[2] * math.sin(angle / 2)
    w = math.cos(angle / 2)

    return (x, y, z, w)


def multiply_quaternions(q1: List, q2: List) -> List:
    """
    Multiply two quaternions using the robotics convention (x, y, z, w).

    :param q1: The first quaternion
    :param q2: The second quaternion
    :return: The quaternion resulting from the multiplication
    """
    x1, y1, z1, w1 = q1
    x2, y2, z2, w2 = q2

    w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2
    x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2
    y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2
    z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2

    return (x, y, z, w)


def quaternion_rotate(q: List, v: List) -> List:
    """
    Rotate a vector v using quaternion q.

    :param q: A quaternion of how v should be rotated
    :param v: A vector that should be rotated by q
    :return: V rotated by Q as a quaternion
    """
    q_conj = (-q[0], -q[1], -q[2], q[3])  # Conjugate of the quaternion
    v_quat = (*v, 0)  # Represent the vector as a quaternion with w=0
    return multiply_quaternions(multiply_quaternions(q, v_quat), q_conj)[:3]


def multiply_poses(pose1: Pose, pose2: Pose) -> Tuple:
    """
    Multiply two poses.

    :param pose1: first Pose that should be multiplied
    :param pose2: Second Pose that should be multiplied
    :return: A Tuple of position and quaternion as result of the multiplication
    """
    pos1, quat1 = pose1.pose.position, pose1.pose.orientation
    pos2, quat2 = pose2.pose.position, pose2.pose.orientation
    # Multiply the orientations
    new_quat = multiply_quaternions(quat1, quat2)

    # Transform the position
    new_pos = np.add(pos1, quaternion_rotate(quat1, pos2))

    return new_pos, new_quat

##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/__init__.py
"""Python3 implementation of CRAM.

To use macros one must put the code in an own file and create a second file (the launcher) which activates MacroPy and then imports the file where the macros are used.
E. g. if you have a file target.py which contains your code, create a file run.py:

#!/usr/bin/env python

import macropy.activate
import target

Now launch run.py to start your program.

Modules:
designator -- implementation of designators.
fluent -- implementation of fluents and the whenever macro.
helper -- implementation of helper classes and functions for internal usage only.
language -- implementation of the CRAM language.
process_module -- implementation of process modules.
"""

from . import utils

import logging
import logging.config

# with utils.suppress_stdout_stderr():
#     import pycram.process_modules
import pycram.process_modules

logging.basicConfig(level=logging.WARNING, format='%(levelname)s - %(name)s  - Line:%(lineno)d - %(message)s')

ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(levelname)s - %(name)s  - Line:%(lineno)d - %(message)s')
ch.setFormatter(formatter)

#from .resolver import *


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/task.py
"""Implementation of TaskTrees using anytree."""

# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import datetime
import inspect
import json
import logging
from typing import List, Dict, Optional, Callable, Any

import anytree
import pybullet
import sqlalchemy.orm.session
import tqdm

from .bullet_world import BulletWorld
from .orm.task import (Code as ORMCode, TaskTreeNode as ORMTaskTreeNode)
from .orm.base import ProcessMetaData
from .plan_failures import PlanFailure
from .language import Code
from .enums import TaskStatus


class TaskCode(Code):
    def __str__(self) -> str:
        if "self" in self.kwargs:
            class_name = self.kwargs["self"].__class__.__name__
        else:
            class_name = ""
        function_name = self.function.__name__

        return f"{function_name}({class_name})"

    def __eq__(self, other):
        return isinstance(other, Code) and other.function.__name__ == self.function.__name__ \
            and other.kwargs == self.kwargs

    def to_json(self) -> Dict:
        """Create a dictionary that can be json serialized."""
        return {"function": self.function.__name__, "kwargs": self.kwargs_to_json()}

    def kwargs_to_json(self):
        """Try to parse the keyword arguments to json. Checks if the objects given as arguments can be serialized
        as standard object or have a to_json method. If not they are skipped. """
        result = dict()
        for keyword, argument in self.kwargs.items():
            to_json_method = getattr(argument, 'to_json', None)

            if to_json_method:
                result[keyword] = argument.to_json()

            else:
                try:
                    argument_ = json.loads(json.dumps(argument))
                    result[keyword] = argument_
                except (TypeError, OverflowError):
                    logging.warning("Object of type %s cannot be JSON serialized. Skipping..." % type(argument))

        return result

    def to_sql(self) -> ORMCode:
        return ORMCode(self.function.__name__)

    def insert(self, session: sqlalchemy.orm.session.Session) -> ORMCode:
        code = self.to_sql()

        # set foreign key to designator if present
        self_ = self.kwargs.get("self")

        if self_ and getattr(self_, "insert", None):
            designator = self_.insert(session)
            code.designator_id = designator.id

        # get and set metadata
        metadata = ProcessMetaData().insert(session)
        code.process_metadata_id = metadata.id

        session.add(code)
        session.commit()
        return code


class NoOperation(TaskCode):
    """
    Convenience class that represents no operation as code.
    """

    def __init__(self):
        # default no operation
        def no_operation(): return None

        # initialize a code block that does nothing
        super().__init__(no_operation)


class TaskTreeNode(anytree.NodeMixin):
    """TaskTreeNode represents one function that was called during a pycram plan.
    Additionally, meta information is stored.

    :ivar code: The function that was executed as Code object.
    :ivar status: The status of the node from the TaskStatus enum.
    :ivar start_time: The starting time of the function, optional
    :ivar end_time: The ending time of the function, optional
    :ivar reason: The reason why this task failed, optional
    """

    def __init__(self, code: TaskCode = NoOperation(), parent: Optional[TaskTreeNode] = None,
                 children: Optional[List[TaskTreeNode]] = None, reason: Optional[Exception] = None):
        """
        Create a TaskTreeNode

        :param code: The function and its arguments that got called as TaskCode object, defaults to NoOperation()
        :param parent: The parent function of this function. None if this the parent, optional
        :param children: An iterable of TaskTreeNode with the ordered children, optional
        """
        super().__init__()
        self.code: TaskCode = code
        self.status: TaskStatus = TaskStatus.CREATED
        self.start_time: Optional[datetime.datetime] = None
        self.end_time: Optional[datetime.datetime] = None
        self.parent = parent
        self.reason: Optional[Exception] = reason

        if children:
            self.children = children

    @property
    def name(self):
        return str(self)

    def to_json(self):
        return {"code": self.code.to_json(),
                "status": self.status.name,
                "start_time": self.start_time.isoformat() if self.start_time else None,
                "end_time": self.end_time.isoformat() if self.end_time else None,
                "id": id(self),
                "parent_id": id(self.parent) if self.parent else None
                }

    def __str__(self):
        return "Code: %s \n " \
               "start_time: %s \n " \
               "Status: %s \n " \
               "end_time: %s \n " \
               "" % (str(self.code), self.start_time, self.status, self.end_time)

    def __repr__(self):
        return str(self.code)

    def __len__(self):
        """Get the number of nodes that are in this subtree."""
        return 1 + sum([len(child) for child in self.children])

    def to_sql(self) -> ORMTaskTreeNode:
        """Convert this object to the corresponding object in the pycram.orm package.

        :returns:  corresponding pycram.orm.task.TaskTreeNode object
        """

        if self.reason:
            reason = type(self.reason).__name__
        else:
            reason = None

        return ORMTaskTreeNode(None, self.start_time, self.end_time, self.status.name,
                               reason, id(self.parent) if self.parent else None)

    def insert(self, session: sqlalchemy.orm.session.Session, recursive: bool = True,
               parent_id: Optional[int] = None, use_progress_bar: bool = True,
               progress_bar: Optional[tqdm.tqdm] = None) -> ORMTaskTreeNode:
        """
        Insert this node into the database.

        :param session: The current session with the database.
        :param recursive: Rather if the entire tree should be inserted or just this node, defaults to True
        :param parent_id: The primary key of the parent node, defaults to None
        :param use_progress_bar: Rather to use a progressbar or not
        :param progress_bar: The progressbar to update. If a progress bar is desired and this is None, a new one will be
            created.

        :return: The ORM object that got inserted
        """
        if use_progress_bar:
            if not progress_bar:
                progress_bar = tqdm.tqdm(desc="Inserting TaskTree into database", leave=True, position=0,
                                         total=len(self) if recursive else 1)

        # insert code
        code = self.code.insert(session)

        # convert self to orm object
        node = self.to_sql()
        node.code_id = code.id

        # get and set metadata
        metadata = ProcessMetaData().insert(session)
        node.process_metadata_id = metadata.id

        # set parent to id from constructor
        node.parent_id = parent_id

        # add the node to database to retrieve the new id
        session.add(node)
        session.commit()

        if progress_bar:
            progress_bar.update()

        # if recursive, insert all children
        if recursive:
            [child.insert(session, parent_id=node.id, use_progress_bar=use_progress_bar, progress_bar=progress_bar)
             for child in self.children]

        return node


class SimulatedTaskTree:
    """TaskTree for execution in a 'new' simulation."""

    def __enter__(self):
        """At the beginning of a with statement the current task tree and bullet world will be suspended and remembered.
        Fresh structures are then available inside the with statement."""
        global task_tree

        def simulation(): return None

        self.suspended_tree = task_tree
        self.world_state, self.objects2attached = BulletWorld.current_bullet_world.save_state()
        self.simulated_root = TaskTreeNode(code=TaskCode(simulation))
        task_tree = self.simulated_root
        pybullet.addUserDebugText("Simulating...", [0, 0, 1.75], textColorRGB=[0, 0, 0],
                                  parentObjectUniqueId=1, lifeTime=0)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        Restore the old state at the end of a with block.
        """
        global task_tree
        task_tree = self.suspended_tree
        BulletWorld.current_bullet_world.restore_state(self.world_state, self.objects2attached)
        pybullet.removeAllUserDebugItems()


task_tree: Optional[TaskTreeNode] = None
"""Current TaskTreeNode"""


def reset_tree() -> None:
    """
    Reset the current task tree to an empty root (NoOperation) node.
    """
    global task_tree
    task_tree = TaskTreeNode(NoOperation())
    task_tree.start_time = datetime.datetime.now()
    task_tree.status = TaskStatus.RUNNING


reset_tree()


def with_tree(fun: Callable) -> Callable:
    """Decorator that records the function name, arguments and execution metadata in the task tree.

    :param fun: The function to record the data from.
    """

    def handle_tree(*args, **kwargs):

        # get the task tree
        global task_tree

        # create the code object that gets executed
        code = TaskCode(fun, inspect.getcallargs(fun, *args, **kwargs))

        task_tree = TaskTreeNode(code, parent=task_tree)

        # Try to execute the task
        try:
            task_tree.status = TaskStatus.CREATED
            task_tree.start_time = datetime.datetime.now()
            result = task_tree.code.execute()

            # if it succeeded set the flag
            task_tree.status = TaskStatus.SUCCEEDED

        # iff a PlanFailure occurs
        except PlanFailure as e:

            # log the error and set the flag
            logging.exception("Task execution failed at %s. Reason %s" % (str(task_tree.code), e))
            task_tree.reason = e
            task_tree.status = TaskStatus.FAILED
            raise e
        finally:
            # set and time and update current node pointer
            task_tree.end_time = datetime.datetime.now()
            task_tree = task_tree.parent
        return result

    return handle_tree


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/event.py
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

from typing import Callable, List, Optional, Any


class Event:
    """
    Base implementation of events in PyCRAM.
    Events allow to attach handler methods to events that fire for specific occurences in the world.

    :ivar handler: List of methods that are called when this event is fired.
    """

    def __init__(self):
        self.handlers: List[Callable] = []

    def add(self, handler: Callable) -> None:
        """
        Adds a new handler to the list of handlers. All handler methods are called when this event is fired.
        Handler have to take the event sender as parameter as well as args* which can contain further parameter.

        :param handler: A method that should be added
        """
        self.handlers.append(handler)

    def remove(self, handler: Callable) -> None:
        """
        Removes a method from the list of handlers, the method will not be called when the event is fired.

        :param handler: The method that should be removed.
        """
        self.handlers.remove(handler)

    def fire(self, sender: Any, earg: Optional[Any] = None) -> None:
        """
        Fire this event, this causes every method to be called with a sender as well as additional args.

        :param sender: The entity that fired the event.
        :param earg: Additional arguments.
        """
        for handler in self.handlers:
            handler(sender, earg)

    def __iadd__(self, other: Callable) -> Event:
        """
        Operator overload that allows to add handlers by the '+=' operator.

        :param other: The handler that should be added.
        :return: This instance
        """
        self.add(other)
        return self

    def __isub__(self, other: Callable) -> Event:
        """
        Operator overload that allows to remove methods as handlers by using the '-=' operator.

        :param other: The method that should be removed as handler.
        :return: This instance
        """
        self.remove(other)
        return self

    __call__ = fire
    """
    Allows to directly call the reference.
    """

##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/language.py
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import time
from typing import Iterable, Optional, Callable, Dict, Any, List, Union
from anytree import NodeMixin, Node, PreOrderIter, RenderTree

from .enums import State
import threading

from .fluent import Fluent
from .plan_failures import PlanFailure, NotALanguageExpression
from .external_interfaces import giskard


class Language(NodeMixin):
    """
    Parent class for language expressions. Implements the operators as well as methods to reduce the resulting language
    tree.
    """
    parallel_blocklist = ["PickUpAction", "PlaceAction", "OpenAction", "CloseAction", "TransportAction", "GraspingAction"]
    do_not_use_giskard = ["SetGripperAction", "MoveGripperMotion", "DetectAction", "DetectingMotion"]
    block_list: List[int] = []
    """List of thread ids which should be blocked from execution."""

    def __init__(self, parent: NodeMixin = None, children: Iterable[NodeMixin] = None):
        """
        Default constructor for anytree nodes. If the parent is none this is the root node.

        :param parent: The parent node of this node
        :param children: All children of this node as a tuple oder iterable
        """
        self.parent = parent
        self.exceptions = {}
        self.state = None
        self.executing_thread = {}
        self.threads: List[threading.Thread] = []
        self.interrupted = False
        self.name = self.__class__.__name__
        if children:
            self.children: Language = children

    def resolve(self) -> Language:
        """
        Dummy method for compatability to designator descriptions

        :return: self reference
        """
        return self

    def perform(self):
        """
        This method should be overwritten in subclasses and implement the behaviour of the language expression regarding
        each child.
        """
        raise NotImplementedError

    def __add__(self, other: Language) -> Sequential:
        """
        Language expression for sequential execution.

        :param other: Another Language expression, either a designator or language expression
        :return: A :func:`~Sequential` object which is the new root node of the language tree
        """
        if not issubclass(other.__class__, Language):
            raise NotALanguageExpression(
                f"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \nThe object '{other}' does not inherit from the Language class.")
        return Sequential(parent=None, children=(self, other)).simplify()

    def __sub__(self, other: Language) -> TryInOrder:
        """
        Language expression for try in order.

        :param other: Another Language expression, either a designator or language expression
        :return: A :func:`~TryInOrder` object which is the new root node of the language tree
        """
        if not issubclass(other.__class__, Language):
            raise NotALanguageExpression(
                f"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \nThe object '{other}' does not inherit from the Language class.")
        return TryInOrder(parent=None, children=(self, other)).simplify()

    def __or__(self, other: Language) -> Parallel:
        """
        Language expression for parallel execution.

        :param other: Another Language expression, either a designator or language expression
        :return: A :func:`~Parallel` object which is the new root node of the language tree
        """
        if not issubclass(other.__class__, Language):
            raise NotALanguageExpression(
                f"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \nThe object '{other}' does not inherit from the Language class.")
        if self.__class__.__name__ in self.parallel_blocklist or other.__class__.__name__ in self.parallel_blocklist:
            raise AttributeError(
                f"You can not execute the Designator {self if self.__class__.__name__ in self.parallel_blocklist else other} in a parallel language expression.")

        return Parallel(parent=None, children=(self, other)).simplify()

    def __xor__(self, other: Language) -> TryAll:
        """
        Language expression for try all execution.

        :param other: Another Language expression, either a designator or language expression
        :return: A :func:`~TryAll` object which is the new root node of the language tree
        """
        if not issubclass(other.__class__, Language):
            raise NotALanguageExpression(
                f"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \nThe object '{other}' does not inherit from the Language class.")
        if self.__class__.__name__ in self.parallel_blocklist or other.__class__.__name__ in self.parallel_blocklist:
            raise AttributeError(
                f"You can not execute the Designator {self if self.__class__.__name__ in self.parallel_blocklist else other} in a try all language expression.")
        return TryAll(parent=None, children=(self, other)).simplify()

    def __rshift__(self, other: Language):
        """
        Operator for Monitors, this always makes the Monitor the parent of the other expression.
        
        :param other: Another Language expression
        :return: The Monitor which is now the new root node.
        """
        if isinstance(self, Monitor) and isinstance(other, Monitor):
            raise AttributeError("You can't attach a Monitor to another Monitor.")
        if isinstance(self, Monitor):
            self.children = [other]
            return self
        elif isinstance(other, Monitor):
            other.children = [self]
            return other

    def __mul__(self, other: int):
        """
        Language expression for Repeated execution. The other attribute of this operator has to be an integer.

        :param other: An integer which states how often the Language expression should be repeated
        :return: A :func:`~Repeat` object which is the new root node of the language tree
        """
        if not isinstance(other, int):
            raise AttributeError("Repeat can only be used in combination with integers")
        return Repeat(parent=None, children=[self], repeat=other)

    def __rmul__(self, other: int):
        """
        Language expression for Repeated execution. The other attribute of this operator has to be an integer. This is
        the reversed operator of __mul__ which allows to write:

        .. code-block:: python
        
            2 * ParkAction()

        :param other: An integer which states how often the Language expression should be repeated
        :return: A :func:`~Repeat` object which is the new root node of the language tree
        """
        if not isinstance(other, int):
            raise AttributeError("Repeat can only be used in combination with integers")
        return Repeat(parent=None, children=[self], repeat=other)

    def simplify(self) -> Language:
        """
        Simplifies the language tree by merging which have a parent-child relation and are of the same type.

        .. code-block:: python

            <pycram.new_language.Parallel>
            ├── <pycram.new_language.Parallel>
            │   ├── <pycram.designators.action_designator.NavigateAction>
            │   └── <pycram.designators.action_designator.MoveTorsoAction>
            └── <pycram.designators.action_designator.DetectAction>


            would be simplified to:

           <pycram.new_language.Parallel>
            ├── <pycram.designators.action_designator.NavigateAction>
            ├── <pycram.designators.action_designator.MoveTorsoAction>
            └── <pycram.designators.action_designator.DetectAction>

        """
        for node in PreOrderIter(self.root):
            for child in node.children:
                if isinstance(child, Monitor):
                    continue
                if type(node) is type(child):
                    self.merge_nodes(node, child)
        return self.root

    @staticmethod
    def merge_nodes(node1: Node, node2: Node) -> None:
        """
        Merges node1 with node2 in a tree. The children of node2 will be re-parented to node1 and node2 will be deleted
        from the tree.

        :param node1: Node that should be left in the tree
        :param node2: Node which children should be appended to node1 and then deleted
        """
        node2.parent = None
        node1.children = node2.children + node1.children

    def interrupt(self) -> None:
        """
        Base method for interrupting the execution of Language expression. To be overwritten in a sub-class.
        """
        raise NotImplementedError


class Repeat(Language):
    """
    Executes all children a given number of times.
    """
    def perform(self):
        """
        Behaviour of repeat, executes all children in a loop as often as stated on initialization.

        :return:
        """
        for i in range(self.repeat):
            for child in self.children:
                if self.interrupted:
                    return
                try:
                    child.resolve().perform()
                except PlanFailure as e:
                    self.root.exceptions[self] = e

    def __init__(self, parent: NodeMixin = None, children: Iterable[NodeMixin] = None, repeat: int = 1):
        """
        Initializes the Repeat expression with a parent and children for the language tree construction and a number
        which states how often the children should be executed.

        :param parent: Parent node of this node, if None this will be the root node
        :param children: A list of children of this node
        :param repeat: An integer of how often the children should be executed.
        """
        super().__init__(parent, children)
        self.repeat: int = repeat

    def interrupt(self) -> None:
        """
        Stops the execution of this language expression by setting the ``interrupted`` variable to True, adding this
        thread to the block_list in ProcessModule and interrupting the current giskard goal
        """
        self.interrupted = True
        self.block_list.append(threading.get_ident())
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class Monitor(Language):
    """
    Monitors a Language Expression and interrupts it when the given condition is evaluated to True.

    Behaviour:
        This Monitor is attached to a language expression, when perform on this Monitor is called it will start a new
        thread which continuously checks if the condition is True. When the condition is True the interrupt function of
        the child will be called.
    """
    def __init__(self, condition: Union[Callable, Fluent] = None):
        """
        When initializing a Monitor a condition must be provided. The condition is a callable or a Fluent which returns \
        True or False.

        :param condition: The condition upon which the Monitor should interrupt the attached language expression.
        """
        super().__init__(None, None)
        self.kill_event = threading.Event()
        if callable(condition):
            self.condition = Fluent(condition)
        elif isinstance(condition, Fluent):
            self.condition = condition
        else:
            raise AttributeError("The condition of a Monitor has to be a Callable or a Fluent")

    def perform(self):
        """
        Behavior of the Monitor, starts a new Thread which checks the condition and then performs the attached language
        expression

        :return: The result of the attached language expression
        """
        def check_condition():
            while not self.condition.get_value() and not self.kill_event.is_set():
                time.sleep(0.1)
            if self.kill_event.is_set():
                return
            for child in self.children:
                child.interrupt()

        t = threading.Thread(target=check_condition)
        t.start()
        res = self.children[0].perform()
        self.kill_event.set()
        t.join()
        return res

    def interrupt(self) -> None:
        """
        Calls interrupt for each child
        """
        for child in self.children:
            child.interrupt()


class Sequential(Language):
    """
    Executes all children sequentially, an exception while executing a child does not terminate the whole process.
    Instead, the exception is saved to a list of all exceptions thrown during execution and returned.

    Behaviour:
        Return the state :py:attr:`~State.SUCCEEDED` *iff* all children are executed without exception.
        In any other case the State :py:attr:`~State.FAILED` will be returned.
    """

    def perform(self) -> State:
        """
        Behaviour of Sequential, calls perform() on each child sequentially

        :return: The state according to the behaviour described in :func:`Sequential`
        """
        try:
            for child in self.children:
                if self.interrupted:
                    if threading.get_ident() in self.block_list:
                        self.block_list.remove(threading.get_ident())
                    return
                self.root.executing_thread[child] = threading.get_ident()
                child.resolve().perform()
        except PlanFailure as e:
            self.root.exceptions[self] = e
            return State.FAILED
        return State.SUCCEEDED

    def interrupt(self) -> None:
        """
        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True and calling
        interrupt on the current giskard goal.
        """
        self.interrupted = True
        self.block_list.append(threading.get_ident())
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class TryInOrder(Language):
    """
    Executes all children sequentially, an exception while executing a child does not terminate the whole process.
    Instead, the exception is saved to a list of all exceptions thrown during execution and returned.

    Behaviour:
        Returns the State :py:attr:`~State.SUCCEEDED` if one or more children are executed without
        exception. In the case that all children could not be executed the State :py:attr:`~State.FAILED` will be returned.
    """

    def perform(self) -> State:
        """
        Behaviour of TryInOrder, calls perform() on each child sequentially and catches raised exceptions.

        :return: The state according to the behaviour described in :func:`TryInOrder`
        """
        failure_list = []
        for child in self.children:
            if self.interrupted:
                if threading.get_ident() in self.block_list:
                    self.block_list.remove(threading.get_ident())
                return
            try:
                child.resolve().perform()
            except PlanFailure as e:
                failure_list.append(e)
        if len(failure_list) > 0:
            self.root.exceptions[self] = failure_list
        if len(failure_list) == len(self.children):
            self.root.exceptions[self] = failure_list
            return State.FAILED
        else:
            return State.SUCCEEDED

    def interrupt(self) -> None:
        """
        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding
        the current thread to the block_list in Language and interrupting the current giskard goal.
        """
        self.interrupted = True
        self.block_list.append(threading.get_ident())
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class Parallel(Language):
    """
    Executes all children in parallel by creating a thread per children and executing them in the respective thread. All
    exceptions during execution will be caught, saved to a list and returned upon end.

    Behaviour:
        Returns the State :py:attr:`~State.SUCCEEDED` *iff* all children could be executed without an exception. In any
        other case the State :py:attr:`~State.FAILED` will be returned.
    """

    def perform(self) -> State:
        """
        Behaviour of Parallel, creates a new thread for each child and calls perform() of the child in the respective
        thread.

        :return: The state according to the behaviour described in :func:`Parallel`
        """

        def lang_call(child_node):
            if ("DesignatorDescription" in [cls.__name__ for cls in child_node.__class__.__mro__]
                    and self.__class__.__name__ not in self.do_not_use_giskard):
                if self not in giskard.par_threads.keys():
                    giskard.par_threads[self] = [threading.get_ident()]
                else:
                    giskard.par_threads[self].append(threading.get_ident())
            try:
                self.root.executing_thread[child] = threading.get_ident()
                child_node.resolve().perform()
            except PlanFailure as e:
                if self in self.root.exceptions.keys():
                    self.root.exceptions[self].append(e)
                else:
                    self.root.exceptions[self] = [e]

        for child in self.children:
            if self.interrupted:
                break
            t = threading.Thread(target=lambda: lang_call(child))
            t.start()
            self.threads.append(t)
        for thread in self.threads:
            thread.join()
            if thread.ident in self.block_list:
                self.block_list.remove(thread.ident)
        if self in self.root.exceptions.keys() and len(self.root.exceptions[self]) != 0:
            return State.FAILED
        return State.SUCCEEDED

    def interrupt(self) -> None:
        """
        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding the
        thread id of all parallel execution threads to the block_list in Language and interrupting the current giskard
        goal.
        """
        self.interrupted = True
        self.block_list += [t.ident for t in self.threads]
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class TryAll(Language):
    """
    Executes all children in parallel by creating a thread per children and executing them in the respective thread. All
    exceptions during execution will be caught, saved to a list and returned upon end.

    Behaviour:
        Returns the State :py:attr:`~State.SUCCEEDED` if one or more children could be executed without raising an
        exception. If all children fail the State :py:attr:`~State.FAILED` will be returned.
    """

    def perform(self) -> State:
        """
        Behaviour of TryAll, creates a new thread for each child and executes all children in their respective threads.

        :return: The state according to the behaviour described in :func:`TryAll`
        """
        self.threads: List[threading.Thread] = []
        failure_list = []

        def lang_call(child_node):
            if ("DesignatorDescription" in [cls.__name__ for cls in child_node.__class__.__mro__]
                    and self.__class__.__name__ not in self.do_not_use_giskard):
                if self not in giskard.par_threads.keys():
                    giskard.par_threads[self] = [threading.get_ident()]
                else:
                    giskard.par_threads[self].append(threading.get_ident())
            try:
                child_node.resolve().perform()
            except PlanFailure as e:
                failure_list.append(e)
                if self in self.root.exceptions.keys():
                    self.root.exceptions[self].append(e)
                else:
                    self.root.exceptions[self] = [e]

        for child in self.children:
            t = threading.Thread(target=lambda: lang_call(child))
            t.start()
            self.threads.append(t)
        for thread in self.threads:
            thread.join()
            if thread.ident in self.block_list:
                self.block_list.remove(thread.ident)
        if len(self.children) == len(failure_list):
            self.root.exceptions[self] = failure_list
            return State.FAILED
        else:
            return State.SUCCEEDED

    def interrupt(self) -> None:
        """
        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding the
        thread id of all parallel execution threads to the block_list in Language and interrupting the current giskard
        """
        self.interrupted = True
        self.block_list += [t.ident for t in self.threads]
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class Code(Language):
    """
    Executable code block in a plan.

    :ivar function: The function (plan) that was called
    :ivar kwargs: Dictionary holding the keyword arguments of the function
    """

    def __init__(self, function: Optional[Callable] = None,
                 kwargs: Optional[Dict] = None):
        """
        Initialize a code call

        :param function: The function that was called
        :param kwargs: The keyword arguments of the function as dict
        """
        self.function: Callable = function

        if kwargs is None:
            kwargs = dict()
        self.kwargs: Dict[str, Any] = kwargs
        self.perform = self.execute

    def execute(self) -> Any:
        """
        Execute the code with its arguments

        :returns: Anything that the function associated with this object will return.
        """
        return self.function(**self.kwargs)

    def interrupt(self) -> None:
        raise NotImplementedError




##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/bullet_world_reasoning.py
import pybullet as p
import itertools
import numpy as np
import rospy

from .bullet_world import _world_and_id, Object, Use_shadow_world, BulletWorld
from .external_interfaces.ik import request_ik
from .local_transformer import LocalTransformer
from .plan_failures import IKError
from .robot_descriptions import robot_description
from .helper import _transform_to_torso, _apply_ik, calculate_wrist_tool_offset, inverseTimes
from .pose import Pose, Transform
from typing import List, Tuple, Optional, Union, Dict


class ReasoningError(Exception):
    def __init__(self, *args, **kwargs):
        Exception.__init__(self, *args, **kwargs)


class CollisionError(Exception):
    def __init__(self, *args, **kwargs):
        Exception.__init__(self, *args, **kwargs)


def _get_joint_names(robot: Object, tip_link: str) -> List[str]:
    res = []
    for i in range(p.getNumJoints(robot.id)):
        info = p.getJointInfo(robot.id, i)
        if info[2] != p.JOINT_FIXED:
            res.append(info[1])
    return res


def _get_images_for_target(target_pose: Pose,
                           cam_pose: Pose,
                           world: Optional[BulletWorld] = None,
                           size: Optional[int] = 256) -> List[np.ndarray]:
    """
    Calculates the view and projection Matrix and returns 3 images:

    1. An RGB image
    2. A depth image
    3. A segmentation Mask, the segmentation mask indicates for every pixel the visible Object.

    From the given target_pose and cam_pose only the position is used.

    :param cam_pose: The pose of the camera
    :param target_pose: The pose to which the camera should point to
    :param size: The height and width of the images in pixel
    :return: A list containing an RGB and depth image as well as a segmentation mask, in this order.
    """
    world, world_id = _world_and_id(world)
    # TODO: Might depend on robot cameras, if so please add these camera parameters to RobotDescription object
    # TODO: of your robot with a CameraDescription object.
    fov = 90
    aspect = size / size
    near = 0.2
    far = 100

    view_matrix = p.computeViewMatrix(cam_pose.position_as_list(), target_pose.position_as_list(), [0, 0, 1])
    projection_matrix = p.computeProjectionMatrixFOV(fov, aspect, near, far)
    return list(p.getCameraImage(size, size, view_matrix, projection_matrix, physicsClientId=world_id))[2:5]


def _get_joint_ranges(robot: Object) -> Tuple[List, List, List, List, List]:
    """
    Calculates the lower and upper limits, the joint ranges and the joint damping. For a given robot Object.
    Fixed joints will be skipped because they don't have limits or ranges.

    :param robot: The robot for whom the values should be calculated
    :return: The lists for the upper and lower limits, joint ranges, rest poses and joint damping
    """
    ll, ul, jr, rp, jd = [], [], [], [], []

    for i in range(0, p.getNumJoints(robot.id)):
        info = p.getJointInfo(robot.id, i)
        if info[3] > -1:
            ll.append(info[8])
            ul.append(info[9])
            jr.append(info[9] - info[8])
            rp.append(p.getJointState(robot.id, i)[0])
            jd.append(info[6])

    return ll, ul, jr, rp, jd


def stable(object: Object,
           world: Optional[BulletWorld] = None) -> bool:
    """
    Checks if an object is stable in the world. Stable meaning that it's position will not change after simulating physics
    in the BulletWorld. This will be done by simulating the world for 10 seconds and compare the previous coordinates
    with the coordinates after the simulation.

    :param object: The object which should be checked
    :param world: The BulletWorld if more than one BulletWorld is active
    :return: True if the given object is stable in the world False else
    """
    world, world_id = _world_and_id(world)
    shadow_obj = BulletWorld.current_bullet_world.get_shadow_object(object)
    with Use_shadow_world():
        coords_prev = shadow_obj.pose.position_as_list()
        state = p.saveState(physicsClientId=BulletWorld.current_bullet_world.client_id)
        p.setGravity(0, 0, -9.8, BulletWorld.current_bullet_world.client_id)

        # one Step is approximately 1/240 seconds
        BulletWorld.current_bullet_world.simulate(2)
        # coords_past = p.getBasePositionAndOrientation(object.id, physicsClientId=world_id)[0]
        coords_past = shadow_obj.pose.position_as_list()

        # p.restoreState(state, physicsClientId=BulletWorld.current_bullet_world.client_id)
        coords_prev = list(map(lambda n: round(n, 3), coords_prev))
        coords_past = list(map(lambda n: round(n, 3), coords_past))
        return coords_past == coords_prev


def contact(object1: Object,
            object2: Object,
            return_links: bool = False) -> Union[bool, Tuple[bool, List]]:
    """
    Checks if two objects are in contact or not. If the links should be returned then the output will also contain a
    list of tuples where the first element is the link name of 'object1' and the second element is the link name of
    'object2'.

    :param object1: The first object
    :param object2: The second object
    :param return_links: If the respective links on the objects that are in contact should be returned.
    :return: True if the two objects are in contact False else. If links should be returned a list of links in contact
    """

    with Use_shadow_world():
        shadow_obj1 = BulletWorld.current_bullet_world.get_shadow_object(object1)
        shadow_obj2 = BulletWorld.current_bullet_world.get_shadow_object(object2)
        p.performCollisionDetection(BulletWorld.current_bullet_world.client_id)
        con_points = p.getContactPoints(shadow_obj1.id, shadow_obj2.id,
                                        physicsClientId=BulletWorld.current_bullet_world.client_id)

        if return_links:
            contact_links = []
            for point in con_points:
                contact_links.append((shadow_obj1.get_link_by_id(point[3]), shadow_obj2.get_link_by_id(point[4])))
            return con_points != (), contact_links

        else:
            return con_points != ()


def visible(object: Object,
            camera_pose: Pose,
            front_facing_axis: Optional[List[float]] = None,
            threshold: float = 0.8,
            world: Optional[BulletWorld] = None) -> bool:
    """
    Checks if an object is visible from a given position. This will be achieved by rendering the object
    alone and counting the visible pixel, then rendering the complete scene and compare the visible pixels with the
    absolut count of pixels.

    :param object: The object for which the visibility should be checked
    :param camera_pose: The pose of the camera in map frame
    :param front_facing_axis: The axis, of the camera frame, which faces to the front of the robot. Given as list of xyz
    :param threshold: The minimum percentage of the object that needs to be visible for this method to return true
    :param world: The BulletWorld if more than one BulletWorld is active
    :return: True if the object is visible from the camera_position False if not
    """
    front_facing_axis = robot_description.front_facing_axis if not front_facing_axis else front_facing_axis
    with Use_shadow_world():
        shadow_obj = BulletWorld.current_bullet_world.get_shadow_object(object)
        if BulletWorld.robot:
            shadow_robot = BulletWorld.current_bullet_world.get_shadow_object(BulletWorld.robot)
        state = p.saveState(physicsClientId=BulletWorld.current_bullet_world.client_id)
        for obj in BulletWorld.current_bullet_world.objects:
            if obj == shadow_obj or BulletWorld.robot and obj == shadow_robot:
                continue
            else:
                obj.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))

        world_to_cam = camera_pose.to_transform("camera")
        cam_to_point = Transform(list(np.multiply(front_facing_axis, 2)), [0, 0, 0, 1], "camera", "point")
        target_point = (world_to_cam * cam_to_point).to_pose()
        # target_point = p.multiplyTransforms(world_to_cam.translation_as_list(), world_to_cam.rotation_as_list(), cam_to_point.translation_as_list(), [0, 0, 0, 1])
        # print(target_point)

        seg_mask = _get_images_for_target(target_point, world_to_cam.to_pose(), BulletWorld.current_bullet_world)[2]
        flat_list = list(itertools.chain.from_iterable(seg_mask))
        max_pixel = sum(list(map(lambda x: 1 if x == shadow_obj.id else 0, flat_list)))
        p.restoreState(state, physicsClientId=BulletWorld.current_bullet_world.client_id)
        if max_pixel == 0:
            # Object is not visible
            return False

        seg_mask = _get_images_for_target(target_point, world_to_cam.to_pose(), BulletWorld.current_bullet_world)[2]
        flat_list = list(itertools.chain.from_iterable(seg_mask))
        real_pixel = sum(list(map(lambda x: 1 if x == shadow_obj.id else 0, flat_list)))

        return real_pixel / max_pixel > threshold > 0


def occluding(object: Object,
              camera_pose: Pose,
              front_facing_axis: Optional[List[float]] = None,
              world: Optional[BulletWorld] = None) -> List[Object]:
    """
    Lists all objects which are occluding the given object. This works similar to 'visible'.
    First the object alone will be rendered and the position of the pixels of the object in the picture will be saved.
    After that the complete scene will be rendered and the previous saved pixel positions will be compared to the
    actual pixels, if in one pixel another object is visible ot will be saved as occluding.

    :param object: The object for which occlusion should be checked
    :param camera_pose: The pose of the camera in world coordinate frame
    :param front_facing_axis: The axis, of the camera frame, which faces to the front of the robot. Given as list of xyz
    :param world: The BulletWorld if more than one BulletWorld is active
    :return: A list of occluding objects
    """
    front_facing_axis = robot_description.front_facing_axis if not front_facing_axis else front_facing_axis
    world, world_id = _world_and_id(world)
    # occ_world = world.copy()
    # state = p.saveState(physicsClientId=occ_world.client_id)
    with Use_shadow_world():
        state = p.saveState(physicsClientId=BulletWorld.current_bullet_world.client_id)
        for obj in BulletWorld.current_bullet_world.objects:
            if obj.name == BulletWorld.robot.name:
                continue
            elif object.get_pose() == obj.get_pose():
                object = obj
            else:
                obj.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))

        world_to_cam = camera_pose.to_transform("camera")
        cam_to_point = Transform(list(np.multiply(front_facing_axis, 2)), [0, 0, 0, 1], "camera", "point")
        target_point = (world_to_cam * cam_to_point).to_pose()

        seg_mask = _get_images_for_target(target_point, world_to_cam.to_pose(), BulletWorld.current_bullet_world)[2]

        # All indices where the object that could be occluded is in the image
        # [0] at the end is to reduce by one dimension because dstack adds an unnecessary dimension
        pix = np.dstack((seg_mask == object.id).nonzero())[0]

        p.restoreState(state, physicsClientId=BulletWorld.current_bullet_world.client_id)

        occluding = []
        seg_mask = _get_images_for_target(target_point, world_to_cam.to_pose(), BulletWorld.current_bullet_world)[2]
        for c in pix:
            if not seg_mask[c[0]][c[1]] == object.id:
                occluding.append(seg_mask[c[0]][c[1]])

        occ_objects = list(set(map(BulletWorld.current_bullet_world.get_object_by_id, occluding)))
        occ_objects = list(map(world.get_bullet_object_for_shadow, occ_objects))

        return occ_objects


def reachable(pose: Union[Object, Pose],
              robot: Object,
              gripper_name: str,
              threshold: float = 0.01) -> bool:
    """
    Checks if the robot can reach a given position. To determine this the inverse kinematics are
    calculated and applied. Afterward the distance between the position and the given end effector is calculated, if
    it is smaller than the threshold the reasoning query returns True, if not it returns False.

    :param pose: The position and rotation or Object for which reachability should be checked or an Object
    :param robot: The robot that should reach for the position
    :param gripper_name: The name of the end effector
    :param threshold: The threshold between the end effector and the position.
    :return: True if the end effector is closer than the threshold to the target position, False in every other case
    """
    if type(pose) == Object:
        pose = pose.get_pose()

    shadow_robot = BulletWorld.current_bullet_world.get_shadow_object(robot)
    with Use_shadow_world():
        arm = "left" if gripper_name == robot_description.get_tool_frame("left") else "right"
        joints = robot_description.chains[arm].joints
        try:
            inv = request_ik(pose, shadow_robot, joints, gripper_name)
        except IKError as e:
            return False

        _apply_ik(shadow_robot, inv, joints)

        diff = pose.dist(shadow_robot.get_link_pose(gripper_name))

    return diff < threshold


def blocking(pose_or_object: Union[Object, Pose],
             robot: Object,
             gripper_name: str,
             grasp: str = None) -> Union[List[Object], None]:
    """
    Checks if any objects are blocking another object when a robot tries to pick it. This works
    similar to the reachable predicate. First the inverse kinematics between the robot and the object will be calculated
    and applied. Then it will be checked if the robot is in contact with any object except the given one. If the given
    pose or Object is not reachable None will be returned

    :param pose_or_object: The object or pose for which blocking objects should be found
    :param robot: The robot Object who reaches for the object
    :param gripper_name: The name of the end effector of the robot
    :param grasp: The grasp type with which the object should be grasped
    :return: A list of objects the robot is in collision with when reaching for the specified object or None if the pose
    or object is not reachable.
    """
    if type(pose_or_object) == Object:
        input_pose = pose_or_object.get_pose()
    else:
        input_pose = pose_or_object

    shadow_robot = BulletWorld.current_bullet_world.get_shadow_object(robot)
    with Use_shadow_world():
        arm = "left" if gripper_name == robot_description.get_tool_frame("left") else "right"
        joints = robot_description.chains[arm].joints
        local_transformer = LocalTransformer()

        target_map = local_transformer.transform_pose(input_pose, "map")
        if grasp:
            grasp_orientation = robot_description.grasps.get_orientation_for_grasp(grasp)
            target_map.orientation.x = grasp_orientation[0]
            target_map.orientation.y = grasp_orientation[1]
            target_map.orientation.z = grasp_orientation[2]
            target_map.orientation.w = grasp_orientation[3]

        try:
            inv = request_ik(target_map, shadow_robot, joints, gripper_name)
        except IKError as e:
            rospy.logerr(f"Pose is not reachable: {e}")
            return None
        _apply_ik(shadow_robot, inv, joints)

        block = []
        for obj in BulletWorld.current_bullet_world.objects:
            if contact(shadow_robot, obj):
                block.append(BulletWorld.current_bullet_world.get_bullet_object_for_shadow(obj))
    return block


def supporting(object1: Object,
               object2: Object) -> bool:
    """
    Checks if one object is supporting another object. An object supports another object if they are in
    contact and the second object is above the first one. (e.g. a Bottle will be supported by a table)

    :param object1: Object that is supported
    :param object2: Object that supports the first object
    :return: True if the second object is in contact with the first one and the second one ist above the first False else
    """
    return contact(object1, object2) and object2.get_position().z > object1.get_position().z


def link_pose_for_joint_config(object: Object, joint_config: Dict[str, float], link_name: str) -> Pose:
    """
    Returns the pose a link would be in if the given joint configuration would be applied to the object. This is done
    by using the respective object in the shadow world and applying the joint configuration to this one. After applying
    the joint configuration the link position is taken from there.

    :param object: Object of which the link is a part
    :param joint_config: Dict with the goal joint configuration
    :param link_name: Name of the link for which the pose should be returned
    :return: The pose of the link after applying the joint configuration
    """
    shadow_object = BulletWorld.current_bullet_world.get_shadow_object(object)
    with Use_shadow_world():
        for joint, pose in joint_config.items():
            shadow_object.set_joint_state(joint, pose)
        return shadow_object.get_link_pose(link_name)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/local_transformer.py
import sys
import logging

import tf

if 'bullet_world' in sys.modules:
    logging.warning("(publisher) Make sure that you are not loading this module from pycram.bullet_world.")
import rospkg
import rospy
import atexit

from threading import Thread, currentThread
from tf import TransformerROS, transformations
from rospy import Duration, logerr, Rate, is_shutdown
from urdf_parser_py.urdf import URDF

from geometry_msgs.msg import TransformStamped
from .pose import Pose, Transform
from .robot_descriptions import robot_description
from typing import List, Optional, Tuple, Union, Callable


class LocalTransformer(TransformerROS):
    """
    This class allows to use the TF class TransformerROS without using the ROS
    network system or the topic /tf, where transforms are usually published to.
    Instead, a local transformer is saved and allows to publish local transforms,
    as well the use of TFs convenient lookup functions (see functions below).

    This class uses the robots (currently only one! supported) URDF file to
    initialize the tfs for the robot. Moreover, the function update_local_transformer_from_btr
    updates these tfs by copying the tfs state from the pybullet world.

    This class extends the TransformerRos, you can find documentation for TransformerROS here:
    `TFDoc <http://wiki.ros.org/tf/TfUsingPython>`_
    """

    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized: return
        super().__init__(interpolate=True, cache_time=Duration(10))

        # TF tf_stampeds and static_tf_stampeds of the Robot in the BulletWorld:
        # These are initialized with the function init_transforms_from_urdf and are
        # used to update the local transformer with the function update_local_transformer_from_btr
        self.tf_stampeds: List[TransformStamped] = []
        self.static_tf_stampeds: List[TransformStamped] = []

        # Since this file can't import bullet_world.py this holds the reference to the current_bullet_world
        self.bullet_world = None
        self.shadow_world = None

        # If the singelton was already initialized
        self._initialized = True

    def update_objects_for_current_world(self) -> None:
        """
        Updates transformations for all objects that are currently in :py:attr:`~pycram.bullet_world.BulletWorld.current_bullet_world`
        """
        curr_time = rospy.Time.now()
        for obj in list(self.bullet_world.current_bullet_world.objects):
            self.update_transforms_for_object(obj, curr_time)

    def transform_pose(self, pose: Pose, target_frame: str) -> Union[Pose, None]:
        """
        Transforms a given pose to the target frame.

        :param pose: Pose that should be transformed
        :param target_frame: Name of the TF frame into which the Pose should be transformed
        :return: A transformed pose in the target frame
        """
        self.update_objects_for_current_world()
        copy_pose = pose.copy()
        copy_pose.header.stamp = rospy.Time(0)
        if not self.canTransform(target_frame, pose.frame, rospy.Time(0)):
            rospy.logerr(
                f"Can not transform pose: \n {pose}\n to frame: {target_frame}.\n Maybe try calling 'update_transforms_for_object'")
            return
        new_pose = super().transformPose(target_frame, copy_pose)

        copy_pose.pose = new_pose.pose
        copy_pose.header.frame_id = new_pose.header.frame_id
        copy_pose.header.stamp = rospy.Time.now()

        return Pose(*copy_pose.to_list(), frame=new_pose.header.frame_id)

    def transform_to_object_frame(self, pose: Pose,
                                  bullet_object: 'bullet_world.Object', link_name: str = None) -> Union[Pose, None]:
        """
        Transforms the given pose to the coordinate frame of the given BulletWorld object. If no link name is given the
        base frame of the Object is used, otherwise the link frame is used as target for the transformation.

        :param pose: Pose that should be transformed
        :param bullet_object: BulletWorld Object in which frame the pose should be transformed
        :param link_name: A link of the BulletWorld Object which will be used as target coordinate frame instead
        :return: The new pose the in coordinate frame of the object
        """
        if link_name:
            target_frame = bullet_object.get_link_tf_frame(link_name)
        else:
            target_frame = bullet_object.tf_frame
        return self.transform_pose(pose, target_frame)

    def tf_transform(self, source_frame: str, target_frame: str,
                     time: Optional[rospy.rostime.Time] = None) -> Transform:
        """
        Returns the latest known transform between the 'source_frame' and 'target_frame'. If no time is given the last
        common time between the two frames is used.

        :param source_frame: Source frame of the transform
        :param target_frame: Target frame of the transform
        :param time: Time at which the transform should be
        :return:
        """
        self.update_objects_for_current_world()
        tf_time = time if time else self.getLatestCommonTime(source_frame, target_frame)
        translation, rotation = self.lookupTransform(source_frame, target_frame, tf_time)
        return Transform(translation, rotation, source_frame, target_frame)

    def update_transforms_for_object(self, bullet_object: 'bullet_world.Object', time: rospy.Time = None) -> None:
        """
        Updates local transforms for a Bullet Object, this includes the base as well as all links

        :param bullet_object: Object for which the Transforms should be updated
        :param time: a specific time that should be used
        """
        time = time if time else rospy.Time.now()
        for transform in bullet_object._current_link_transforms.values():
            transform.header.stamp = time
            self.setTransform(transform)


    def get_all_frames(self) -> List[str]:
        """
        Returns all know coordinate frames as a list with human-readable entries.

        :return: A list of all know coordinate frames.
        """
        frames = self.allFramesAsString().split("\n")
        frames.remove("")
        return frames

    def transformPose(self, target_frame, ps) -> Pose:
        """
        Alias for :func:`~LocalTransformer.transform_pose` to avoid confusion since a similar method exists in the
        super class.

        :param target_frame: Frame into which the pose should be transformer
        :param ps: Pose that should be transformed
        :return: Input pose in the target_frame
        """
        return self.transform_pose(ps, target_frame)



##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/costmaps.py
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import numpy as np
import pybullet as p
import rospy
import matplotlib.pyplot as plt
from matplotlib import colors
import psutil
import time
from .bullet_world import BulletWorld, Use_shadow_world, Object
from .bullet_world_reasoning import _get_images_for_target
from nav_msgs.msg import OccupancyGrid, MapMetaData
from typing import Tuple, List, Union, Optional

from .local_transformer import LocalTransformer
from .pose import Pose


class Costmap:
    """
    The base class of all Costmaps which implements the visualization of costmaps
    in the BulletWorld.
    """

    def __init__(self, resolution: float,
                 height: int,
                 width: int,
                 origin: Pose,
                 map: np.ndarray):
        """
        The constructor of the base class of all Costmaps.

        :param resolution: The distance in metre in the real world which is represented by a single entry in the costmap.
        :param height: The height of the costmap.
        :param width: The width of the costmap.
        :param origin: The origin of the costmap, in world coordinate frame. The origin of the costmap is located in the centre of the costmap
        :param map: The costmap represents as a 2D numpy array.
        """
        self.resolution: float = resolution
        self.size: int = height
        self.height: int = height
        self.width: int = width
        local_transformer = LocalTransformer()
        self.origin: Pose = local_transformer.transform_pose(origin, 'map')
        self.map: np.ndarray = map
        self.vis_ids: List[int] = []

    def visualize(self) -> None:
        """
        Visualizes a costmap in the BulletWorld, the visualisation works by
        subdividing the costmap in rectangles which are then visualized as pybullet
        visual shapes.
        """
        if self.vis_ids != []:
            return

        # working on a copy of the costmap, since found rectangles are deleted
        map = np.copy(self.map)
        curr_width = 0
        curr_height = 0
        curr_pose = []
        boxes = []
        # Finding all rectangles in the costmap
        for i in range(0, map.shape[0]):
            for j in range(0, map.shape[1]):
                if map[i][j] > 0:
                    curr_width = self._find_consectuive_line((i, j), map)
                    curr_pose = (i, j)
                    curr_height = self._find_max_box_height((i, j), curr_width, map)
                    avg = np.average(map[i:i + curr_height, j:j + curr_width])
                    boxes.append([curr_pose, curr_height, curr_width, avg])
                    map[i:i + curr_height, j:j + curr_width] = 0
        cells = []
        # Creation of the visual shapes, for documentation of the visual shapes
        # please look here: https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit#heading=h.q1gn7v6o58bf
        for box in boxes:
            visual = p.createVisualShape(p.GEOM_BOX,
                                         halfExtents=[(box[1] * self.resolution) / 2, (box[2] * self.resolution) / 2,
                                                      0.001],
                                         rgbaColor=[1, 0, 0, 0.6],
                                         visualFramePosition=[(box[0][0] + box[1] / 2) * self.resolution,
                                                              (box[0][1] + box[2] / 2) * self.resolution, 0.])
            cells.append(visual)
        # Set to 127 for since this is the maximal amount of links in a multibody
        for cell_parts in self._chunks(cells, 127):
            # Dummy paramater since these are needed to spawn visual shapes as a
            # multibody.
            link_poses = [[0, 0, 0] for c in cell_parts]
            link_orientations = [[0, 0, 0, 1] for c in cell_parts]
            link_masses = [1.0 for c in cell_parts]
            link_parent = [0 for c in cell_parts]
            link_joints = [p.JOINT_FIXED for c in cell_parts]
            link_collision = [-1 for c in cell_parts]
            link_joint_axis = [[1, 0, 0] for c in cell_parts]
            # The position at which the multibody will be spawned. Offset such that
            # the origin referes to the centre of the costmap.
            # origin_pose = self.origin.position_as_list()
            # base_pose = [origin_pose[0] - self.height / 2 * self.resolution,
            #              origin_pose[1] - self.width / 2 * self.resolution, origin_pose[2]]

            offset = [[-self.height / 2 * self.resolution, -self.width / 2 * self.resolution, 0.05], [0, 0, 0, 1]]
            new_pose = p.multiplyTransforms(self.origin.position_as_list(), self.origin.orientation_as_list(),
                                            offset[0], offset[1])

            map_obj = p.createMultiBody(baseVisualShapeIndex=-1, linkVisualShapeIndices=cell_parts,
                                        basePosition=new_pose[0], baseOrientation=new_pose[1], linkPositions=link_poses,
                                        # [0, 0, 1, 0]
                                        linkMasses=link_masses, linkOrientations=link_orientations,
                                        linkInertialFramePositions=link_poses,
                                        linkInertialFrameOrientations=link_orientations, linkParentIndices=link_parent,
                                        linkJointTypes=link_joints, linkJointAxis=link_joint_axis,
                                        linkCollisionShapeIndices=link_collision)
            self.vis_ids.append(map_obj)

    def _chunks(self, lst: List, n: int) -> List:
        """
        Yield successive n-sized chunks from lst.

        :param lst: The list from which chunks should be yielded
        :param n: Size of the chunks
        :return: A list of size n from lst
        """
        for i in range(0, len(lst), n):
            yield lst[i:i + n]

    def close_visualization(self) -> None:
        """
        Removes the visualization from the BulletWorld.
        """
        for id in self.vis_ids:
            p.removeBody(id)
        self.vis_ids = []

    def _find_consectuive_line(self, start: Tuple[int, int], map: np.ndarray) -> int:
        """
        Finds the number of consecutive entries in the costmap which are greater
        than zero.

        :param start: The indices in the costmap from which the consecutive line should be found.
        :param map: The costmap in which the line should be found.
        :return: The length of the consecutive line of entries greater than zero.
        """
        width = map.shape[1]
        lenght = 0
        for i in range(start[1], width):
            if map[start[0]][i] > 0:
                lenght += 1
            else:
                return lenght
        return lenght

    def _find_max_box_height(self, start: Tuple[int, int], lenght: int, map: np.ndarray) -> int:
        """
        Finds the maximal height for a rectangle with a given width in a costmap.
        The method traverses one row at a time and checks if all entries for the
        given width are greater than zero. If an entry is less or equal than zero
        the height is returned.

        :param start: The indices in the costmap from which the method should start.
        :param length: The given width for the rectangle
        :param map: The costmap in which should be searched.
        :return: The height of the rectangle.
        """
        height, width = map.shape
        curr_height = 1
        for i in range(start[0], height):
            for j in range(start[1], start[1] + lenght):
                if map[i][j] <= 0:
                    return curr_height
            curr_height += 1
        return curr_height

    def merge(self, other_cm: Costmap) -> Costmap:
        """
        Merges the values of two costmaps and returns a new costmap that has for
        every cell the merged values of both inputs. To merge two costmaps they
        need to fulfill 3 constrains:

        1. They need to have the same size
        2. They need to have the same x and y coordinates in the origin
        3. They need to have the same resolution

        If any of these constrains is not fulfilled a ValueError will be raised.

        :param other_cm: The other costmap with which this costmap should be merged.
        :return: A new costmap that contains the merged values
        """
        if self.size != other_cm.size:
            raise ValueError("You can only merge costmaps of the same size.")
        elif self.origin.position.x != other_cm.origin.position.x or self.origin.position.y != other_cm.origin.position.y \
                or self.origin.orientation != other_cm.origin.orientation:
            raise ValueError("To merge costmaps, the x and y coordinate as well as the orientation must be equal.")
        elif self.resolution != other_cm.resolution:
            raise ValueError("To merge two costmaps their resolution must be equal.")
        new_map = np.zeros((self.height, self.width))
        # A nunpy array of the positions where both costmaps are greater than 0
        merge = np.logical_and(self.map > 0, other_cm.map > 0)
        new_map[merge] = self.map[merge] * other_cm.map[merge]
        new_map = (new_map / np.max(new_map)).reshape((self.height, self.width))
        return Costmap(self.resolution, self.height, self.width, self.origin, new_map)

    def __add__(self, other: Costmap) -> Costmap:
        """
        Overloading of the "+" operator for merging of Costmaps. Furthermore, checks if 'other' is actual a Costmap and
        raises a ValueError if this is not the case. Please check :func:`~Costmap.merge` for further information of merging.

        :param other: Another Costmap
        :return: A new Costmap that contains the merged values from this Costmap and the other Costmap
        """
        if isinstance(other, Costmap):
            return self.merge(other)
        else:
            raise ValueError(f"Can only combine two costmaps other type was {type(other)}")


class OccupancyCostmap(Costmap):
    """
    The occupancy Costmap represents a map of the environment where obstacles or
    positions which are inaccessible for a robot have a value of -1.
    """

    def __init__(self, distance_to_obstacle: float,
                 from_ros: Optional[bool] = False,
                 size: Optional[int] = 100,
                 resolution: Optional[float] = 0.02,
                 origin: Optional[Pose] = None):
        """
        Constructor for the Occupancy costmap, the actual costmap is received
        from the ROS map_server and wrapped by this class. Meta-data about the
        costmap is also received from the map_server.

        :param distance_to_obstacle: The distance by which the obstacles should be
            inflated. Meaning that obstacles in the costmap are growing bigger by this
            distance.
        :param from_ros: This determines if the Occupancy map should be created
            from the map provided by the ROS map_server or from the BulletWorld.
            If True then the map from the ROS map_server will be used otherwise
            the Occupancy map will be created from the BulletWorld.
        :param size: The length of the side of the costmap. The costmap will be created
            as a square. This will only be used if from_ros is False.
        :param resolution: The resolution of this costmap. This determines how much
            meter one pixel in the costmap represents. This is only used if from_ros
            is False.
        :param origin: This determines the origin of the costmap. The origin will
            be in the middle of the costmap. This parameter is only used if from_ros
            is False.
        """
        if from_ros:
            meta = self._get_map_metadata()
            self.original_map = np.reshape(self._get_map(), (meta.height, meta.width))
            self.meta_origin = [meta.origin.position.x, meta.origin.position.y, meta.origin.position.z]
            self.resolution = meta.resolution
            self.height = meta.height
            self.width = meta.width
            # Nunber of cells that have to be between a valid cell and an obstacle
            self.distance_obstacle = max(int(distance_to_obstacle / self.resolution), 1)
            Costmap.__init__(self, meta.resolution, meta.height, meta.width,
                             self._calculate_diff_origin(meta.height, meta.width),
                             np.rot90(np.flip(self._convert_map(self.original_map), 0)))
        else:
            self.size = size
            self.origin = Pose() if not origin else origin
            self.resolution = resolution
            self.distance_obstacle = max(int(distance_to_obstacle / self.resolution), 1)
            self.map = self._create_from_bullet(size, resolution)
            Costmap.__init__(self, resolution, size, size, self.origin, self.map)

    def _calculate_diff_origin(self, height: int, width: int) -> Pose:
        """
        Calculates the difference between the origin of the costmap
        as stated by the meta-data and the actual middle of the costmap which
        is used by PyCRAM to visualize the costmap. The origin as stated by the
        meta-data refers to the position of the global coordinate frame with
        the bottom left corner as reference.

        :param height: The height of the costmap
        :param width: The width of the costmap
        :return: The difference between the actual origin and center of the costmap
        """
        actual_origin = [int(height / 2) * self.resolution, int(width / 2) * self.resolution, 0]
        origin = np.array(self.meta_origin) + np.array(actual_origin)
        return Pose(origin)

    @staticmethod
    def _get_map() -> np.ndarray:
        """
        Receives the map array from the map_server converts it and into a numpy array.

        :return: The costmap as a numpy array.
        """
        print("Waiting for Map")
        map = rospy.wait_for_message("/map", OccupancyGrid)
        print("Recived Map")
        return np.array(map.data)

    @staticmethod
    def _get_map_metadata() -> MapMetaData:
        """
        Receives the meta-data about the costmap from the map_server and returns it.
        The meta-data contains things like, height, width, origin and resolution.

        :return: The meta-data for the costmap array.
        """
        print("Waiting for Map Meta Data")
        meta = rospy.wait_for_message("/map_metadata", MapMetaData)
        print("Recived Meta Data")
        return meta

    def _convert_map(self, map: np.ndarray) -> np.ndarray:
        """
        Converts the Occupancy Map received from ROS to be more consistent
        with how PyCRAM handles its costmap. Every possible cell for a robot to stand
        is set to one while anything else is set to zero. Additionally, this method
        also takes into account the distance_to_obstacle parameter and sets cell values
        that are too close to an obstacle to 0.

        :param map: The map that should be converted. Represented as 2d numpy array
        :return: The converted map. Represented as 2d numpy array.
        """
        map = np.pad(map, (int(self.distance_obstacle / 2), int(self.distance_obstacle / 2)))

        sub_shape = (self.distance_obstacle, self.distance_obstacle)
        view_shape = tuple(np.subtract(map.shape, sub_shape) + 1) + sub_shape
        strides = map.strides + map.strides

        sub_matrices = np.lib.stride_tricks.as_strided(map, view_shape, strides)
        sub_matrices = sub_matrices.reshape(sub_matrices.shape[:-2] + (-1,))
        sum = np.sum(sub_matrices, axis=2)
        return (sum == 0).astype('int16')

    def create_sub_map(self, sub_origin: Pose, size: int) -> Costmap:
        """
        Creates a smaller map from the overall occupancy map, the new map is centered
        around the point specified by "sub_origin" and has the size "size". The
        resolution of the costmap stays the same for the sub costmap.

        :param sub_origin: The point in global coordinate frame, around which the sub costmap should be centered.
        :param size: The size the sub costmap should have.
        :return: The sub costmap, represented as 2d numpy array.
        """
        # To ensure this is a numpy array
        sub_origin = np.array(sub_origin.position_as_list())
        # Since origin obtained from the meta data uses bottom left corner as reference.
        sub_origin *= -1
        # Calculates origin of sub costmap as vector between origin and given sub_origin
        new_origin = np.array(self.meta_origin) + sub_origin
        # Convert from vector in meter to index values
        new_origin /= self.resolution
        new_origin = np.abs(new_origin)
        # Offset to top left corner, for easier slicing
        new_origin = (new_origin - size / 2).astype(int)

        # slices a submap with size "size" around the given origin
        sub_map = self.original_map[new_origin[1]: new_origin[1] + size,
                  new_origin[0]: new_origin[0] + size]
        # Convert map to fit with the other costmaps
        sub_map = np.rot90(np.flip(self._convert_map(sub_map), 0))
        return Costmap(self.resolution, size, size, Pose(list(sub_origin * -1)), sub_map)

    def _create_from_bullet(self, size: int, resolution: float) -> np.ndarray:
        """
        Creates an Occupancy Costmap for the specified BulletWorld.
        This map marks every position as valid that has no object above it. After
        creating the costmap the distance to obstacle parameter is applied.

        :param size: The size of this costmap. The size specifies the length of one side of the costmap. The costmap is created as a square.
        :param resolution: The resolution of this costmap. This determines how much meter a pixel in the costmap represents.
        """
        origin_position = self.origin.position_as_list()
        # Generate 2d grid with indices
        indices = np.concatenate(np.dstack(np.mgrid[int(-size / 2):int(size / 2), int(-size / 2):int(size / 2)]),
                                 axis=0) * resolution + np.array(origin_position[:2])
        # Add the z-coordinate to the grid, which is either 0 or 10
        indices_0 = np.pad(indices, (0, 1), mode='constant', constant_values=0)[:-1]
        indices_10 = np.pad(indices, (0, 1), mode='constant', constant_values=10)[:-1]
        # Zips both arrays such that there are tuples for every coordinate that
        # only differ in the z-coordinate
        rays = np.dstack(np.dstack((indices_0, indices_10))).T

        res = np.zeros(len(rays))
        # Using the PyBullet rayTest to check if there is an object above the position
        # if there is no object the position is marked as valid
        # 16383 is the maximal number of rays that can be processed in a batch
        i = 0
        j = 0
        for n in self._chunks(np.array(rays), 16380):
            with Use_shadow_world():
                r_t = p.rayTestBatch(n[:, 0], n[:, 1], numThreads=0,
                                     physicsClientId=BulletWorld.current_bullet_world.client_id)
                while r_t is None:
                    r_t = p.rayTestBatch(n[:, 0], n[:, 1], numThreads=0,
                                         physicsClientId=BulletWorld.current_bullet_world.client_id)
                j += len(n)
                if BulletWorld.robot:
                    shadow_robot = BulletWorld.current_bullet_world.get_shadow_object(BulletWorld.robot)
                    attached_objs = BulletWorld.robot.attachments.keys()
                    attached_objs_shadow_id = [BulletWorld.current_bullet_world.get_shadow_object(x).id for x in
                                               attached_objs]
                    res[i:j] = [
                        1 if ray[0] == -1 or ray[0] == shadow_robot.id or ray[0] in attached_objs_shadow_id else 0 for
                        ray in r_t]
                else:
                    res[i:j] = [1 if ray[0] == -1 else 0 for ray in r_t]
                i += len(n)

        res = np.flip(np.reshape(np.array(res), (size, size)))

        map = np.pad(res, (int(self.distance_obstacle / 2), int(self.distance_obstacle / 2)))

        sub_shape = (self.distance_obstacle * 2, self.distance_obstacle * 2)
        view_shape = tuple(np.subtract(map.shape, sub_shape) + 1) + sub_shape
        strides = map.strides + map.strides

        sub_matrices = np.lib.stride_tricks.as_strided(map, view_shape, strides)
        sub_matrices = sub_matrices.reshape(sub_matrices.shape[:-2] + (-1,))

        sum = np.sum(sub_matrices, axis=2)
        map = (sum == (self.distance_obstacle * 2) ** 2).astype('int16')
        # The map loses some size due to the strides and because I dont want to
        # deal with indices outside of the index range
        offset = self.size - map.shape[0]
        odd = 0 if offset % 2 == 0 else 1
        map = np.pad(map, (offset // 2, offset // 2 + odd))

        return np.flip(map)

    def _chunks(self, lst: List, n: int) -> List:
        """
        Yield successive n-sized chunks from lst.

        :param lst: The list from which chunks should be yielded
        :param n: Size of the chunks
        :return: A list of size n from lst
        """
        for i in range(0, len(lst), n):
            yield lst[i:i + n]


class VisibilityCostmap(Costmap):
    """
    A costmap that represents the visibility of a specific point for every position around
    this point. For a detailed explanation on how the creation of the costmap works
    please look here: `PhD Thesis (page 173) <https://mediatum.ub.tum.de/doc/1239461/1239461.pdf>`_
    """

    def __init__(self, min_height: float,
                 max_height: float,
                 size: Optional[int] = 100,
                 resolution: Optional[float] = 0.02,
                 origin: Optional[Pose] = None,
                 world: Optional[BulletWorld] = None):
        """
        Visibility Costmaps show for every position around the origin pose if the origin can be seen from this pose.
        The costmap is able to deal with height differences of the camera while in a single position, for example, if
        the robot has a movable torso.

        :param min_height: This is the minimal height the camera can be. This parameter
            is mostly relevant if the vertical position of the camera can change.
        :param max_height: This is the maximal height the camera can be. This is
            mostly relevant if teh vertical position of the camera can change.
        :param size: The length of the side of the costmap, the costmap is created
            as a square.
        :param resolution: This parameter specifies how much meter a pixel in the
            costmap represents.
        :param origin: The pose in world coordinate frame around which the
            costmap should be created.
        :param world: The BulletWorld for which the costmap should be created.
        """
        if (11 * size ** 2 + size ** 3) * 2 > psutil.virtual_memory().available:
            raise OSError("Not enough free RAM to calculate a costmap of this size")

        self.world = world if world else BulletWorld.current_bullet_world
        self.map = np.zeros((size, size))
        self.size = size
        self.resolution = resolution
        # for pr2 = 1.27
        self.max_height: float = max_height
        # for pr2 = 1.6
        self.min_height: float = min_height
        self.origin: Pose = Pose() if not origin else origin
        self._generate_map()
        Costmap.__init__(self, resolution, size, size, self.origin, self.map)

    def _create_images(self) -> List[np.ndarray]:
        """
        Creates four depth images in every direction around the point
        for which the costmap should be created. The depth images are converted
        to metre, meaning that every entry in the depth images represents the
        distance to the next object in metre.

        :return: A list of four depth images, the images are represented as 2D arrays.
        """
        images = []
        camera_pose = self.origin

        with Use_shadow_world():
            origin_copy = self.origin.copy()
            origin_copy.position.y += 1
            images.append(
                _get_images_for_target(origin_copy, camera_pose, BulletWorld.current_bullet_world, size=self.size)[1])

            origin_copy = self.origin.copy()
            origin_copy.position.x -= 1
            images.append(
                _get_images_for_target(origin_copy, camera_pose, BulletWorld.current_bullet_world, size=self.size)[1])

            origin_copy = self.origin.copy()
            origin_copy.position.y -= 1
            images.append(
                _get_images_for_target(origin_copy, camera_pose, BulletWorld.current_bullet_world, size=self.size)[1])

            origin_copy = self.origin.copy()
            origin_copy.position.x += 1
            images.append(
                _get_images_for_target(origin_copy, camera_pose, BulletWorld.current_bullet_world, size=self.size)[1])

        for i in range(0, 4):
            images[i] = self._depth_buffer_to_meter(images[i])
        return images

    def _depth_buffer_to_meter(self, buffer: np.ndarray) -> np.ndarray:
        """
        Converts the depth images generated by PyBullet to represent
        each position in metre.

        :return: The depth image in metre
        """
        near = 0.2
        far = 100
        return far * near / (far - (far - near) * buffer)

    def _generate_map(self):
        """
        This method generates the resulting density map by using the algorithm explained
        in Lorenz Mösenlechners `PhD Thesis (page 178) <https://mediatum.ub.tum.de/doc/1239461/1239461.pdf>`_
        The resulting map is then saved to :py:attr:`self.map`
        """
        depth_imgs = self._create_images()
        # A 2D array where every cell contains the arctan2 value with respect to
        # the middle of the array. Additionally, the interval is shifted such that
        # it is between 0 and 2pi
        tan = np.arctan2(np.mgrid[-int(self.size / 2): int(self.size / 2), -int(self.size / 2): int(self.size / 2)][0],
                         np.mgrid[-int(self.size / 2): int(self.size / 2), -int(self.size / 2): int(self.size / 2)][
                             1]) + np.pi
        res = np.zeros(tan.shape)

        # Just for completion, since the res array has zeros in every position this
        # operation is not necessary.
        # res[np.logical_and(tan <= np.pi * 0.25, tan >= np.pi * 1.75)] = 0

        # Creates a 2D array which contains the index of the depth image for every
        # coordinate
        res[np.logical_and(tan >= np.pi * 1.25, tan <= np.pi * 1.75)] = 3
        res[np.logical_and(tan >= np.pi * 0.75, tan < np.pi * 1.25)] = 2
        res[np.logical_and(tan >= np.pi * 0.25, tan < np.pi * 0.75)] = 1

        indices = np.dstack(np.mgrid[0: self.size, 0: self.size])
        depth_indices = np.zeros(indices.shape)
        # x-value of index: res == n, :1
        # y-value of index: res == n, 1:2

        # (y, size-x-1) for index between 1.25 pi and 1.75 pi
        depth_indices[res == 3, :1] = indices[res == 3, 1:2]
        depth_indices[res == 3, 1:2] = self.size - indices[res == 3, :1] - 1

        # (size-x-1, y) for index between 0.75 pi and 1.25 pi
        depth_indices[res == 2, :1] = self.size - indices[res == 2, :1] - 1
        depth_indices[res == 2, 1:2] = indices[res == 2, 1:2]

        # (size-y-1, x) for index between 0.25 pi and 0.75 pi
        depth_indices[res == 1, :1] = self.size - indices[res == 1, 1:2] - 1
        depth_indices[res == 1, 1:2] = indices[res == 1, :1]

        # (x, y) for index between 0.25 pi and 1.75 pi
        depth_indices[res == 0, :1] = indices[res == 0, :1]
        depth_indices[res == 0, 1:2] = indices[res == 0, 1:2]

        # Convert back to origin in the middle of the costmap
        depth_indices[:, :, :1] -= self.size / 2
        depth_indices[:, :, 1:2] = np.absolute(self.size / 2 - depth_indices[:, :, 1:2])

        # Sets the y index for the coordinates of the middle of the costmap to 1,
        # the computed value is 0 which would cause an error in the next step where
        # the calculation divides the x coordinates by the y coordinates
        depth_indices[int(self.size / 2), int(self.size / 2), 1] = 1

        # Calculate columns for the respective position in the costmap
        columns = np.around(((depth_indices[:, :, :1] / depth_indices[:, :, 1:2]) \
                             * (self.size / 2)) + self.size / 2).reshape((self.size, self.size)).astype('int16')

        # An array with size * size that contains the euclidean distance to the
        # origin (in the middle of the costmap) from every cell
        distances = np.maximum(np.linalg.norm(np.dstack(np.mgrid[-int(self.size / 2): int(self.size / 2), \
                                                        -int(self.size / 2): int(self.size / 2)]), axis=2), 0.001)

        # Row ranges
        # Calculation of the ranges of coordinates in the row which have to be
        # taken into account. The range is from r_min to r_max.
        # These are two arrays with shape: size*size, the r_min constrains the beginning
        # of the range for every coordinate and r_max contains the end for each
        # coordinate
        r_min = (np.arctan((self.min_height - self.origin.position.z) / distances) * self.size) + self.size / 2
        r_max = (np.arctan((self.max_height - self.origin.position.z) / distances) * self.size) + self.size / 2

        r_min = np.minimum(np.around(r_min), self.size - 1).astype('int16')
        r_max = np.minimum(np.around(r_max), self.size - 1).astype('int16')

        rs = np.dstack((r_min, r_max + 1)).reshape((self.size ** 2, 2))
        r = np.arange(self.size)
        # Calculates a mask from the r_min and r_max values. This mask is for every
        # coordinate respectively and determines which values from the computed column
        # of the depth image should be taken into account for the costmap.
        # A Mask of a single coordinate has the length of the column of the depth image
        # and together with the computed column at this coordinate determines which
        # values of the depth image make up the value of the visibility costmap at this
        # point.
        mask = ((rs[:, 0, None] <= r) & (rs[:, 1, None] > r)).reshape((self.size, self.size, self.size))

        values = np.zeros((self.size, self.size))
        map = np.zeros((self.size, self.size))
        # This is done to iterate over the depth images one at a time
        for i in range(4):
            row_masks = mask[res == i].T
            # This statement does several things, first it takes the values from
            # the depth image for this quarter of the costmap. The values taken are
            # the complete columns of the depth image (which where computed beforehand)
            # and checks if the values in them are greater than the distance to the
            # respective coordinates. This does not take the row ranges into account.
            values = depth_imgs[i][:, columns[res == i].flatten()] > \
                     np.tile(distances[res == i][:, None], (1, self.size)).T * self.resolution
            # This applies the created mask of the row ranges to the values of
            # the columns which are compared in the previous statement
            masked = np.ma.masked_array(values, mask=~row_masks)
            # The calculated values are added to the costmap
            map[res == i] = np.sum(masked, axis=0)
        map /= np.max(map)
        # Weird flipping shit so that the map fits the orientation of the visualization.
        # the costmap in itself is consistent and just needs to be flipped to fit the world coordinate system
        map = np.flip(map, axis=0)
        map = np.flip(map)
        self.map = map


class GaussianCostmap(Costmap):
    """
    Gaussian Costmaps are 2D gaussian distributions around the origin with the given mean and sigma
    """

    def __init__(self, mean: int, sigma: float, resolution: Optional[float] = 0.02,
                 origin: Optional[Pose] = None):
        """
        This Costmap creates a 2D gaussian distribution around the origin with
        the specified size.

        :param mean: The mean input for the gaussian distribution, this also specifies
            the length of the side of the resulting costmap. The costmap is Created
            as a square.
        :param sigma: The sigma input for the gaussian distribution.
        :param resolution: The resolution of the costmap, this specifies how much
            meter a pixel represents.
        :param origin: The origin of the costmap around which it will be created.
        """
        self.gau: np.ndarray = self._gaussian_window(mean, sigma)
        self.map: np.ndarray = np.outer(self.gau, self.gau)
        self.size: float = mean
        self.origin: Pose = Pose() if not origin else origin
        Costmap.__init__(self, resolution, mean, mean, self.origin, self.map)

    def _gaussian_window(self, mean: int, std: float) -> np.ndarray:
        """
        This method creates a window of values with a gaussian distribution of
        size "mean" and standart deviation "std".
        Code from `Scipy <https://github.com/scipy/scipy/blob/v0.14.0/scipy/signal/windows.py#L976>`_
        """
        n = np.arange(0, mean) - (mean - 1.0) / 2.0
        sig2 = 2 * std * std
        w = np.exp(-n ** 2 / sig2)
        return w


class SemanticCostmap(Costmap):
    """
    Semantic Costmaps represent a 2D distribution over a link of an Object. An example of this would be a Costmap for a
    table surface.
    """

    def __init__(self, object, urdf_link_name, size=100, resolution=0.02, world=None):
        """
        Creates a semantic costmap for the given parameter. The semantic costmap will be on top of the link of the given
        Object.

        :param object: The object of which the link is a part
        :param urdf_link_name: The link name, as stated in the URDF
        :param resolution: Resolution of the final costmap
        :param world: The BulletWorld from which the costmap should be created
        """
        self.world: BulletWorld = world if world else BulletWorld.current_bullet_world
        self.object: Object = object
        self.link: str = urdf_link_name
        self.resolution: float = resolution
        self.origin: Pose = object.get_link_pose(urdf_link_name)
        self.height: int = 0
        self.width: int = 0
        self.map: np.ndarray = []
        self.generate_map()

        Costmap.__init__(self, resolution, self.height, self.width, self.origin, self.map)

    def generate_map(self) -> None:
        """
        Generates the semantic costmap according to the provided parameters. To do this the axis aligned bounding box (AABB)
        for the link name will be used. Height and width of the final Costmap will be the x and y sizes of the AABB.
        """
        min, max = self.get_aabb_for_link()
        self.height = int((max[0] - min[0]) // self.resolution)
        self.width = int((max[1] - min[1]) // self.resolution)
        self.map = np.ones((self.height, self.width))

    def get_aabb_for_link(self) -> Tuple[List[float], List[float]]:
        """
        Returns the axis aligned bounding box (AABB) of the link provided when creating this costmap. To try and let the
        AABB as close to the actual object as possible, the Object will be rotated such that the link will be in the
        identity orientation.

        :return: Two points in world coordinate space, which span a rectangle
        """
        shadow_obj = BulletWorld.current_bullet_world.get_shadow_object(self.object)
        with Use_shadow_world():
            shadow_obj.set_orientation(Pose(orientation=[0, 0, 0, 1]))
            link_orientation = shadow_obj.get_link_pose(self.link)
            link_orientation_trans = link_orientation.to_transform(self.object.get_link_tf_frame(self.link))
            inverse_orientation = link_orientation_trans.invert()
            shadow_obj.set_orientation(inverse_orientation.to_pose())
            return shadow_obj.get_AABB(self.link)


cmap = colors.ListedColormap(['white', 'black', 'green', 'red', 'blue'])


# Mainly used for debugging
# Data is 2d array
def plot_grid(data: np.ndarray) -> None:
    """
    An auxiliary method only used for debugging, it will plot a 2D numpy array using MatplotLib.
    """
    rows = data.shape[0]
    cols = data.shape[1]
    fig, ax = plt.subplots()
    ax.imshow(data, cmap=cmap)
    # draw gridlines
    # ax.grid(which='major', axis='both', linestyle='-', color='k', linewidth=1)
    ax.set_xticks(np.arange(0.5, rows, 1));
    ax.set_yticks(np.arange(0.5, cols, 1));
    plt.tick_params(axis='both', labelsize=0, length=0)
    # fig.set_size_inches((8.5, 11), forward=False)
    # plt.savefig(saveImageName + ".png", dpi=500)
    plt.show()


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/plan_failures.py
class PlanFailure(Exception):
    """Implementation of plan failures."""

    def __init__(self, *args, **kwargs):
        """Create a new plan failure."""
        Exception.__init__(self, *args, **kwargs)


class NotALanguageExpression(PlanFailure):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class FailureDiagnosis(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class LowLevelFailure(FailureDiagnosis):
    """Failure thrown by low-level modules: robot or projection PMs."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ActionlibActionTimeout(LowLevelFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class HighLevelFailure(FailureDiagnosis):
    """Failure thrown by high-level modules, i.e. plans."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class DeliveringFailed(HighLevelFailure):
    """Thrown when delivering plan completely gives up."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ManipulationLowLevelFailure(LowLevelFailure):
    """Thrown when a low-level, i.e. hardware related, failure is detected in a manipulation action."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class EnvironmentManipulationGoalNotReached(ManipulationLowLevelFailure):
    """Thrown when door / drawer opening / closing goal is still not reached."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class EnvironmentManipulationImpossible(HighLevelFailure):
    """Thrown when environment manipulation cannot be achieved."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class EnvironmentUnreachable(HighLevelFailure):
    """Thrown when environment manipulation in collision or unreachable."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class FetchingFailed(HighLevelFailure):
    """Thrown when fetching plan completely gives up."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class GripperLowLevelFailure(LowLevelFailure):
    """Thrown when a failure involving the gripper hardware occurs."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class GripperClosedCompletely(GripperLowLevelFailure):
    """Thrown when the gripper closed completely, despite not being expected to do so (e.g. because it should have
    grasped something)."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class GripperGoalNotReached(GripperLowLevelFailure):
    """Thrown when the gripper does not reach its goal."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class LookingHighLevelFailure(HighLevelFailure):
    """High-level failure produced when looking for an object, i.e. it is not a hardware issue but one relating to
    the looking task, its parameters, and how they relate to the environment."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ManipulationGoalInCollision(HighLevelFailure):
    """Thrown when executing a manipulation action results in a collision."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ManipulationGoalNotReached(ManipulationLowLevelFailure):
    """Thrown when after executing the action, goal is still not reached."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class IKError(PlanFailure):
    """Thrown when no inverse kinematics solution could be found"""
    def __init__(self, pose, base_frame):
        self.message = "Position {} in frame '{}' is not reachable for end effector".format(pose, base_frame)
        super(IKError, self).__init__(self.message)


class ManipulationPoseUnreachable(ManipulationLowLevelFailure):
    """Thrown when no IK solution can be found."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationHighLevelFailure(HighLevelFailure):
    """High-level failure produced while navigating the robot, i.e. it is not a hardware issue but one relating to
    the navigation task, its parameters, and how they relate to the environment."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationGoalInCollision(NavigationHighLevelFailure):
    """Navigation goal cannot be reached because the goal itself is already occupied by some other object."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationLowLevelFailure(LowLevelFailure):
    """Low-level failure produced while navigating the robot, i.e. some kind of hardware issue."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationGoalNotReached(NavigationLowLevelFailure):
    """Thrown when the base moved as a result of the navigation action but the goal was not reached."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationPoseUnreachable(NavigationLowLevelFailure):
    """Thrown when the goal pose for navigation is computed to be unreachable."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectNowhereToBeFound(HighLevelFailure):
    """Thrown when the robot cannot find an object of a given description in its surroundings."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectUndeliverable(HighLevelFailure):
    """Thrown when no base positioning can assure a reachable pose to place the object from."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectUnfetchable(HighLevelFailure):
    """Thrown when no base positioning can assure a reachable pose to grasp the object from."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectUnreachable(HighLevelFailure):
    """Thrown when no IK found for particular base pose."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class PerceptionLowLevelFailure(LowLevelFailure):
    """Low-level failure produced while perceiving, i.e. some kind of hardware issue."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class PerceptionObjectNotFound(PerceptionLowLevelFailure):
    """Thrown when an attempt to find an object by perception fails -- and this can still be interpreted as the robot
    not looking in the right direction, as opposed to the object being absent."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class PerceptionObjectNotInWorld(PerceptionLowLevelFailure):
    """Thrown when an attempt to find an object by perception fails -- and this is because the object can be assumed
    absent or perhaps is known absent because of the setup of a simulation."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SearchingFailed(HighLevelFailure):
    """Thrown when searching plan completely gives up."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class TorsoLowLevelFailure(LowLevelFailure):
    """Low-level failure produced while moving the torso, i.e. some kind of hardware issue."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class TorsoGoalNotReached(TorsoLowLevelFailure):
    """Thrown when the torso moved as a result of a torso action but the goal was not reached."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class TorsoGoalUnreachable(TorsoLowLevelFailure):
    """Thrown when the goal for the torso is computed to be unreachable."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class Task(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class Grasping(Task):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class Looking(Task):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectPoseMisestimation(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SuccessfulCompletion(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectNotFound(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class LocomotorFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ArmFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectLost(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SensorFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class IllPosedGoalFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class CapabilityAbsenceFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ReachabilityFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class TorsoFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ConfigurationNotReached(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class Timeout(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class EndEffectorFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectUnavailable(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SustainedFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/pose.py
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import copy
import math
import datetime
from typing import List, Union, Optional

import numpy as np
import rospy
import sqlalchemy.orm
from geometry_msgs.msg import PoseStamped, TransformStamped, Vector3
from geometry_msgs.msg import (Pose as GeoPose, Quaternion as GeoQuaternion)
from std_msgs.msg import Header
from tf import transformations
from .orm.base import Pose as ORMPose, Position, Quaternion, ProcessMetaData


class Pose(PoseStamped):
    """
    Pose representation for PyCRAM, this class extends the PoseStamped ROS message from geometry_msgs. Thus making it
    compatible with every ROS service and message expecting a PoseStamped message.

    Naming convention for Poses:
        Pose: Instances of this class, representing a cartesian position and a quaternion for orientation

        Position: Only the cartesian position in xyz

        Orientation: Only the quaternion as xyzw
    """

    def __init__(self, position: Optional[List[float]] = None, orientation: Optional[List[float]] = None,
                 frame: str = "map", time: rospy.Time = None):
        """
        Poses can be initialized by a position and orientation given as lists, this is optional. By default, Poses are
        initialized with the position being [0, 0, 0], the orientation being [0, 0, 0, 1] and the frame being 'map'.

        :param position: An optional position of this Pose
        :param orientation: An optional orientation of this Pose
        :param frame: An optional frame in which this pose is
        :param time: The time at which this Pose is valid, as ROS time
        """
        super().__init__()
        if position:
            self.position = position

        if orientation:
            self.orientation = orientation
        else:
            self.pose.orientation.w = 1.0

        self.header.frame_id = frame

        self.header.stamp = time if time else rospy.Time.now()

        self.frame = frame

    @staticmethod
    def from_pose_stamped(pose_stamped: PoseStamped) -> Pose:
        """
        Converts a geometry_msgs/PoseStamped message to a Pose object. Should be used for compatability with ROS.

        :param pose_stamped: The pose stamped message which should be converted
        :return: A Pose object with the same information as the given message
        """
        p = Pose()
        p.header = pose_stamped.header
        p.pose = pose_stamped.pose
        return p

    @property
    def frame(self) -> str:
        """
        Property for the frame_id such that it is easier accessible. Instead of Pose.header.frame_id it is Pose.frame

        :return: The TF frame of this Pose
        """
        return self.header.frame_id

    @frame.setter
    def frame(self, value: str) -> None:
        """
        Sets the TF frame of this pose to the given new frame

        :param value: The new TF frame
        """
        self.header.frame_id = value

    @property
    def position(self) -> GeoPose:
        """
        Property that points to the position of this pose
        """
        return self.pose.position

    @position.setter
    def position(self, value) -> None:
        """
        Sets the position for this Pose, the position can either be a list of xyz or a geometry_msgs/Pose message.

        :param value: List or geometry_msgs/Pose message for the position
        """
        if not type(value) == list and not type(value) == tuple and not type(value) == GeoPose:
            print(type(value))
            rospy.logwarn("Position can only be a list or geometry_msgs/Pose")
            return
        if type(value) == list or type(value) == tuple and len(value) == 3:
            self.pose.position.x = value[0]
            self.pose.position.y = value[1]
            self.pose.position.z = value[2]
        else:
            self.pose.position = value

    @property
    def orientation(self) -> GeoQuaternion:
        """
        Property that points to the orientation of this pose
        """
        return self.pose.orientation

    @orientation.setter
    def orientation(self, value) -> None:
        """
        Sets the orientation of this Pose, the orientation can either be a list of xyzw or a geometry_msgs/Quaternion
        message

        :param value: New orientation, either a list or geometry_msgs/Quaternion
        """
        if not type(value) == list and not type(value) == tuple and not type(value) == GeoQuaternion:
            rospy.logwarn("Orientation can only be a list or geometry_msgs/Quaternion")
            return

        if type(value) == list or type(value) == tuple and len(value) == 4:
            orientation = np.array(value)
        else:
            orientation = np.array([value.x, value.y, value.z, value.w])
        # This is used instead of np.linalg.norm since numpy is too slow on small arrays
        mag = math.sqrt(sum(v**2 for v in orientation))
        normed_orientation = orientation / mag

        self.pose.orientation.x = normed_orientation[0]
        self.pose.orientation.y = normed_orientation[1]
        self.pose.orientation.z = normed_orientation[2]
        self.pose.orientation.w = normed_orientation[3]

    def to_list(self) -> List[List[float]]:
        """
        Returns the position and orientation of this pose as a list containing two list.

        :return: The position and orientation as lists
        """
        return [[self.pose.position.x, self.pose.position.y, self.pose.position.z],
                [self.pose.orientation.x, self.pose.orientation.y, self.pose.orientation.z, self.pose.orientation.w]]

    def to_transform(self, child_frame: str) -> Transform:
        """
        Converts this pose to a Transform from the TF frame of the pose to the given child_frame

        :param child_frame: Child frame id to which the Transform points
        :return: A new Transform
        """
        return Transform(self.position_as_list(), self.orientation_as_list(), self.frame, child_frame, self.header.stamp)

    def copy(self) -> Pose:
        """
        Creates a deep copy of this pose.

        :return: A copy of this pose
        """
        p = Pose(self.position_as_list(), self.orientation_as_list(), self.frame, self.header.stamp)
        p.header.frame_id = self.header.frame_id
        # p.header.stamp = self.header.stamp
        return p

    def position_as_list(self) -> List[float]:
        """
        Returns only the position as a list of xyz.

        :return: The position as a list
        """
        return [self.pose.position.x, self.pose.position.y, self.pose.position.z]

    def orientation_as_list(self) -> List[float]:
        """
        Returns only the orientation as a list of a quaternion

        :return: The orientation as a quaternion with xyzw
        """
        return [self.pose.orientation.x, self.pose.orientation.y, self.pose.orientation.z, self.pose.orientation.w]

    def dist(self, other_pose: Pose) -> float:
        """
        Calculates the euclidian distance between this Pose and the given one. For distance calculation only the
        position is used.

        :param other_pose: Pose to which the distance should be calculated
        :return: The distance between the Poses
        """
        self_position = self.position_as_list()
        other_position = other_pose.position_as_list()
        return np.linalg.norm(np.array(self_position) - np.array(other_position))

    def __eq__(self, other: Pose) -> bool:
        """
        Overloads the '==' operator to check for equality between two Poses. Only compares the position, orientation and
        frame. Timestamps of Poses are not takes into account.

        :param other: Other pose which should be compared
        :return: True if both Poses have the same position, orientation and frame. False otherwise
        """
        if not type(other) == Pose:
            return False
        self_position = self.position_as_list()
        other_position = other.position_as_list()

        self_orient = self.orientation_as_list()
        other_orient = other.orientation_as_list()

        return self_position == other_position and self_orient == other_orient and self.frame == other.frame

    def set_position(self, new_position: List[float]) -> None:
        """
        Sets the position of this Pose to the given position. Position has to be given as a vector in cartesian space.

        :param new_position: New position as a vector of xyz
        """
        self.position = new_position

    def set_orientation(self, new_orientation: List[float]) -> None:
        """
        Sets the orientation to the given quaternion. The new orientation has to be given as a quaternion.

        :param new_orientation: New orientation as a quaternion with xyzw
        """
        self.orientation = new_orientation

    def to_sql(self) -> ORMPose:
        return ORMPose(datetime.datetime.utcfromtimestamp(self.header.stamp.to_sec()), self.frame)

    def insert(self, session: sqlalchemy.orm.Session) -> ORMPose:

        metadata = ProcessMetaData().insert(session)

        position = Position(*self.position_as_list())
        position.process_metadata_id = metadata.id
        orientation = Quaternion(*self.orientation_as_list())
        orientation.process_metadata_id = metadata.id

        session.add(position)
        session.add(orientation)
        session.commit()
        pose = self.to_sql()
        pose.process_metadata_id = metadata.id
        pose.position_id = position.id
        pose.orientation_id = orientation.id

        session.add(pose)
        session.commit()

        return pose


class Transform(TransformStamped):
    """
    Represents a Transformation from one TF frame to another in PyCRAM. Like with Poses this class inherits from the ROS
    message TransformStamped form geometry_msgs and is therefore compatible with ROS services and messages that require
    a TransformStamped message.

    Naming Convention for Transforms:
        Transform: Instances of this class, representing a translation and rotation from frame_id to child_frame_id

        Translation: A vector representing the conversion in cartesian space

        Rotation: A quaternion representing the conversion of rotation between both frames
    """
    def __init__(self, translation: Optional[List[float]] = None, rotation: Optional[List[float]] = None,
                 frame: Optional[str] = "map", child_frame: Optional[str] = "", time: rospy.Time = None):
        """
        Transforms take a translation, rotation, frame and child_frame as optional arguments. If nothing is given the
        Transform will be initialized with [0, 0, 0] for translation, [0, 0, 0, 1] for rotation, 'map' for frame and an
        empty string for child_frame

        :param translation: Optional translation from frame to child_frame in cartesian space
        :param rotation: Optional rotation from frame to child frame given as quaternion
        :param frame: Origin TF frame of this Transform
        :param child_frame: Target frame for this Transform
        :param time: The time at which this Transform is valid, as ROS time
        """
        super().__init__()
        if translation:
            self.translation = translation

        if rotation:
            self.rotation = rotation
        else:
            self.transform.rotation.w = 1.0

        self.header.frame_id = frame
        self.child_frame_id = child_frame
        self.header.stamp = time if time else rospy.Time.now()

        self.frame = frame

    @staticmethod
    def from_transform_stamped(transform_stamped: TransformStamped) -> Transform:
        """
        Creates a Transform instance from a geometry_msgs/TransformStamped message. Should be used for compatibility with
        ROS.

        :param transform_stamped: The transform stamped message that should be converted
        :return: An Transform with the same information as the transform stamped message
        """
        t = Transform()
        t.header = transform_stamped.header
        t.child_frame_id = transform_stamped.child_frame_id
        t.transform = transform_stamped.transform

        return t

    @property
    def frame(self) -> str:
        """
        Property for the frame_id such that it is easier accessible. Instead of Pose.header.frame_id it is Pose.frame

        :return: The TF frame of this Pose
        """
        return self.header.frame_id

    @frame.setter
    def frame(self, value: str) -> None:
        """
        Sets the TF frame of this pose to the given new frame

        :param value: The new TF frame
        """
        self.header.frame_id = value

    @property
    def translation(self) -> None:
        """
        Property that points to the translation of this Transform
        """
        return self.transform.translation

    @translation.setter
    def translation(self, value) -> None:
        """
        Setter for the translation of this Transform, the new value can either be of type list or a
        geometry_msgs/Vector message.

        :param value: The new value for the translation, either a list or geometry_msgs/Vector3
        """
        if not type(value) == list and not type(value) == Vector3:
            rospy.logwarn("Value of a translation can only be a list of a geometry_msgs/Vector3")
            return
        if type(value) == list and len(value) == 3:
            self.transform.translation.x = value[0]
            self.transform.translation.y = value[1]
            self.transform.translation.z = value[2]
        else:
            self.transform.translation = value

    @property
    def rotation(self) -> None:
        """
        Property that points to the rotation of this Transform
        """
        return self.transform.rotation

    @rotation.setter
    def rotation(self, value):
        """
        Setter for the rotation of this Transform, the new value can either be a list or a geometry_msgs/Quaternion
        message

        :param value: The new value for the rotation, either a list or geometry_msgs/Quaternion
        """
        if not type(value) == list and not type(value) == GeoQuaternion:
            rospy.logwarn("Value of the rotation can only be a list or a geometry.msgs/Quaternion")
            return
        if type(value) == list and len(value) == 4:
            rotation = np.array(value)

        else:
            rotation = np.array([value.x, value.y, value.z, value.w])
        # This is used instead of np.linalg.norm since numpy is too slow on small arrays
        mag = math.sqrt(sum(v**2 for v in rotation))
        normed_rotation = rotation / mag

        self.transform.rotation.x = normed_rotation[0]
        self.transform.rotation.y = normed_rotation[1]
        self.transform.rotation.z = normed_rotation[2]
        self.transform.rotation.w = normed_rotation[3]

    def copy(self) -> Transform:
        """
        Creates a deep copy of this pose.

        :return: A copy of this pose
        """
        t = Transform(self.translation_as_list(), self.rotation_as_list(), self.frame, self.child_frame_id, self.header.stamp)
        t.header.frame_id = self.header.frame_id
        # t.header.stamp = self.header.stamp
        return t

    def translation_as_list(self) -> List[float]:
        """
        Returns the translation of this Transform as a list.

        :return: The translation as a list of xyz
        """
        return [self.transform.translation.x, self.transform.translation.y, self.transform.translation.z]

    def rotation_as_list(self) -> List[float]:
        """
        Returns the rotation of this Transform as a list representing a quaternion.

        :return: The rotation of this Transform as a list with xyzw
        """
        return [self.transform.rotation.x, self.transform.rotation.y, self.transform.rotation.z,
                self.transform.rotation.w]

    def to_pose(self) -> Pose:
        """
        Converts this Transform to a Pose, in this process the child_frame_id is lost.

        :return: A new pose with same translation as position and rotation as orientation
        """
        return Pose(self.translation_as_list(), self.rotation_as_list(), self.frame, self.header.stamp)

    def invert(self) -> Transform:
        """
        Inverts this Transform, the new Transform points from the child_frame_id to the frame_id

        :return: A new inverted Transform
        """
        transform = transformations.concatenate_matrices(transformations.translation_matrix(self.translation_as_list()),
                                                         transformations.quaternion_matrix(self.rotation_as_list()))
        inverse_transform = transformations.inverse_matrix(transform)
        translation = transformations.translation_from_matrix(inverse_transform)
        quaternion = transformations.quaternion_from_matrix(inverse_transform)
        return Transform(list(translation), list(quaternion), self.child_frame_id, self.header.frame_id, self.header.stamp)

    def __mul__(self, other: Transform) -> Union[Transform, None]:
        """
        Multiplies this Transform with another one. The resulting Transform points from the frame_id of this Transform
        to the child_frame_id of the other Transform.

        :param other: The Transform which should be multiplied with this one.
        :return: The resulting Transform from the multiplication
        """
        if not type(other) == Transform:
            rospy.logerr(f"Can only multiply two Transforms")
            return
        self_trans = transformations.translation_matrix(self.translation_as_list())
        self_rot = transformations.quaternion_matrix(self.rotation_as_list())
        self_mat = np.dot(self_trans, self_rot)

        other_trans = transformations.translation_matrix(other.translation_as_list())
        other_rot = transformations.quaternion_matrix(other.rotation_as_list())
        other_mat = np.dot(other_trans, other_rot)

        new_mat = np.dot(self_mat, other_mat)
        new_trans = transformations.translation_from_matrix(new_mat)
        new_rot = transformations.quaternion_from_matrix(new_mat)
        return Transform(list(new_trans), list(new_rot), self.frame, other.child_frame_id)

    def inverse_times(self, other_transform: Transform) -> Transform:
        """
        Like a 'minus' for Transforms, subtracts the other_transform from this one.

        :param other_transform: Transform which should be subtracted from this one
        :return: The resulting Transform form the calculation
        """
        inv = other_transform.invert()
        return self * inv

    def __eq__(self, other: Transform) -> bool:
        """
        Overloads the '==' operator to check for equality between two Transforms. Only compares the translation,
        rotation, frame and child frame. Timestamps of Poses are not takes into account.

        :param other: Other pose which should be compared
        :return: True if both Transforms have the same translation, rotation, frame and child frame. False otherwise
        """
        if not type(other) == Transform:
            return False
        self_position = self.translation_as_list()
        other_position = other.translation_as_list()

        self_orient = self.rotation_as_list()
        other_orient = other.rotation_as_list()

        return self_position == other_position and self_orient == other_orient and \
            self.frame == other.frame and self.child_frame_id == other.child_frame_id

    def set_translation(self, new_translation: List[float]) -> None:
        """
        Sets the translation of this Transform to the newly given one. Translation has to be a vector in cartesian space

        :param new_translation: The new translation as a vector with xyz.
        """
        self.translation = new_translation

    def set_rotation(self, new_rotation: List[float]) -> None:
        """
        Sets the rotation of this Transform to the newly given one. Rotation has to be a quaternion.

        :param new_rotation: The new rotation as a quaternion with xyzw
        """
        self.rotation = new_rotation




##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/ros/tf_broadcaster.py
import time
import rospy
import threading
import atexit

from ..pose import Pose
from ..bullet_world import BulletWorld
from tf2_msgs.msg import TFMessage


class TFBroadcaster:
    """
    Broadcaster that publishes TF frames for every object in the BulletWorld.
    """
    def __init__(self, projection_namespace="simulated", odom_frame="odom", interval=0.1):
        """
        The broadcaster prefixes all published TF messages with a projection namespace to distinguish between the TF
        frames from the simulation and the one from the real robot.

        :param projection_namespace: Name with which the TF frames should be prefixed
        :param odom_frame: Name of the statically published odom frame
        :param interval: Interval at which the TFs should be published, in seconds
        """
        self.world = BulletWorld.current_bullet_world

        self.tf_static_publisher = rospy.Publisher("/tf_static", TFMessage, queue_size=10)
        self.tf_publisher = rospy.Publisher("/tf", TFMessage, queue_size=10)
        self.thread = threading.Thread(target=self._publish, daemon=True)
        self.kill_event = threading.Event()
        self.interval = interval

        # Namespaces
        self.projection_namespace = projection_namespace
        self.odom_frame = odom_frame

        self.thread.start()

        atexit.register(self._stop_publishing)

    def update(self):
        """
        Updates the TFs for the static odom frame and all objects currently in the BulletWorld.
        """
        # Update static odom
        self._update_static_odom()
        # Update pose of objects which are possibly attached on the robot
        self._update_objects()

    def _update_objects(self) -> None:
        """
        Publishes the current pose of all objects in the BulletWorld. As well as the poses of all links of these objects.
        """
        for obj in self.world.objects:
            pose = obj.get_pose()
            pose.header.stamp = rospy.Time.now()
            self._publish_pose(obj.tf_frame, pose)
            for link in obj.links.keys():
                link_pose = obj.get_link_pose(link)
                link_pose.header.stamp = rospy.Time.now()
                self._publish_pose(obj.get_link_tf_frame(link), link_pose)

    def _update_static_odom(self) -> None:
        """
        Publishes a static odom frame to the tf_static topic.
        """
        self._publish_pose(self.odom_frame,
                           Pose([0, 0, 0], [0, 0, 0, 1]), static=True)

    def _publish_pose(self, child_frame_id: str, pose: Pose, static=False) -> None:
        """
        Publishes the given pose to the ROS TF topic. First the pose is converted to a Transform between pose.frame and
        the given child_frame_id. Afterward, the frames of the Transform are prefixed with the projection namespace.

        :param child_frame_id: Name of the TF frame which the pose points to
        :param pose: Pose that should be published
        :param static: If the pose should be published to the tf_static topic
        """
        frame_id = pose.frame
        if frame_id != child_frame_id:
            tf_stamped = pose.to_transform(child_frame_id)
            tf_stamped.frame = self.projection_namespace + "/" + tf_stamped.frame
            tf_stamped.child_frame_id = self.projection_namespace + "/" + tf_stamped.child_frame_id
            tf2_msg = TFMessage()
            tf2_msg.transforms.append(tf_stamped)
            if static:
                self.tf_static_publisher.publish(tf2_msg)
            else:
                self.tf_publisher.publish(tf2_msg)

    def _publish(self) -> None:
        """
        Constantly publishes the positions of all objects in the BulletWorld.
        """
        while not self.kill_event.is_set():
            self.update()
            time.sleep(self.interval)

    def _stop_publishing(self) -> None:
        """
        Called when the process ends, sets the kill_event which terminates the thread that publishes to the TF topic.
        """
        self.kill_event.set()
        self.thread.join()


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/ros/force_torque_sensor.py
import atexit
import time
import threading

import rospy
import pybullet as pb

from geometry_msgs.msg import WrenchStamped
from std_msgs.msg import Header
from..bullet_world import BulletWorld


class ForceTorqueSensor:
    """
    Simulated force-torque sensor for a joint with a given name.
    Reads simulated forces and torques at that joint from bullet_world and publishes geometry_msgs/Wrench messages
    to the given topic.
    """
    def __init__(self, joint_name, fts_topic="/pycram/fts", interval=0.1):
        """
        The given joint_name has to be part of :py:attr:`~pycram.bullet_world.BulletWorld.robot` otherwise a
        RuntimeError will be raised.

        :param joint_name: Name of the joint for which force-torque should be simulated
        :param fts_topic: Name of the ROS topic to which should be published
        :param interval: Interval at which the messages should be published, in seconds
        """
        self.world = BulletWorld.current_bullet_world
        self.fts_joint_idx = None
        self.joint_name = joint_name
        if joint_name in self.world.robot.joints.keys():
            self.fts_joint_idx = self.world.robot.joints[joint_name]
        else:
            raise RuntimeError(f"Could not register ForceTorqueSensor: Joint {joint_name} does not exist in robot object")
        pb.enableJointForceTorqueSensor(self.world.robot.id, self.fts_joint_idx, enableSensor=1)

        self.fts_pub = rospy.Publisher(fts_topic, WrenchStamped, queue_size=10)
        self.interval = interval
        self.kill_event = threading.Event()

        self.thread = threading.Thread(target=self._publish)
        self.thread.start()

        atexit.register(self._stop_publishing)

    def _publish(self) -> None:
        """
        Continuously publishes the force-torque values for the simulated joint. Values are published as long as the
        kill_event is not set.
        """
        seq = 0
        while not self.kill_event.is_set():
            current_joint_state = pb.getJointState(self.world.robot.id, self.fts_joint_idx)
            joint_ft = current_joint_state[2]
            h = Header()
            h.seq = seq
            h.stamp = rospy.Time.now()
            h.frame_id = self.joint_name

            wrench_msg = WrenchStamped()
            wrench_msg.header = h
            wrench_msg.wrench.force.x = joint_ft[0]
            wrench_msg.wrench.force.y = joint_ft[1]
            wrench_msg.wrench.force.z = joint_ft[2]

            wrench_msg.wrench.torque.x = joint_ft[3]
            wrench_msg.wrench.torque.y = joint_ft[4]
            wrench_msg.wrench.torque.z = joint_ft[5]

            self.fts_pub.publish(wrench_msg)
            seq += 1
            time.sleep(self.interval)

    def _stop_publishing(self) -> None:
        """
        Sets the kill_event and therefore terminates the Thread publishing the force-torque values as well as join the
        threads.
        """
        self.kill_event.set()
        self.thread.join()


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/ros/__init__.py


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/ros/robot_state_updater.py
import rospy
import threading
import atexit
import tf
import time 

from geometry_msgs.msg import TransformStamped
from sensor_msgs.msg import JointState
from pycram.bullet_world import BulletWorld
from pycram.robot_descriptions import robot_description
from pycram.pose import Transform, Pose


class RobotStateUpdater:
    """
    Updates the robot in the Bullet World with information of the real robot published to ROS topics.
    Infos used to update the robot are:
        * The current pose of the robot
        * The current joint state of the robot
    """

    def __init__(self, tf_topic: str, joint_state_topic: str):
        """
        The robot state updater uses a TF topic and a joint state topic to get the current state of the robot.

        :param tf_topic: Name of the TF topic, needs to publish geometry_msgs/TransformStamped
        :param joint_state_topic: Name of the joint state topic, needs to publish sensor_msgs/JointState
        """
        self.tf_listener = tf.TransformListener()
        time.sleep(1)
        self.tf_topic = tf_topic
        self.joint_state_topic = joint_state_topic

        self.tf_timer = rospy.Timer(rospy.Duration(0.1), self._subscribe_tf)
        self.joint_state_timer = rospy.Timer(rospy.Duration(0.1), self._subscribe_joint_state)

        

        atexit.register(self._stop_subscription)

    def _subscribe_tf(self, msg: TransformStamped) -> None:
        """
        Callback for the TF timer, will do a lookup of the transform between map frame and the robot base frame.

        :param msg: TransformStamped message published to the topic
        """
        trans, rot = self.tf_listener.lookupTransform("/map", robot_description.base_frame, rospy.Time(0))
        BulletWorld.robot.set_pose(Pose(trans, rot))

    def _subscribe_joint_state(self, msg: JointState) -> None:
        """
        Sets the current joint configuration of the robot in the bullet world to the configuration published on the topic.
        Since this uses rospy.wait_for_message which can have errors when used with threads there might be an attribute error 
        in the rospy implementation. 

        :param msg: JointState message published to the topic.
        """
        try:
            msg = rospy.wait_for_message(self.joint_state_topic, JointState)
            for name, position in zip(msg.name, msg.position):
                BulletWorld.robot.set_joint_state(name, position)
        except AttributeError:
            pass
        

    def _stop_subscription(self) -> None:
        """
        Stops the Timer for TF and joint states and therefore the updating of the robot in the bullet world.
        """
        self.tf_timer.shutdown()
        self.joint_state_timer.shutdown()


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/ros/viz_marker_publisher.py
import atexit
import threading
import time

from geometry_msgs.msg import Vector3
from std_msgs.msg import ColorRGBA

from pycram.bullet_world import BulletWorld, Object
from visualization_msgs.msg import MarkerArray, Marker
import rospy
import urdf_parser_py
from tf.transformations import quaternion_from_euler

from pycram.pose import Transform


class VizMarkerPublisher:
    """
    Publishes an Array of visualization marker which represent the situation in the Bullet World
    """
    def __init__(self, topic_name="/pycram/viz_marker", interval=0.1):
        """
        The Publisher creates an Array of Visualization marker with a Marker for each link of each Object in the Bullet
        World. This Array is published with a rate of interval.

        :param topic_name: The name of the topic to which the Visualization Marker should be published.
        :param interval: The interval at which the visualization marker should be published, in seconds.
        """
        self.topic_name = topic_name
        self.interval = interval

        self.pub = rospy.Publisher(self.topic_name, MarkerArray, queue_size=10)

        self.thread = threading.Thread(target=self._publish)
        self.kill_event = threading.Event()
        self.thread.start()

        atexit.register(self._stop_publishing)

    def _publish(self) -> None:
        """
        Constantly publishes the Marker Array. To the given topic name at a fixed rate.
        """
        while not self.kill_event.is_set():
            marker_array = self._make_marker_array()

            self.pub.publish(marker_array)
            time.sleep(self.interval)

    def _make_marker_array(self) -> MarkerArray:
        """
        Creates the Marker Array to be published. There is one Marker for link for each object in the Array, each Object
        creates a name space in the visualization Marker. The type of Visualization Marker is decided by the collision
        tag of the URDF.

        :return: An Array of Visualization Marker
        """
        marker_array = MarkerArray()
        for obj in BulletWorld.current_bullet_world.objects:
            if obj.name == "floor":
                continue
            for link in obj.links.keys():
                geom = obj.link_to_geometry[link]
                if not geom:
                    continue
                msg = Marker()
                msg.header.frame_id = "map"
                msg.ns = obj.name
                msg.id = obj.links[link]
                msg.type = Marker.MESH_RESOURCE
                msg.action = Marker.ADD
                link_pose = obj.get_link_pose(link).to_transform(link)
                if obj.urdf_object.link_map[link].collision.origin:
                    link_origin = Transform(obj.urdf_object.link_map[link].collision.origin.xyz,
                                            list(quaternion_from_euler(*obj.urdf_object.link_map[link].collision.origin.rpy)))
                else:
                    link_origin = Transform()
                link_pose_with_origin = link_pose * link_origin
                msg.pose = link_pose_with_origin.to_pose().pose

                color = [1, 1, 1, 1] if obj.links[link] == -1 else obj.get_color(link)

                msg.color = ColorRGBA(*color)
                msg.lifetime = rospy.Duration(1)

                if type(geom) == urdf_parser_py.urdf.Mesh:
                    msg.type = Marker.MESH_RESOURCE
                    msg.mesh_resource = "file://" + geom.filename
                    msg.scale = Vector3(1, 1, 1)
                    msg.mesh_use_embedded_materials = True
                elif type(geom) == urdf_parser_py.urdf.Cylinder:
                    msg.type = Marker.CYLINDER
                    msg.scale = Vector3(geom.radius * 2, geom.radius * 2, geom.length)
                elif type(geom) == urdf_parser_py.urdf.Box:
                    msg.type = Marker.CUBE
                    msg.scale = Vector3(*geom.size)
                elif type(geom) == urdf_parser_py.urdf.Sphere:
                    msg.type == Marker.SPHERE
                    msg.scale = Vector3(geom.radius * 2, geom.radius * 2, geom.radius * 2)

                marker_array.markers.append(msg)
        return marker_array

    def _stop_publishing(self) -> None:
        """
        Stops the publishing of the Visualization Marker update by setting the kill event and collecting the thread.
        """
        self.kill_event.set()
        self.thread.join()



##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/ros/joint_state_publisher.py
import time
import threading
import atexit

import rospy

from sensor_msgs.msg import JointState
from std_msgs.msg import Header
from ..bullet_world import BulletWorld


class JointStatePublisher:
    """
    Joint state publisher for the robot currently loaded in the BulletWorld
    """
    def __init__(self, joint_state_topic="/pycram/joint_state", interval=0.1):
        """
        Robot object is from :py:attr:`~pycram.bullet_world.BulletWorld.robot` and current joint states are published to
        the given joint_state_topic as a JointState message.

        :param joint_state_topic: Topic name to which the joint states should be published
        :param interval: Interval at which the joint states should be published, in seconds
        """
        self.world = BulletWorld.current_bullet_world

        self.joint_state_pub = rospy.Publisher(joint_state_topic, JointState, queue_size=10)
        self.interval = interval
        self.kill_event = threading.Event()
        self.thread = threading.Thread(target=self._publish)
        self.thread.start()

        atexit.register(self._stop_publishing)

    def _publish(self) -> None:
        """
        Publishes the current joint states of the :py:attr:`~pycram.bullet_world.BulletWorld.robot` in an infinite loop.
        The joint states are published as long as the kill_event is not set by :py:meth:`~JointStatePublisher._stop_publishing`
        """
        robot = BulletWorld.robot
        joint_names = [joint_name for joint_name in robot.joints.keys()]
        seq = 0

        while not self.kill_event.is_set():
            current_joint_states = [robot.get_joint_state(joint_name) for joint_name in joint_names]
            h = Header()
            h.stamp = rospy.Time.now()
            h.seq = seq
            h.frame_id = ""
            joint_state_msg = JointState()
            joint_state_msg.header = h
            joint_state_msg.name = joint_names
            joint_state_msg.position = current_joint_states
            # joint_state_msg.velocity = [joint_state[1] for joint_state in current_joint_states]
            self.joint_state_pub.publish(joint_state_msg)
            seq += 1
            time.sleep(self.interval)

    def _stop_publishing(self) -> None:
        """
        Sets the kill_event to terminate the publishing thread and joins the thread.
        """
        self.kill_event.set()
        self.thread.join()


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/process_modules/boxy_process_modules.py
from threading import Lock
import numpy as np
import pycram.bullet_world_reasoning as btr
import pycram.helper as helper
from ..bullet_world import BulletWorld, Object
from ..designators.motion_designator import *
from ..enums import JointType
from ..external_interfaces.ik import request_ik
from ..local_transformer import LocalTransformer
from ..process_module import ProcessModule, ProcessModuleManager
from ..robot_descriptions import robot_description


def _park_arms(arm):
    """
    Defines the joint poses for the parking positions of the arms of Boxy and applies them to the
    in the BulletWorld defined robot.
    :return: None
    """

    robot = BulletWorld.robot
    if arm == "right":
        for joint, pose in robot_description.get_static_joint_chain("right", "park").items():
            robot.set_joint_state(joint, pose)
    if arm == "left":
        for joint, pose in robot_description.get_static_joint_chain("left", "park").items():
            robot.set_joint_state(joint, pose)


class BoxyNavigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig: MoveMotion):
        robot = BulletWorld.robot
        robot.set_pose(desig.target)


class BoxyOpen(ProcessModule):
    """
    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.
    """

    def _execute(self, desig: OpeningMotion):
        part_of_object = desig.object_part.bullet_world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)

        _move_arm_tcp(goal_pose, BulletWorld.robot, desig.arm)

        desig.object_part.bullet_world_object.set_joint_state(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[1])


class BoxyClose(ProcessModule):
    """
    Low-level implementation that lets the robot close a grasped container, in simulation
    """
    def _execute(self, desig: ClosingMotion):
        part_of_object = desig.object_part.bullet_world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)

        _move_arm_tcp(goal_pose, BulletWorld.robot, desig.arm)

        desig.object_part.bullet_world_object.set_joint_state(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[0])


class BoxyParkArms(ProcessModule):
    """
    This process module is for moving the arms in a parking position.
    It is currently not used.
    """

    def _execute(self, desig):
        solutions = desig.reference()
        if solutions['cmd'] == 'park':
            _park_arms()


class BoxyMoveHead(ProcessModule):
    """
    This process module moves the head to look at a specific point in the world coordinate frame.
    This point can either be a position or an object.
    """

    def _execute(self, desig):
        target = desig.target
        robot = BulletWorld.robot

        local_transformer = LocalTransformer()

        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame("neck_shoulder_link"))

        if pose_in_shoulder.position.x >= 0 and pose_in_shoulder.position.x >= abs(pose_in_shoulder.position.y):
            robot.set_joint_states(robot_description.get_static_joint_chain("neck", "front"))
        if pose_in_shoulder.position.y >= 0 and pose_in_shoulder.position.y >= abs(pose_in_shoulder.position.x):
            robot.set_joint_states(robot_description.get_static_joint_chain("neck", "neck_right"))
        if pose_in_shoulder.position.x <= 0 and abs(pose_in_shoulder.position.x) > abs(pose_in_shoulder.position.y):
            robot.set_joint_states(robot_description.get_static_joint_chain("neck", "back"))
        if pose_in_shoulder.position.y <= 0 and abs(pose_in_shoulder.position.y) > abs(pose_in_shoulder.position.x):
            robot.set_joint_states(robot_description.get_static_joint_chain("neck", "neck_left"))

        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame("neck_shoulder_link"))

        new_pan = np.arctan2(pose_in_shoulder.position.y, pose_in_shoulder.position.x)

        robot.set_joint_state("neck_shoulder_pan_joint", new_pan + robot.get_joint_state("neck_shoulder_pan_joint"))


class BoxyMoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only move one gripper at a time.
    """

    def _execute(self, desig):
        robot = BulletWorld.robot
        gripper = desig.gripper
        motion = desig.motion
        robot.set_joint_states(robot_description.get_static_gripper_chain(gripper, motion))


class BoxyDetecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """

    def _execute(self, desig):
        robot = BulletWorld.robot
        object_type = desig.object_type
        # Should be "wide_stereo_optical_frame"
        cam_frame_name = robot_description.get_camera_frame()
        # should be [0, 0, 1]
        front_facing_axis = robot_description.front_facing_axis

        objects = BulletWorld.current_bullet_world.get_objects_by_type(object_type)
        for obj in objects:
            if btr.visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):
                return obj


class BoxyMoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig: MoveTCPMotion):
        target = desig.target
        robot = BulletWorld.robot

        _move_arm_tcp(target, robot, desig.arm)


class BoxyMoveArmJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig: MoveArmJointsMotion):

        robot = BulletWorld.robot
        if desig.right_arm_poses:
            robot.set_joint_states(desig.right_arm_poses)
        if desig.left_arm_poses:
            robot.set_joint_states(desig.left_arm_poses)


class BoxyWorldStateDetecting(ProcessModule):
    """
    This process module detectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig: WorldStateDetectingMotion):
        obj_type = desig.object_type
        return list(filter(lambda obj: obj.type == obj_type, BulletWorld.current_bullet_world.objects))[0]


def _move_arm_tcp(target: Pose, robot: Object, arm: str) -> None:
    gripper = robot_description.get_tool_frame(arm)

    joints = robot_description.chains[arm].joints

    inv = request_ik(target, robot, joints, gripper)
    helper._apply_ik(robot, inv, joints)


class BoxyManager(ProcessModuleManager):

    def __init__(self):
        super().__init__("boxy")
        self._navigate_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type == "simulated":
            return BoxyNavigation(self._navigate_lock)

    def looking(self):
        if ProcessModuleManager.execution_type == "simulated":
            return BoxyMoveHead(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return BoxyDetecting(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type == "simulated":
            return BoxyMoveTCP(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type == "simulated":
            return BoxyMoveArmJoints(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return BoxyWorldStateDetecting(self._world_state_detecting_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type == "simulated":
            return BoxyMoveGripper(self._move_gripper_lock)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/process_modules/hsr_process_modules.py
from threading import Lock

from ..robot_descriptions import robot_description
from ..process_module import ProcessModule, ProcessModuleManager
from ..bullet_world import BulletWorld
from ..helper import _apply_ik
import pycram.bullet_world_reasoning as btr
import pybullet as p
import logging
import time


def _park_arms(arm):
    """
    Defines the joint poses for the parking positions of the arm of HSR and applies them to the
    in the BulletWorld defined robot.
    :return: None
    """

    robot = BulletWorld.robot
    if arm == "left":
        for joint, pose in robot_description.get_static_joint_chain("left", "park").items():
            robot.set_joint_state(joint, pose)


class HSRNavigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == 'navigate':
            robot = BulletWorld.robot
            robot.set_position_and_orientation(solution['target'], solution['orientation'])


class HSRPickUp(ProcessModule):
    """
    This process module is for picking up a given object.
    The object has to be reachable for this process module to succeed.
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == 'pick':
            object = solution['object']
            robot = BulletWorld.robot
            target = object.get_position()
            inv = p.calculateInverseKinematics(robot.id, robot.get_link_id(solution['gripper']), target,
                                               maxNumIterations=100)
            _apply_ik(robot, inv)
            robot.attach(object, solution['gripper'])
            time.sleep(0.5)


class HSRPlace(ProcessModule):
    """
    This process module places an object at the given position in world coordinate frame.
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == 'place':
            object = solution['object']
            robot = BulletWorld.robot
            inv = p.calculateInverseKinematics(robot.id, robot.get_link_id(solution['gripper']), solution['target'],
                                               maxNumIterations=100)
            _apply_ik(robot, inv)
            robot.detach(object)
            time.sleep(0.5)


class HSRAccessing(ProcessModule):
    """
    This process module responsible for opening drawers to access the objects inside. This works by firstly moving
    the end effector to the handle of the drawer. Next, the end effector is moved the respective distance to the back.
    This provides the illusion the robot would open the drawer by himself.
    Then the drawer will be opened by setting the joint pose of the drawer joint.
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == 'access':
            kitchen = solution['part_of']
            robot = BulletWorld.robot
            gripper = solution['gripper']
            drawer_handle = solution['drawer_handle']
            drawer_joint = solution['drawer_joint']
            dis = solution['distance']
            inv = p.calculateInverseKinematics(robot.id, robot.get_link_id(gripper),
                                               kitchen.get_link_position(drawer_handle))
            _apply_ik(robot, inv)
            time.sleep(0.2)
            han_pose = kitchen.get_link_position(drawer_handle)
            new_p = [han_pose[0] - dis, han_pose[1], han_pose[2]]
            inv = p.calculateInverseKinematics(robot.id, robot.get_link_id(gripper), new_p)
            _apply_ik(robot, inv)
            kitchen.set_joint_state(drawer_joint, 0.3)
            time.sleep(0.5)


class HSRParkArms(ProcessModule):
    """
    This process module is for moving the arms in a parking position.
    It is currently not used.
    """

    def _execute(self, desig):
        solutions = desig.reference()
        if solutions['cmd'] == 'park':
            _park_arms()


class HSRMoveHead(ProcessModule):
    """
    This process module moves the head to look at a specific point in the world coordinate frame.
    This point can either be a position or an object.
    """

    def _execute(self, desig):
        solutions = desig.reference()
        if solutions['cmd'] == 'looking':
            target = solutions['target']
            if target == 'forward' or target == 'down':
                robot = BulletWorld.robot
                for joint, state in robot_description.get_static_joint_chain("neck", target).items():
                    robot.set_joint_state(joint, state)
            else:
                logging.error("There is no target position defined with the target %s.", target)


class HSRMoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only moved one gripper at a time.
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == "move-gripper":
            robot = BulletWorld.robot
            gripper = solution['gripper']
            motion = solution['motion']
            for joint, state in robot_description.get_static_gripper_chain(gripper, motion).items():
                robot.set_joint_state(joint, state)
            time.sleep(0.5)


class HSRDetecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == "detecting":
            robot = BulletWorld.robot
            object_type = solution['object_type']
            cam_frame_name = solution['cam_frame']
            front_facing_axis = solution['front_facing_axis']

            objects = BulletWorld.current_bullet_world.get_objects_by_type(object_type)
            for obj in objects:
                if btr.visible(obj, robot.get_link_position_and_orientation(cam_frame_name), front_facing_axis, 0.5):
                    return obj


class HSRMoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == "move-tcp":
            target = solution['target']
            gripper = solution['gripper']
            robot = BulletWorld.robot
            inv = p.calculateInverseKinematics(robot.id, robot.get_link_id(gripper), target)
            _apply_ik(robot, inv)
            time.sleep(0.5)


class HSRMoveJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == "move-arm-joints":
            robot = BulletWorld.robot
            left_arm_poses = solution['left_arm_poses']

            if type(left_arm_poses) == dict:
                for joint, pose in left_arm_poses.items():
                    robot.set_joint_state(joint, pose)
            elif type(left_arm_poses) == str and left_arm_poses == "park":
                _park_arms("left")

            time.sleep(0.5)


class HSRWorldStateDetecting(ProcessModule):
    """
    This process module detectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig):
        solution = desig.reference()
        if solution['cmd'] == "world-state-detecting":
            obj_type = solution['object_type']
            return list(filter(lambda obj: obj.type == obj_type, BulletWorld.current_bullet_world.objects))[0]


class HSRManager(ProcessModuleManager):

    def __init__(self):
        super().__init__("hsrb")
        self._navigate_lock = Lock()
        self._pick_up_lock = Lock()
        self._place_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRNavigation(self._navigate_lock)

    def pick_up(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRPickUp(self._pick_up_lock)

    def place(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRPlace(self._place_lock)

    def looking(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRMoveHead(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRDetecting(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRMoveTCP(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRMoveJoints(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRWorldStateDetecting(self._world_state_detecting_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type == "simulated":
            return HSRMoveGripper(self._move_gripper_lock)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/process_modules/pr2_process_modules.py
from abc import ABC
from threading import Lock
from typing import Any

import actionlib

import pycram.bullet_world_reasoning as btr
import numpy as np
import time
import rospy
import pybullet as p

from ..plan_failures import EnvironmentManipulationImpossible
from ..robot_descriptions import robot_description
from ..process_module import ProcessModule, ProcessModuleManager
from ..bullet_world import BulletWorld, Object
from ..helper import transform
from ..external_interfaces.ik import request_ik, IKError
from ..helper import _transform_to_torso, _apply_ik, calculate_wrist_tool_offset, inverseTimes
from ..local_transformer import LocalTransformer
from ..designators.motion_designator import *
from ..enums import JointType, ObjectType
from ..external_interfaces import giskard
from ..external_interfaces.robokudo import query

try:
    from pr2_controllers_msgs.msg import Pr2GripperCommandGoal, Pr2GripperCommandAction, Pr2
except ImportError:
    pass


def _park_arms(arm):
    """
    Defines the joint poses for the parking positions of the arms of PR2 and applies them to the
    in the BulletWorld defined robot.
    :return: None
    """

    robot = BulletWorld.robot
    if arm == "right":
        for joint, pose in robot_description.get_static_joint_chain("right", "park").items():
            robot.set_joint_state(joint, pose)
    if arm == "left":
        for joint, pose in robot_description.get_static_joint_chain("left", "park").items():
            robot.set_joint_state(joint, pose)


class Pr2Navigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig: MoveMotion):
        robot = BulletWorld.robot
        robot.set_pose(desig.target)


class Pr2MoveHead(ProcessModule):
    """
    This process module moves the head to look at a specific point in the world coordinate frame.
    This point can either be a position or an object.
    """

    def _execute(self, desig: LookingMotion):
        target = desig.target
        robot = BulletWorld.robot

        local_transformer = LocalTransformer()
        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_pan_link"))
        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_tilt_link"))

        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)
        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1

        current_pan = robot.get_joint_state("head_pan_joint")
        current_tilt = robot.get_joint_state("head_tilt_joint")

        robot.set_joint_state("head_pan_joint", new_pan + current_pan)
        robot.set_joint_state("head_tilt_joint", new_tilt + current_tilt)


class Pr2MoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only moved one gripper at a time.
    """

    def _execute(self, desig: MoveGripperMotion):
        robot = BulletWorld.robot
        gripper = desig.gripper
        motion = desig.motion
        for joint, state in robot_description.get_static_gripper_chain(gripper, motion).items():
            robot.set_joint_state(joint, state)


class Pr2Detecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """

    def _execute(self, desig: DetectingMotion):
        robot = BulletWorld.robot
        object_type = desig.object_type
        # Should be "wide_stereo_optical_frame"
        cam_frame_name = robot_description.get_camera_frame()
        # should be [0, 0, 1]
        front_facing_axis = robot_description.front_facing_axis

        objects = BulletWorld.current_bullet_world.get_objects_by_type(object_type)
        for obj in objects:
            if btr.visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):
                return obj


class Pr2MoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig: MoveTCPMotion):
        target = desig.target
        robot = BulletWorld.robot

        _move_arm_tcp(target, robot, desig.arm)


class Pr2MoveArmJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig: MoveArmJointsMotion):

        robot = BulletWorld.robot
        if desig.right_arm_poses:
            robot.set_joint_states(desig.right_arm_poses)
        if desig.left_arm_poses:
            robot.set_joint_states(desig.left_arm_poses)


class PR2MoveJoints(ProcessModule):
    """
    Process Module for generic joint movements, is not confined to the arms but can move any joint of the robot
    """
    def _execute(self, desig: MoveJointsMotion):
        robot = BulletWorld.robot
        robot.set_joint_states(dict(zip(desig.names, desig.positions)))


class Pr2WorldStateDetecting(ProcessModule):
    """
    This process module detectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig: WorldStateDetectingMotion):
        obj_type = desig.object_type
        return list(filter(lambda obj: obj.type == obj_type, BulletWorld.current_bullet_world.objects))[0]


class Pr2Open(ProcessModule):
    """
    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.
    """

    def _execute(self, desig: OpeningMotion):
        part_of_object = desig.object_part.bullet_world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)

        _move_arm_tcp(goal_pose, BulletWorld.robot, desig.arm)

        desig.object_part.bullet_world_object.set_joint_state(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[1])


class Pr2Close(ProcessModule):
    """
    Low-level implementation that lets the robot close a grasped container, in simulation
    """

    def _execute(self, desig: ClosingMotion):
        part_of_object = desig.object_part.bullet_world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)

        _move_arm_tcp(goal_pose, BulletWorld.robot, desig.arm)

        desig.object_part.bullet_world_object.set_joint_state(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[0])


def _move_arm_tcp(target: Pose, robot: Object, arm: str) -> None:
    gripper = robot_description.get_tool_frame(arm)

    joints = robot_description.chains[arm].joints

    inv = request_ik(target, robot, joints, gripper)
    _apply_ik(robot, inv, joints)


###########################################################
########## Process Modules for the Real PR2 ###############
###########################################################


class Pr2NavigationReal(ProcessModule):
    """
    Process module for the real PR2 that sends a cartesian goal to giskard to move the robot base
    """

    def _execute(self, designator: MoveMotion) -> Any:
        rospy.logdebug(f"Sending goal to giskard to Move the robot")
        giskard.achieve_cartesian_goal(designator.target, robot_description.base_link, "map")


class Pr2MoveHeadReal(ProcessModule):
    """
    Process module for the real robot to move that such that it looks at the given position. Uses the same calculation
    as the simulated one
    """

    def _execute(self, desig: LookingMotion):
        target = desig.target
        robot = BulletWorld.robot

        local_transformer = LocalTransformer()
        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_pan_link"))
        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_tilt_link"))

        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)
        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1

        current_pan = robot.get_joint_state("head_pan_joint")
        current_tilt = robot.get_joint_state("head_tilt_joint")

        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal({"head_pan_joint": new_pan + current_pan,
                                    "head_tilt_joint": new_tilt + current_tilt})


class Pr2DetectingReal(ProcessModule):
    """
    Process Module for the real Pr2 that tries to detect an object fitting the given object description. Uses Robokudo
    for perception of the environment.
    """

    def _execute(self, designator: DetectingMotion) -> Any:
        query_result = query(ObjectDesignatorDescription(types=[designator.object_type]))
        # print(query_result)
        obj_pose = query_result["ClusterPoseBBAnnotator"]

        lt = LocalTransformer()
        obj_pose = lt.transform_pose(obj_pose, BulletWorld.robot.get_link_tf_frame("torso_lift_link"))
        obj_pose.orientation = [0, 0, 0, 1]
        obj_pose.position.x += 0.05

        bullet_obj = BulletWorld.current_bullet_world.get_objects_by_type(designator.object_type)
        if bullet_obj:
            bullet_obj[0].set_pose(obj_pose)
            return bullet_obj[0]
        elif designator.object_type == ObjectType.JEROEN_CUP:
            cup = Object("cup", ObjectType.JEROEN_CUP, "jeroen_cup.stl", pose=obj_pose)
            return cup
        elif designator.object_type == ObjectType.BOWL:
            bowl = Object("bowl", ObjectType.BOWL, "bowl.stl", pose=obj_pose)
            return bowl


        return bullet_obj[0]


class Pr2MoveTCPReal(ProcessModule):
    """
    Moves the tool center point of the real PR2 while avoiding all collisions
    """

    def _execute(self, designator: MoveTCPMotion) -> Any:
        lt = LocalTransformer()
        pose_in_map = lt.transform_pose(designator.target, "map")

        if designator.allow_gripper_collision:
            giskard.allow_gripper_collision(designator.arm)
        giskard.achieve_cartesian_goal(pose_in_map, robot_description.get_tool_frame(designator.arm),
                                       robot_description.base_link)


class Pr2MoveArmJointsReal(ProcessModule):
    """
    Moves the arm joints of the real PR2 to the given configuration while avoiding all collisions
    """

    def _execute(self, designator: MoveArmJointsMotion) -> Any:
        joint_goals = {}
        if designator.left_arm_poses:
            joint_goals.update(designator.left_arm_poses)
        if designator.right_arm_poses:
            joint_goals.update(designator.right_arm_poses)
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal(joint_goals)


class Pr2MoveJointsReal(ProcessModule):
    """
    Moves any joint using giskard, avoids all collisions while doint this.
    """

    def _execute(self, designator: MoveJointsMotion) -> Any:
        name_to_position = dict(zip(designator.names, designator.positions))
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal(name_to_position)


class Pr2MoveGripperReal(ProcessModule):
    """
    Opens or closes the gripper of the real PR2, gripper uses an action server for this instead of giskard 
    """

    def _execute(self, designator: MoveGripperMotion) -> Any:
        def activate_callback():
            rospy.loginfo("Started gripper Movement")

        def done_callback(state, result):
            rospy.loginfo(f"Reached goal {designator.motion}: {result.reached_goal}")

        def feedback_callback(msg):
            pass

        goal = Pr2GripperCommandGoal()
        goal.command.position = 0.0 if designator.motion == "close" else 0.1
        goal.command.max_effort = 50.0
        controller_topic = "r_gripper_controller/gripper_action" if designator.gripper == "right" else "l_gripper_controller/gripper_action"
        client = actionlib.SimpleActionClient(controller_topic, Pr2GripperCommandAction)
        rospy.loginfo("Waiting for action server")
        client.wait_for_server()
        client.send_goal(goal, active_cb=activate_callback, done_cb=done_callback, feedback_cb=feedback_callback)
        wait = client.wait_for_result()


class Pr2OpenReal(ProcessModule):
    """
    Tries to open an already grasped container
    """

    def _execute(self, designator: OpeningMotion) -> Any:
        giskard.achieve_open_container_goal(robot_description.get_tool_frame(designator.arm),
                                            designator.object_part.name)


class Pr2CloseReal(ProcessModule):
    """
    Tries to close an already grasped container
    """

    def _execute(self, designator: ClosingMotion) -> Any:
        giskard.achieve_close_container_goal(robot_description.get_tool_frame(designator.arm),
                                             designator.object_part.name)


class Pr2Manager(ProcessModuleManager):

    def __init__(self):
        super().__init__("pr2")
        self._navigate_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type == "simulated":
            return Pr2Navigation(self._navigate_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2NavigationReal(self._navigate_lock)

    def looking(self):
        if ProcessModuleManager.execution_type == "simulated":
            return Pr2MoveHead(self._looking_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2MoveHeadReal(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return Pr2Detecting(self._detecting_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2DetectingReal(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type == "simulated":
            return Pr2MoveTCP(self._move_tcp_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2MoveTCPReal(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type == "simulated":
            return Pr2MoveArmJoints(self._move_arm_joints_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2MoveArmJointsReal(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type == "simulated" or ProcessModuleManager.execution_type == "real":
            return Pr2WorldStateDetecting(self._world_state_detecting_lock)

    def move_joints(self):
        if ProcessModuleManager.execution_type == "simulated":
            return PR2MoveJoints(self._move_joints_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2MoveJointsReal(self._move_joints_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type == "simulated":
            return Pr2MoveGripper(self._move_gripper_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2MoveGripperReal(self._move_gripper_lock)

    def open(self):
        if ProcessModuleManager.execution_type == "simulated":
            return Pr2Open(self._open_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2OpenReal(self._open_lock)

    def close(self):
        if ProcessModuleManager.execution_type == "simulated":
            return Pr2Close(self._close_lock)
        elif ProcessModuleManager.execution_type == "real":
            return Pr2CloseReal(self._close_lock)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/process_modules/__init__.py
from .pr2_process_modules import Pr2Manager
from .boxy_process_modules import BoxyManager
from .donbot_process_modules import DonbotManager
from .hsr_process_modules import HSRManager
from .default_process_modules import DefaultManager

Pr2Manager()
BoxyManager()
DonbotManager()
HSRManager()
DefaultManager()


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/process_modules/donbot_process_modules.py
import time
from threading import Lock

import numpy as np
import pybullet as p

import pycram.bullet_world_reasoning as btr
import pycram.helper as helper
from ..bullet_world import BulletWorld, Object
from ..designators.motion_designator import MoveArmJointsMotion, WorldStateDetectingMotion
from ..external_interfaces.ik import request_ik
from ..local_transformer import LocalTransformer
from ..pose import Pose
from ..process_module import ProcessModule, ProcessModuleManager
from ..robot_descriptions import robot_description
from tf.transformations import euler_from_quaternion, quaternion_from_euler


def _park_arms(arm):
    """
    Defines the joint poses for the parking positions of the arm of Donbot and applies them to the
    in the BulletWorld defined robot.
    :return: None
    """

    robot = BulletWorld.robot
    if arm == "left":
        for joint, pose in robot_description.get_static_joint_chain("left", "park").items():
            robot.set_joint_state(joint, pose)


class DonbotNavigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig):
        robot = BulletWorld.robot
        robot.set_pose(desig.target)

class DonbotPickUp(ProcessModule):
    """
    This process module is for picking up a given object.
    The object has to be reachable for this process module to succeed.
    """

    def _execute(self, desig):
        object = desig.object_desig.bullet_world_object
        robot = BulletWorld.robot
        grasp = robot_description.grasps.get_orientation_for_grasp(desig.grasp)
        target = object.get_pose()
        target.orientation.x = grasp[0]
        target.orientation.y = grasp[1]
        target.orientation.z = grasp[2]
        target.orientation.w = grasp[3]

        _move_arm_tcp(target, robot, "left")
        tool_frame = robot_description.get_tool_frame("left")
        robot.attach(object, tool_frame)


class DonbotPlace(ProcessModule):
    """
    This process module places an object at the given position in world coordinate frame.
    """

    def _execute(self, desig):
        object = desig.object.bullet_world_object
        robot = BulletWorld.robot

        # Transformations such that the target position is the position of the object and not the tcp
        object_pose = object.get_pose()
        local_tf = LocalTransformer()
        tcp_to_object = local_tf.transform_pose(object_pose,
                                                robot.get_link_tf_frame(robot_description.get_tool_frame("left")))
        target_diff = desig.target.to_transform("target").inverse_times(tcp_to_object.to_transform("object")).to_pose()

        _move_arm_tcp(target_diff, robot, "left")
        robot.detach(object)



class DonbotMoveHead(ProcessModule):
    """
    This process module moves the head to look at a specific point in the world coordinate frame.
    This point can either be a position or an object.
    """

    def _execute(self, desig):
        target = desig.target
        robot = BulletWorld.robot

        local_transformer = LocalTransformer()

        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame("ur5_shoulder_link"))

        if pose_in_shoulder.position.x >= 0 and pose_in_shoulder.position.x >= abs(pose_in_shoulder.position.y):
            robot.set_joint_states(robot_description.get_static_joint_chain("left", "front"))
        if pose_in_shoulder.position.y >= 0 and pose_in_shoulder.position.y >= abs(pose_in_shoulder.position.x):
            robot.set_joint_states(robot_description.get_static_joint_chain("left", "arm_right"))
        if pose_in_shoulder.position.x <= 0 and abs(pose_in_shoulder.position.x) > abs(pose_in_shoulder.position.y):
            robot.set_joint_states(robot_description.get_static_joint_chain("left", "back"))
        if pose_in_shoulder.position.y <= 0 and abs(pose_in_shoulder.position.y) > abs(pose_in_shoulder.position.x):
            robot.set_joint_states(robot_description.get_static_joint_chain("left", "arm_left"))

        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame("ur5_shoulder_link"))

        new_pan = np.arctan2(pose_in_shoulder.position.y, pose_in_shoulder.position.x)

        robot.set_joint_state("ur5_shoulder_pan_joint", new_pan + robot.get_joint_state("ur5_shoulder_pan_joint"))


class DonbotMoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only move one gripper at a time.
    """

    def _execute(self, desig):
        robot = BulletWorld.robot
        gripper = desig.gripper
        motion = desig.motion
        robot.set_joint_states(robot_description.get_static_gripper_chain(gripper, motion))


class DonbotDetecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """

    def _execute(self, desig):
        robot = BulletWorld.robot
        object_type = desig.object_type
        # Should be "wide_stereo_optical_frame"
        cam_frame_name = robot_description.get_camera_frame()
        # should be [0, 0, 1]
        front_facing_axis = robot_description.front_facing_axis

        objects = BulletWorld.current_bullet_world.get_objects_by_type(object_type)
        for obj in objects:
            if btr.visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):
                return obj


class DonbotMoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig):
        target = desig.target
        robot = BulletWorld.robot

        _move_arm_tcp(target, robot, desig.arm)


class DonbotMoveJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig: MoveArmJointsMotion):
        robot = BulletWorld.robot
        if desig.left_arm_poses:
            robot.set_joint_states(desig.left_arm_poses)


class DonbotWorldStateDetecting(ProcessModule):
    """
    This process module detectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig: WorldStateDetectingMotion):
        obj_type = desig.object_type
        return list(filter(lambda obj: obj.type == obj_type, BulletWorld.current_bullet_world.objects))[0]

def _move_arm_tcp(target: Pose, robot: Object, arm: str) -> None:
    gripper = robot_description.get_tool_frame(arm)

    joints = robot_description.chains[arm].joints

    inv = request_ik(target, robot, joints, gripper)
    helper._apply_ik(robot, inv, joints)


class DonbotManager(ProcessModuleManager):

    def __init__(self):
        super().__init__("iai_donbot")
        self._navigate_lock = Lock()
        self._pick_up_lock = Lock()
        self._place_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotNavigation(self._navigate_lock)

    def pick_up(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotPickUp(self._pick_up_lock)

    def place(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotPlace(self._place_lock)

    def looking(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotMoveHead(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotDetecting(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotMoveTCP(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotMoveJoints(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotWorldStateDetecting(self._world_state_detecting_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DonbotMoveGripper(self._move_gripper_lock)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/process_modules/default_process_modules.py
from threading import Lock

import pycram.bullet_world_reasoning as btr
import numpy as np

from ..robot_descriptions import robot_description
from ..process_module import ProcessModule, ProcessModuleManager
from ..bullet_world import BulletWorld, Object
from ..external_interfaces.ik import request_ik, IKError
from ..helper import _apply_ik
from ..local_transformer import LocalTransformer
from ..designators.motion_designator import *
from ..enums import JointType


class DefaultNavigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig: MoveMotion):
        robot = BulletWorld.robot
        robot.set_pose(desig.target)


class DefaultMoveHead(ProcessModule):
    """
    This process module moves the head to look at a specific point in the world coordinate frame.
    This point can either be a position or an object.
    """

    def _execute(self, desig: LookingMotion):
        target = desig.target
        robot = BulletWorld.robot

        local_transformer = LocalTransformer()

        pan_link = robot_description.chains["neck"].links[0]
        tilt_link = robot_description.chains["neck"].links[1]

        pan_joint = robot_description.chains["neck"].joints[0]
        tilt_joint = robot_description.chains["neck"].joints[1]
        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame(pan_link))
        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame(tilt_link))

        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)
        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1

        current_pan = robot.get_joint_state(pan_joint)
        current_tilt = robot.get_joint_state(tilt_joint)

        robot.set_joint_state(pan_joint, new_pan + current_pan)
        robot.set_joint_state(tilt_joint, new_tilt + current_tilt)


class DefaultMoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only moved one gripper at a time.
    """

    def _execute(self, desig: MoveGripperMotion):
        robot = BulletWorld.robot
        gripper = desig.gripper
        motion = desig.motion
        for joint, state in robot_description.get_static_gripper_chain(gripper, motion).items():
            robot.set_joint_state(joint, state)


class DefaultDetecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """

    def _execute(self, desig: DetectingMotion):
        robot = BulletWorld.robot
        object_type = desig.object_type
        # Should be "wide_stereo_optical_frame"
        cam_frame_name = robot_description.get_camera_frame()
        # should be [0, 0, 1]
        front_facing_axis = robot_description.front_facing_axis

        objects = BulletWorld.current_bullet_world.get_objects_by_type(object_type)
        for obj in objects:
            if btr.visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):
                return obj


class DefaultMoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig: MoveTCPMotion):
        target = desig.target
        robot = BulletWorld.robot

        _move_arm_tcp(target, robot, desig.arm)


class DefaultMoveArmJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig: MoveArmJointsMotion):

        robot = BulletWorld.robot
        if desig.right_arm_poses:
            for joint, pose in desig.right_arm_poses.items():
                robot.set_joint_state(joint, pose)
        if desig.left_arm_poses:
            for joint, pose in desig.left_arm_poses.items():
                robot.set_joint_state(joint, pose)


class DefaultMoveJoints(ProcessModule):
    def _execute(self, desig: MoveJointsMotion):
        robot = BulletWorld.robot
        for joint, pose in zip(desig.names, desig.positions):
            robot.set_joint_state(joint, pose)


class DefaultWorldStateDetecting(ProcessModule):
    """
    This process module detectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig: WorldStateDetectingMotion):
        obj_type = desig.object_type
        return list(filter(lambda obj: obj.type == obj_type, BulletWorld.current_bullet_world.objects))[0]


class DefaultOpen(ProcessModule):
    """
    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.
    """

    def _execute(self, desig: OpeningMotion):
        part_of_object = desig.object_part.bullet_world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)

        _move_arm_tcp(goal_pose, BulletWorld.robot, desig.arm)

        desig.object_part.bullet_world_object.set_joint_state(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[1])


class DefaultClose(ProcessModule):
    """
    Low-level implementation that lets the robot close a grasped container, in simulation
    """
    def _execute(self, desig: ClosingMotion):
        part_of_object = desig.object_part.bullet_world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)

        _move_arm_tcp(goal_pose, BulletWorld.robot, desig.arm)

        desig.object_part.bullet_world_object.set_joint_state(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[0])


def _move_arm_tcp(target: Pose, robot: Object, arm: str) -> None:
    gripper = robot_description.get_tool_frame(arm)

    joints = robot_description.chains[arm].joints

    inv = request_ik(target, robot, joints, gripper)
    _apply_ik(robot, inv, joints)


class DefaultManager(ProcessModuleManager):

    def __init__(self):
        super().__init__("default")
        self._navigate_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultNavigation(self._navigate_lock)

    def looking(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultMoveHead(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultDetecting(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultMoveTCP(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultMoveArmJoints(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultWorldStateDetecting(self._world_state_detecting_lock)

    def move_joints(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultMoveJoints(self._move_joints_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultMoveGripper(self._move_gripper_lock)

    def open(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultOpen(self._open_lock)

    def close(self):
        if ProcessModuleManager.execution_type == "simulated":
            return DefaultClose(self._close_lock)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/robot_descriptions/ur5_description.py
from ..robot_description import *


class UR5Description(RobotDescription):
    def __init__(self):
        # all joints which are not fix,
        super(UR5Description, self).__init__("ur5_robotiq", "world", "base_link")

        # Arm
        arm_joints = ["shoulder_pan_joint", "shoulder_lift_joint", "elbow_joint", "wrist_1_joint", "wrist_2_joint",
                      "wrist_3_joint"]
        arm_links = ["base_link", "shoulder_link", "upper_arm_link", "forearm_link", "wrist_1_link", "wrist_2_link", "wrist_3_link"]
        gripper_joints = ["robotiq_85_left_finger_joint", "robotiq_85_right_finger_joint",
                          "robotiq_85_left_inner_knuckle_joint", "robotiq_85_right_inner_knuckle_joint",
                          "robotiq_85_left_finger_tip_joint", "robotiq_85_left_finger_tip_joint"]
        gripper_links = ["robotiq_85_base_link", "robotiq_85_left_knuckle_link", "robotiq_85_right_knuckle_link",
                         "robotiq_85_left_finger_link", "robotiq_85_right_finger_link",
                         "robotiq_85_left_inner_knuckle_link", "robotiq_85_right_inner_knuckle_link",
                         "robotiq_85_left_finger_tip_link" "robotiq_85_right_finger_tip_link"]

        # Arm
        manipulator_chain = ChainDescription("manipulator", arm_joints, arm_links)
        manipulator_inter = InteractionDescription(manipulator_chain, "ee_link")
        # Gripper
        gripper = GripperDescription("gripper", gripper_links, gripper_joints)
        # Adding Arm + Gripper
        manipulator = ManipulatorDescription(manipulator_inter, tool_frame="ee_link",
                                             gripper_description=gripper)
        self.add_chains({"manipulator": manipulator})
        # Adding Static Joint Poses
        # Static Arm Positions
        manipulator_home = [0, 0, 0, 0, 0, 0]
        self.add_static_joint_chain("manipulator", "home", manipulator_home)
        # Static Gripper Positions
        gripper_confs = {"open": [0.0], "close": [1.0]}
        self.add_static_gripper_chains("gripper", gripper_confs)

    def get_camera_frame(self, name="camera"):
        # TODO: Hacky since only one optical camera frame from pr2 is used
        return super().get_camera_frame(name)




##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/robot_descriptions/donbot_description.py
from ..robot_description import *

class DonbotDescription(RobotDescription):

    def __init__(self):

        super().__init__("iai_donbot", "base_footprint", "base_link", "ur5_base_link",
                         "arm_base_mounting_joint", odom_frame="odom",
                         odom_joints=["odom_x_joint", "odom_y_joint", "odom_z_joint"])
        # Camera
        rgb_camera = CameraDescription("camera_link",
                                       horizontal_angle=0.99483, vertical_angle=0.75049,
                                       minimal_height=0.5, maximal_height=1.2)
        rs_camera = CameraDescription("rs_camera_link",
                                      horizontal_angle=0.99483, vertical_angle=0.75049,
                                      minimal_height=0.5, maximal_height=1.2)
        # not in the iai_donbot.urdf, although used in cram
        # realsense_camera = CameraDescription("rs_camera_depth_optical_frame",
        #                                     horizontal_angle=0.99483, vertical_angle=0.75049,
        #                                     minimal_height=0.5, maximal_height=1.2)
        # virtual_camera = CameraDescription("rs_camera_color_optical_frame",
        #                                   horizontal_angle=0.99483, vertical_angle=0.75049,
        #                                   minimal_height=0.5, maximal_height=1.2)
        self.add_cameras({"rgb_camera": rgb_camera, "rs_camera": rs_camera})
        # self.cameras["realsense_camera"] = realsense_camera
        # self.cameras["virtual_camera"] = virtual_camera
        # The axis which points away from the camera and along which the picture of the camera is created
        self.front_facing_axis = [0, 0, 1]

        # Gripper
        gripper_links = ["wrist_collision", "gripper_base_link", "gripper_finger_left_link",
                         "gripper_finger_right_link", "gripper_gripper_left_link", "gripper_gripper_right_link",
                         "marco_left_finger_link", "marco_right_finger_link"]
        gripper_joints = ["gripper_joint"]
        gripper = GripperDescription("gripper", gripper_links=gripper_links, gripper_joints=gripper_joints,
                                     gripper_meter_to_jnt_multiplier=1.0, gripper_minimal_position=0.0,
                                     gripper_convergence_delta=0.001)
        # Arm
        arm_links = ["ur5_shoulder_link", "ur5_upper_arm_link", "ur5_forearm_link", "ur5_wrist_1_link",
                     "ur5_wrist_2_link", "ur5_wrist_3_link"]
        arm_joints = ["ur5_shoulder_pan_joint", "ur5_shoulder_lift_joint", "ur5_elbow_joint",
                      "ur5_wrist_1_joint", "ur5_wrist_2_joint", "ur5_wrist_3_joint"]
        arm_chain = ChainDescription("left", arm_joints, arm_links)
        arm_inter = InteractionDescription(arm_chain, "ur5_ee_link")
        arm_manip = ManipulatorDescription(arm_inter, tool_frame="gripper_tool_frame",
                                           gripper_description=gripper)  # or ur5_tool0
        self.add_chain("left", arm_manip)
        self.add_chain("right", arm_manip)
        # Neck
        neck_base_link = "ur5_base_link"
        neck = ChainDescription("neck", arm_joints, arm_links, base_link=neck_base_link)
        self.add_chain("neck", neck)
        # Adding Static Joint Poses
        # Static Neck Positions
        down = [4.130944728851318, 0.04936718940734863, -1.9734209219561976,
                -1.7624157110797327, 1.6369260549545288, -1.6503327528582972]
        right = [1.6281344890594482, -1.1734271208392542, -1.1555221716510218,
                 # 2:-1.4734271208392542, 4: -0.9881671110736292,
                 -1.7555221716510218, 1.4996352195739746, -1.4276765028582972]
        left = [-1.6281344890594482, -1.1734271208392542, -1.1555221716510218,
                # 2:-1.4734271208392542, 4: -0.9881671110736292,
                -1.7555221716510218, 1.4996352195739746, -1.4276765028582972]
        right_separators = [1.4752850532531738, -1.4380276838885706, -1.9198325316058558,
                            -0.0680769125567835, 1.704722285270691, -1.5686963240252894]
        right_separators_preplace_state = [1.585883378982544, -0.49957687059511,
                                           -1.61414081255068, -1.1720898787127894,
                                           1.37771737575531, -1.3602331320392054]
        self.add_static_joint_chains("neck", {"down": down, "right": right, "left": left,
                                              "right_separators": right_separators,
                                              "right_separators_preplace_state": right_separators_preplace_state})
        # Static Arm Positions
        park = [3.234022855758667, -1.5068710486041468, -0.7870314756976526, -2.337625328694479,
                1.5699548721313477, -1.6504042784320276]
        self.add_static_joint_chain("left", "park", park)
        front = [-1.5, -1.5, 0, 1.5, -1.5, 1.5]
        arm_right = [-3, -1.5, 0, 1.5, -1.5, 1.5]
        back = [-4.7, -1.5, 0, 1.5, -1.5, 1.5]
        arm_left = [0, -1.5, 0, 1.5, -1.5, 1.5]
        self.add_static_joint_chains("left", {"front": front, "arm_right": arm_right, "back": back,
                                              "arm_left": arm_left})

    def get_camera_frame(self, name="rgb_camera"):
        # TODO: Hacky since only one optical camera frame from pr2 is used
        return super().get_camera_frame(name)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/robot_descriptions/tiago_description.py
from ..robot_description import *


class TiagoDescription(RobotDescription):

    def __init__(self):
        super().__init__("tiago_dual", "base_footprint", "base_link", "torso_lift_link", "torso_lift_joint")
        # Camera
        minimal_height = 1.0665
        maximal_height = 1.4165
        horizontal_angle = 0.99483
        vertical_angle = 0.75049

        optical = CameraDescription("xtion_optical_frame",
                                    horizontal_angle=horizontal_angle, vertical_angle=vertical_angle,
                                    minimal_height=minimal_height, maximal_height=maximal_height)
        rgb_optical = CameraDescription("xtion_rgb_optical_frame",
                                        horizontal_angle=horizontal_angle, vertical_angle=vertical_angle,
                                        minimal_height=minimal_height, maximal_height=maximal_height)
        depth = CameraDescription("xtion_rgb_optical_frame",
                                  horizontal_angle=horizontal_angle, vertical_angle=vertical_angle,
                                  minimal_height=minimal_height, maximal_height=maximal_height)

        self.add_cameras({"optical": optical, "rgb_optical": rgb_optical, "depth": depth})

        # The axis which points away from the camera and along which the picture of the camera is created
        self.front_facing_axis = [0, 0, 1]
        # Chains
        neck_static_joints = dict()
        neck_static_joints["forward"] = [0.0, 0.0]
        neck = ChainDescription("neck", ["head_1_joint", "head_2_joint"],
                                ["head_1_link", "head_2_link"],
                                static_joint_states=neck_static_joints)
        self.add_chain("neck", neck)
        # Arms
        r_joints = ["arm_right_1_joint",
                    "arm_right_2_joint",
                    "arm_right_3_joint",
                    "arm_right_4_joint",
                    "arm_right_5_joint",
                    "arm_right_6_joint",
                    "arm_right_7_joint"]
        l_joints = ["arm_left_1_joint",
                    "arm_left_2_joint",
                    "arm_left_3_joint",
                    "arm_left_4_joint",
                    "arm_left_5_joint",
                    "arm_left_6_joint",
                    "arm_left_7_joint"]
        r_links = ["arm_right_1_link",
                   "arm_right_2_link",
                   "arm_right_3_link",
                   "arm_right_4_link",
                   "arm_right_5_link",
                   "arm_right_6_link",
                   "arm_right_7_link",
                   "arm_right_tool_link",
                   "wrist_right_ft_link",
                   "wrist_right_ft_tool_link",
                   "gripper_right_link",
                   "gripper_right_left_finger_link",
                   "gripper_right_right_finger_link",
                   "gripper_right_tool_link"]
        l_links = ["arm_left_1_link",
                   "arm_left_2_link",
                   "arm_left_3_link",
                   "arm_left_4_link",
                   "arm_left_5_link",
                   "arm_left_6_link",
                   "arm_left_7_link",
                   "arm_left_tool_link",
                   "wrist_left_ft_link",
                   "wrist_left_ft_tool_link",
                   "gripper_left_link",
                   "gripper_left_left_finger_link",
                   "gripper_left_right_finger_link",
                   "gripper_left_tool_link"]
        r_gripper_joints = ["gripper_right_left_finger_joint", "gripper_right_right_finger_joint"]
        r_gripper_links = ["gripper_right_link",
                           "gripper_right_left_finger_link",
                           "gripper_right_right_finger_link",
                           "gripper_right_tool_link"]
        l_gripper_joints = ["gripper_left_left_finger_joint", "gripper_left_right_finger_joint"]
        l_gripper_links = ["gripper_left_link",
                           "gripper_left_left_finger_link",
                           "gripper_left_right_finger_link",
                           "gripper_left_tool_link"]
        # Arms
        left = ChainDescription("left", l_joints, l_links)
        right = ChainDescription("right", r_joints, r_links)
        left_inter = InteractionDescription(left, "arm_left_tool_link")
        right_inter = InteractionDescription(right, "arm_right_tool_link")
        # Gripper
        left_gripper = GripperDescription("left_gripper", l_gripper_links, l_gripper_joints,
                                          gripper_meter_to_jnt_multiplier=5.0,
                                          gripper_minimal_position=0.0,
                                          gripper_convergence_delta=0.005)
        right_gripper = GripperDescription("right_gripper", r_gripper_links, r_gripper_joints,
                                           gripper_meter_to_jnt_multiplier=5.0,
                                           gripper_minimal_position=0.0,
                                           gripper_convergence_delta=0.005)
        # Adding Arm + Gripper
        left_arm = ManipulatorDescription(left_inter, tool_frame="gripper_left_grasping_frame",
                                          gripper_description=left_gripper)
        right_arm = ManipulatorDescription(right_inter, tool_frame="gripper_right_grasping_frame",
                                           gripper_description=right_gripper)
        self.add_chains({"left": left_arm, "right": right_arm})
        # Adding Static Joint Poses
        # Static Arm Positions
        r_arm_park = [0.27, -1.07, 1.5, 2.0, -2.0, 1.2, 0.5]
        l_arm_park = [0.27, -1.07, 1.5, 1.96, -2.0, 1.2, 0.5]
        self.add_static_joint_chain("right", "park", r_arm_park)
        self.add_static_joint_chain("left", "park", l_arm_park)
        # Static Gripper Positions
        gripper_confs = {"open": [0.048, 0.048], "close": [0.0, 0.0]}
        self.add_static_gripper_chains("left", gripper_confs)
        self.add_static_gripper_chains("right", gripper_confs)

        self.grasps = GraspingDescription({"front": [0, 0, 0, 1],
                                           "left": [0, 0, -1, 1],
                                           "right": [0, 0, 1, 1],
                                           "top": [0, 1, 0, 1]})

    def get_camera_frame(self, name="optical"):
        # TODO: Hacky since only one optical camera frame from pr2 is used
        return super().get_camera_frame(name)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/robot_descriptions/pr2_description.py
from ..robot_description import *


class PR2Description(RobotDescription):

    def __init__(self):
        super().__init__("pr2", "base_footprint", "base_link", "torso_lift_link", "torso_lift_joint")
        # Camera
        minimal_height = 1.27
        maximal_height = 1.60
        horizontal_angle = 0.99483
        vertical_angle = 0.75049
        kinect = CameraDescription("head_mount_kinect_rgb_optical_frame",
                                   horizontal_angle=horizontal_angle, vertical_angle=vertical_angle,
                                   minimal_height=minimal_height, maximal_height=maximal_height)
        openni = CameraDescription("openni_rgb_optical_frame",
                                   horizontal_angle=horizontal_angle, vertical_angle=vertical_angle,
                                   minimal_height=minimal_height, maximal_height=maximal_height)
        stereo = CameraDescription("narrow_stereo_optical_frame",
                                   horizontal_angle=horizontal_angle, vertical_angle=vertical_angle,
                                   minimal_height=minimal_height, maximal_height=maximal_height)
        wide_stereo_optical_frame = CameraDescription("wide_stereo_optical_frame",
                                                      horizontal_angle=horizontal_angle,
                                                      vertical_angle=vertical_angle,
                                                      minimal_height=minimal_height, maximal_height=maximal_height)
        self.add_cameras({"optical_frame": wide_stereo_optical_frame, "kinect": kinect,
                          "openni": openni, "stereo": stereo})

        # The axis which points away from the camera and along which the picture of the camera is created
        self.front_facing_axis = [0, 0, 1]
        # Chains
        neck_static_joints = {}
        neck_static_joints["forward"] = [0.0, 0.0]
        neck = ChainDescription("neck", ["head_pan_joint", "head_tilt_joint"],
                                ["head_pan_link", "head_tilt_link"],
                                static_joint_states=neck_static_joints)
        self.add_chain("neck", neck)
        # Arms
        r_joints = ["r_shoulder_pan_joint", "r_shoulder_lift_joint", "r_upper_arm_roll_joint",
                    "r_elbow_flex_joint", "r_forearm_roll_joint", "r_wrist_flex_joint",
                    "r_wrist_roll_joint"]
        l_joints = ["l_shoulder_pan_joint", "l_shoulder_lift_joint", "l_upper_arm_roll_joint",
                    "l_elbow_flex_joint", "l_forearm_roll_joint", "l_wrist_flex_joint",
                    "l_wrist_roll_joint"]
        r_links = ["r_shoulder_pan_link", "r_shoulder_lift_link", "r_upper_arm_roll_link",
                   "r_upper_arm_link", "r_elbow_flex_link", "r_forearm_roll_link",
                   "r_forearm_link", "r_wrist_flex_link", "r_wrist_roll_link",
                   "r_gripper_led_frame", "r_gripper_motor_accelerometer_link", "r_gripper_tool_frame",
                   "r_gripper_motor_slider_link", "r_gripper_motor_screw_link"]
        l_links = ["l_shoulder_pan_link", "l_shoulder_lift_link", "l_upper_arm_roll_link",
                   "l_upper_arm_link", "l_elbow_flex_link", "l_forearm_roll_link", "l_forearm_link",
                   "l_wrist_flex_link", "l_wrist_roll_link", "l_gripper_led_frame",
                   "l_gripper_motor_accelerometer_link", "l_gripper_tool_frame",
                   "l_gripper_motor_slider_link", "l_gripper_motor_screw_link",
                   "l_force_torque_link", "l_force_torque_adapter_link"]
        r_gripper_joints = ["r_gripper_l_finger_joint", "r_gripper_r_finger_joint"]
        r_gripper_links = ["r_gripper_l_finger_tip_link", "r_gripper_r_finger_tip_link",
                           "r_gripper_l_finger_link", "r_gripper_r_finger_link",
                           "r_gripper_l_finger_tip_frame", "r_gripper_palm_link"]
        l_gripper_joints = ["l_gripper_l_finger_joint", "l_gripper_r_finger_joint"]
        l_gripper_links = ["l_gripper_l_finger_tip_link", "l_gripper_r_finger_tip_link",
                           "l_gripper_l_finger_link", "l_gripper_r_finger_link",
                           "l_gripper_l_finger_tip_frame", "l_gripper_palm_link"]
        # Arms
        left = ChainDescription("left", l_joints, l_links)
        right = ChainDescription("right", r_joints, r_links)
        left_inter = InteractionDescription(left, "l_wrist_roll_link")
        right_inter = InteractionDescription(right, "r_wrist_roll_link")
        # Gripper
        left_gripper = GripperDescription("left_gripper", l_gripper_links, l_gripper_joints,
                                          gripper_meter_to_jnt_multiplier=5.0,
                                          gripper_minimal_position=0.013,
                                          gripper_convergence_delta=0.005)
        right_gripper = GripperDescription("right_gripper", r_gripper_links, r_gripper_joints,
                                           gripper_meter_to_jnt_multiplier=5.0,
                                           gripper_minimal_position=0.013,
                                           gripper_convergence_delta=0.005)
        # Adding Arm + Gripper
        left_arm = ManipulatorDescription(left_inter, tool_frame="l_gripper_tool_frame",
                                          gripper_description=left_gripper)
        right_arm = ManipulatorDescription(right_inter, tool_frame="r_gripper_tool_frame",
                                           gripper_description=right_gripper)
        self.add_chains({"left": left_arm, "right": right_arm})
        # Adding Static Joint Poses
        # Static Arm Positions
        r_arm_park = [-1.712, -0.256, -1.463, -2.12, 1.766, -0.07, 0.051]
        l_arm_park = [1.712, -0.264, 1.38, -2.12, 16.996, -0.073, 0.0]
        self.add_static_joint_chain("right", "park", r_arm_park)
        self.add_static_joint_chain("left", "park", l_arm_park)
        # Static Gripper Positions
        gripper_confs = {"open": [0.548, 0.548], "close": [0.0, 0.0]}
        self.add_static_gripper_chains("left", gripper_confs)
        self.add_static_gripper_chains("right", gripper_confs)

        self.grasps = GraspingDescription({"front": [0, 0, 0, 1],
                                           "left": [0, 0, -1, 1],
                                           "right": [0, 0, 1, 1],
                                           "top": [0, 1, 0, 1]})

        self.gripper_action_topics = {"left": "l_gripper_controller/gripper_action",
                                      "right": "r_gripper_controller/gripper_action"}

    def get_camera_frame(self, name="optical_frame"):
        # TODO: Hacky since only one optical camera frame from pr2 is used
        return super().get_camera_frame(name)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/robot_descriptions/__init__.py
import logging
import re

import rospy

from .boxy_description import BoxyDescription
from .donbot_description import DonbotDescription
from .hsr_description import HSRDescription
from .pr2_description import PR2Description
from .ur5_description import UR5Description
from .tiago_description import TiagoDescription
from .. import utils
from ..robot_description import RobotDescription

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


class InitializedRobotDescription():
    # singleton instance short named as 'i'
    i = None
    current_description_loaded = None

    def __init__(self, robot_description):
        assert issubclass(robot_description, RobotDescription) and robot_description is not RobotDescription
        if not InitializedRobotDescription.i or \
                InitializedRobotDescription.current_description_loaded is not robot_description:
            InitializedRobotDescription.current_description_loaded = robot_description
            InitializedRobotDescription.i = robot_description()
            logger.info("(robot-description) (Re)Loaded Description of robot %s.", self.i.name)


def update_robot_description(robot_name=None, from_ros=None):
    # Get robot name
    if robot_name:
        robot = robot_name
    elif from_ros:
        try:
            urdf = rospy.get_param('robot_description')
        except Exception as e:
            logger.error("(robot-description) Could not get robot name from parameter server. Try again.")
            return None
        res = re.findall(r"robot\ *name\ *=\ *\"\ *[a-zA-Z_0-9]*\ *\"", urdf)
        if len(res) == 1:
            begin = res[0].find("\"")
            end = res[0][begin + 1:].find("\"")
            robot = res[0][begin + 1:begin + 1 + end].lower()
    else:
        return None

    # Choose Description based on robot name
    if 'iai_donbot' in robot:
        description = DonbotDescription
    elif 'pr2' in robot:
        description = PR2Description
    elif 'boxy' in robot:
        description = BoxyDescription
    elif 'hsr' in robot:
        description = HSRDescription
    elif "ur5_robotiq" in robot:
        description = UR5Description
    elif "tiago_dual" in robot:
        description = TiagoDescription
    else:
        logger.error("(robot-description) The given robot name %s has no description class.", robot_name)
        return None
    return InitializedRobotDescription(description)


with utils.suppress_stdout_stderr():
    update_robot_description(from_ros=True)  # "ur5_robotiq")#  # todo: put in ros init

robot_description = InitializedRobotDescription.i


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/robot_descriptions/boxy_description.py
from ..robot_description import *


class BoxyDescription(RobotDescription):

    def __init__(self):

        super().__init__("boxy", "base_footprint", "base_link", "triangle_base_link",
                         "triangle_base_joint", odom_frame="odom",
                         odom_joints=["odom_x_joint", "odom_y_joint", "odom_z_joint"])
        camera = CameraDescription("head_mount_kinect2_rgb_optical_frame",
                                   minimal_height=0.0, maximal_height=2.5,
                                   horizontal_angle=0.99483, vertical_angle=0.75049)
        self.add_camera("camera", camera)
        # The axis which points away from the camera and along which the picture of the camera is created
        self.front_facing_axis = [0, 0, 1]
        # Neck
        neck_links = ["neck_shoulder_link", "neck_upper_arm_link", "neck_forearm_link",
                      "neck_wrist_1_link", "neck_wrist_2_link", "neck_wrist_3_link"]
        neck_joints = ["neck_shoulder_pan_joint", "neck_shoulder_lift_joint", "neck_elbow_joint",
                       "neck_wrist_1_joint", "neck_wrist_2_joint", "neck_wrist_3_joint"]
        neck_base = "neck_base_link"
        neck_away = [-1.3155, -1.181355, -1.9562, 0.142417, 1.13492, 0.143467]  # up
        neck_down = [-1.176, -3.1252, -0.8397, 0.83967, 1.1347, -0.0266]
        neck_down_left = [-0.776, -3.1252, -0.8397, 0.83967, 1.1347, -0.0266]
        neck_down_right = [-2.176, -3.1252, -0.8397, 0.83967, 1.1347, -0.0266]
        neck_behind_up = [2.10, -1.11, -1.89, 0.64, 1.11, -0.43]
        neck_behind = [-1.68, -0.26, -0.12, -0.24, 1.49, 3.09]
        # neck_forward = [-1.39, -3.09, -0.78, 1.91, 1.51, -0.14]
        neck_forward = [-1.20, 2.39, 0.17, 1.77, 1.44, -0.35]
        # neck_right = [-1.20, 2.39, 0.17, 1.77, 1.44, 0.0]
        # neck_left = [-1.20, 2.39, 0.17, 1.77, 1.44, -0.7]
        neck = ChainDescription("neck", neck_joints, neck_links, base_link=neck_base)
        neck.add_static_joint_chains({"away": neck_away, "down": neck_down, "down_left": neck_down_left,
                                      "down_right": neck_down_right, "behind_up": neck_behind_up, "behind": neck_behind,
                                      "forward": neck_forward})
        self.add_chain("neck", neck)
        front = [-1.5, -1.57, 0, 1.58, -1.5, 0]
        neck_right = [3.14, -1.57, 0, 1.58, -1.5, 0]
        back = [1.5, -1.57, 0, 1.58, -1.5, 0]
        neck_left = [0, -1.57, 0, 1.58, -1.5, 0]
        self.add_static_joint_chains("neck", {"front": front, "neck_right": neck_right, "back": back,
                                              "neck_left": neck_left})

        # Arms
        left_joints = ["left_arm_0_joint", "left_arm_1_joint", "left_arm_2_joint",
                       "left_arm_3_joint", "left_arm_4_joint", "left_arm_5_joint",
                       "left_arm_6_joint"]
        left_links = ["left_arm_1_link", "left_arm_2_link", "left_arm_3_link",
                      "left_arm_4_link", "left_arm_5_link", "left_arm_6_link",
                      "left_arm_7_link"]
        right_joints = ["right_arm_0_joint", "right_arm_1_joint", "right_arm_2_joint",
                        "right_arm_3_joint", "right_arm_4_joint", "right_arm_5_joint",
                        "right_arm_6_joint"]
        right_links = ["right_arm_1_link", "right_arm_2_link", "right_arm_3_link",
                       "right_arm_4_link", "right_arm_5_link", "right_arm_6_link",
                       "right_arm_7_link"]
        # Gripper
        gripper_meter_to_jnt_multiplier = 1.0
        gripper_minimal_position = 0.0
        gripper_convergence_delta = 0.001
        l_gripper_links = ["left_gripper_base_link", "left_gripper_finger_left_link",
                           "left_gripper_finger_right_link", "left_gripper_gripper_left_link",
                           "left_gripper_gripper_right_link", "left_gripper_tool_frame"]
        l_gripper_joints = ["left_gripper_joint"]
        left_gripper = GripperDescription("left_gripper", gripper_links=l_gripper_links,
                                          gripper_joints=l_gripper_joints,
                                          gripper_meter_to_jnt_multiplier=gripper_meter_to_jnt_multiplier,
                                          gripper_minimal_position=gripper_minimal_position,
                                          gripper_convergence_delta=gripper_convergence_delta)
        r_gripper_links = ["right_gripper_base_link", "right_gripper_finger_left_link",
                           "right_gripper_finger_right_link", "right_gripper_gripper_left_link",
                           "right_gripper_gripper_right_link", "right_gripper_tool_frame"]
        r_gripper_joints = ["right_gripper_joint"]
        right_gripper = GripperDescription("right_gripper", gripper_links=r_gripper_links,
                                           gripper_joints=r_gripper_joints,
                                           gripper_meter_to_jnt_multiplier=gripper_meter_to_jnt_multiplier,
                                           gripper_minimal_position=gripper_minimal_position,
                                           gripper_convergence_delta=gripper_convergence_delta)
        # Arms
        left = ChainDescription("left", left_joints, left_links)
        left_inter = InteractionDescription(left, "left_arm_7_link")
        left_arm = ManipulatorDescription(left_inter, tool_frame="left_gripper_tool_frame",
                                          gripper_description=left_gripper)
        right = ChainDescription("right", right_joints, right_links)
        right_inter = InteractionDescription(right, "right_arm_7_link")
        right_arm = ManipulatorDescription(right_inter, tool_frame="right_gripper_tool_frame",
                                           gripper_description=right_gripper)
        self.add_chains({"left": left_arm, "right": right_arm})
        # Adding Static Joint Poses
        # Static Arm Positions
        l_carry = [-1.858, 0.70571, 0.9614, -0.602, -2.5922, -1.94065, -1.28735]
        r_carry = [1.858, -0.70571, -0.9614, 0.602, 2.5922, 1.94065, 1.28735]
        l_handover = [-0.32, 1.8, -0.74, -1.49, 2.29, 1.68, 0.2]
        l_flip = [-1.2274070978164673, 0.8496202230453491, -0.10349386930465698,
                  -1.0852965116500854, -0.4587952196598053, 1.259474515914917,
                  -0.06962397694587708]
        left_arm.add_static_joint_chains({"park": l_carry, "handover": l_handover, "flip": l_flip})
        right_arm.add_static_joint_chain("park", r_carry)

        # Grasping Poses
        self.grasps = GraspingDescription({"left":[1,0,0,1],
                                        "top": [1,1,0,0],
                                        "right": [0,1,1,0],
                                        "front": [1,0,1,0]})

##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/robot_descriptions/hsr_description.py
from ..robot_description import *


class HSRDescription(RobotDescription):

    def __init__(self):

        super().__init__("hsrb", "base_footprint", "base_link", "arm_lift_link", "arm_lift_joint")
        # Camera
        head_center_camera = CameraDescription("head_center_camera_frame",
                                               horizontal_angle=0.99483, vertical_angle=0.75049)
        head_r_camera = CameraDescription("head_r_stereo_camera_link",
                                          horizontal_angle=0.99483, vertical_angle=0.75049)
        head_l_camera = CameraDescription("head_r_stereo_camera_link",
                                          horizontal_angle=0.99483, vertical_angle=0.75049)
        head_rgbd_camera = CameraDescription("head_rgbd_sensor_link",
                                             horizontal_angle=0.99483, vertical_angle=0.75049)
        hand_camera = CameraDescription("hand_camera_frame",
                                        horizontal_angle=0.99483, vertical_angle=0.75049)
        self.add_cameras({"head_center_camera": head_center_camera, "head_rgbd_camera": head_rgbd_camera,
                          "head_l_camera": head_l_camera, "head_r_camera": head_r_camera,
                          "hand_camera": hand_camera})
        # The axis which points away from the camera and along which the picture of the camera is created
        self.front_facing_axis = [0, 0, 1]
        # Neck
        neck_links = ["head_pan_link", "head_tilt_link"]
        neck_joints = ["head_pan_joint", "head_tilt_joint"]
        neck_forward = {"forward": [0.0, 0.0], "down": [0.0, -0.7]}
        neck_chain = ChainDescription("neck", neck_joints, neck_links, static_joint_states=neck_forward)
        self.add_chain("neck", neck_chain)
        # Arm
        arm_joints = ["arm_flex_joint", "arm_roll_joint", "wrist_flex_joint", "wrist_roll_joint"]
        arm_links = ["arm_flex_link", "arm_roll_link", "wrist_flex_link", "wrist_roll_link"]
        arm_carry = {"park": [0, 1.5, -1.85, 0]}
        gripper_links = ["hand_l_distal_link", "hand_l_spring_proximal_link", "hand_palm_link",
                         "hand_r_distal_link", "hand_r_spring_proximal_link"]
        gripper_joints = ["hand_motor_joint"]
        gripper = GripperDescription("gripper", gripper_links=gripper_links, gripper_joints=gripper_joints,
                                     gripper_meter_to_jnt_multiplier=1.0, gripper_minimal_position=0.0,
                                     gripper_convergence_delta=0.001)
        arm_chain = ChainDescription("left", arm_joints, arm_links, static_joint_states=arm_carry)
        arm_inter = InteractionDescription(arm_chain, "wrist_roll_link")
        arm_manip = ManipulatorDescription(arm_inter, tool_frame="gripper_tool_frame", gripper_description=gripper)
        self.add_chain("left", arm_manip)
        self.add_static_gripper_chains("left", {"open": [0.3], "close": [0.0]})

    def get_camera_frame(self, name="head_center_camera"):
        # TODO: Hacky since only one optical camera frame from pr2 is used
        return super().get_camera_frame(name)

##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/orm/action_designator.py
from typing import Optional

from .base import RobotState, Designator, MapperArgsMixin, PoseMixin
from .object_designator import ObjectMixin
from ..enums import Arms
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import ForeignKey


class Action(MapperArgsMixin, Designator):
    """ORM class of pycram.designators.action_designator.ActionDesignator.
    The purpose of this class is to correctly map the inheritance from the action designator class into the database.
    Inheritance is implemented as Joined Table Inheritance (see https://docs.sqlalchemy.org/en/20/orm/inheritance.html)
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), primary_key=True, init=False)
    dtype: Mapped[str] = mapped_column("action_dtype", init=False)
    robot_state_id: Mapped[int] = mapped_column(ForeignKey(f"{RobotState.__tablename__}.id"), init=False)
    robot_state: Mapped[RobotState] = relationship(init=False)


class ParkArmsAction(Action):
    """ORM Class of pycram.designators.action_designator.ParkArmsDesignator."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms] = mapped_column(default=None)


class NavigateAction(PoseMixin, Action):
    """ORM Class of pycram.designators.action_designator.NavigateAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)


class MoveTorsoAction(Action):
    """ORM Class of pycram.designators.action_designator.MoveTorsoAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    position: Mapped[Optional[float]] = mapped_column(default=None)


class SetGripperAction(Action):
    """ORM Class of pycram.designators.action_designator.SetGripperAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    gripper: Mapped[str]
    motion: Mapped[str]


class Release(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.Release."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    gripper: Mapped[str] = mapped_column(init=False)


class GripAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.GripAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    gripper: Mapped[str] = mapped_column(init=False)
    effort: Mapped[float] = mapped_column(init=False)
    # TODO grasped_object


class PickUpAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.PickUpAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]
    grasp: Mapped[str]


class PlaceAction(PoseMixin, ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.PlaceAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]


class TransportAction(PoseMixin, ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.TransportAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]


class LookAtAction(PoseMixin, Action):
    """ORM Class of pycram.designators.action_designator.LookAtAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)


class DetectAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.DetectAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)


class OpenAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.OpenAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]
    # distance: Mapped[float] = mapped_column(init=False)


class CloseAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.CloseAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]


class GraspingAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.GraspingAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]



##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/orm/utils.py
import traceback
from anytree import Node, RenderTree, LevelOrderIter
import rospy
import sqlalchemy
import pycram.orm.base
from pycram.designators.action_designator import *
from pycram.designators.object_designator import *
import json

from pycram.designators.action_designator import *
from pycram.designators.location_designator import *
from pycram.process_module import simulated_robot
from pycram.enums import Arms, ObjectType
from pycram.task import with_tree
import pycram.orm


def write_database_to_file(in_sessionmaker: sqlalchemy.orm.sessionmaker, filename: str,
                           b_write_to_console: bool = False):
    """
    Writes all Tables stored within the given session into a local file. File will be written in JSON Format

    :param in_sessionmaker: sessionmaker that allows us to access the Database
    :param filename: Filename of the logfile
    :param b_write_to_console: enables writing to the console. Default false
    """
    with in_sessionmaker() as session:
        with open("whatever.txt", "w") as f:
            to_json_dict = dict()
            for table in pycram.orm.base.Base.metadata.sorted_tables:
                list_of_row = list()
                for column_object in session.query(table).all():
                    list_of_row.append(column_object)
                to_json_dict[table.name] = list_of_row
            json_data_dict = json.dumps(to_json_dict, default=str)
            f.write(json_data_dict)


def print_database(in_sessionmaker: sqlalchemy.orm.sessionmaker):
    """
    Prints all ORM Class data within the given Session.

    :param in_sessionmaker: Database Session which should be printed
    """
    with in_sessionmaker() as session:
        for table in pycram.orm.base.Base.metadata.sorted_tables:
            try:
                smt = sqlalchemy.select('*').select_from(table)
                result = session.execute(smt).all()
                rospy.loginfo("Table: {}\tcontent:{}".format(table, result))
            except sqlalchemy.exc.ArgumentError as e:
                rospy.logwarn(e)


def update_primary_key(source_session_maker: sqlalchemy.orm.sessionmaker,
                       destination_session_maker: sqlalchemy.orm.sessionmaker):
    """
    Updates all the primary keys of the database associated with the destination engine, so that there will be no
    problems when merging it into the source database. In order to achieve this the highest id value of the source
    engine is searched and the primary keys of the destination database will get all the values following that.
    Cascading triggers in the database will take care of the rest. Careful 2023 this will not work in
    memory databases as there are no triggers.

    :param source_session_maker: Session maker of the source data_base
    :param destination_session_maker: Session maker of the destination data_base
    """
    destination_session = destination_session_maker()
    source_session = source_session_maker()
    sortedTables = pycram.orm.base.Base.metadata.sorted_tables
    for table in sortedTables:
        try:
            list_of_primary_keys_of_this_table = table.primary_key.columns.values()
            for key in list_of_primary_keys_of_this_table:
                all_source_key_values = []
                all_destination_key_values = []
                for key_value_row in source_session.query(key).all():
                    all_source_key_values.append(key_value_row[0])  # get all values of key from source session
                for key_value_row in destination_session.query(key).all():
                    all_destination_key_values.append(key_value_row[0])  # get all values of key from source session

                highest_free_key_value = max(max(all_source_key_values, default=0),
                                             max(all_destination_key_values, default=0)) + 1
                results = destination_session.execute(sqlalchemy.select(table))
                for column_object in results:  # iterate over all columns
                    if column_object.__getattr__(key.name) in all_source_key_values:
                        rospy.loginfo(
                            "Found primary_key collision in table {} value: {} max value in memory {}".format(table,
                                                                                                              column_object.__getattr__(
                                                                                                                  key.name),
                                                                                                              highest_free_key_value))
                        mini_dict = dict()
                        mini_dict[key.name] = highest_free_key_value
                        update_statement = sqlalchemy.update(table).where(
                            table.c.id == column_object.__getattr__(key)).values(mini_dict)
                        destination_session.execute(update_statement)
                        highest_free_key_value += 1
            destination_session.commit()  # commit after every table
        except AttributeError as e:
            rospy.logwarn("Possible found abstract ORM class {}".format(e.__name__))
            rospy.logwarn(e)
    destination_session.close()


def copy_database(source_session_maker: sqlalchemy.orm.sessionmaker,
                  destination_session_maker: sqlalchemy.orm.sessionmaker):
    """
    Iterates through all tables within tht source database and merges them into the destination database. Careful
    this function does not check if there are any primary key collisions or updates any data.

     .. note::
        Ignores all previously detached data, could result in loss of information. During testing database objects
        sometimes had a detached twin. As a possible feature in the future it maybe useful to give the user an
        opportunity to decide what happens with the detached objects. Careful this could lead to duplicated data in the
        destination database.

    :param source_session_maker: Sessionmaker of the source database
    :param destination_session_maker: Sessionmaker of the destination database
    """

    with source_session_maker() as source_session, destination_session_maker() as destination_session:
        sorted_tables = pycram.orm.base.Base.metadata.sorted_tables
        for table in sorted_tables:
            for value in source_session.query(table).all():
                insert_statement = sqlalchemy.insert(table).values(value)
                destination_session.execute(insert_statement)
            destination_session.commit()  # commit after every table


def update_primary_key_constrains(session_maker: sqlalchemy.orm.sessionmaker):
    '''
    Iterates through all tables related to any ORM Class and sets in their corresponding foreign keys in the given
    endpoint to "ON UPDATE CASCADING".

        .. note::
            Careful currently only works on postgres databases.

    :param session_maker:
    :return: empty
    '''
    with session_maker() as session:
        for table in pycram.orm.base.Base.metadata.sorted_tables:
            try:
                foreign_key_statement = sqlalchemy.text(
                    "SELECT con.oid, con.conname, con.contype, con.confupdtype, con.confdeltype, con.confmatchtype, pg_get_constraintdef(con.oid) FROM pg_catalog.pg_constraint con INNER JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid INNER JOIN pg_catalog.pg_namespace nsp ON nsp.oid = connamespace WHERE rel.relname = '{}';".format(
                        table))
                response = session.execute(foreign_key_statement)
                rospy.loginfo(25 * '~' + "{}".format(table) + 25 * '~')
                for line in response:
                    if line.conname.endswith("fkey"):
                        if 'a' in line.confupdtype:  # a --> no action | if there is no action we set it to cascading
                            # Assumes there aren't any other constraints
                            drop_statement = sqlalchemy.text(
                                "alter table \"{}\" drop constraint \"{}\";".format(table,
                                                                                    line.conname))
                            drop_response = session.execute(
                                drop_statement)  # There is no real data coming back for this
                            alter_statement = sqlalchemy.text(
                                "alter table \"{}\" add constraint {} {} on update cascade;".format(
                                    table,
                                    line.conname,
                                    line.pg_get_constraintdef))
                            alter_response = session.execute(
                                alter_statement)  # There is no real data coming back for this
                            session.commit()
            except AttributeError:
                rospy.loginfo("Attribute Error: {} has no attribute __tablename__".format(table))


def migrate_neems(source_session_maker: sqlalchemy.orm.sessionmaker,
                  destination_session_maker: sqlalchemy.orm.sessionmaker):
    """
        Merges the database connected to the source session maker into the database connected to the destination session
        maker. Will first update the primary constrains inside the destination database (if needed). Afterwards
        updates the primary keys within the destination database (as there are cascading updates now) and then merges
        the source database into the destination.

         .. note::
            Assumes the destination database is a postgres database

        :param source_session_maker: Sessionmaker of the source database
        :param destination_session_maker: Sessionmaker of the destination database
        """

    update_primary_key_constrains(destination_session_maker)
    update_primary_key(source_session_maker, destination_session_maker)
    copy_database(source_session_maker, destination_session_maker)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/orm/object_designator.py
from dataclasses import field
from typing import Optional

from pycram.orm.base import Base, MapperArgsMixin, PoseMixin, Pose
from sqlalchemy.orm import Mapped, mapped_column, declared_attr, relationship, MappedAsDataclass
from sqlalchemy import ForeignKey
from ..enums import ObjectType


class ObjectMixin(MappedAsDataclass):
    """
    ObjectMixin holds a foreign key column and its relationship to the referenced table.
    For information about Mixins, see https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/mixins.html
    """

    __abstract__ = True
    object_to_init: bool = field(default=False, init=False)

    @declared_attr
    def object_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=self.object_to_init)

    @declared_attr
    def object(self):
        return relationship(Object.__tablename__, init=False)


class Object(PoseMixin, Base):
    """ORM class of pycram.designators.object_designator.ObjectDesignator"""

    dtype: Mapped[str] = mapped_column(init=False)
    type: Mapped[Optional[ObjectType]]
    name: Mapped[str]

    __mapper_args__ = {
        "polymorphic_identity": "Object",
        "polymorphic_on": "dtype",
    }


class ObjectPart(Object):
    """ORM Class of pycram.designators.object_designator.LocatedObject."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), primary_key=True, init=False)
    # part_of: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=False)

    __mapper_args__ = {
        "polymorphic_identity": "ObjectPart",
        "inherit_condition": Object.id == id
    }


class BelieveObject(MapperArgsMixin, Object):

    id: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), primary_key=True, init=False)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/orm/base.py
"""Implementation of base classes for orm modelling."""
import datetime
import getpass
import os
from dataclasses import field
from typing import Optional

import git
import rospkg
import sqlalchemy.sql.functions
from sqlalchemy import ForeignKey, String
from sqlalchemy.orm import DeclarativeBase, Mapped, MappedAsDataclass, mapped_column, Session, relationship, \
    declared_attr

from ..enums import ObjectType


def get_pycram_version_from_git() -> Optional[str]:
    """
    Get the PyCRAM commit hash that is used to run this version.

    This assumes that you have gitpython installed and that the PyCRAM git repository on your system can be found
    with "roscd pycram".
    """

    r = rospkg.RosPack()
    repo = git.Repo(path=r.get_path('pycram'))
    return repo.head.object.hexsha


class _Base(DeclarativeBase, MappedAsDataclass):
    """Dummy class"""
    type_annotation_map = {
        str: String(255)
    }

    id: Mapped[int] = mapped_column(autoincrement=True, primary_key=True, init=False, nullable=False)
    """Unique integer ID as auto incremented primary key."""

    @declared_attr
    def __tablename__(self):
        return self.__name__


class Base(_Base):
    """
    Base class to add orm functionality to all pycram mappings
    """
    __abstract__ = True

    @declared_attr
    def process_metadata_id(self) -> Mapped[Optional[int]]:
        return mapped_column(ForeignKey(f'{ProcessMetaData.__tablename__}.id'), default=None, init=False)
    """Related MetaData Object to store information about the context of this experiment."""

    @declared_attr
    def process_metadata(self):
        return relationship(ProcessMetaData.__tablename__)
    """model relationship between foreign key in ProcessMetaData table and the ids of all inheriting
    tables"""


class MapperArgsMixin(MappedAsDataclass):
    """
    MapperArgsMixin stores __mapper_args__ information for certain subclass-tables.
    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html
    """

    __abstract__ = True

    @declared_attr
    def __mapper_args__(self):
        return {"polymorphic_identity": self.__tablename__}


class PositionMixin(MappedAsDataclass):
    """
    PositionMixin holds a foreign key column and its relationship to the referenced table.
    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html
    """

    __abstract__ = True
    position_to_init: bool = field(default=False, init=False)

    @declared_attr
    def position_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{Position.__tablename__}.id'), init=self.position_to_init)

    @declared_attr
    def position(self):
        return relationship(Position.__tablename__, init=False)


class QuaternionMixin(MappedAsDataclass):
    """
    QuaternionMixin holds a foreign key column and its relationship to the referenced table.
    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html
    """

    __abstract__ = True
    orientation_to_init: bool = field(default=False, init=False)

    @declared_attr
    def orientation_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{Quaternion.__tablename__}.id'), init=self.orientation_to_init)

    @declared_attr
    def orientation(self):
        return relationship(Quaternion.__tablename__, init=False)


class PoseMixin(MappedAsDataclass):
    """
    PoseMixin holds a foreign key column and its relationship to the referenced table.
    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html
    """

    __abstract__ = True
    pose_to_init: bool = field(default=False, init=False)

    @declared_attr
    def pose_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{Pose.__tablename__}.id'), init=self.pose_to_init)

    @declared_attr
    def pose(self):
        return relationship(Pose.__tablename__, init=False)


class ProcessMetaData(_Base):
    """
    ProcessMetaData stores information about the context of this experiment.

    This class is a singleton and only one MetaData can exist per session.
    """

    created_at: Mapped[datetime.datetime] = mapped_column(server_default=sqlalchemy.sql.functions.current_timestamp(),
                                                          init=False)
    """The timestamp where this row got created. This is an aid for versioning."""

    created_by: Mapped[str] = mapped_column(default=getpass.getuser(), init=False)
    """The user that created the experiment."""

    description: Mapped[str] = mapped_column(init=False)
    """A description of the purpose (?) of this experiment."""

    pycram_version: Mapped[str] = mapped_column(default=get_pycram_version_from_git(),
                                                nullable=True, init=False)
    """The PyCRAM version used to generate this row."""

    _self = None
    """The singleton instance."""

    def __new__(cls):
        if cls._self is None:
            cls._self = super().__new__(cls)
        return cls._self

    def committed(self):
        """Return if this object is in the database or not."""
        return self.id is not None

    def insert(self, session: Session):
        """Insert this into the database using the session. Skipped if it already is inserted."""
        if not self.committed():
            session.add(self)
            session.commit()
        return self

    @classmethod
    def reset(cls):
        """Reset the singleton instance to None, s. t. next time the class is called a new instance is created."""
        cls._self = None


class Designator(Base):
    """ORM Class holding every performed action and motion serving as every actions and motions root."""

    @declared_attr
    def dtype(self) -> Mapped[str]:
        return mapped_column(String(255), nullable=False, init=False)

    @declared_attr
    def __mapper_args__(self):
        return {
            "polymorphic_on": "dtype",
        }


class Position(Base):
    """ORM Class for 3D positions."""

    x: Mapped[float]
    y: Mapped[float]
    z: Mapped[float]


class Quaternion(Base):
    """ORM Class for Quaternions."""

    x: Mapped[float]
    y: Mapped[float]
    z: Mapped[float]
    w: Mapped[float]


class Pose(PositionMixin, QuaternionMixin, Base):
    """ORM Class for Poses."""

    time: Mapped[datetime.datetime]
    frame: Mapped[str]


class Color(Base):
    """ORM Class for Colors."""

    r: Mapped[float]
    g: Mapped[float]
    b: Mapped[float]
    alpha: Mapped[float]


class RobotState(PoseMixin, Base):
    """ORM Representation of a robots state."""

    pose_to_init = True

    torso_height: Mapped[float]
    """The torso height of the robot."""

    type: Mapped[ObjectType]
    """The type of the robot."""


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/orm/__init__.py
from . import base, action_designator, object_designator, motion_designator, task


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/orm/task.py
"""Implementation of ORM classes associated with pycram.task."""
from typing import Optional
from sqlalchemy import ForeignKey
from sqlalchemy.orm import MappedAsDataclass, Mapped, mapped_column, relationship
from .action_designator import Action
from .base import Base, Designator
from .motion_designator import Motion
from ..enums import TaskStatus
import datetime


class TaskTreeNode(Base):
    """ORM equivalent of pycram.task.TaskTreeNode."""

    id: Mapped[int] = mapped_column(autoincrement=True, primary_key=True, init=False)
    """id overriden in order to be able to set the remote_side of the parent attribute"""

    code_id: Mapped[int] = mapped_column(ForeignKey("Code.id"), default=None)
    code: Mapped["Code"] = relationship(init=False)
    start_time: Mapped[datetime.datetime] = mapped_column(default=None)
    end_time: Mapped[Optional[datetime.datetime]] = mapped_column(default=None)
    status: Mapped[TaskStatus] = mapped_column(default=None)
    reason: Mapped[Optional[str]] = mapped_column(default=None)
    parent_id: Mapped[Optional[int]] = mapped_column(ForeignKey("TaskTreeNode.id"), default=None)
    parent: Mapped["TaskTreeNode"] = relationship(foreign_keys=[parent_id], init=False, remote_side=[id])


class Code(Base):
    """ORM equivalent of pycram.task.Code."""

    function: Mapped[str] = mapped_column(default=None)
    designator_id: Mapped[Optional[int]] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), default=None)
    designator: Mapped[Designator] = relationship(init=False)



##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/orm/motion_designator.py
"""
This module defines a set of ORM classes related to motion designators in the pycram framework.

Each motion designator class has its own table in the database with columns representing its attributes.
The MotionDesignator class is the base class that defines the polymorphic behavior of all other motion designator
classes.
"""
from typing import Optional

from .base import MapperArgsMixin, Designator, PoseMixin
from .object_designator import Object, ObjectMixin
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import ForeignKey

from ..enums import ObjectType


class Motion(MapperArgsMixin, Designator):
    """
    ORM class of pycram.designators.motion_designator.MotionDesignatorDescription

    :ivar id: (Integer) Auto-incrementing primary key
    :ivar dtype: (String) Polymorphic discriminator
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), primary_key=True, init=False)
    dtype: Mapped[str] = mapped_column("motion_dtype", init=False)


class MoveMotion(PoseMixin, Motion):
    """
    ORM class of pycram.designators.motion_designator.MoveMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)


class AccessingMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.AccessingMotion

    :ivar arm: (String) Name of the arm used
    :ivar gripper: (String) Name of the gripper used
    :ivar distance: (Float) Distance from the drawer to the robot
    :ivar drawer_joint:
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    part_of: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=False)
    object: Mapped[Object] = relationship(init=False)
    arm: Mapped[str] = mapped_column(init=False)
    gripper: Mapped[str] = mapped_column(init=False)
    distance: Mapped[float] = mapped_column(init=False)
    drawer_joint: Mapped[str] = mapped_column(init=False)
    drawer_handle: Mapped[str] = mapped_column(init=False)


class MoveTCPMotion(PoseMixin, Motion):
    """
    ORM class of pycram.designators.motion_designator.MoveTCPMotion

    :ivar arm: String specifying which arm to move the TCP of
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]
    allow_gripper_collision: Mapped[Optional[bool]]


class LookingMotion(PoseMixin, Motion):
    """
    ORM class of pycram.designators.motion_designator.LookingMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)


class MoveGripperMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.MoveGripperMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    motion: Mapped[str]
    gripper: Mapped[str]
    allow_gripper_collision: Mapped[Optional[bool]]


class DetectingMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.DetectingMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    object_type: Mapped[ObjectType]


class WorldStateDetectingMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.WorldStateDetectingMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    object_type: Mapped[str] = mapped_column(init=False)


class OpeningMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.OpeningMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]


class ClosingMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.ClosingMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[str]


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/external_interfaces/giskard.py
import json
import threading

import rosnode
import rospy
import sys
import rosnode
import urdf_parser_py

import traceback

from ..pose import Pose
from ..robot_descriptions import robot_description
from ..bullet_world import BulletWorld, Object
from ..robot_description import ManipulatorDescription

from typing import List, Tuple, Dict, Callable, Optional
from geometry_msgs.msg import PoseStamped, PointStamped, QuaternionStamped, Vector3Stamped
from threading import Lock, RLock

try:
    from giskardpy.python_interface import GiskardWrapper
    from giskard_msgs.msg import WorldBody, MoveResult, CollisionEntry
    from giskard_msgs.srv import UpdateWorldRequest, UpdateWorld, UpdateWorldResponse, RegisterGroupResponse
except ModuleNotFoundError as e:
    rospy.logwarn("Failed to import Giskard messages")

giskard_wrapper = None
giskard_update_service = None
is_init = False

number_of_par_goals = 0
giskard_lock = Lock()
giskard_rlock = RLock()
with giskard_rlock:
    par_threads = {}
    par_motion_goal = {}


def thread_safe(func: Callable) -> Callable:
    """
    Adds thread safety to a function via a decorator. This uses the giskard_lock

    :param func: Function that should be thread safe
    :return: A function with thread safety
    """

    def wrapper(*args, **kwargs):
        with giskard_rlock:
            return func(*args, **kwargs)

    return wrapper


def init_giskard_interface(func: Callable) -> Callable:
    """
    Checks if the ROS messages are available and if giskard is running, if that is the case the interface will be
    initialized.

    :param func: Function this decorator should be wrapping
    :return: A callable function which initializes the interface and then calls the wrapped function
    """

    def wrapper(*args, **kwargs):
        global giskard_wrapper
        global giskard_update_service
        global is_init
        if is_init and "/giskard" in rosnode.get_node_names():
            return func(*args, **kwargs)
        elif is_init and "/giskard" not in rosnode.get_node_names():
            rospy.logwarn("Giskard node is not available anymore, could not initialize giskard interface")
            is_init = False
            return

        if "giskard_msgs" not in sys.modules:
            rospy.logwarn("Could not initialize the Giskard interface since the giskard_msgs are not imported")
            return

        if "/giskard" in rosnode.get_node_names():
            giskard_wrapper = GiskardWrapper()
            giskard_update_service = rospy.ServiceProxy("/giskard/update_world", UpdateWorld)
            rospy.loginfo_once("Successfully initialized Giskard interface")
            is_init = True
        else:
            rospy.logwarn("Giskard is not running, could not initialize Giskard interface")
            return
        return func(*args, **kwargs)

    return wrapper


# Believe state management between pycram and giskard


@init_giskard_interface
def initial_adding_objects() -> None:
    """
    Adds object that are loaded in the BulletWorld to the Giskard belief state, if they are not present at the moment.
    """
    groups = giskard_wrapper.get_group_names()
    for obj in BulletWorld.current_bullet_world.objects:
        if obj is BulletWorld.robot:
            continue
        name = obj.name + "_" + str(obj.id)
        if name not in groups:
            spawn_object(obj)


@init_giskard_interface
def removing_of_objects() -> None:
    """
    Removes objects that are present in the Giskard belief state but not in the BulletWorld from the Giskard belief state.
    """
    groups = giskard_wrapper.get_group_names()
    object_names = list(
        map(lambda obj: object_names.name + "_" + str(obj.id), BulletWorld.current_bullet_world.objects))
    diff = list(set(groups) - set(object_names))
    for grp in diff:
        giskard_wrapper.remove_group(grp)


@init_giskard_interface
def sync_worlds() -> None:
    """
    Synchronizes the BulletWorld and the Giskard belief state, this includes adding and removing objects to the Giskard
    belief state such that it matches the objects present in the BulletWorld and moving the robot to the position it is
    currently at in the BulletWorld.
    """
    add_gripper_groups()
    bullet_object_names = set()
    for obj in BulletWorld.current_bullet_world.objects:
        if obj.name != robot_description.name and len(obj.links) != 1:
            bullet_object_names.add(obj.name + "_" + str(obj.id))

    giskard_object_names = set(giskard_wrapper.get_group_names())
    robot_name = {robot_description.name}
    if not bullet_object_names.union(robot_name).issubset(giskard_object_names):
        giskard_wrapper.clear_world()
    initial_adding_objects()


@init_giskard_interface
def update_pose(object: Object) -> 'UpdateWorldResponse':
    """
    Sends an update message to giskard to update the object position. Might not work when working on the real robot just
    in standalone mode.

    :param object: Object that should be updated
    :return: An UpdateWorldResponse
    """
    return giskard_wrapper.update_group_pose(object.name + "_" + str(object.id), object.get_pose())


@init_giskard_interface
def spawn_object(object: Object) -> None:
    """
    Spawns a BulletWorld Object in the giskard belief state.

    :param object: BulletWorld object that should be spawned
    """
    if len(object.links) == 1:
        geometry = object.urdf_object.link_map[object.urdf_object.get_root()].collision.geometry
        if isinstance(geometry, urdf_parser_py.urdf.Mesh):
            filename = geometry.filename
            spawn_mesh(object.name + "_" + str(object.id), filename, object.get_pose())
    else:
        spawn_urdf(object.name + "_" + str(object.id), object.path, object.get_pose())


@init_giskard_interface
def remove_object(object: Object) -> 'UpdateWorldResponse':
    """
    Removes an object from the giskard belief state.

    :param object: The BulletWorld Object that should be removed
    """
    return giskard_wrapper.remove_group(object.name + "_" + str(object.id))


@init_giskard_interface
def spawn_urdf(name: str, urdf_path: str, pose: Pose) -> 'UpdateWorldResponse':
    """
    Spawns an URDF in giskard's belief state.

    :param name: Name of the URDF
    :param urdf_path: Path to the URDF file
    :param pose: Pose in which the URDF should be spawned
    :return: An UpdateWorldResponse message
    """
    urdf_string = ""
    with open(urdf_path) as f:
        urdf_string = f.read()

    return giskard_wrapper.add_urdf(name, urdf_string, pose)


@init_giskard_interface
def spawn_mesh(name: str, path: str, pose: Pose) -> 'UpdateWorldResponse':
    """
    Spawns a mesh into giskard's belief state

    :param name: Name of the mesh
    :param path: Path to the mesh file
    :param pose: Pose in which the mesh should be spawned
    :return: An UpdateWorldResponse message
    """
    return giskard_wrapper.add_mesh(name, path, pose)


# Sending Goals to Giskard

@thread_safe
def _manage_par_motion_goals(goal_func, *args) -> Optional['MoveResult']:
    """
    Manages multiple goals that should be executed in parallel. The current sequence of motion goals is saved and the
    parallel motion goal is loaded if there is one, then the new motion goal given by ``goal_func`` is added to the
    parallel motion goal. If this was the last motion goal for the parallel motion goal it is then executed.

    :param goal_func: Function which adds a new motion goal to the giskard_wrapper
    :param args: Arguments for the ``goal_func`` function
    :return: MoveResult of the execution if there was an execution, True if a new motion goal was added to the giskard_wrapper and None in any other case
    """
    for key, value in par_threads.items():
        if threading.get_ident() in value:
            tmp = giskard_wrapper.cmd_seq

            if key in par_motion_goal.keys():
                giskard_wrapper.cmd_seq = par_motion_goal[key]
            else:
                giskard_wrapper.clear_cmds()

            goal_func(*args)

            # Check if there are multiple constraints that use the same joint, if this is the case the
            used_joints = set()
            for cmd in giskard_wrapper.cmd_seq:
                for con in cmd.constraints:
                    par_value_pair = json.loads(con.parameter_value_pair)
                    if "tip_link" in par_value_pair.keys() and "root_link" in par_value_pair.keys():
                        if par_value_pair["tip_link"] == robot_description.base_link:
                            continue
                        chain = BulletWorld.robot.urdf_object.get_chain(par_value_pair["root_link"],
                                                                        par_value_pair["tip_link"])
                        if set(chain).intersection(used_joints) != set():
                            giskard_wrapper.cmd_seq = tmp
                            raise AttributeError(f"The joint(s) {set(chain).intersection(used_joints)} is used by multiple Designators")
                        else:
                            [used_joints.add(joint) for joint in chain]
                            
                    elif "goal_state" in par_value_pair.keys():
                        if set(par_value_pair["goal_state"].keys()).intersection(used_joints) != set():
                            giskard_wrapper.cmd_seq = tmp
                            raise AttributeError(f"The joint(s) {set(par_value_pair['goal_state'].keys()).intersection(used_joints)} is used by multiple Designators")
                        else:
                            [used_joints.add(joint) for joint in par_value_pair["goal_state"].keys()]

            par_threads[key].remove(threading.get_ident())
            if len(par_threads[key]) == 0:
                if key in par_motion_goal.keys():
                    del par_motion_goal[key]
                del par_threads[key]
                res = giskard_wrapper.plan_and_execute()
                giskard_wrapper.cmd_seq = tmp
                return res
            else:
                par_motion_goal[key] = giskard_wrapper.cmd_seq
                giskard_wrapper.cmd_seq = tmp
                return True


@init_giskard_interface
@thread_safe
def achieve_joint_goal(goal_poses: Dict[str, float]) -> 'MoveResult':
    """
    Takes a dictionary of joint position that should be achieved, the keys in the dictionary are the joint names and
    values are the goal joint positions.

    :param goal_poses: Dictionary with joint names and position goals
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_joint_goal, goal_poses)
    if par_return:
        return par_return

    giskard_wrapper.set_joint_goal(goal_poses)
    return giskard_wrapper.plan_and_execute()


@init_giskard_interface
@thread_safe
def achieve_cartesian_goal(goal_pose: Pose, tip_link: str, root_link: str) -> 'MoveResult':
    """
    Takes a cartesian position and tries to move the tip_link to this position using the chain defined by
    tip_link and root_link.

    :param goal_pose: The position which should be achieved with tip_link
    :param tip_link: The end link of the chain as well as the link which should achieve the goal_pose
    :param root_link: The starting link of the chain which should be used to achieve this goal
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_cart_goal, _pose_to_pose_stamped(goal_pose),
                                          tip_link, root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)
    return giskard_wrapper.plan_and_execute()


@init_giskard_interface
@thread_safe
def achieve_straight_cartesian_goal(goal_pose: Pose, tip_link: str,
                                    root_link: str) -> 'MoveResult':
    """
    Takes a cartesian position and tries to move the tip_link to this position in a straight line, using the chain
    defined by tip_link and root_link.

    :param goal_pose: The position which should be achieved with tip_link
    :param tip_link: The end link of the chain as well as the link which should achieve the goal_pose
    :param root_link: The starting link of the chain which should be used to achieve this goal
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_straight_cart_goal, _pose_to_pose_stamped(goal_pose),
                                          tip_link, root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_straight_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)
    return giskard_wrapper.plan_and_execute()


@init_giskard_interface
@thread_safe
def achieve_translation_goal(goal_point: List[float], tip_link: str, root_link: str) -> 'MoveResult':
    """
    Tries to move the tip_link to the position defined by goal_point using the chain defined by root_link and
    tip_link. Since goal_point only defines the position but no rotation, rotation is not taken into account.

    :param goal_point: The goal position of the tip_link
    :param tip_link: The link which should be moved to goal_point as well as the end of the used chain
    :param root_link: The start link of the chain
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_translation_goal, make_point_stamped(goal_point),
                                          tip_link, root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_translation_goal(make_point_stamped(goal_point), tip_link, root_link)
    return giskard_wrapper.plan_and_execute()


@init_giskard_interface
@thread_safe
def achieve_straight_translation_goal(goal_point: List[float], tip_link: str, root_link: str) -> 'MoveResult':
    """
    Tries to move the tip_link to the position defined by goal_point in a straight line, using the chain defined by
    root_link and tip_link. Since goal_point only defines the position but no rotation, rotation is not taken into account.

    :param goal_point: The goal position of the tip_link
    :param tip_link: The link which should be moved to goal_point as well as the end of the used chain
    :param root_link: The start link of the chain
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_straight_translation_goal,
                                          make_point_stamped(goal_point),
                                          tip_link, root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_straight_translation_goal(make_point_stamped(goal_point), tip_link, root_link)
    return giskard_wrapper.plan_and_execute()


@init_giskard_interface
@thread_safe
def achieve_rotation_goal(quat: List[float], tip_link: str, root_link: str) -> 'MoveResult':
    """
    Tries to bring the tip link into the rotation defined by quat using the chain defined by root_link and
    tip_link.

    :param quat: The rotation that should be achieved, given as a quaternion
    :param tip_link: The link that should be in the rotation defined by quat
    :param root_link: The start link of the chain
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_rotation_goal, make_quaternion_stamped(quat),
                                          tip_link, root_link)
    if par_threads:
        return par_return

    giskard_wrapper.set_rotation_goal(make_quaternion_stamped(quat), tip_link, root_link)
    return giskard_wrapper.plan_and_execute()


@init_giskard_interface
@thread_safe
def achieve_align_planes_goal(goal_normal: List[float], tip_link: str, tip_normal: List[float],
                              root_link: str) -> 'MoveResult':
    """
    Tries to align the plane defined by tip normal with goal_normal using the chain between root_link and
    tip_link.

    :param goal_normal: The goal plane, given as a list of XYZ
    :param tip_link: The end link of the chain that should be used.
    :param tip_normal: The plane that should be aligned with goal_normal, given as a list of XYZ
    :param root_link: The starting link of the chain that should be used.
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_align_planes_goal, make_vector_stamped(goal_normal),
                                          tip_link, make_vector_stamped(tip_normal), root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_align_planes_goal(make_vector_stamped(goal_normal), tip_link,
                                          make_vector_stamped(tip_normal),
                                          root_link)
    return giskard_wrapper.plan_and_execute()


@init_giskard_interface
@thread_safe
def achieve_open_container_goal(tip_link: str, environment_link: str) -> 'MoveResult':
    """
    Tries to open a container in an environment, this only works if the container was added as a URDF. This goal assumes
    that the handle was already grasped. Can only handle container with 1 DOF

    :param tip_link: The End effector that should open the container
    :param environment_link: The name of the handle for this container.
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_open_container_goal, tip_link, environment_link)
    if par_return:
        return par_return
    giskard_wrapper.set_open_container_goal(tip_link, environment_link)
    return giskard_wrapper.plan_and_execute()


@init_giskard_interface
@thread_safe
def achieve_close_container_goal(tip_link: str, environment_link: str) -> 'MoveResult':
    """
    Tries to close a container, this only works if the container was added as a URDF. Assumes that the handle of the
    container was already grasped. Can only handle container with 1 DOF.

    :param tip_link: Link name that should be used to close the container.
    :param environment_link: Name of the handle
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_close_container_goal, tip_link, environment_link)
    if par_return:
        return par_return

    giskard_wrapper.set_close_container_goal(tip_link, environment_link)
    return giskard_wrapper.plan_and_execute()


# Managing collisions

@init_giskard_interface
def allow_gripper_collision(gripper: str) -> None:
    """
    Allows the specified gripper to collide with anything.

    :param gripper: The gripper which can collide, either 'right', 'left' or 'all'
    """
    add_gripper_groups()
    for gripper_group in get_gripper_group_names():
        if gripper in gripper_group or gripper == "all":
            giskard_wrapper.allow_collision(gripper_group, CollisionEntry.ALL)


@init_giskard_interface
def get_gripper_group_names() -> List[str]:
    """
    Returns a list of groups that are registered in giskard which have 'gripper' in their name.

    :return: The list of gripper groups
    """
    groups = giskard_wrapper.get_group_names()
    return list(filter(lambda elem: "gripper" in elem, groups))


@init_giskard_interface
def add_gripper_groups() -> None:
    """
    Adds the gripper links as a group for collision avoidance.

    :return: Response of the RegisterGroup Service
    """
    with giskard_lock:
        for name in giskard_wrapper.get_group_names():
            if "gripper" in name:
                return

        for name, description in robot_description.chains.items():
            if isinstance(description, ManipulatorDescription):
                root_link = robot_description.chains[name].gripper.links[-1]
                giskard_wrapper.register_group(name + "_gripper", root_link, robot_description.name)


@init_giskard_interface
def avoid_all_collisions() -> None:
    """
    Will avoid all collision for the next goal.
    """
    giskard_wrapper.avoid_all_collisions()


@init_giskard_interface
def allow_self_collision() -> None:
    """
    Will allow the robot collision with itself.
    """
    giskard_wrapper.allow_self_collision()


@init_giskard_interface
def avoid_collisions(object1: Object, object2: Object) -> None:
    """
    Will avoid collision between the two objects for the next goal.

    :param object1: The first BulletWorld Object
    :param object2: The second BulletWorld Object
    """
    giskard_wrapper.avoid_collision(-1, object1.name + "_" + str(object1.id), object2.name + "_" + str(object2.id))


# Creating ROS messages

@init_giskard_interface
def make_world_body(object: Object) -> 'WorldBody':
    """
    Creates a WorldBody message for a BulletWorld Object. The WorldBody will contain the URDF of the BulletWorld Object

    :param object: The BulletWorld Object
    :return: A WorldBody message for the BulletWorld Object
    """
    urdf_string = ""
    with open(object.path) as f:
        urdf_sting = f.read()
    urdf_body = WorldBody()
    urdf_body.type = WorldBody.URDF_BODY
    urdf_body.urdf = urdf_string

    return urdf_body


def make_point_stamped(point: List[float]) -> PointStamped:
    """
    Creates a PointStamped message for the given position in world coordinate frame.

    :param point: XYZ coordinates of the point
    :return: A PointStamped message
    """
    msg = PointStamped()
    msg.header.stamp = rospy.Time.now()
    msg.header.frame_id = "map"

    msg.point.x = point[0]
    msg.point.y = point[1]
    msg.point.z = point[2]

    return msg


def make_quaternion_stamped(quaternion: List[float]) -> QuaternionStamped:
    """
    Creates a QuaternionStamped message for the given quaternion.

    :param quaternion: The quaternion as a list of xyzw
    :return: A QuaternionStamped message
    """
    msg = QuaternionStamped()
    msg.header.stamp = rospy.Time.now()
    msg.header.frame_id = "map"

    msg.quaternion.x = quaternion[0]
    msg.quaternion.y = quaternion[1]
    msg.quaternion.z = quaternion[2]
    msg.quaternion.w = quaternion[3]

    return msg


def make_vector_stamped(vector: List[float]) -> Vector3Stamped:
    """
    Creates a Vector3Stamped message, this is similar to PointStamped but represents a vector instead of a point.

    :param vector: The vector given as xyz in world frame
    :return: A Vector3Stamped message
    """
    msg = Vector3Stamped()
    msg.header.stamp = rospy.Time.now()
    msg.header.frame_id = "map"

    msg.vector.x = vector[0]
    msg.vector.y = vector[1]
    msg.vector.z = vector[2]

    return msg


def _pose_to_pose_stamped(pose: Pose) -> PoseStamped:
    """
    Transforms a PyCRAM pose to a PoseStamped message, this is necessary since Giskard NEEDS a PoseStamped message
    otherwise it will crash.

    :param pose: PyCRAM pose that should be converted
    :return: An equivalent PoseStamped message
    """
    ps = PoseStamped()
    ps.pose = pose.pose
    ps.header = pose.header

    return ps


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/external_interfaces/knowrob.py
import logging
import os
import sys
import rosservice

from typing import Dict, List, Union

SCRIPT_DIR = os.path.abspath(os.path.dirname(__file__))
sys.path.append(os.path.join(SCRIPT_DIR, os.pardir, os.pardir, "neem-interface", "src"))

if 'rosprolog/query' in rosservice.get_service_list():
    from neem_interface_python.neem_interface import NEEMInterface
    from neem_interface_python.rosprolog_client import Prolog, PrologException, atom

    neem_interface = NEEMInterface()
    prolog = Prolog()

else:
    logging.warning("No KnowRob services found, knowrob is not available")


#logging.setLoggerClass(logging.Logger)
logger = logging.getLogger(__name__)
from pycram import ch

logger.addHandler(ch)
logger.setLevel(logging.DEBUG)


def all_solutions(q):
    logging.info(q)
    r = prolog.all_solutions(q)
    return r


def once(q) -> Union[List, Dict]:
    r = all_solutions(q)
    if len(r) == 0:
        return []
    return r[0]


def load_beliefstate(path: str):
    logging.info(f"Restoring beliefstate from {path}")
    once(f"remember('{path}')")


def clear_beliefstate():
    logging.info("Clearing beliefstate")
    once("mem_clear_memory")


def load_owl(path, ns_alias=None, ns_url=None):
    """
    Example: load_owl("package://external_interfaces/owl/maps/iai_room_v1.owl", "map", "http://knowrob.org/kb/v1/IAI-Kitchen.owl#")
    :param str path: path to log folder
    :rtype: bool
    """
    if ns_alias is None or ns_url is None:            # Load without namespace
        q = "load_owl('{}')".format(path)
    else:
        q = "load_owl('{0}', [namespace({1},'{2}')])".format(path, ns_alias, ns_url)
    try:
        once(q)
        return True
    except PrologException as e:
        logging.warning(e)
        return False


def new_iri(owl_class: str):
    res = once(f"kb_call(new_iri(IRI, {owl_class}))")
    return res["IRI"]


def object_type(object_iri: str) -> str:
    """
    :param object_iri: The name (identifier) of the object individual in the KnowRob knowledge base
    """
    res = once(f"kb_call(instance_of({atom(object_iri)}, Class))")
    return res["Class"]


def instances_of(type_: str) -> List[str]:
    """
    :param type_: An object type (i.e. class)
    """
    all_sols = all_solutions(f"kb_call(instance_of(Individual, {atom(type_)}))")
    return [sol["Individual"] for sol in all_sols]


def object_pose(object_iri: str, reference_cs: str = "world", timestamp=None) -> List[float]:
    """
    :param object_iri: The name (identifier) of the object individual in the KnowRob knowledge base
    :param reference_cs: The coordinate system relative to which the pose should be defined
    """
    if timestamp is None:
        res = once(f"mem_tf_get({atom(object_iri)}, {atom(reference_cs)}, Pos, Ori)")
    else:
        res = once(f"mem_tf_get({atom(object_iri)}, {atom(reference_cs)}, Pos, Ori, {timestamp})")
    pos = res["Pos"]
    ori = res["Ori"]
    return pos + ori


def grasp_pose(object_iri: str) -> List[float]:
    query = f"""
    kb_call(has_grasp_point({atom(object_iri)}, GraspPointName)),
    mem_tf_get(GraspPointName, world, Pos, Ori)
    """
    res = once(query)
    pos = res["Pos"]
    ori = res["Ori"]
    return pos + ori


def knowrob_string_to_pose(pose_as_string: str) -> List[float]:
    reference_frame = ""
    for i, char in enumerate(pose_as_string[1:-1]):
        if char == ",":
            break
        reference_frame += char
    pos, ori = pose_as_string[1+i+2:-2].split("],[")
    xyz = list(map(float, pos.split(",")))
    qxyzw = list(map(float, ori.split(",")))
    return xyz + qxyzw


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/external_interfaces/robokudo.py
import sys
from typing import Callable

import rosnode
import rospy
import actionlib
import rosnode

from ..designator import ObjectDesignatorDescription
from ..pose import Pose
from ..local_transformer import LocalTransformer
from ..bullet_world import BulletWorld
from ..enums import ObjectType

try:
    from robokudo_msgs.msg import ObjectDesignator as robokudo_ObjetDesignator
    from robokudo_msgs.msg import QueryAction, QueryGoal, QueryResult
except ModuleNotFoundError as e:
    rospy.logwarn(f"Could not import RoboKudo messages, RoboKudo interface could not be initialized")

robokudo_action_client = None


def init_robokudo_interface(func: Callable) -> Callable:
    """
    Tries to import the RoboKudo messages and with that initialize the RoboKudo interface.
    """
    def wrapper(*args, **kwargs):
        global robokudo_action_client
        topics = list(map(lambda x: x[0], rospy.get_published_topics()))
        if "robokudo_msgs" not in sys.modules:
            rospy.logwarn("Could not initialize the RoboKudo interface since the robokudo_msgs are not imported")
            return

        if "/robokudo" in rosnode.get_node_names():
            robokudo_action_client = create_robokudo_action_client()
            rospy.loginfo("Successfully initialized robokudo interface")
        else:
            rospy.logwarn("RoboKudo is not running, could not initialize RoboKudo interface")
            return

        func(*args, **kwargs)
    return wrapper


def create_robokudo_action_client() -> Callable:
    """
    Creates a new action client for the RoboKudo query interface and returns a function encapsulating the action client.
    The returned function can be called with an ObjectDesigantor as parameter and returns the result of the action client.

    :return: A callable function encapsulating the action client
    """
    client = actionlib.SimpleActionClient('robokudo/query', QueryAction)
    rospy.loginfo("Waiting for action server")
    client.wait_for_server()

    def action_client(object_desc):
        global query_result

        def active_callback():
            rospy.loginfo("Send query to Robokudo")

        def done_callback(state, result):
            rospy.loginfo("Finished perceiving")
            global query_result
            query_result = result

        def feedback_callback(msg):
            pass

        object_goal = make_query_goal_msg(object_desc)
        client.send_goal(object_goal, active_cb=active_callback, done_cb=done_callback, feedback_cb=feedback_callback)
        wait = client.wait_for_result()
        return query_result

    return action_client


def msg_from_obj_desig(obj_desc: ObjectDesignatorDescription) -> 'robokudo_ObjetDesignator':
    """
    Creates a RoboKudo Object designator from a PyCRAM Object Designator description

    :param obj_desc: The PyCRAM Object designator that should be converted
    :return: The RobotKudo Object Designator for the given PyCRAM designator
    """
    obj_msg = robokudo_ObjetDesignator()
    obj_msg.uid = str(id(obj_desc))
    obj_msg.type = obj_desc.types[0] # For testing purposes

    return obj_msg


def make_query_goal_msg(obj_desc: ObjectDesignatorDescription) -> 'QueryGoal':
    """
    Creates a QueryGoal message from a PyCRAM Object designator description for the use of Querying RobotKudo.

    :param obj_desc: The PyCRAM object designator description that should be converted
    :return: The RoboKudo QueryGoal for the given object designator description
    """
    goal_msg = QueryGoal()
    goal_msg.obj.uid = str(id(obj_desc))
    goal_msg.obj.type = str(obj_desc.types[0].name) # For testing purposes
    if ObjectType.JEROEN_CUP == obj_desc.types[0]:
        goal_msg.obj.color.append("blue")
    elif ObjectType.BOWL == obj_desc.types[0]:
        goal_msg.obj.color.append("red")
    return goal_msg


@init_robokudo_interface
def query(object_desc: ObjectDesignatorDescription) -> ObjectDesignatorDescription.Object:
    """
    Sends a query to RoboKudo to look for an object that fits the description given by the Object designator description.
    For sending the query to RoboKudo a simple action client will be created and the Object designator description is
    sent as a goal.

    :param object_desc: The object designator description which describes the object that should be perceived
    :return: An object designator for the found object, if there was an object that fitted the description.
    """
    query_result = robokudo_action_client(object_desc)
    pose_candidates = {}
    if query_result.res == []:
        rospy.logwarn("No suitable object could be found")
        return

    for i in range(0, len(query_result.res[0].pose)):
        pose = Pose.from_pose_stamped(query_result.res[0].pose[i])
        pose.frame = BulletWorld.current_bullet_world.robot.get_link_tf_frame(pose.frame)
        source = query_result.res[0].poseSource[i]

        lt = LocalTransformer()
        pose = lt.transform_pose(pose, "map")

        pose_candidates[source] = pose

    return pose_candidates


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/external_interfaces/__init__.py


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/external_interfaces/ik.py
from typing import List

import pybullet as p
import rospy
from moveit_msgs.msg import PositionIKRequest
from moveit_msgs.msg import RobotState
from moveit_msgs.srv import GetPositionIK
from sensor_msgs.msg import JointState

from ..bullet_world import Object
from ..helper import calculate_wrist_tool_offset
from ..local_transformer import LocalTransformer
from ..pose import Pose, Transform
from ..robot_descriptions import robot_description
from ..plan_failures import IKError


def _get_position_for_joints(robot, joints):
    """
    Returns a list with all joint positions for the joint names specified in
    the joints parameter

    :param robot: The robot the joint states should be taken from
    :param joints: The list of joint names that should be in the output
    :return: A list of joint states according and in the same order as the joint
    names in the joints parameter
    """
    return list(
        map(lambda x: p.getJointState(robot.id, robot.get_joint_id(x), physicsClientId=robot.world.client_id)[0],
            joints))


def _make_request_msg(root_link: str, tip_link: str, target_pose: Pose, robot_object: Object,
                      joints: List[str]) -> PositionIKRequest:
    """
    Generates an ik request message for the kdl_ik_service. The message is
    of the type moveit_msgs/PositionIKRequest and contains all information
    contained in the parameter.

    :param root_link: The first link of the chain of joints to be altered
    :param tip_link: The last link of the chain of joints to be altered
    :param target_pose: Target pose for which the message should be created
    :param robot_object: The robot for which the ik should be generated
    :param joints: A list of joint names between the root_link and tip_link that should be altered.
    :return: A moveit_msgs/PositionIKRequest message containing all the information from the parameter
    """
    local_transformer = LocalTransformer()
    target_pose = local_transformer.transform_pose(target_pose, robot_object.get_link_tf_frame(root_link))

    robot_state = RobotState()
    joint_state = JointState()
    joint_state.name = joints
    joint_state.position = _get_position_for_joints(robot_object, joints)
    # joint_state.velocity = [0.0 for x in range(len(joints))]
    # joint_state.effort = [0.0 for x in range(len(joints))]
    robot_state.joint_state = joint_state

    msg_request = PositionIKRequest()
    # msg_request.group_name = "arm"
    msg_request.ik_link_name = tip_link
    msg_request.pose_stamped = target_pose
    msg_request.avoid_collisions = False
    msg_request.robot_state = robot_state
    msg_request.timeout = rospy.Duration(secs=1000)
    # msg_request.attempts = 1000

    return msg_request


def call_ik(root_link: str, tip_link: str, target_pose: Pose, robot_object: Object, joints: List[str]) -> List[float]:
    """
   Sends a request to the kdl_ik_service and returns the solution.
   Note that the robot in robot_object should be identical to the robot description
   uploaded to the parameter server. Furthermore, note that the root_link and
   tip_link are the links attached to the first and last joints in the joints list.

   :param root_link: The first link of the chain of joints to be altered
   :param tip_link: The last link in the chain of joints to be altered
   :param target_pose: The target pose in frame of root link
   second is the orientation as quaternion in world coordinate frame
   :param robot_object: The robot object for which the ik solution should be generated
   :param joints: A list of joint name that should be altered
   :return: The solution that was generated as a list of joint values corresponding to the order of joints given
   """
    if robot_description.name == "pr2":
        ik_service = "/pr2_right_arm_kinematics/get_ik" if "r_wrist" in tip_link else "/pr2_left_arm_kinematics/get_ik"
    else:
        ik_service = "/kdl_ik_service/get_ik"

    rospy.wait_for_service(ik_service)

    req = _make_request_msg(root_link, tip_link, target_pose, robot_object, joints)
    req.pose_stamped.header.frame_id = root_link
    ik = rospy.ServiceProxy(ik_service, GetPositionIK)
    try:
        resp = ik(req)
    except rospy.ServiceException as e:
        if robot_description.name == "pr2":
            raise IKError(target_pose, root_link)
        else:
            raise e

    if resp.error_code.val == -31:
        raise IKError(target_pose, root_link)

    return resp.solution.joint_state.position


def request_ik(target_pose: Pose, robot: Object, joints: List[str], gripper: str) -> List[float]:
    """
    Top-level method to request ik solution for a given pose. Before calling the ik service the links directly before
    and after the joint chain will be queried and the target_pose will be transformed into the frame of the root_link.
    Afterward, the offset between the tip_link and end effector will be calculated and taken into account. Lastly the
    ik service is called and the result returned

    :param target_pose: Pose for which an ik solution should be found
    :param robot: Robot object which should be used
    :param joints: List of joints that should be used in computation
    :param gripper: Name of the gripper which should grasp, this should be at the end of the given joint chain
    :return: A list of joint values
    """
    local_transformer = LocalTransformer()
    base_link = robot_description.get_parent(joints[0])
    # Get link after last joint in chain
    end_effector = robot_description.get_child(joints[-1])

    target_torso = local_transformer.transform_pose(target_pose, robot.get_link_tf_frame(base_link))
    # target_torso = _transform_to_torso(pose, shadow_robot)

    diff = calculate_wrist_tool_offset(end_effector, gripper, robot)
    target_diff = target_torso.to_transform("target").inverse_times(diff).to_pose()

    inv = call_ik(base_link, end_effector, target_diff, robot, joints)

    return inv



##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/designators/action_designator.py
import itertools
from typing_extensions import List, Union, Callable
from .object_designator import ObjectDesignatorDescription, ObjectPart
from ..enums import Arms
from ..designator import ActionDesignatorDescription
from ..pose import Pose
from pycram.designators.actions.actions import (ParkArmsActionPerformable, MoveTorsoActionPerformable,
                                                SetGripperActionPerformable, GripActionPerformable,
                                                PlaceActionPerformable, PickUpActionPerformable,
                                                NavigateActionPerformable, TransportActionPerformable,
                                                LookAtActionPerformable, DetectActionPerformable, OpenActionPerformable,
                                                CloseActionPerformable, GraspingActionPerformable,
                                                ReleaseActionPerformable)


class MoveTorsoAction(ActionDesignatorDescription):
    """
    Action Designator for Moving the torso of the robot up and down
    """

    def __init__(self, positions: List[float], resolver=None):
        """
        Create a designator description to move the torso of the robot up and down.

        :param positions: List of possible positions of the robots torso, possible position is a float of height in metres
        :param resolver: An optional resolver that returns a performable designator for a designator description.
        """
        super().__init__(resolver)
        self.positions: List[float] = positions

    def ground(self) -> MoveTorsoActionPerformable:
        """
        Creates a performable action designator with the first element from the list of possible torso heights.

        :return: A performable action designator
        """
        return MoveTorsoActionPerformable(self.positions[0])

    def __iter__(self):
        """
        Iterates over all possible values for this designator and returns a performable action designator with the value.

        :return: A performable action designator
        """
        for position in self.positions:
            yield MoveTorsoActionPerformable(position)


class SetGripperAction(ActionDesignatorDescription):
    """
    Set the gripper state of the robot
    """

    def __init__(self, grippers: List[str], motions: List[str], resolver=None):
        """
        Sets the gripper state, the desired state is given with the motion. Motion can either be 'open' or 'close'.

        :param grippers: A list of possible grippers
        :param motions: A list of possible motions
        :param resolver: An alternative resolver that returns a performable designator for a designator description
        """
        super().__init__(resolver)
        self.grippers: List[str] = grippers
        self.motions: List[str] = motions

    def ground(self) -> SetGripperActionPerformable:
        """
        Default resolver that returns a performable designator with the first element in the grippers and motions list.

        :return: A performable designator
        """
        return SetGripperActionPerformable(self.grippers[0], self.motions[0])

    def __iter__(self):
        """
        Iterates over all possible combinations of grippers and motions

        :return: A performable designator with a combination of gripper and motion
        """
        for parameter_combination in itertools.product(self.grippers, self.motions):
            yield SetGripperActionPerformable(*parameter_combination)


class ReleaseAction(ActionDesignatorDescription):
    """
    Releases an Object from the robot.

    Note: This action can not be used yet.
    """

    def __init__(self, grippers: List[str], object_designator_description: ObjectDesignatorDescription,
                 resolver=None):
        super().__init__(resolver)
        self.grippers: List[str] = grippers
        self.object_designator_description = object_designator_description

    def ground(self) -> ReleaseActionPerformable:
        return ReleaseActionPerformable(self.grippers[0], self.object_designator_description.ground())


class GripAction(ActionDesignatorDescription):
    """
    Grip an object with the robot.

    :ivar grippers: The grippers to consider
    :ivar object_designator_description: The description of objects to consider
    :ivar efforts: The efforts to consider

    Note: This action can not be used yet.
    """

    def __init__(self, grippers: List[str], object_designator_description: ObjectDesignatorDescription,
                 efforts: List[float], resolver=None):
        super().__init__(resolver)
        self.grippers: List[str] = grippers
        self.object_designator_description: ObjectDesignatorDescription = object_designator_description
        self.efforts: List[float] = efforts

    def ground(self) -> GripActionPerformable:
        return GripActionPerformable(self.grippers[0], self.object_designator_description.ground(), self.efforts[0])


class ParkArmsAction(ActionDesignatorDescription):
    """
    Park the arms of the robot.
    """

    def __init__(self, arms: List[Arms], resolver=None):
        """
        Moves the arms in the pre-defined parking position. Arms are taken from pycram.enum.Arms

        :param arms: A list of possible arms, that could be used
        :param resolver: An optional resolver that returns a performable designator from the designator description
        """
        super().__init__(resolver)
        self.arms: List[Arms] = arms

    def ground(self) -> ParkArmsActionPerformable:
        """
        Default resolver that returns a performable designator with the first element of the list of possible arms

        :return: A performable designator
        """
        return ParkArmsActionPerformable(self.arms[0])


class PickUpAction(ActionDesignatorDescription):
    """
    Designator to let the robot pick up an object.
    """

    def __init__(self, object_designator_description:  Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],
                 arms: List[str], grasps: List[str], resolver=None):
        """
        Lets the robot pick up an object. The description needs an object designator describing the object that should be
        picked up, an arm that should be used as well as the grasp from which side the object should be picked up.

        :param object_designator_description: List of possible object designator
        :param arms: List of possible arms that could be used
        :param grasps: List of possible grasps for the object
        :param resolver: An optional resolver that returns a performable designator with elements from the lists of possible paramter
        """
        super().__init__(resolver)
        self.object_designator_description: Union[
            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description
        self.arms: List[str] = arms
        self.grasps: List[str] = grasps

    def ground(self) -> PickUpActionPerformable:
        """
        Default resolver, returns a performable designator with the first entries from the lists of possible parameter.

        :return: A performable designator
        """
        obj_desig = self.object_designator_description if isinstance(self.object_designator_description,
                                                                     ObjectDesignatorDescription.Object) else self.object_designator_description.resolve()

        return PickUpActionPerformable(obj_desig, self.arms[0], self.grasps[0])


class PlaceAction(ActionDesignatorDescription):
    """
    Places an Object at a position using an arm.
    """

    def __init__(self,
                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],
                 target_locations: List[Pose],
                 arms: List[str], resolver=None):
        """
        Create an Action Description to place an object

        :param object_designator_description: Description of object to place.
        :param target_locations: List of possible positions/orientations to place the object
        :param arms: List of possible arms to use
        :param resolver: Grounding method to resolve this designator
        """
        super().__init__(resolver)
        self.object_designator_description: Union[
            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description
        self.target_locations: List[Pose] = target_locations
        self.arms: List[str] = arms

    def ground(self) -> PlaceActionPerformable:
        """
        Default resolver that returns a performable designator with the first entries from the list of possible entries.

        :return: A performable designator
        """
        obj_desig = self.object_designator_description if isinstance(self.object_designator_description,
                                                                     ObjectDesignatorDescription.Object) else self.object_designator_description.resolve()

        return PlaceActionPerformable(obj_desig, self.arms[0], self.target_locations[0])


class NavigateAction(ActionDesignatorDescription):
    """
    Navigates the Robot to a position.
    """

    def __init__(self, target_locations: List[Pose], resolver=None):
        """
        Navigates the robot to a location.

        :param target_locations: A list of possible target locations for the navigation.
        :param resolver: An alternative resolver that creates a performable designator from the list of possible parameter
        """
        super().__init__(resolver)
        self.target_locations: List[Pose] = target_locations

    def ground(self) -> NavigateActionPerformable:
        """
        Default resolver that returns a performable designator with the first entry of possible target locations.

        :return: A performable designator
        """
        return NavigateActionPerformable(self.target_locations[0])


class TransportAction(ActionDesignatorDescription):
    """
    Transports an object to a position using an arm
    """

    def __init__(self,
                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],
                 arms: List[str],
                 target_locations: List[Pose], resolver=None):
        """
        Designator representing a pick and place plan.

        :param object_designator_description: Object designator description or a specified Object designator that should be transported
        :param arms: A List of possible arms that could be used for transporting
        :param target_locations: A list of possible target locations for the object to be placed
        :param resolver: An alternative resolver that returns a performable designator for the list of possible parameter
        """
        super().__init__(resolver)
        self.object_designator_description: Union[
            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description
        self.arms: List[str] = arms
        self.target_locations: List[Pose] = target_locations

    def ground(self) -> TransportActionPerformable:
        """
        Default resolver that returns a performable designator with the first entries from the lists of possible parameter.

        :return: A performable designator
        """
        obj_desig = self.object_designator_description \
            if isinstance(self.object_designator_description, ObjectDesignatorDescription.Object)\
            else self.object_designator_description.resolve()

        return TransportActionPerformable(obj_desig, self.arms[0], self.target_locations[0])


class LookAtAction(ActionDesignatorDescription):
    """
    Lets the robot look at a position.
    """

    def __init__(self, targets: List[Pose], resolver=None):
        """
        Moves the head of the robot such that it points towards the given target location.

        :param targets: A list of possible locations to look at
        :param resolver: An alternative resolver that returns a performable designator for a list of possible target locations
        """
        super().__init__(resolver)
        self.targets: List[Pose] = targets

    def ground(self) -> LookAtActionPerformable:
        """
        Default resolver that returns a performable designator with the first entry in the list of possible targets

        :return: A performable designator
        """
        return LookAtActionPerformable(self.targets[0])


class DetectAction(ActionDesignatorDescription):
    """
    Detects an object that fits the object description and returns an object designator describing the object.
    """

    def __init__(self, object_designator_description: ObjectDesignatorDescription, resolver=None):
        """
        Tries to detect an object in the field of view (FOV) of the robot.

        :param object_designator_description: Object designator describing the object
        :param resolver: An alternative resolver
        """
        super().__init__(resolver)
        self.object_designator_description: ObjectDesignatorDescription = object_designator_description

    def ground(self) -> DetectActionPerformable:
        """
        Default resolver that returns a performable designator with the resolved object description.

        :return: A performable designator
        """
        return DetectActionPerformable(self.object_designator_description.resolve())


class OpenAction(ActionDesignatorDescription):
    """
    Opens a container like object

    Can currently not be used
    """

    def __init__(self, object_designator_description: ObjectPart, arms: List[str], resolver=None):
        """
        Moves the arm of the robot to open a container.

        :param object_designator_description: Object designator describing the handle that should be used to open
        :param arms: A list of possible arms that should be used
        :param resolver: A alternative resolver that returns a performable designator for the lists of possible parameter.
        """
        super().__init__(resolver)
        self.object_designator_description: ObjectPart = object_designator_description
        self.arms: List[str] = arms

    def ground(self) -> OpenActionPerformable:
        """
        Default resolver that returns a performable designator with the resolved object description and the first entries
        from the lists of possible parameter.

        :return: A performable designator
        """
        return OpenActionPerformable(self.object_designator_description.resolve(), self.arms[0])


class CloseAction(ActionDesignatorDescription):
    """
    Closes a container like object.

    Can currently not be used
    """

    def __init__(self, object_designator_description: ObjectPart, arms: List[str],
                 resolver=None):
        """
        Attempts to close an open container

        :param object_designator_description: Object designator description of the handle that should be used
        :param arms: A list of possible arms to use
        :param resolver: An alternative resolver that returns a performable designator for the list of possible parameter
        """
        super().__init__(resolver)
        self.object_designator_description: ObjectPart = object_designator_description
        self.arms: List[str] = arms

    def ground(self) -> CloseActionPerformable:
        """
        Default resolver that returns a performable designator with the resolved object designator and the first entry from
        the list of possible arms.

        :return: A performable designator
        """
        return CloseActionPerformable(self.object_designator_description.resolve(), self.arms[0])


class GraspingAction(ActionDesignatorDescription):
    """
    Grasps an object described by the given Object Designator description
    """

    def __init__(self, arms: List[str], object_description: Union[ObjectDesignatorDescription, ObjectPart],
                 resolver: Callable = None):
        """
        Will try to grasp the object described by the given description. Grasping is done by moving into a pre grasp
        position 10 cm before the object, opening the gripper, moving to the object and then closing the gripper.

        :param arms: List of Arms that should be used for grasping
        :param object_description: Description of the object that should be grasped
        :param resolver: An alternative resolver to get a specified designator from the designator description
        """
        super().__init__(resolver)
        self.arms: List[str] = arms
        self.object_description: ObjectDesignatorDescription = object_description

    def ground(self) -> GraspingActionPerformable:
        """
        Default resolver that takes the first element from the list of arms and the first solution for the object
        designator description ond returns it.

        :return: A performable action designator that contains specific arguments
        """
        return GraspingActionPerformable(self.arms[0], self.object_description.resolve())


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/designators/object_designator.py
import dataclasses
from typing import List, Union, Optional, Callable, Tuple, Iterable
import sqlalchemy.orm
from ..bullet_world import BulletWorld, Object as BulletWorldObject
from ..designator import DesignatorDescription, ObjectDesignatorDescription
from ..orm.base import ProcessMetaData
from ..orm.object_designator import (BelieveObject as ORMBelieveObject, ObjectPart as ORMObjectPart)
from ..pose import Pose
from ..external_interfaces.robokudo import query


class BelieveObject(ObjectDesignatorDescription):
    """
    Description for Objects that are only believed in.
    """

    @dataclasses.dataclass
    class Object(ObjectDesignatorDescription.Object):
        """
        Concrete object that is believed in.
        """

        def to_sql(self) -> ORMBelieveObject:
            return ORMBelieveObject(self.type, self.name)

        def insert(self, session: sqlalchemy.orm.session.Session) -> ORMBelieveObject:
            self_ = self.to_sql()
            session.add(self_)
            session.commit()
            metadata = ProcessMetaData().insert(session)
            self_.process_metadata_id = metadata.id
            return self_


class ObjectPart(ObjectDesignatorDescription):
    """
    Object Designator Descriptions for Objects that are part of some other object.
    """

    @dataclasses.dataclass
    class Object(ObjectDesignatorDescription.Object):

        # The rest of attributes is inherited
        part_pose: Pose

        def to_sql(self) -> ORMObjectPart:
            return ORMObjectPart(self.type, self.name)

        def insert(self, session: sqlalchemy.orm.session.Session) -> ORMObjectPart:
            obj = self.to_sql()
            metadata = ProcessMetaData().insert(session)
            obj.process_metadata_id = metadata.id
            pose = self.part_pose.insert(session)
            obj.pose_id = pose.id

            session.add(obj)
            session.commit()

            return obj

    def __init__(self, names: List[str],
                 part_of: ObjectDesignatorDescription.Object,
                 type: Optional[str] = None,
                 resolver: Optional[Callable] = None):
        """
        Describing the relationship between an object and a specific part of it.

        :param names: Possible names for the part
        :param part_of: Parent object of which the part should be described
        :param type: Type of the part
        :param resolver: An alternative resolver to resolve the input parameter to an object designator
        """
        super().__init__(names, type, resolver)

        if not part_of:
            raise AttributeError("part_of cannot be None.")

        self.type: Optional[str] = type
        self.names: Optional[List[str]] = names
        self.part_of = part_of

    def ground(self) -> Object:
        """
        Default resolver, returns the first result of the iterator of this instance.

        :return: A resolved object designator
        """
        return next(iter(self))

    def __iter__(self):
        """
        Iterates through every possible solution for the given input parameter.

        :yield: A resolved Object designator
        """
        for name in self.names:
            if name in self.part_of.bullet_world_object.links.keys():
                yield self.Object(name, self.type, self.part_of.bullet_world_object,
                                  self.part_of.bullet_world_object.get_link_pose(name))


class LocatedObject(ObjectDesignatorDescription):
    """
    Description for KnowRob located objects.
    **Currently has no resolver**
    """

    @dataclasses.dataclass
    class Object(ObjectDesignatorDescription.Object):
        reference_frame: str
        """
        Reference frame in which the position is given
        """
        timestamp: float
        """
        Timestamp at which the position was valid
        """

    def __init__(self, names: List[str], types: List[str],
                 reference_frames: List[str], timestamps: List[float], resolver: Optional[Callable] = None):
        """
        Describing an object resolved through knowrob.

        :param names: List of possible names describing the object
        :param types: List of possible types describing the object
        :param reference_frames: Frame of reference in which the object position should be
        :param timestamps: Timestamps for which positions should be returned
        :param resolver: An alternative resolver that resolves the input parameter to an object designator.
        """
        super(LocatedObject, self).__init__(names, types, resolver)
        self.reference_frames: List[str] = reference_frames
        self.timestamps: List[float] = timestamps


class RealObject(ObjectDesignatorDescription):
    """
    Object designator representing an object in the real world, when resolving this object designator description ]
    RoboKudo is queried to perceive an object fitting the given criteria. Afterward the resolver tries to match
    the found object to an Object in the BulletWorld.
    """

    @dataclasses.dataclass
    class Object(ObjectDesignatorDescription.Object):
        pose: Pose
        """
        Pose of the perceived object
        """

    def __init__(self, names: Optional[List[str]] = None, types: Optional[List[str]] = None,
                 bullet_world_object: BulletWorldObject = None, resolver: Optional[Callable] = None):
        """
        
        :param names: 
        :param types: 
        :param bullet_world_object: 
        :param resolver: 
        """
        super().__init__(resolver)
        self.types: Optional[List[str]] = types
        self.names: Optional[List[str]] = names
        self.bullet_world_object: BulletWorldObject = bullet_world_object

    def __iter__(self):
        """
        Queries RoboKudo for objects that fit the description and then iterates over all BulletWorld objects that have
        the same type to match a BulletWorld object to the real object.

        :yield: A resolved object designator with reference bullet world object
        """
        object_candidates = query(self)
        for obj_desig in object_candidates:
            for bullet_obj in BulletWorld.get_objects_by_type(obj_desig.type):
                obj_desig.bullet_world_object = bullet_obj
                yield obj_desig
                # if bullet_obj.get_pose().dist(obj_deisg.pose) < 0.05:
                #     obj_deisg.bullet_world_object = bullet_obj
                #     yield obj_deisg


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/designators/location_designator.py
import dataclasses
import time
from typing import List, Tuple, Union, Iterable, Optional, Callable

from .object_designator import ObjectDesignatorDescription, ObjectPart
from ..bullet_world import Object, BulletWorld, Use_shadow_world
from ..bullet_world_reasoning import link_pose_for_joint_config
from ..designator import Designator, DesignatorError, LocationDesignatorDescription
from ..costmaps import OccupancyCostmap, VisibilityCostmap, SemanticCostmap, GaussianCostmap
from ..robot_descriptions import robot_description
from ..enums import JointType
from ..helper import transform
from ..plan_failures import EnvironmentManipulationImpossible
from ..pose_generator_and_validator import pose_generator, visibility_validator, reachability_validator, \
    generate_orientation
from ..robot_description import ManipulatorDescription
from ..pose import Pose


class Location(LocationDesignatorDescription):
    """
    Default location designator which only wraps a pose.
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        pass

    def __init__(self, pose: Pose, resolver=None):
        """
        Basic location designator that represents a single pose.

        :param pose: The pose that should be represented by this location designator
        :param resolver: An alternative resolver that returns a resolved location
        """
        super().__init__(resolver)
        self.pose: Pose = pose

    def ground(self) -> Location:
        """
        Default resolver which returns a resolved designator which contains the pose given in init.

        :return: A resolved designator
        """
        return self.Location(self.pose)


# TODO Maybe delete this
class ObjectRelativeLocation(LocationDesignatorDescription):
    """
    Location relative to an object
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        relative_pose: Pose
        """
        Pose relative to the object
        """
        reference_object: ObjectDesignatorDescription.Object
        """
        Object to which the pose is relative
        """

    def __init__(self, relative_pose: Pose = None, reference_object: ObjectDesignatorDescription = None,
                 resolver=None):
        """
        Location designator representing a location relative to a given object.

        :param relative_pose: Pose that should be relative, in world coordinate frame
        :param reference_object: Object to which the pose should be relative
        :param resolver: An alternative resolver that returns a resolved location for the input parameter
        """
        super().__init__(resolver)
        self.relative_pose: Pose = relative_pose
        self.reference_object: ObjectDesignatorDescription = reference_object

    def ground(self) -> Location:
        """
        Default resolver which returns a resolved location for description input. Resolved location is the first result
        of the iteration of this instance.

        :return: A resolved location
        """
        return next(iter(self))

    def __iter__(self) -> Iterable[Location]:
        """
        Iterates over all possible solutions for a resolved location that is relative to the given object.

        :yield: An instance of ObjectRelativeLocation.Location with the relative pose
        """
        if self.relative_pose is None or self.reference_object is None:
            raise DesignatorError(
                "Could not ground ObjectRelativeLocation: (Relative) pose and reference object must be given")
        # Fetch the object pose and yield the grounded description
        obj_grounded = self.reference_object.resolve()
        obj_pose_world = obj_grounded.get_position_and_location()
        obj_pose_world_flat = [i for sublist in obj_pose_world for i in sublist]
        relative_pose_flat = [i for sublist in self.relative_pose for i in sublist]
        pose = transform(obj_pose_world_flat, relative_pose_flat, local_coords=False)

        yield self.Location(self.relative_pose, pose, self.reference_object)


class CostmapLocation(LocationDesignatorDescription):
    """
    Uses Costmaps to create locations for complex constrains
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        reachable_arms: List[str]
        """
        List of arms with which the pose can be reached, is only used when the 'rechable_for' parameter is used
        """

    def __init__(self, target: Union[Pose, ObjectDesignatorDescription.Object],
                 reachable_for: Optional[ObjectDesignatorDescription.Object] = None,
                 visible_for: Optional[ObjectDesignatorDescription.Object] = None,
                 reachable_arm: Optional[str] = None, resolver: Optional[Callable] = None):
        """
        Location designator that uses costmaps as base to calculate locations for complex constrains like reachable or
        visible. In case of reachable the resolved location contains a list of arms with which the location is reachable.

        :param target: Location for which visibility or reachability should be calculated
        :param reachable_for: Object for which the reachability should be calculated, usually a robot
        :param visible_for: Object for which the visibility should be calculated, usually a robot
        :param reachable_arm: An optional arm with which the target should be reached
        :param resolver: An alternative resolver that returns a resolved location for the given input of this description
        """
        super().__init__(resolver)
        self.target: Union[Pose, ObjectDesignatorDescription.Object] = target
        self.reachable_for: ObjectDesignatorDescription.Object = reachable_for
        self.visible_for: ObjectDesignatorDescription.Object = visible_for
        self.reachable_arm: Optional[str] = reachable_arm

    def ground(self) -> Location:
        """
        Default resolver which returns the first result from the iterator of this instance.

        :return: A resolved location
        """
        return next(iter(self))

    def __iter__(self):
        """
           Generates positions for a given set of constrains from a costmap and returns
           them. The generation is based of a costmap which itself is the product of
           merging costmaps, each for a different purpose. In any case an occupancy costmap
           is used as the base, then according to the given constrains a visibility or
           gaussian costmap is also merged with this. Once the costmaps are merged,
           a generator generates pose candidates from the costmap. Each pose candidate
           is then validated against the constraints given by the designator if all validators
           pass the pose is considered valid and yielded.

           :yield: An instance of CostmapLocation.Location with a valid position that satisfies the given constraints
           """
        min_height = list(robot_description.cameras.values())[0].min_height
        max_height = list(robot_description.cameras.values())[0].max_height
        # This ensures that the costmaps always get a position as their origin.
        if isinstance(self.target, ObjectDesignatorDescription.Object):
            target_pose = self.target.bullet_world_object.get_pose()
        else:
            target_pose = self.target.copy()

        # ground_pose = [[target_pose[0][0], target_pose[0][1], 0], target_pose[1]]
        ground_pose = Pose(target_pose.position_as_list())
        ground_pose.position.z = 0

        occupancy = OccupancyCostmap(0.35, False, 200, 0.02, ground_pose)
        final_map = occupancy

        if self.reachable_for:
            gaussian = GaussianCostmap(200, 15, 0.02, ground_pose)
            final_map += gaussian
        if self.visible_for:
            visible = VisibilityCostmap(min_height, max_height, 200, 0.02, Pose(target_pose.position_as_list()))
            final_map += visible

        if self.visible_for or self.reachable_for:
            robot_object = self.visible_for.bullet_world_object if self.visible_for else self.reachable_for.bullet_world_object
            test_robot = BulletWorld.current_bullet_world.get_shadow_object(robot_object)

        with Use_shadow_world():

            for maybe_pose in pose_generator(final_map, number_of_samples=600):
                res = True
                arms = None
                if self.visible_for:
                    res = res and visibility_validator(maybe_pose, test_robot, target_pose,
                                                       BulletWorld.current_bullet_world)
                if self.reachable_for:
                    hand_links = []
                    for name, chain in robot_description.chains.items():
                        if isinstance(chain, ManipulatorDescription):
                            hand_links += chain.gripper.links
                    valid, arms = reachability_validator(maybe_pose, test_robot, target_pose,
                                                         allowed_collision={test_robot: hand_links})
                    if self.reachable_arm:
                        res = res and valid and self.reachable_arm in arms
                    else:
                        res = res and valid

                if res:
                    yield self.Location(maybe_pose, arms)


class AccessingLocation(LocationDesignatorDescription):
    """
    Location designator which describes poses used for opening drawers
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        arms: List[str]
        """
        List of arms that can be used to for accessing from this pose
        """

    def __init__(self, handle_desig: ObjectPart.Object, robot_desig: ObjectDesignatorDescription.Object, resolver=None):
        """
        Describes a position from where a drawer can be opened. For now this position should be calculated before the
        drawer will be opened. Calculating the pose while the drawer is open could lead to problems.

        :param handle_desig: ObjectPart designator for handle of the drawer
        :param robot: Object designator for the robot which should open the drawer
        :param resolver: An alternative resolver to create the location
        """
        super().__init__(resolver)
        self.handle: ObjectPart.Object = handle_desig
        self.robot: ObjectDesignatorDescription.Object = robot_desig.bullet_world_object

    def ground(self) -> Location:
        """
        Default resolver for this location designator, just returns the first element from the iteration

        :return: A location designator for a pose from which the drawer can be opened
        """
        return next(iter(self))

    def __iter__(self) -> Location:
        """
        Creates poses from which the robot can open the drawer specified by the ObjectPart designator describing the
        handle. Poses are validated by checking if the robot can grasp the handle while the drawer is closed and if
        the handle can be grasped if the drawer is open.

        :yield: A location designator containing the pose and the arms that can be used.
        """
        # ground_pose = [[self.handle.part_pose[0][0], self.handle.part_pose[0][1], 0], self.handle.part_pose[1]]
        ground_pose = Pose(self.handle.part_pose.position_as_list())
        ground_pose.position.z = 0
        occupancy = OccupancyCostmap(distance_to_obstacle=0.4, from_ros=False, size=200, resolution=0.02,
                                     origin=ground_pose)
        gaussian = GaussianCostmap(200, 15, 0.02, ground_pose)

        final_map = occupancy + gaussian

        test_robot = BulletWorld.current_bullet_world.get_shadow_object(self.robot)

        # Find a Joint of type prismatic which is above the handle in the URDF tree
        container_joint = self.handle.bullet_world_object.find_joint_above(self.handle.name, JointType.PRISMATIC)

        init_pose = link_pose_for_joint_config(self.handle.bullet_world_object, {
            container_joint: self.handle.bullet_world_object.get_joint_limits(container_joint)[0]},
                                               self.handle.name)

        # Calculate the pose the handle would be in if the drawer was to be fully opened
        goal_pose = link_pose_for_joint_config(self.handle.bullet_world_object, {
            container_joint: self.handle.bullet_world_object.get_joint_limits(container_joint)[1] - 0.05},
                                               self.handle.name)

        # Handle position for calculating rotation of the final pose
        half_pose = link_pose_for_joint_config(self.handle.bullet_world_object, {
            container_joint: self.handle.bullet_world_object.get_joint_limits(container_joint)[1] / 1.5},
                                               self.handle.name)

        with Use_shadow_world():
            for maybe_pose in pose_generator(final_map, number_of_samples=600,
                                             orientation_generator=lambda p, o: generate_orientation(p, half_pose)):

                hand_links = []
                for name, chain in robot_description.chains.items():
                    if isinstance(chain, ManipulatorDescription):
                        hand_links += chain.gripper.links

                valid_init, arms_init = reachability_validator(maybe_pose, test_robot, init_pose,
                                                               allowed_collision={test_robot: hand_links})

                valid_goal, arms_goal = reachability_validator(maybe_pose, test_robot, goal_pose,
                                                               allowed_collision={test_robot: hand_links})

                if valid_init and valid_goal:
                    yield self.Location(maybe_pose, list(set(arms_init).intersection(set(arms_goal))))


class SemanticCostmapLocation(LocationDesignatorDescription):
    """
    Locations over semantic entities, like a table surface
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        pass

    def __init__(self, urdf_link_name, part_of, for_object=None, resolver=None):
        """
        Creates a distribution over a urdf link to sample poses which are on this link. Can be used, for example, to find
        poses that are on a table. Optionally an object can be given for which poses should be calculated, in that case
        the poses are calculated such that the bottom of the object is on the link.

        :param urdf_link_name: Name of the urdf link for which a distribution should be calculated
        :param part_of: Object of which the urdf link is a part
        :param for_object: Optional object that should be placed at the found location
        :param resolver: An alternative resolver that creates a resolved location for the input parameter of this description
        """
        super().__init__(resolver)
        self.urdf_link_name: str = urdf_link_name
        self.part_of: ObjectDesignatorDescription.Object = part_of
        self.for_object: Optional[ObjectDesignatorDescription.Object] = for_object

    def ground(self) -> Location:
        """
        Default resolver which returns the first element of the iterator of this instance.

        :return: A resolved location
        """
        return next(iter(self))

    def __iter__(self):
        """
        Creates a costmap on top of a link of an Object and creates positions from it. If there is a specific Object for
        which the position should be found, a height offset will be calculated which ensures that the bottom of the Object
        is at the position in the Costmap and not the origin of the Object which is usually in the centre of the Object.

        :yield: An instance of SemanticCostmapLocation.Location with the found valid position of the Costmap.
        """
        sem_costmap = SemanticCostmap(self.part_of.bullet_world_object, self.urdf_link_name)
        height_offset = 0
        if self.for_object:
            min, max = self.for_object.bullet_world_object.get_AABB()
            height_offset = (max[2] - min[2]) / 2
        for maybe_pose in pose_generator(sem_costmap):
            maybe_pose.position.z += height_offset
            yield self.Location(maybe_pose)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/designators/__init__.py


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/designators/motion_designator.py
from abc import ABC, abstractmethod
from dataclasses import dataclass

from sqlalchemy.orm import Session
from .object_designator import ObjectDesignatorDescription, ObjectPart, RealObject
from ..designator import ResolutionError
from ..enums import ObjectType
from ..orm.base import ProcessMetaData
from ..plan_failures import PerceptionObjectNotFound
from ..process_module import ProcessModuleManager
from ..orm.motion_designator import (MoveMotion as ORMMoveMotion, AccessingMotion as ORMAccessingMotion,
                                     MoveTCPMotion as ORMMoveTCPMotion, LookingMotion as ORMLookingMotion,
                                     MoveGripperMotion as ORMMoveGripperMotion, DetectingMotion as ORMDetectingMotion,
                                     WorldStateDetectingMotion as ORMWorldStateDetectingMotion,
                                     OpeningMotion as ORMOpeningMotion, ClosingMotion as ORMClosingMotion,
                                     Motion as ORMMotionDesignator)

from typing_extensions import Dict, Optional, get_type_hints, get_args, get_origin
from ..pose import Pose
from ..task import with_tree


@dataclass
class BaseMotion(ABC):

    @abstractmethod
    def perform(self):
        """
        Passes this designator to the process module for execution. Will be overwritten by each motion.
        """
        pass
        # return ProcessModule.perform(self)

    @abstractmethod
    def to_sql(self) -> ORMMotionDesignator:
        """
        Create an ORM object that corresponds to this description. Will be overwritten by each motion.

        :return: The created ORM object.
        """
        return ORMMotionDesignator()

    @abstractmethod
    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        """
        Add and commit this and all related objects to the session.
        Auto-Incrementing primary keys and foreign keys have to be filled by this method.

        :param session: Session with a database that is used to add and commit the objects
        :param args: Possible extra arguments
        :param kwargs: Possible extra keyword arguments
        :return: The completely instanced ORM motion.
        """
        metadata = ProcessMetaData().insert(session)

        motion = self.to_sql()
        motion.process_metadata_id = metadata.id

        return motion

    def __post_init__(self):
        """
        Checks if types are missing or wrong
        """
        right_types = get_type_hints(self)
        attributes = self.__dict__.copy()

        missing = []
        wrong_type = {}
        current_type = {}

        for k in attributes.keys():
            attribute = attributes[k]
            attribute_type = type(attributes[k])
            right_type = right_types[k]
            types = get_args(right_type)
            if attribute is None:
                if not any([x is type(None) for x in get_args(right_type)]):
                    missing.append(k)
            elif attribute_type is not right_type:
                if attribute_type not in types:
                    if attribute_type not in [get_origin(x) for x in types if x is not type(None)]:
                        wrong_type[k] = right_types[k]
                        current_type[k] = attribute_type
        if missing != [] or wrong_type != {}:
            raise ResolutionError(missing, wrong_type, current_type, self.__class__)


@dataclass
class MoveMotion(BaseMotion):
    """
    Moves the robot to a designated location
    """

    target: Pose
    """
    Location to which the robot should be moved
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.navigate().execute(self)
        # return ProcessModule.perform(self)

    def to_sql(self) -> ORMMoveMotion:
        return ORMMoveMotion()

    def insert(self, session, *args, **kwargs) -> ORMMoveMotion:
        motion = super().insert(session)

        pose = self.target.insert(session)
        motion.pose_id = pose.id

        session.add(motion)
        session.commit()

        return motion


@dataclass
class MoveTCPMotion(BaseMotion):
    """
    Moves the Tool center point (TCP) of the robot
    """

    target: Pose
    """
    Target pose to which the TCP should be moved
    """
    arm: str
    """
    Arm with the TCP that should be moved to the target
    """
    allow_gripper_collision: Optional[bool] = None
    """
    If the gripper can collide with something
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.move_tcp().execute(self)

    def to_sql(self) -> ORMMoveTCPMotion:
        return ORMMoveTCPMotion(self.arm, self.allow_gripper_collision)

    def insert(self, session: Session, *args, **kwargs) -> ORMMoveTCPMotion:
        motion = super().insert(session)

        pose = self.target.insert(session)
        motion.pose_id = pose.id

        session.add(motion)
        session.commit()

        return motion


@dataclass
class LookingMotion(BaseMotion):
    """
    Lets the robot look at a point
    """
    target: Pose

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.looking().execute(self)

    def to_sql(self) -> ORMLookingMotion:
        return ORMLookingMotion()

    def insert(self, session: Session, *args, **kwargs) -> ORMLookingMotion:
        motion = super().insert(session)

        pose = self.target.insert(session)
        motion.pose_id = pose.id

        session.add(motion)
        session.commit()

        return motion


@dataclass
class MoveGripperMotion(BaseMotion):
    """
    Opens or closes the gripper
    """

    motion: str
    """
    Motion that should be performed, either 'open' or 'close'
    """
    gripper: str
    """
    Name of the gripper that should be moved
    """
    allow_gripper_collision: Optional[bool] = None
    """
    If the gripper is allowed to collide with something
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.move_gripper().execute(self)

    def to_sql(self) -> ORMMoveGripperMotion:
        return ORMMoveGripperMotion(self.motion, self.gripper, self.allow_gripper_collision)

    def insert(self, session: Session, *args, **kwargs) -> ORMMoveGripperMotion:
        motion = super().insert(session)

        session.add(motion)
        session.commit()
        return motion


@dataclass
class DetectingMotion(BaseMotion):
    """
    Tries to detect an object in the FOV of the robot
    """

    object_type: ObjectType
    """
    Type of the object that should be detected
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        bullet_world_object = pm_manager.detecting().execute(self)
        if not bullet_world_object:
            raise PerceptionObjectNotFound(
                f"Could not find an object with the type {self.object_type} in the FOV of the robot")
        if ProcessModuleManager.execution_type == "real":
            return RealObject.Object(bullet_world_object.name, bullet_world_object.type,
                                                  bullet_world_object, bullet_world_object.get_pose())

        return ObjectDesignatorDescription.Object(bullet_world_object.name, bullet_world_object.type,
                                                  bullet_world_object)

    def to_sql(self) -> ORMDetectingMotion:
        return ORMDetectingMotion(self.object_type)

    def insert(self, session: Session, *args, **kwargs) -> ORMDetectingMotion:
        motion = super().insert(session)
        session.add(motion)
        session.commit()
        return motion


@dataclass
class MoveArmJointsMotion(BaseMotion):
    """
    Moves the joints of each arm into the given position
    """

    left_arm_poses: Optional[Dict[str, float]]
    """
    Target positions for the left arm joints
    """
    right_arm_poses: Optional[Dict[str, float]]
    """
    Target positions for the right arm joints
    """

    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.move_arm_joints().execute(self)

    def to_sql(self) -> ORMMotionDesignator:
        pass

    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        pass


@dataclass
class WorldStateDetectingMotion(BaseMotion):
    """
    Detects an object based on the world state.
    """

    object_type: str
    """
    Object type that should be detected
    """

    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.world_state_detecting().execute(self)

    def to_sql(self) -> ORMMotionDesignator:
        pass

    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        pass


@dataclass
class MoveJointsMotion(BaseMotion):
    """
    Moves any joint on the robot
    """

    names: list
    """
    List of joint names that should be moved 
    """
    positions: list
    """
    Target positions of joints, should correspond to the list of names
    """

    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.move_joints().execute(self)

    def to_sql(self) -> ORMMotionDesignator:
        pass

    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        pass


@dataclass
class OpeningMotion(BaseMotion):
    """
    Designator for opening container
    """

    object_part: ObjectPart.Object
    """
    Object designator for the drawer handle
    """
    arm: str
    """
    Arm that should be used
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.open().execute(self)

    def to_sql(self) -> ORMOpeningMotion:
        return ORMOpeningMotion(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMOpeningMotion:
        motion = super().insert(session)

        op = self.object_part.insert(session)
        motion.object_id = op.id

        session.add(motion)
        session.commit()

        return motion


@dataclass
class ClosingMotion(BaseMotion):
    """
    Designator for closing a container
    """

    object_part: ObjectPart.Object
    """
    Object designator for the drawer handle
    """
    arm: str
    """
    Arm that should be used
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.close().execute(self)

    def to_sql(self) -> ORMClosingMotion:
        return ORMClosingMotion(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMClosingMotion:
        motion = super().insert(session)

        op = self.object_part.insert(session)
        motion.object_id = op.id

        session.add(motion)
        session.commit()

        return motion


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/designators/actions/actions.py
import abc
from typing_extensions import Union
from pycram.designator import ActionDesignatorDescription
from pycram.designators.motion_designator import *
from pycram.enums import Arms
from pycram.task import with_tree
from dataclasses import dataclass, field
from ..location_designator import CostmapLocation
from ..object_designator import BelieveObject
from ...bullet_world import BulletWorld
from ...helper import multiply_quaternions
from ...local_transformer import LocalTransformer
from ...orm.base import Base
from ...plan_failures import ObjectUnfetchable, ReachabilityFailure
from ...robot_descriptions import robot_description
from ...orm.action_designator import (ParkArmsAction as ORMParkArmsAction, NavigateAction as ORMNavigateAction,
                                      PickUpAction as ORMPickUpAction, PlaceAction as ORMPlaceAction,
                                      MoveTorsoAction as ORMMoveTorsoAction, SetGripperAction as ORMSetGripperAction,
                                      LookAtAction as ORMLookAtAction, DetectAction as ORMDetectAction,
                                      TransportAction as ORMTransportAction, OpenAction as ORMOpenAction,
                                      CloseAction as ORMCloseAction, GraspingAction as ORMGraspingAction, Action)


@dataclass
class ActionAbstract(ActionDesignatorDescription.Action, abc.ABC):
    """Base class for performable actions."""

    @abc.abstractmethod
    def perform(self) -> None:
        """
        Perform the action. Will be overwritten by each action.
        """
        pass

    @abc.abstractmethod
    def to_sql(self) -> Action:
        """
        Convert this action to its ORM equivalent. Will be overwritten by each action.
        """
        pass

    @abc.abstractmethod
    def insert(self, session: Session, **kwargs) -> Action:
        """
        Insert this action into the database.

        :param session: Session with a database that is used to add and commit the objects
        :param kwargs: Possible extra keyword arguments
        :return: The completely instanced ORM object
        """

        action = super().insert(session)
        return action


@dataclass
class MoveTorsoActionPerformable(ActionAbstract):
    """
    Move the torso of the robot up and down.
    """

    position: float
    """
    Target position of the torso joint
    """

    @with_tree
    def perform(self) -> None:
        MoveJointsMotion([robot_description.torso_joint], [self.position]).perform()

    def to_sql(self) -> ORMMoveTorsoAction:
        return ORMMoveTorsoAction(self.position)

    def insert(self, session: Session, **kwargs) -> ORMMoveTorsoAction:
        action = super().insert(session)
        session.add(action)
        session.commit()
        return action


@dataclass
class SetGripperActionPerformable(ActionAbstract):
    """
    Set the gripper state of the robot.
    """

    gripper: str
    """
    The gripper that should be set 
    """
    motion: str
    """
    The motion that should be set on the gripper
    """

    @with_tree
    def perform(self) -> None:
        MoveGripperMotion(gripper=self.gripper, motion=self.motion).perform()

    def to_sql(self) -> ORMSetGripperAction:
        return ORMSetGripperAction(self.gripper, self.motion)

    def insert(self, session: Session, *args, **kwargs) -> ORMSetGripperAction:
        action = super().insert(session)
        session.add(action)
        session.commit()
        return action


@dataclass
class ReleaseActionPerformable(ActionAbstract):
    """
    Releases an Object from the robot.

    Note: This action can not ve used yet.
    """

    gripper: str

    object_designator: ObjectDesignatorDescription.Object

    def perform(self) -> None:
        raise NotImplementedError

    def to_sql(self) -> ORMParkArmsAction:
        raise NotImplementedError

    def insert(self, session: Session, **kwargs) -> ORMParkArmsAction:
        raise NotImplementedError


@dataclass
class GripActionPerformable(ActionAbstract):
    """
    Grip an object with the robot.

    Note: This action can not be used yet.
    """

    gripper: str
    object_designator: ObjectDesignatorDescription.Object
    effort: float

    @with_tree
    def perform(self) -> None:
        raise NotImplementedError()

    def to_sql(self) -> Base:
        raise NotImplementedError()

    def insert(self, session: Session, *args, **kwargs) -> Base:
        raise NotImplementedError()


@dataclass
class ParkArmsActionPerformable(ActionAbstract):
    """
    Park the arms of the robot.
    """

    arm: Arms
    """
    Entry from the enum for which arm should be parked
    """

    @with_tree
    def perform(self) -> None:
        # create the keyword arguments
        kwargs = dict()
        left_poses = None
        right_poses = None

        # add park left arm if wanted
        if self.arm in [Arms.LEFT, Arms.BOTH]:
            kwargs["left_arm_config"] = "park"
            left_poses = robot_description.get_static_joint_chain("left", kwargs["left_arm_config"])

        # add park right arm if wanted
        if self.arm in [Arms.RIGHT, Arms.BOTH]:
            kwargs["right_arm_config"] = "park"
            right_poses = robot_description.get_static_joint_chain("right", kwargs["right_arm_config"])

        MoveArmJointsMotion(left_poses, right_poses).perform()

    def to_sql(self) -> ORMParkArmsAction:
        return ORMParkArmsAction(self.arm.name)

    def insert(self, session: Session, **kwargs) -> ORMParkArmsAction:
        action = super().insert(session)
        session.add(action)
        session.commit()
        return action


@dataclass
class PickUpActionPerformable(ActionAbstract):
    """
    Let the robot pick up an object.
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    Object designator describing the object that should be picked up
    """

    arm: str
    """
    The arm that should be used for pick up
    """

    grasp: str
    """
    The grasp that should be used. For example, 'left' or 'right'
    """

    object_at_execution: Optional[ObjectDesignatorDescription.Object] = field(init=False)
    """
    The object at the time this Action got created. It is used to be a static, information holding entity. It is
    not updated when the BulletWorld object is changed.
    """

    @with_tree
    def perform(self) -> None:
        # Store the object's data copy at execution
        self.object_at_execution = self.object_designator.frozen_copy()
        robot = BulletWorld.robot
        # Retrieve object and robot from designators
        object = self.object_designator.bullet_world_object
        # Get grasp orientation and target pose
        grasp = robot_description.grasps.get_orientation_for_grasp(self.grasp)
        # oTm = Object Pose in Frame map
        oTm = object.get_pose()
        # Transform the object pose to the object frame, basically the origin of the object frame
        mTo = object.local_transformer.transform_to_object_frame(oTm, object)
        # Adjust the pose according to the special knowledge of the object designator
        adjusted_pose = self.object_designator.special_knowledge_adjustment_pose(self.grasp, mTo)
        # Transform the adjusted pose to the map frame
        adjusted_oTm = object.local_transformer.transform_pose(adjusted_pose, "map")
        # multiplying the orientation therefore "rotating" it, to get the correct orientation of the gripper
        ori = multiply_quaternions([adjusted_oTm.orientation.x, adjusted_oTm.orientation.y,
                                    adjusted_oTm.orientation.z, adjusted_oTm.orientation.w],
                                   grasp)

        # Set the orientation of the object pose by grasp in MAP
        adjusted_oTm.orientation.x = ori[0]
        adjusted_oTm.orientation.y = ori[1]
        adjusted_oTm.orientation.z = ori[2]
        adjusted_oTm.orientation.w = ori[3]

        # prepose depending on the gripper (its annoying we have to put pr2_1 here tbh
        # gripper_frame = "pr2_1/l_gripper_tool_frame" if self.arm == "left" else "pr2_1/r_gripper_tool_frame"
        gripper_frame = robot.get_link_tf_frame(robot_description.get_tool_frame(self.arm))
        # First rotate the gripper, so the further calculations makes sense
        tmp_for_rotate_pose = object.local_transformer.transform_pose(adjusted_oTm, gripper_frame)
        tmp_for_rotate_pose.pose.position.x = 0
        tmp_for_rotate_pose.pose.position.y = 0
        tmp_for_rotate_pose.pose.position.z = -0.1
        gripper_rotate_pose = object.local_transformer.transform_pose(tmp_for_rotate_pose, "map")

        #Perform Gripper Rotate
        # BulletWorld.current_bullet_world.add_vis_axis(gripper_rotate_pose)
        # MoveTCPMotion(gripper_rotate_pose, self.arm).resolve().perform()

        oTg = object.local_transformer.transform_pose(adjusted_oTm, gripper_frame)
        oTg.pose.position.x -= 0.1 # in x since this is how the gripper is oriented
        prepose = object.local_transformer.transform_pose(oTg, "map")

        # Perform the motion with the prepose and open gripper
        BulletWorld.current_bullet_world.add_vis_axis(prepose)
        MoveTCPMotion(prepose, self.arm).perform()
        MoveGripperMotion(motion="open", gripper=self.arm).perform()

        # Perform the motion with the adjusted pose -> actual grasp and close gripper
        BulletWorld.current_bullet_world.add_vis_axis(adjusted_oTm)
        MoveTCPMotion(adjusted_oTm, self.arm).perform()
        adjusted_oTm.pose.position.z += 0.03
        MoveGripperMotion(motion="close", gripper=self.arm).perform()
        tool_frame = robot_description.get_tool_frame(self.arm)
        robot.attach(object, tool_frame)

        # Lift object
        BulletWorld.current_bullet_world.add_vis_axis(adjusted_oTm)
        MoveTCPMotion(adjusted_oTm, self.arm).perform()

        # Remove the vis axis from the world
        BulletWorld.current_bullet_world.remove_vis_axis()

    def to_sql(self) -> ORMPickUpAction:
        return ORMPickUpAction(self.arm, self.grasp)

    def insert(self, session: Session, **kwargs) -> ORMPickUpAction:
        action = super().insert(session)

        od = self.object_at_execution.insert(session)
        action.object_id = od.id

        session.add(action)
        session.commit()

        return action


@dataclass
class PlaceActionPerformable(ActionAbstract):
    """
    Places an Object at a position using an arm.
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    Object designator describing the object that should be place
    """
    arm: str
    """
    Arm that is currently holding the object
    """
    target_location: Pose
    """
    Pose in the world at which the object should be placed
    """

    @with_tree
    def perform(self) -> None:
        object_pose = self.object_designator.bullet_world_object.get_pose()
        local_tf = LocalTransformer()

        # Transformations such that the target position is the position of the object and not the tcp
        tcp_to_object = local_tf.transform_pose(object_pose,
                                                BulletWorld.robot.get_link_tf_frame(
                                                    robot_description.get_tool_frame(self.arm)))
        target_diff = self.target_location.to_transform("target").inverse_times(
            tcp_to_object.to_transform("object")).to_pose()

        MoveTCPMotion(target_diff, self.arm).perform()
        MoveGripperMotion("open", self.arm).perform()
        BulletWorld.robot.detach(self.object_designator.bullet_world_object)
        retract_pose = local_tf.transform_pose(target_diff, BulletWorld.robot.get_link_tf_frame(
            robot_description.get_tool_frame(self.arm)))
        retract_pose.position.x -= 0.07
        MoveTCPMotion(retract_pose, self.arm).perform()

    def to_sql(self) -> ORMPlaceAction:
        return ORMPlaceAction(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMPlaceAction:
        action = super().insert(session)

        od = self.object_designator.insert(session)
        action.object_id = od.id

        pose = self.target_location.insert(session)
        action.pose_id = pose.id

        session.add(action)
        session.commit()

        return action


@dataclass
class NavigateActionPerformable(ActionAbstract):
    """
    Navigates the Robot to a position.
    """

    target_location: Pose
    """
    Location to which the robot should be navigated
    """

    @with_tree
    def perform(self) -> None:
        MoveMotion(self.target_location).perform()

    def to_sql(self) -> ORMNavigateAction:
        return ORMNavigateAction()

    def insert(self, session: Session, *args, **kwargs) -> ORMNavigateAction:
        action = super().insert(session)

        pose = self.target_location.insert(session)
        action.pose_id = pose.id

        session.add(action)
        session.commit()

        return action


@dataclass
class TransportActionPerformable(ActionAbstract):
    """
    Transports an object to a position using an arm
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    Object designator describing the object that should be transported.
    """
    arm: str
    """
    Arm that should be used
    """
    target_location: Pose
    """
    Target Location to which the object should be transported
    """

    @with_tree
    def perform(self) -> None:
        robot_desig = BelieveObject(names=[robot_description.name])
        # ParkArmsAction.Action(Arms.BOTH).perform()
        ParkArmsActionPerformable(Arms.BOTH).perform()
        pickup_loc = CostmapLocation(target=self.object_designator, reachable_for=robot_desig.resolve(),
                                     reachable_arm=self.arm)
        # Tries to find a pick-up posotion for the robot that uses the given arm
        pickup_pose = None
        for pose in pickup_loc:
            if self.arm in pose.reachable_arms:
                pickup_pose = pose
                break
        if not pickup_pose:
            raise ObjectUnfetchable(
                f"Found no pose for the robot to grasp the object: {self.object_designator} with arm: {self.arm}")

        NavigateActionPerformable(pickup_pose.pose).perform()
        PickUpActionPerformable(self.object_designator, self.arm, "front").perform()
        # ParkArmsAction.Action(Arms.BOTH).perform()
        ParkArmsActionPerformable(Arms.BOTH).perform()
        try:
            place_loc = CostmapLocation(target=self.target_location, reachable_for=robot_desig.resolve(),
                                        reachable_arm=self.arm).resolve()
        except StopIteration:
            raise ReachabilityFailure(
                f"No location found from where the robot can reach the target location: {self.target_location}")
        NavigateActionPerformable(place_loc.pose).perform()
        PlaceActionPerformable(self.object_designator, self.arm, self.target_location).perform()
        ParkArmsActionPerformable(Arms.BOTH).perform()

    def to_sql(self) -> ORMTransportAction:
        return ORMTransportAction(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMTransportAction:
        action = super().insert(session)

        od = self.object_designator.insert(session)
        action.object_id = od.id

        pose = self.target_location.insert(session)
        action.pose_id = pose.id

        session.add(action)
        session.commit()

        return action


@dataclass
class LookAtActionPerformable(ActionAbstract):
    """
    Lets the robot look at a position.
    """

    target: Pose
    """
    Position at which the robot should look, given as 6D pose
    """

    @with_tree
    def perform(self) -> None:
        LookingMotion(target=self.target).perform()

    def to_sql(self) -> ORMLookAtAction:
        return ORMLookAtAction()

    def insert(self, session: Session, *args, **kwargs) -> ORMLookAtAction:
        action = super().insert(session)

        pose = self.target.insert(session)
        action.pose_id = pose.id

        session.add(action)
        session.commit()
        return action


@dataclass
class DetectActionPerformable(ActionAbstract):
    """
    Detects an object that fits the object description and returns an object designator describing the object.
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    Object designator loosely describing the object, e.g. only type. 
    """

    @with_tree
    def perform(self) -> None:
        return DetectingMotion(object_type=self.object_designator.type).perform()

    def to_sql(self) -> ORMDetectAction:
        return ORMDetectAction()

    def insert(self, session: Session, *args, **kwargs) -> ORMDetectAction:
        action = super().insert(session)

        od = self.object_designator.insert(session)
        action.object_id = od.id

        session.add(action)
        session.commit()

        return action


@dataclass
class OpenActionPerformable(ActionAbstract):
    """
    Opens a container like object
    """

    object_designator: ObjectPart.Object
    """
    Object designator describing the object that should be opened
    """
    arm: str
    """
    Arm that should be used for opening the container
    """

    @with_tree
    def perform(self) -> None:
        GraspingActionPerformable(self.arm, self.object_designator).perform()
        OpeningMotion(self.object_designator, self.arm).perform()

        MoveGripperMotion("open", self.arm, allow_gripper_collision=True).perform()

    def to_sql(self) -> ORMOpenAction:
        return ORMOpenAction(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMOpenAction:
        action = super().insert(session)

        op = self.object_designator.insert(session)
        action.object_id = op.id

        session.add(action)
        session.commit()

        return action


@dataclass
class CloseActionPerformable(ActionAbstract):
    """
    Closes a container like object.
    """

    object_designator: ObjectPart.Object
    """
    Object designator describing the object that should be closed
    """
    arm: str
    """
    Arm that should be used for closing
    """

    @with_tree
    def perform(self) -> None:
        GraspingActionPerformable(self.arm, self.object_designator).perform()
        ClosingMotion(self.object_designator, self.arm).perform()

        MoveGripperMotion("open", self.arm, allow_gripper_collision=True).perform()

    def to_sql(self) -> ORMCloseAction:
        return ORMCloseAction(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMCloseAction:
        action = super().insert(session)

        op = self.object_designator.insert(session)
        action.object_id = op.id

        session.add(action)
        session.commit()

        return action


@dataclass
class GraspingActionPerformable(ActionAbstract):
    """
    Grasps an object described by the given Object Designator description
    """

    arm: str
    """
    The arm that should be used to grasp
    """
    object_desig: Union[ObjectDesignatorDescription.Object, ObjectPart.Object]
    """
    Object Designator for the object that should be grasped
    """

    @with_tree
    def perform(self) -> None:
        if isinstance(self.object_desig, ObjectPart.Object):
            object_pose = self.object_desig.part_pose
        else:
            object_pose = self.object_desig.bullet_world_object.get_pose()
        lt = LocalTransformer()
        gripper_name = robot_description.get_tool_frame(self.arm)

        object_pose_in_gripper = lt.transform_pose(object_pose,
                                                   BulletWorld.robot.get_link_tf_frame(gripper_name))

        pre_grasp = object_pose_in_gripper.copy()
        pre_grasp.pose.position.x -= 0.1

        MoveTCPMotion(pre_grasp, self.arm).perform()
        MoveGripperMotion("open", self.arm).perform()

        MoveTCPMotion(object_pose, self.arm, allow_gripper_collision=True).perform()
        MoveGripperMotion("close", self.arm, allow_gripper_collision=True).perform()

    def to_sql(self) -> ORMGraspingAction:
        return ORMGraspingAction(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMGraspingAction:
        action = super().insert(session)

        od = self.object_desig.insert(session)
        action.object_id = od.id

        session.add(action)
        session.commit()

        return action


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/designators/actions/__init__.py


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/resolver/__init__.py
from .location.jpt_location import JPTCostmapLocation

##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/resolver/location/jpt_location.py
import dataclasses
import time
from typing import Optional, List, Tuple

import jpt
import numpy as np
import pybullet
import tf

import pycram.designators.location_designator
import pycram.task
from ...costmaps import OccupancyCostmap, plot_grid
from ...plan_failures import PlanFailure
from ...pose import Pose
from pycram.bullet_world import BulletWorld, Object


class JPTCostmapLocation(pycram.designators.location_designator.CostmapLocation):
    """Costmap Locations using Joint Probability Trees (JPTs).
    JPT costmaps are trained to model the dependency with a robot position relative to the object, the robots type,
    the objects type, the robot torso height, and the grasp parameters.
    Solutions to the problem definitions are chosen in such a way that the success probability is highest.
    """

    @dataclasses.dataclass
    class Location(pycram.designators.location_designator.LocationDesignatorDescription.Location):
        pose: Pose
        reachable_arm: str
        torso_height: float
        grasp: str

    def __init__(self, target: Object, reachable_for=None, reachable_arm=None,
                 model: Optional[jpt.trees.JPT] = None, path: Optional[str] = None, resolver=None):
        """
        Create a JPT Costmap

        :param target: The target object
        :param reachable_for: The robot to grab the object with
        :param reachable_arm: The arm to use
        :param model: The JPT model as a loaded tree in memory, either model or path must be set
        :param path: The path to the JPT model, either model or path must be set
        """
        super().__init__(target, reachable_for, None, reachable_arm, resolver)
        # check if arguments are plausible
        if (not model and not path) or (model and path):
            raise ValueError("Either model or path must be set.")

        # set model
        if model:
            self.model = model

        # load model from path
        if path:
            self.model = jpt.trees.JPT.load(path)

        # initialize member for visualized objects
        self.visual_ids: List[int] = []

    def evidence_from_occupancy_costmap(self) -> List[jpt.variables.LabelAssignment]:
        """
        Create a list of boxes that can be used as evidences for a jpt. The list of boxes describe areas where the
        robot can stand.

        :return: List of evidences describing the found boxes
        """

        # create Occupancy costmap for the target object
        position, orientation = self.target.pose.to_list()
        position = list(position)
        position[-1] = 0

        ocm = OccupancyCostmap(distance_to_obstacle=0.3, from_ros=False, size=200, resolution=0.02,
                               origin=Pose(position, orientation))
        # ocm.visualize()

        # working on a copy of the costmap, since found rectangles are deleted
        map = np.copy(ocm.map)

        # initialize result
        queries = []

        origin = np.array([ocm.height/2, ocm.width/2])

        # for every index pair (i, j) in the occupancy map
        for i in range(0, map.shape[0]):
            for j in range(0, map.shape[1]):

                # if this index has not been used yet
                if map[i][j] > 0:

                    # get consecutive box
                    width = ocm._find_consectuive_line((i, j), map)
                    height = ocm._find_max_box_height((i, j), width, map)

                    # mark box as used
                    map[i:i+height, j:j+width] = 0

                    # calculate to coordinates relative to the objects pose
                    pose = np.array([i, j])
                    lower_corner = (pose - origin) * ocm.resolution
                    upper_corner = (pose - origin + np.array([height, width])) * ocm.resolution
                    rectangle = np.array([lower_corner, upper_corner]).T

                    # transform to jpt query
                    query = self.model.bind({"x": list(rectangle[0]), "y": list(rectangle[1])})
                    queries.append(query)

        return queries

    def create_evidence(self, use_success=True) -> jpt.variables.LabelAssignment:
        """
        Create evidence usable for JPTs where type and status are set if wanted.

        :param use_success: Rather to set success or not
        :return: The usable label-assignment
        """
        evidence = dict()

        evidence["type"] = {self.target.type}

        if use_success:
            evidence["status"] = {"SUCCEEDED"}

        return self.model.bind(evidence)

    def sample(self, amount: int = 1) -> np.ndarray:
        """
        Sample from the locations that fit the CostMap and are not occupied.

        :param amount: The amount of samples to draw
        :return: A numpy array containing the samples drawn from the tree.
        """
        evidence = self.create_evidence()

        locations = self.evidence_from_occupancy_costmap()
        solutions = []

        for location in locations:
            for variable, value in evidence.items():
                location[variable] = value

            for leaf in self.model.apply(location):
                if leaf.probability(location) == 0:
                    continue
                altered_leaf = leaf.conditional_leaf(location)
                # success_probability = altered_leaf.probability(location)
                success_probability = altered_leaf.probability(self.model.bind({"status": "SUCCEEDED"}))

                mpe_state, _ = altered_leaf.mpe(self.model.minimal_distances)
                location["grasp"] = mpe_state["grasp"]
                location["arm"] = mpe_state["arm"]
                location["relative torso height"] = mpe_state["relative torso height"]
                location["x"] = mpe_state["x"]
                location["y"] = mpe_state["y"]
                solutions.append((location, success_probability, leaf.prior))

        solutions = sorted(solutions, key=lambda x: x[1], reverse=True)
        best_solution = solutions[0]
        conditional_model = self.model.conditional_jpt(best_solution[0])

        # conditional_model.plot(plotvars=conditional_model.variables)
        return conditional_model.sample(amount)

    def sample_to_location(self, sample: np.ndarray) -> Location:
        """
        Convert a numpy array sampled from the JPT to a costmap-location

        :param sample: The drawn sample
        :return: The usable costmap-location
        """
        sample_dict = {variable.name: value for variable, value in zip(self.model.variables, sample)}
        target_x, target_y, target_z = self.target.pose.position_as_list()
        pose = [target_x + sample_dict["x"], target_y + sample_dict["y"], 0]

        angle = np.arctan2(pose[1] - target_y, pose[0] - target_x) + np.pi

        orientation = list(tf.transformations.quaternion_from_euler(0, 0, angle, axes="sxyz"))
        torso_height = np.clip(target_z - sample_dict["relative torso height"], 0, 0.33)
        result = self.Location(Pose(pose, orientation), sample_dict["arm"], torso_height, sample_dict["grasp"])
        return result

    def __iter__(self):
        samples = self.sample(200)
        for sample in samples:
            yield self.sample_to_location(sample)

    def visualize(self):
        """
        Plot the possible areas to stand in the BulletWorld. The opacity is the probability of success.

        """

        evidence = self.create_evidence(use_success=False)

        conditional_model = self.model.conditional_jpt(evidence)

        for leaf in conditional_model.leaves.values():

            success = leaf.distributions["status"].p({"SUCCEEDED"})

            if success == 0:
                continue

            x_intervals = leaf.distributions["x"].cdf.intervals
            y_intervals = leaf.distributions["y"].cdf.intervals

            x_range = np.array([x_intervals[0].upper, x_intervals[-1].lower])
            y_range = np.array([y_intervals[0].upper, y_intervals[-1].lower])

            center = np.array([sum(x_range) / 2, sum(y_range) / 2])

            visual = pybullet.createVisualShape(pybullet.GEOM_BOX,
                                                halfExtents=[(x_range[1] - x_range[0]) / 2,
                                                             (y_range[1] - y_range[0]) / 2, 0.001],
                                                rgbaColor=[1, 0, 0, success],
                                                visualFramePosition=[*center, 0])

            self.visual_ids.append(visual)

        for id_list in np.array_split(np.array(self.visual_ids), np.ceil(len(self.visual_ids) / 127)):
            # Dummy paramater since these are needed to spawn visual shapes as a multibody.
            link_poses = [[0, 0, 0] for c in id_list]
            link_orientations = [[0, 0, 0, 1] for c in id_list]
            link_masses = [1.0 for c in id_list]
            link_parent = [0 for c in id_list]
            link_joints = [pybullet.JOINT_FIXED for c in id_list]
            link_collision = [-1 for c in id_list]
            link_joint_axis = [[1, 0, 0] for c in id_list]

            # The position at which the multibody will be spawned. Offset such that
            # the origin referes to the centre of the costmap.
            origin_pose = self.target.pose.to_list()
            base_position = list(origin_pose[0])
            base_position[2] = 0

            map_obj = pybullet.createMultiBody(baseVisualShapeIndex=-1, linkVisualShapeIndices=id_list,
                                               basePosition=base_position, baseOrientation=origin_pose[1],
                                               linkPositions=link_poses,
                                               linkMasses=link_masses, linkOrientations=link_orientations,
                                               linkInertialFramePositions=link_poses,
                                               linkInertialFrameOrientations=link_orientations,
                                               linkParentIndices=link_parent,
                                               linkJointTypes=link_joints, linkJointAxis=link_joint_axis,
                                               linkCollisionShapeIndices=link_collision)
            self.visual_ids.append(map_obj)

    def close_visualization(self) -> None:
        """
        Close all plotted objects.

        """
        for id in self.visual_ids:
            pybullet.removeBody(id)
        self.visual_ids = []


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/resolver/location/giskard_location.py
from pycram.external_interfaces.giskard import achieve_cartesian_goal
from pycram.designators.location_designator import CostmapLocation
from pycram.bullet_world import Use_shadow_world, BulletWorld
from pycram.helper import _apply_ik
from pycram.pose import Pose
from pycram.robot_descriptions import robot_description
from pycram.pose_generator_and_validator import reachability_validator
from typing import Tuple, Dict

import tf
import numpy as np


class GiskardLocation(CostmapLocation):

    def __iter__(self) -> CostmapLocation.Location:
        """
        Resolves a CostmapLocation for reachability to a specific Location using Giskard. Since Giskard is able to perform
        full body IK solving we can use this to get the Pose of a robot at which it is able to reach a certain point.
        This resolver only supports reachable_for and not visible_for

        :param desig: A CostmapLocation Designator description
        :return: An instance of CostmapLocation.Location with a pose from which the robot can reach the target
        """
        if self.reachable_for:
            pose_right, end_config_right = self._get_reachable_pose_for_arm(self.target,
                                                                            robot_description.get_tool_frame("right"))
            pose_left, end_config_left = self._get_reachable_pose_for_arm(self.target,
                                                                          robot_description.get_tool_frame("left"))

            test_robot = BulletWorld.current_bullet_world.get_shadow_object(BulletWorld.robot)
            with Use_shadow_world():
                valid, arms = reachability_validator(pose_right, test_robot, self.target, {})
                if valid:
                    yield CostmapLocation.Location(pose_right, arms)
                valid, arms = reachability_validator(pose_left, test_robot, self.target, {})
                if valid:
                    yield self.Location(pose_left, arms)

    def _get_reachable_pose_for_arm(self, target: Pose, end_effector_link: str) -> Tuple[Pose, Dict]:
        """
        Calls Giskard to perform full body ik solving between the map and the given end effector link. The end joint
        configuration of the robot as well as its end pose are then returned.

        :param target: The pose which the robots end effector should reach
        :param end_effector_link: The name of the end effector which should reach the target
        :return: The end pose of the robot as well as its final joint configuration
        """
        giskard_result = achieve_cartesian_goal(target, end_effector_link, "map")
        joints = giskard_result.trajectory.joint_names
        trajectory_points = giskard_result.trajectory.points

        end_config = dict(zip(joints, trajectory_points[-1].positions))
        orientation = list(tf.transformations.quaternion_from_euler(0, 0, end_config["yaw"], axes="sxyz"))
        pose = Pose([end_config["x"], end_config["y"], 0], orientation)
        return pose, end_config


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/resolver/location/database_location.py
import numpy as np
import sqlalchemy.orm
import sqlalchemy.sql
from sqlalchemy import select, Select
from tf import transformations
import pycram.designators.location_designator
import pycram.task
from pycram.costmaps import OccupancyCostmap
from pycram.orm.action_designator import PickUpAction, Action
from pycram.orm.object_designator import Object
from pycram.orm.base import Position, RobotState, Designator, Base
from pycram.orm.task import TaskTreeNode, Code
from .jpt_location import JPTCostmapLocation
from ... import orm
from ...pose import Pose


class DatabaseCostmapLocation(pycram.designators.location_designator.CostmapLocation):
    """
    Class that represents costmap locations from a given Database.
    The database has to have a schema that is compatible with the pycram.orm package.
    """

    def __init__(self, target, session: sqlalchemy.orm.Session = None,
                 reachable_for=None, reachable_arm=None, resolver=None):
        """
        Create a Database Costmap

        :param target: The target object
        :param session: A session that can be used to execute queries
        :param reachable_for: The robot to grab the object with
        :param reachable_arm: The arm to use

        """
        super().__init__(target, reachable_for, None, reachable_arm, resolver)
        self.session = session

    def create_query_from_occupancy_costmap(self) -> Select:
        """
        Create a query that queries all relative robot positions from an object that are not occluded using an
        OccupancyCostmap.
        """

        robot_pos = sqlalchemy.orm.aliased(Position)

        # query all relative robot positions in regard to an objects position
        # make sure to order the joins() correctly
        query = (select(PickUpAction.arm, PickUpAction.grasp, RobotState.torso_height, Position.x, Position.y)
                 .join(TaskTreeNode.code)
                 .join(Code.designator.of_type(PickUpAction))
                 .join(PickUpAction.robot_state)
                 .join(RobotState.pose)
                 .join(orm.base.Pose.position)
                 .join(PickUpAction.object).where(Object.type == self.target.type)
                                           .where(TaskTreeNode.status == "SUCCEEDED"))

        # create Occupancy costmap for the target object
        position, orientation = self.target.pose.to_list()
        position = list(position)
        position[-1] = 0

        ocm = OccupancyCostmap(distance_to_obstacle=0.3, from_ros=False, size=200, resolution=0.02,
                               origin=Pose(position, orientation))
        # ocm.visualize()

        # working on a copy of the costmap, since found rectangles are deleted
        map = np.copy(ocm.map)

        origin = np.array([ocm.height / 2, ocm.width / 2])

        filters = []

        # for every index pair (i, j) in the occupancy map
        for i in range(0, map.shape[0]):
            for j in range(0, map.shape[1]):

                # if this index has not been used yet
                if map[i][j] > 0:
                    # get consecutive box
                    width = ocm._find_consectuive_line((i, j), map)
                    height = ocm._find_max_box_height((i, j), width, map)

                    # mark box as used
                    map[i:i + height, j:j + width] = 0

                    # calculate to coordinates relative to the objects pose
                    pose = np.array([i, j])
                    lower_corner = (pose - origin) * ocm.resolution
                    upper_corner = (pose - origin + np.array([height, width])) * ocm.resolution
                    rectangle = np.array([lower_corner, upper_corner]).T

                    # transform to jpt query
                    filters.append(sqlalchemy.and_(robot_pos.x >= rectangle[0][0], robot_pos.x < rectangle[0][1],
                                                   robot_pos.y >= rectangle[1][0], robot_pos.y < rectangle[1][1]))
                    # query = self.model.bind({"x": list(rectangle[0]), "y": list(rectangle[1])})

        return query.where(sqlalchemy.or_(*filters))

    def sample_to_location(self, sample: sqlalchemy.engine.row.Row) -> JPTCostmapLocation.Location:
        """
        Convert a database row to a costmap location.

        :param sample: The database row.
        :return: The costmap location
        """
        target_x, target_y, target_z = self.target.pose.position_as_list()
        pose = [target_x + sample.x, target_y + sample.y, 0]
        angle = np.arctan2(pose[1] - target_y, pose[0] - target_x) + np.pi
        orientation = list(transformations.quaternion_from_euler(0, 0, angle, axes="sxyz"))

        result = JPTCostmapLocation.Location(Pose(pose, orientation), sample.arm, sample.torso_height, sample.grasp)
        return result

    def __iter__(self) -> JPTCostmapLocation.Location:
        statement = self.create_query_from_occupancy_costmap().limit(200)
        samples = self.session.execute(statement).all()
        for sample in samples:
            yield self.sample_to_location(sample)


##New # Content from: /home/julius/ros/ros_ws/src/pycram/src/pycram/resolver/location/__init__.py


