##New # Content from: #<src/pycram/designator.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

from dataclasses import dataclass, field, fields
from abc import ABC, abstractmethod
from inspect import isgenerator, isgeneratorfunction

import rospy
try:
    import owlready2
except ImportError:
    owlready2 = None
    rospy.logwarn("owlready2 is not installed!")

from sqlalchemy.orm.session import Session

from .datastructures.world import World
from .world_concepts.world_object import Object as WorldObject
from .utils import GeneratorList, bcolors
from threading import Lock
from time import time
from typing_extensions import Type, List, Dict, Any, Optional, Union, get_type_hints, Callable, Iterable, TYPE_CHECKING, get_args, get_origin

from .local_transformer import LocalTransformer
from .language import Language
from .datastructures.pose import Pose
from .robot_description import RobotDescription
from .datastructures.enums import ObjectType

import logging

from .orm.action_designator import (Action as ORMAction)
from .orm.object_designator import (Object as ORMObjectDesignator)
from .orm.motion_designator import Motion as ORMMotionDesignator

from .orm.base import RobotState, ProcessMetaData
from .tasktree import with_tree

if TYPE_CHECKING:
    from .ontology.ontology_common import OntologyConceptHolder


class DesignatorError(Exception):
    """Implementation of designator errors."""

    def __init__(self, *args, **kwargs):
        """Create a new designator error."""
        Exception.__init__(self, *args, **kwargs)


class ResolutionError(Exception):
    def __init__(self, missing_properties: List[str], wrong_type: Dict, current_type: Any, designator: Designator):
        self.error = f"\nSome requiered properties where missing or had the wrong type when grounding the Designator: {designator}.\n"
        self.missing = f"The missing properties where: {missing_properties}\n"
        self.wrong = f"The properties with the wrong type along with the currrent -and right type :\n"
        self.head = "Property   |   Current Type    |     Right Type\n-------------------------------------------------------------\n"
        self.tab = ""
        for prop in wrong_type.keys():
            self.tab += prop + "     " + str(current_type[prop]) + "      " + str(wrong_type[prop]) + "\n"
        self.message = self.error
        if missing_properties != []:
            self.message += self.missing
        if wrong_type != {}:
            self.message += self.wrong + self.head + self.tab
        self.message = f"{bcolors.BOLD}{bcolors.FAIL}" + self.message + f"{bcolors.ENDC}"
        super(ResolutionError, self).__init__(self.message)


class Designator(ABC):
    """
    Implementation of designators. DEPRECTAED SINCE DESIGNATOR DESCRIPTIONS ARE USED AS BASE CLASS

    Designators are objects containing sequences of key-value pairs. They can be resolved which means to generate real
    parameters for executing performables from these pairs of key and value.

    :ivar timestamp: The timestamp of creation of reference or None if still not referencing an object.
    """


    resolvers = {}
    """
    List of all designator resolvers. Designator resolvers are functions which take a designator as
    argument and return a list of solutions. A solution can also be a generator. 
    """

    def __init__(self, description: DesignatorDescription, parent: Optional[Designator] = None):
        """Create a new desginator.

        Arguments:
        :param description: A list of tuples (key-value pairs) describing this designator.
        :param parent: The parent to equate with (default is None).
        """
        self._mutex: Lock = Lock()
        self._parent: Union[Designator, None] = None
        self._successor: Union[Designator, None] = None
        self._effective: bool = False
        self._data: Any = None
        self._solutions = None
        self._index: int = 0
        self.timestamp = None
        self._description: DesignatorDescription = description

        if parent is not None:
            self.equate(parent)

    def equate(self, parent: Designator) -> None:
        """Equate the designator with the given parent.

        Arguments:
        parent -- the parent to equate with.
        """
        if self.equal(parent):
            return

        youngest_parent = parent.current()
        first_parent = parent.first()

        if self._parent is not None:
            first_parent._parent = self._parent
            first_parent._parent._successor = first_parent

        self._parent = youngest_parent
        youngest_parent._successor = self

    def equal(self, other: Designator) -> bool:
        """Check if the designator describes the same entity as another designator, i.e. if they are equated.

        Arguments:
        other -- the other designator.
        """
        return other.first() is self.first()

    def first(self) -> Designator:
        """Return the first ancestor in the chain of equated designators."""
        if self._parent is None:
            return self

        return self._parent.first()

    def current(self) -> Designator:
        """Return the newest designator, i.e. that one that has been equated last to the designator or one of its
        equated designators."""
        if self._successor is None:
            return self

        return self._successor.current()

    def _reference(self) -> Any:
        """This is a helper method for internal usage only.

        This method is to be overwritten instead of the reference method.
        """
        resolver = self.resolvers[self._description.resolver]
        if self._solutions is None:
            def generator():
                solution = resolver(self)
                if isgeneratorfunction(solution):
                    solution = solution()

                if isgenerator(solution):
                    while True:
                        try:
                            yield next(solution)
                        except StopIteration:
                            break
                else:
                    yield solution

            self._solutions = GeneratorList(generator)

        if self._data is not None:
            return self._data

        try:
            self._data = self._solutions.get(self._index)
            return self._data
        except StopIteration:
            raise DesignatorError('There was no Solution for this Designator')

    def reference(self) -> Any:
        """Try to dereference the designator and return its data object or raise DesignatorError if it is not an
        effective designator. """
        with self._mutex:
            ret = self._reference()

        self._effective = True

        if self.timestamp is None:
            self.timestamp = time()

        return ret

    @abstractmethod
    def next_solution(self):
        """Return another solution for the effective designator or None if none exists. The next solution is a newly
        constructed designator with identical properties that is equated to the designator since it describes the same
        entity. """
        pass

    def solutions(self, from_root: Optional[Designator] = None):
        """Return a generator for all solutions of the designator.

        Arguments:
        from_root -- if not None, the generator for all solutions beginning from with the original designator is returned (default is None).
        """
        if from_root is not None:
            desig = self.first()
        else:
            desig = self

        def generator(desig):
            while desig is not None:
                try:
                    yield desig.reference()
                except DesignatorError:
                    pass

                desig = desig.next_solution()

        return generator(desig)

    def copy(self, new_properties: Optional[List] = None) -> Designator:
        """Construct a new designator with the same properties as this one. If new properties are specified, these will
        be merged with the old ones while the new properties are dominant in this relation.

        Arguments:
        new_properties -- a list of new properties to merge into the old ones (default is None).
        """
        description = self._description.copy()

        if new_properties:
            for key, value in new_properties:
                description.__dict__[key] = value

        return self.__class__(description)

    def make_effective(self, properties: Optional[List] = None,
                       data: Optional[Any] = None,
                       timestamp: Optional[float] = None) -> Designator:
        """Create a new effective designator of the same type as this one. If no properties are specified, this ones are used.

        Arguments:
        new_properties -- a list of properties (default is None).
        data -- the low-level data structure the new designator describes (default is None).
        timestamp -- the timestamp of creation of reference (default is the current).
        """
        if properties is None:
            properties = self._description

        desig = self.__class__(properties)
        desig._effective = True
        desig._data = data

        if timestamp is None:
            desig.timestamp = time()
        else:
            desig.timestamp = timestamp

        return desig

    def newest_effective(self) -> Designator:
        """Return the newest effective designator."""

        def find_effective(desig):
            if desig is None or desig._effective:
                return desig

            return find_effective(desig._parent)

        return find_effective(self.current())

    def prop_value(self, key: str) -> Any:
        """Return the first value matching the specified property key.

        Arguments:
        key -- the key to return the value of.
        """
        try:
            return self._description.__dict__[key]
        except KeyError:
            logging.error(f"The given key '{key}' is not in this Designator")
            return None

    def check_constraints(self, properties: List) -> bool:
        """Return True if all the given properties match, False otherwise.

        Arguments:
        properties -- the properties which have to match. A property can be a tuple in which case its first value is the
        key of a property which must equal the second value. Otherwise it's simply the key of a property which must be
        not None.
        """
        for prop in properties:
            if type(prop) == tuple:
                key, value = prop

                if self.prop_value(key) != value:
                    return False
            else:
                if self.prop_value(prop) is None:
                    return False

        return True

    def make_dictionary(self, properties: List) -> Dict:
        """ DEPRECATED, Moved to the description. Function only keept because of
        backward compatability.
        Return the given properties as dictionary.

        Arguments:
        properties -- the properties to create a dictionary of. A property can be a tuple in which case its first value
        is the dictionary key and the second value is the dictionary value. Otherwise it's simply the dictionary key
        and the key of a property which is the dictionary value.
        """

        return self._description.make_dictionary(properties)

    def rename_prop(self, old: str, new: str) -> Designator:
        old_value = self.prop_value(old)
        if old_value is not None:
            self._description.__dict__[new] = old_value
            del self._description.__dict__[old]
        else:
            raise DesignatorError("Old property does not exists.")
        return self.current()


class DesignatorDescription(ABC):
    """
    :ivar resolve: The specialized_designators function to use for this designator, defaults to self.ground
    """

    def __init__(self, resolver: Optional[Callable] = None, ontology_concept_holders: Optional[List[OntologyConceptHolder]] = None):
        """
        Create a Designator description.

        :param resolver: The grounding method used for the description. The grounding method creates a location instance that matches the description.
        :param ontology_concept_holders: A list of holders of ontology concepts that the designator is categorized as or associated with
        """

        if resolver is None:
            self.resolve = self.ground
        self.ontology_concept_holders = [] if ontology_concept_holders is None else ontology_concept_holders

    def make_dictionary(self, properties: List[str]):
        """
        Creates a dictionary of this description with only the given properties
        included.

        :param properties: A list of properties that should be included in the dictionary.
                            The given properties have to be an attribute of this description.
        :return: A dictionary with the properties as keys.
        """
        attributes = self.__dict__
        ret = {}
        for att in attributes.keys():
            if att in properties:
                ret[att] = attributes[att]
        return ret

    def ground(self) -> Any:
        """
        Should be overwritten with an actual grounding function which infers missing properties.
        """
        return self

    def get_slots(self) -> List[str]:
        """
        Returns a list of all slots of this description. Can be used for inspecting different descriptions and debugging.

        :return: A list of all slots.
        """
        return list(self.__dict__.keys())

    def copy(self) -> DesignatorDescription:
        return self

    def get_default_ontology_concept(self) -> owlready2.Thing | None:
        """
        Returns the first element of ontology_concept_holders if there is, else None
        """
        return self.ontology_concept_holders[0].ontology_concept if self.ontology_concept_holders else None

class ActionDesignatorDescription(DesignatorDescription, Language):
    """
    Abstract class for action designator descriptions.
    Descriptions hold possible parameter ranges for action designators.
    """

    @dataclass
    class Action:
        """
        The performable designator with a single element for each list of possible parameter.
        """
        robot_position: Pose = field(init=False)
        """
        The position of the robot at the start of the action.
        """
        robot_torso_height: float = field(init=False)
        """
        The torso height of the robot at the start of the action.
        """

        robot_type: ObjectType = field(init=False)
        """
        The type of the robot at the start of the action.
        """

        def __post_init__(self):
            self.robot_position = World.robot.get_pose()
            self.robot_torso_height = World.robot.get_joint_position(RobotDescription.current_robot_description.torso_joint)
            self.robot_type = World.robot.obj_type

        @with_tree
        def perform(self) -> Any:
            """
            Executes the action with the single parameters from the description.
            """
            raise NotImplementedError()

        def to_sql(self) -> ORMAction:
            """
            Create an ORM object that corresponds to this description.

            :return: The created ORM object.
            """
            raise NotImplementedError(f"{type(self)} has no implementation of to_sql. Feel free to implement it.")

        def insert(self, session: Session, *args, **kwargs) -> ORMAction:
            """
            Add and commit this and all related objects to the session.
            Auto-Incrementing primary keys and foreign keys have to be filled by this method.

            :param session: Session with a database that is used to add and commit the objects
            :param args: Possible extra arguments
            :param kwargs: Possible extra keyword arguments
            :return: The completely instanced ORM object
            """

            pose = self.robot_position.insert(session)

            # get or create metadata
            metadata = ProcessMetaData().insert(session)

            # create robot-state object
            robot_state = RobotState(self.robot_torso_height, self.robot_type)
            robot_state.pose = pose
            robot_state.process_metadata = metadata
            session.add(robot_state)

            # create action
            action = self.to_sql()
            action.process_metadata = metadata
            action.robot_state = robot_state

            return action

    def __init__(self, resolver=None, ontology_concept_holders: Optional[List[OntologyConceptHolder]] = None):
        """
        Base of all action designator descriptions.

        :param resolver: An alternative resolver that returns an action designator
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        Language.__init__(self)
        from .ontology.ontology import OntologyManager
        self.soma = OntologyManager().soma

    def ground(self) -> Action:
        """Fill all missing parameters and chose plan to execute. """
        raise NotImplementedError(f"{type(self)}.ground() is not implemented.")

    def init_ontology_concepts(self, ontology_concept_classes: Dict[str, Type[owlready2.Thing]]):
        """
        Initialize the ontology concept holders for this action designator

        :param ontology_concept_classes: The ontology concept classes that the action is categorized as or associated with
        :param ontology_concept_name: The name of the ontology concept instance to be created
        """
        from .ontology.ontology_common import OntologyConceptHolderStore, OntologyConceptHolder
        if not self.ontology_concept_holders:
            for concept_name, concept_class in ontology_concept_classes.items():
                if concept_class:
                    existing_holders = OntologyConceptHolderStore().get_ontology_concept_holders_by_class(concept_class)
                    self.ontology_concept_holders.extend(existing_holders if existing_holders \
                                                         else [OntologyConceptHolder(concept_class(concept_name))])

    def __iter__(self):
        """
        Iterate through all possible performables fitting this description

        :yield: A resolved action designator
        """
        yield self.ground()


class LocationDesignatorDescription(DesignatorDescription):
    """
    Parent class of location designator descriptions.
    """

    @dataclass
    class Location:
        """
        Resolved location that represents a specific point in the world which satisfies the constraints of the location
        designator description.
        """
        pose: Pose
        """
        The resolved pose of the location designator. Pose is inherited by all location designator.
        """

    def __init__(self, resolver=None, ontology_concept_holders: Optional[List[owlready2.Thing]] = None):
        super().__init__(resolver, ontology_concept_holders)

    def ground(self) -> Location:
        """
        Find a location that satisfies all constrains.
        """
        raise NotImplementedError(f"{type(self)}.ground() is not implemented.")


#this knowledge should be somewhere else i guess
SPECIAL_KNOWLEDGE = {
    'bigknife':
        [("top", [-0.08, 0, 0])],
    'whisk':
        [("top", [-0.08, 0, 0])],
    'bowl':
        [("front", [1.0, 2.0, 3.0]),
         ("key2", [4.0, 5.0, 6.0])]
}


class ObjectDesignatorDescription(DesignatorDescription):
    """
    Class for object designator descriptions.
    Descriptions hold possible parameter ranges for object designators.
    """

    @dataclass
    class Object:
        """
        A single element that fits the description.
        """

        name: str
        """
        Name of the object
        """

        obj_type: ObjectType
        """
        Type of the object
        """

        world_object: Optional[WorldObject]
        """
        Reference to the World object
        """

        _pose: Optional[Callable] = field(init=False)
        """
        A callable returning the pose of this object. The _pose member is used overwritten for data copies
        which will not update when the original world_object is moved.
        """

        def __post_init__(self):
            if self.world_object:
                self._pose = self.world_object.get_pose

        def to_sql(self) -> ORMObjectDesignator:
            """
            Create an ORM object that corresponds to this description.

            :return: The created ORM object.
            """
            return ORMObjectDesignator(self.obj_type, self.name)

        def insert(self, session: Session) -> ORMObjectDesignator:
            """
            Add and commit this and all related objects to the session.
            Auto-Incrementing primary keys and foreign keys have to be filled by this method.

            :param session: Session with a database that is used to add and commit the objects
            :return: The completely instanced ORM object
            """
            metadata = ProcessMetaData().insert(session)
            pose = self.pose.insert(session)

            # create object orm designator
            obj = self.to_sql()
            obj.process_metadata = metadata
            obj.pose = pose
            session.add(obj)
            return obj

        def frozen_copy(self) -> 'ObjectDesignatorDescription.Object':
            """
            Returns a copy of this designator containing only the fields.

            :return: A copy containing only the fields of this class. The WorldObject attached to this pycram object is not copied. The _pose gets set to a method that statically returns the pose of the object when this method was called.
            """
            result = ObjectDesignatorDescription.Object(self.name, self.obj_type, None)
            # get current object pose and set resulting pose to always be that
            pose = self.pose
            result.pose = lambda: pose
            return result

        @property
        def pose(self):
            """
            Property of the current position and orientation of the object.
            Evaluate the _pose function.

            :return: Position and orientation
            """
            return self._pose()

        @pose.setter
        def pose(self, value: Callable):
            """
            Set the pose to a new method that returns the current pose.

            :param value: A callable that returns a pose.
            """
            self._pose = value

        def __repr__(self):
            return self.__class__.__qualname__ + f"(" + ', '.join(
                [f"{f.name}={self.__getattribute__(f.name)}" for f in fields(self)] + [
                    f"pose={self.pose}"]) + ')'

        def special_knowledge_adjustment_pose(self, grasp: str, pose: Pose) -> Pose:
            """
            Returns the adjusted target pose based on special knowledge for "grasp front".

            :param grasp: From which side the object should be grasped
            :param pose: Pose at which the object should be grasped, before adjustment
            :return: The adjusted grasp pose
            """
            lt = LocalTransformer()
            pose_in_object = lt.transform_pose(pose, self.world_object.tf_frame)

            special_knowledge = []  # Initialize as an empty list
            if self.obj_type in SPECIAL_KNOWLEDGE:
                special_knowledge = SPECIAL_KNOWLEDGE[self.obj_type]

            for key, value in special_knowledge:
                if key == grasp:
                    # Adjust target pose based on special knowledge
                    pose_in_object.pose.position.x += value[0]
                    pose_in_object.pose.position.y += value[1]
                    pose_in_object.pose.position.z += value[2]
                    rospy.loginfo("Adjusted target pose based on special knowledge for grasp: %s", grasp)
                    return pose_in_object
            return pose

    def __init__(self, names: Optional[List[str]] = None, types: Optional[List[ObjectType]] = None,
                 resolver: Optional[Callable] = None, ontology_concept_holders: Optional[List[owlready2.Thing]] = None):
        """
        Base of all object designator descriptions. Every object designator has the name and type of the object.

        :param names: A list of names that could describe the object
        :param types: A list of types that could represent the object
        :param resolver: An alternative specialized_designators that returns an object designator for the list of names and types
        :param ontology_concept_holders: A list of ontology concepts that the object is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.types: Optional[List[ObjectType]] = types
        self.names: Optional[List[str]] = names

    def ground(self) -> Union[Object, bool]:
        """
        Return the first object from the world that fits the description.

        :return: A resolved object designator
        """
        return next(iter(self))

    def __iter__(self) -> Iterable[Object]:
        """
        Iterate through all possible objects fitting this description

        :yield: A resolved object designator
        """
        # for every world object
        for obj in World.current_world.objects:

            # skip if name does not match specification
            if self.names and obj.name not in self.names:
                continue

            # skip if type does not match specification
            if self.types and obj.obj_type not in self.types:
                continue

            yield self.Object(obj.name, obj.obj_type, obj)

@dataclass
class BaseMotion(ABC):

    @abstractmethod
    def perform(self):
        """
        Passes this designator to the process module for execution. Will be overwritten by each motion.
        """
        pass
        # return ProcessModule.perform(self)

    @abstractmethod
    def to_sql(self) -> ORMMotionDesignator:
        """
        Create an ORM object that corresponds to this description. Will be overwritten by each motion.

        :return: The created ORM object.
        """
        return ORMMotionDesignator()

    @abstractmethod
    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        """
        Add and commit this and all related objects to the session.
        Auto-Incrementing primary keys and foreign keys have to be filled by this method.

        :param session: Session with a database that is used to add and commit the objects
        :param args: Possible extra arguments
        :param kwargs: Possible extra keyword arguments
        :return: The completely instanced ORM motion.
        """
        metadata = ProcessMetaData().insert(session)

        motion = self.to_sql()
        motion.process_metadata = metadata

        return motion

    def __post_init__(self):
        """
        Checks if types are missing or wrong
        """
        right_types = get_type_hints(self)
        attributes = self.__dict__.copy()

        missing = []
        wrong_type = {}
        current_type = {}

        for k in attributes.keys():
            attribute = attributes[k]
            attribute_type = type(attributes[k])
            right_type = right_types[k]
            types = get_args(right_type)
            if attribute is None:
                if not any([x is type(None) for x in get_args(right_type)]):
                    missing.append(k)
            elif attribute_type is not right_type:
                if attribute_type not in types:
                    if attribute_type not in [get_origin(x) for x in types if x is not type(None)]:
                        wrong_type[k] = right_types[k]
                        current_type[k] = attribute_type
        if missing != [] or wrong_type != {}:
            raise ResolutionError(missing, wrong_type, current_type, self.__class__)



##New # Content from: #<src/pycram/utils.py>#
"""Implementation of helper functions and classes for internal usage only.

Functions:
_block -- wrap multiple statements into a single block.

Classes:
GeneratorList -- implementation of generator list wrappers.
"""
from inspect import isgeneratorfunction
from typing_extensions import List, Tuple, Callable

import os

from .datastructures.pose import Pose
import math

from typing_extensions import Dict


class bcolors:
    """
    Color codes which can be used to highlight Text in the Terminal. For example,
    for warnings.
    Usage:
    Firstly import the class into the file.
    print(f'{bcolors.WARNING} Some Text {bcolors.ENDC}')
    """
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def _apply_ik(robot: 'pycram.world_concepts.WorldObject', pose_and_joint_poses: Tuple[Pose, Dict[str, float]]) -> None:
    """
    Apllies a list of joint poses calculated by an inverse kinematics solver to a robot

    :param robot: The robot the joint poses should be applied on
    :param pose_and_joint_poses: The base pose and joint states as returned by the ik solver
    :return: None
    """
    pose, joint_states = pose_and_joint_poses
    robot.set_pose(pose)
    robot.set_joint_positions(joint_states)


class GeneratorList:
    """Implementation of generator list wrappers.

    Generator lists store the elements of a generator, so these can be fetched multiple times.

    Methods:
    get -- get the element at a specific index.
    has -- check if an element at a specific index exists.
    """

    def __init__(self, generator: Callable):
        """Create a new generator list.

        Arguments:
        generator -- the generator to use.
        """
        if isgeneratorfunction(generator):
            self._generator = generator()
        else:
            self._generator = generator

        self._generated = []

    def get(self, index: int = 0):
        """Get the element at a specific index or raise StopIteration if it doesn't exist.

        Arguments:
        index -- the index to get the element of.
        """
        while len(self._generated) <= index:
            self._generated.append(next(self._generator))

        return self._generated[index]

    def has(self, index: int) -> bool:
        """Check if an element at a specific index exists and return True or False.

        Arguments:
        index -- the index to check for.
        """
        try:
            self.get(index)
            return True
        except StopIteration:
            return False


def axis_angle_to_quaternion(axis: List, angle: float) -> Tuple:
    """
    Convert axis-angle to quaternion.

    :param axis: (x, y, z) tuple representing rotation axis.
    :param angle: rotation angle in degree
    :return: The quaternion representing the axis angle
    """
    angle = math.radians(angle)
    axis_length = math.sqrt(sum([i ** 2 for i in axis]))
    normalized_axis = tuple(i / axis_length for i in axis)

    x = normalized_axis[0] * math.sin(angle / 2)
    y = normalized_axis[1] * math.sin(angle / 2)
    z = normalized_axis[2] * math.sin(angle / 2)
    w = math.cos(angle / 2)

    return (x, y, z, w)


class suppress_stdout_stderr(object):
    """
    A context manager for doing a "deep suppression" of stdout and stderr in
    Python, i.e. will suppress all prints, even if the print originates in a
    compiled C/Fortran sub-function.

    This will not suppress raised exceptions, since exceptions are printed
    to stderr just before a script exits, and after the context manager has
    exited (at least, I think that is why it lets exceptions through).
    Copied from https://stackoverflow.com/questions/11130156/suppress-stdout-stderr-print-from-python-functions
    """

    def __init__(self):
        # Open a pair of null files
        self.null_fds = [os.open(os.devnull, os.O_RDWR) for x in range(2)]
        # Save the actual stdout (1) and stderr (2) file descriptors.
        self.save_fds = [os.dup(1), os.dup(2)]

    def __enter__(self):
        # Assign the null pointers to stdout and stderr.
        # This one is not needed for URDF parsing output
        # os.dup2(self.null_fds[0], 1)
        os.dup2(self.null_fds[1], 2)

    def __exit__(self, *_):
        # Re-assign the real stdout/stderr back to (1) and (2)
        # This one is not needed for URDF parsing output
        # os.dup2(self.save_fds[0], 1)
        os.dup2(self.save_fds[1], 2)
        # Close all file descriptors
        for fd in self.null_fds + self.save_fds:
            os.close(fd)


##New # Content from: #<src/pycram/robot_description.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import rospy
from typing_extensions import List, Dict, Union, Optional
from urdf_parser_py.urdf import URDF

from .utils import suppress_stdout_stderr
from .datastructures.enums import Arms, Grasp, GripperState, GripperType


class RobotDescriptionManager:
    """
    Singleton class to manage multiple robot descriptions. Stores all robot descriptions and loads a robot description
    according to the name of the loaded robot.
    """
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        """
        Initialize the RobotDescriptionManager, if no instance exists a new instance is created.
        """
        if self._initialized: return
        self.descriptions: Dict[str, RobotDescription] = {}
        self._initialized = True

    def load_description(self, name: str):
        """
        Loads a robot description according to the name of the robot. This required that a robot description with the
        corresponding name is registered.

        :param name: Name of the robot to which the description should be loaded.
        :return: The loaded robot description.
        """
        if name in self.descriptions.keys():
            RobotDescription.current_robot_description = self.descriptions[name]
            return self.descriptions[name]
        else:
            rospy.logerr(f"Robot description {name} not found")

    def register_description(self, description: RobotDescription):
        """
        Register a robot description to the RobotDescriptionManager. The description is stored with the name of the
        description as key. This will later be used to load the description.

        :param description: RobotDescription to register.
        """
        if description.name in self.descriptions.keys():
            raise ValueError(f"Description {description.name} already exists")
        self.descriptions[description.name] = description


class RobotDescription:
    """
    Base class of a robot description. Contains all necessary information about a robot, like the URDF, the base link,
    the torso link and joint, the kinematic chains and cameras.
    """
    current_robot_description: RobotDescription = None
    """
    The currently loaded robot description.
    """
    name: str
    """
    Name of the robot
    """
    base_link: str
    """
    Base link of the robot
    """
    torso_link: str
    """
    Torso link of the robot
    """
    torso_joint: str
    """
    Torso joint of the robot
    """
    urdf_object: URDF
    """
    Parsed URDF of the robot
    """
    kinematic_chains: Dict[str, KinematicChainDescription]
    """
    All kinematic chains defined for this robot
    """
    cameras: Dict[str, CameraDescription]
    """
    All cameras defined for this robot
    """
    grasps: Dict[Grasp, List[float]]
    """
    The orientations of the end effector for different grasps
    """
    links: List[str]
    """
    All links defined in the URDF
    """
    joints: List[str]
    """
    All joints defined in the URDF, by default fixed joints are not included
    """

    def __init__(self, name: str, base_link: str, torso_link: str, torso_joint: str, urdf_path: str):
        """
        Initialize the RobotDescription. The URDF is loaded from the given path and used as basis for the kinematic
        chains.

        :param name: Name of the robot
        :param base_link: Base link of the robot, meaning the first link in the URDF
        :param torso_link: Torso link of the robot
        :param torso_joint: Torso joint of the robot, this is the joint that moves the torso upwards if there is one
        :param urdf_path: Path to the URDF file of the robot
        """
        self.name = name
        self.base_link = base_link
        self.torso_link = torso_link
        self.torso_joint = torso_joint
        with suppress_stdout_stderr():
            # Since parsing URDF causes a lot of warning messages which can't be deactivated, we suppress them
            self.urdf_object = URDF.from_xml_file(urdf_path)
        self.kinematic_chains: Dict[str, KinematicChainDescription] = {}
        self.cameras: Dict[str, CameraDescription] = {}
        self.grasps: Dict[Grasp, List[float]] = {}
        self.links: List[str] = [l.name for l in self.urdf_object.links]
        self.joints: List[str] = [j.name for j in self.urdf_object.joints]

    def add_kinematic_chain_description(self, chain: KinematicChainDescription):
        """
        Adds a KinematicChainDescription object to the RobotDescription. The chain is stored with the name of the chain
        as key.

        :param chain: KinematicChainDescription object to add
        """
        if chain.name in self.kinematic_chains.keys():
            raise ValueError(f"Chain {chain.name} already exists for robot {self.name}")
        self.kinematic_chains[chain.name] = chain

    def add_kinematic_chain(self, name: str, start_link: str, end_link: str):
        """
        Creates and adds a KinematicChainDescription object to the RobotDescription.

        :param name: Name of the KinematicChainDescription object
        :param start_link: First link of the chain
        :param end_link: Last link of the chain
        """
        if name in self.kinematic_chains.keys():
            raise ValueError(f"Chain {name} already exists for robot {self.name}")
        chain = KinematicChainDescription(name, start_link, end_link, self.urdf_object)
        self.add_kinematic_chain_description(chain)

    def add_camera_description(self, camera: CameraDescription):
        """
        Adds a CameraDescription object to the RobotDescription. The camera is stored with the name of the camera as key.
        :param camera: The CameraDescription object to add
        """
        name = camera.name
        if name in self.cameras.keys():
            raise ValueError(f"Camera {name} already exists for robot {self.name}")
        self.cameras[name] = camera

    def add_camera(self, name: str, camera_link: str, minimal_height: float, maximal_height: float):
        """
        Creates and adds a CameraDescription object to the RobotDescription. Minimal and maximal height of the camera are
        relevant if the robot has a moveable torso or the camera is mounted on a moveable part of the robot. Otherwise
        both values can be the same.

        :param name: Name of the CameraDescription object
        :param camera_link: Link of the camera in the URDF
        :param minimal_height: Minimal height of the camera
        :param maximal_height: Maximal height of the camera
        :return:
        """
        camera_desc = CameraDescription(name, camera_link, minimal_height, maximal_height)
        self.cameras[name] = camera_desc

    def add_grasp_orientation(self, grasp: Grasp, orientation: List[float]):
        """
        Adds a grasp orientation to the robot description. This is used to define the orientation of the end effector
        when grasping an object.

        :param grasp: Gasp from the Grasp enum which should be added
        :param orientation: List of floats representing the orientation
        """
        self.grasps[grasp] = orientation

    def add_grasp_orientations(self, orientations: Dict[Grasp, List[float]]):
        """
        Adds multiple grasp orientations to the robot description. This is used to define the orientation of the end effector
        when grasping an object.

        :param orientations: Dictionary of grasp orientations
        """
        self.grasps.update(orientations)

    def get_manipulator_chains(self) -> List[KinematicChainDescription]:
        """
        Returns a list of all manipulator chains of the robot which posses an end effector.

        :return: A list of KinematicChainDescription objects
        """
        result = []
        for chain in self.kinematic_chains.values():
            if chain.end_effector:
                result.append(chain)
        return result

    def get_camera_frame(self) -> str:
        """
        Quick method to get the name of a link of a camera. Uses the first camera in the list of cameras.

        :return: A name of the link of a camera
        """
        return self.cameras[list(self.cameras.keys())[0]].link_name

    def get_default_camera(self) -> CameraDescription:
        """
        Returns the first camera in the list of cameras.

        :return: A CameraDescription object
        """
        return self.cameras[list(self.cameras.keys())[0]]

    def get_static_joint_chain(self, kinematic_chain_name: str, configuration_name: str):
        """
        Returns the static joint states of a kinematic chain for a specific configuration. When trying to access one of
        the robot arms the function `:func: get_arm_chain` should be used.

        :param kinematic_chain_name:
        :param configuration_name:
        :return:
        """
        if kinematic_chain_name in self.kinematic_chains.keys():
            if configuration_name in self.kinematic_chains[kinematic_chain_name].static_joint_states.keys():
                return self.kinematic_chains[kinematic_chain_name].static_joint_states[configuration_name]
            else:
                raise ValueError(
                    f"There is no static joint state with the name {configuration_name} for Kinematic chain {kinematic_chain_name} of robot {self.name}")
        else:
            raise ValueError(f"There is no KinematicChain with name {kinematic_chain_name} for robot {self.name}")

    def get_parent(self, name: str) -> str:
        """
        Returns the parent of a link or joint in the URDF. Always returns the imeadiate parent, for a link this is a joint
        and vice versa.

        :param name: Name of the link or joint in the URDF
        :return: Name of the parent link or joint
        """
        if name not in self.links and name not in self.joints:
            raise ValueError(f"Link or joint {name} not found in URDF")
        if name in self.links:
            if name in self.urdf_object.parent_map:
                parent_joint, parent_link = self.urdf_object.parent_map[name]
                return parent_joint
            else:
                raise ValueError(f"Link {name} has no parent")
        elif name in self.joints:
            parent_link = self.urdf_object.joint_map[name].parent
            return parent_link

    def get_child(self, name: str, return_multiple_children: bool = False) -> Union[str, List[str]]:
        """
        Returns the child of a link or joint in the URDF. Always returns the immediate child, for a link this is a joint
        and vice versa. Since a link can have multiple children, the return_multiple_children parameter can be set to
        True to get a list of all children.

        :param name: Name of the link or joint in the URDF
        :param return_multiple_children: If True, a list of all children is returned
        :return: Name of the child link or joint or a list of all children
        """
        if name not in self.links and name not in self.joints:
            raise ValueError(f"Link or joint {name} not found in URDF")
        if name in self.links:
            if name in self.urdf_object.child_map:
                children = self.urdf_object.child_map[name]
                # A link can have multiple children
                child_joints = [child[0] for child in children]
                if return_multiple_children:
                    child_joints.reverse()
                    return child_joints
                else:
                    return child_joints[0]

            else:
                raise ValueError(f"Link {name} has no children")
        elif name in self.joints:
            child_link = self.urdf_object.joint_map[name].child
            return child_link

    def get_arm_chain(self, arm: Arms) -> Union[KinematicChainDescription, List[KinematicChainDescription]]:
        """
        Returns the kinematic chain of a specific arm. If the arm is set to BOTH, all kinematic chains are returned.

        :param arm: Arm for which the chain should be returned
        :return: KinematicChainDescription object of the arm
        """
        if arm == Arms.BOTH:
            return list(filter(lambda chain: chain.arm_type is not None, self.kinematic_chains.values()))
        for chain in self.kinematic_chains.values():
            if chain.arm_type == arm:
                return chain
        raise ValueError(f"There is no Kinematic Chain for the Arm {arm}")


class KinematicChainDescription:
    """
    Represents a kinematic chain of a robot. A Kinematic chain is a chain of links and joints that are connected to each
    other and can be moved.

    This class contains all necessary information about the chain, like the start and end
    link, the URDF object and the joints of the chain.
    """

    name: str
    """
    Name of the chain
    """
    start_link: str
    """
    First link of the chain
    """
    end_link: str
    """
    Last link of the chain
    """
    urdf_object: URDF
    """
    Parsed URDF of the robot
    """
    include_fixed_joints: bool
    """
    If True, fixed joints are included in the chain
    """
    link_names: List[str]
    """
    List of all links in the chain
    """
    joint_names: List[str]
    """
    List of all joints in the chain
    """
    end_effector: EndEffectorDescription
    """
    End effector of the chain, if there is one
    """
    arm_type: Arms
    """
    Type of the arm, if the chain is an arm
    """
    static_joint_states: Dict[str, Dict[str, float]]
    """
    Dictionary of static joint states for the chain
    """

    def __init__(self, name: str, start_link: str, end_link: str, urdf_object: URDF, arm_type: Arms = None,
                 include_fixed_joints=False):
        """
        Initialize the KinematicChainDescription object.

        :param name: Name of the chain
        :param start_link: First link of the chain
        :param end_link: Last link of the chain
        :param urdf_object: URDF object of the robot which is used to get the chain
        :param arm_type: Type of the arm, if the chain is an arm
        :param include_fixed_joints: If True, fixed joints are included in the chain
        """
        self.name: str = name
        self.start_link: str = start_link
        self.end_link: str = end_link
        self.urdf_object: URDF = urdf_object
        self.include_fixed_joints: bool = include_fixed_joints
        self.link_names: List[str] = []
        self.joint_names: List[str] = []
        self.arm_type: Arms = arm_type
        self.static_joint_states: Dict[str, Dict[str, float]] = {}
        self.end_effector = None

        self._init_links()
        self._init_joints()

    def _init_links(self):
        """
        Initializes the links of the chain by getting the chain from the URDF object.
        """
        self.link_names = self.urdf_object.get_chain(self.start_link, self.end_link, joints=False)

    def _init_joints(self):
        """
        Initializes the joints of the chain by getting the chain from the URDF object.
        """
        joints = self.urdf_object.get_chain(self.start_link, self.end_link, links=False)
        self.joint_names = list(filter(lambda j: self.urdf_object.joint_map[j].type != "fixed" or self.include_fixed_joints, joints))

    def get_joints(self) -> List[str]:
        """
        Returns a list of all joints of the chain.

        :return: List of joint names
        """
        return self.joint_names

    def get_links(self) -> List[str]:
        """
        Returns a list of all links of the chain.

        :return: List of link names
        """
        return self.link_names

    @property
    def links(self) -> List[str]:
        """
        Property to get the links of the chain.

        :return: List of link names
        """
        return self.get_links()

    @property
    def joints(self) -> List[str]:
        """
        Property to get the joints of the chain.

        :return: List of joint names
        """
        return self.get_joints()

    def add_static_joint_states(self, name: str, states: dict):
        """
        Adds static joint states to the chain. These define a specific configuration of the chain.

        :param name: Name of the static joint states
        :param states: Dictionary of joint names and their values
        """
        for joint_name, value in states.items():
            if joint_name not in self.joint_names:
                raise ValueError(f"Joint {joint_name} is not part of the chain")
        self.static_joint_states[name] = states

    def get_static_joint_states(self, name: str) -> Dict[str, float]:
        """
        Returns the dictionary of static joint states for a given name of the static joint states.

        :param name: Name of the static joint states
        :return: Dictionary of joint names and their values
        """
        try:
            return self.static_joint_states[name]
        except KeyError:
            rospy.logerr(f"Static joint states for chain {name} not found")

    def get_tool_frame(self) -> str:
        """
        Returns the name of the tool frame of the end effector of this chain, if it has an end effector.

        :return: The name of the link of the tool frame in the URDF.
        """
        if self.end_effector:
            return self.end_effector.tool_frame
        else:
            raise ValueError(f"The Kinematic chain {self.name} has no end-effector")

    def get_static_gripper_state(self, state: GripperState) -> Dict[str, float]:
        """
        Returns the static joint states for the gripper of the chain.

        :param state: Name of the static joint states
        :return: Dictionary of joint names and their values
        """
        if self.end_effector:
            return self.end_effector.static_joint_states[state]
        else:
            raise ValueError(f"The Kinematic chain {self.name} has no end-effector")


class CameraDescription:
    """
    Represents a camera mounted on a robot. Contains all necessary information about the camera, like the link name,
    minimal and maximal height, horizontal and vertical angle and the front facing axis.
    """
    name: str
    """
    Name of the camera
    """
    link_name: str
    """
    Name of the link in the URDF
    """
    minimal_height: float
    """
    Minimal height the camera can be at
    """
    maximal_height: float
    """
    Maximal height the camera can be at
    """
    horizontal_angle: float
    """
    Horizontal opening angle of the camera
    """
    vertical_angle: float
    """
    Vertical opening angle of the camera
    """
    front_facing_axis: List[int]
    """
    Axis along which the camera is taking the image
    """

    def __init__(self, name: str, link_name: str, minimal_height: float, maximal_height: float,
                 horizontal_angle: float = 20, vertical_angle: float = 20, front_facing_axis: List[float] = None):
        """
        Initialize the CameraDescription object.

        :param name: Name of the camera
        :param link_name: Name of the link in the URDF
        :param minimal_height: Minimal height the camera can be at
        :param maximal_height: Maximal height the camera can be at
        :param horizontal_angle: Horizontal opening angle of the camera
        :param vertical_angle: Vertical opening angle of the camera
        :param front_facing_axis: Axis along which the camera taking the image
        """
        self.name: str = name
        self.link_name: str = link_name
        self.minimal_height: float = minimal_height
        self.maximal_height: float = maximal_height
        self.horizontal_angle: float = horizontal_angle
        self.vertical_angle: float = vertical_angle
        self.front_facing_axis: List[int] = front_facing_axis if front_facing_axis else [0, 0, 1]


class EndEffectorDescription:
    """
    Describes an end effector of robot. Contains all necessary information about the end effector, like the
    base link, the tool frame, the URDF object and the static joint states.
    """
    name: str
    """
    Name of the end effector
    """
    start_link: str
    """
    Root link of the end effector, every link below this link in the URDF is part of the end effector
    """
    tool_frame: str
    """
    Name of the tool frame link in the URDf
    """
    urdf_object: URDF
    """
    Parsed URDF of the robot
    """
    link_names: List[str]
    """
    List of all links in the end effector
    """
    joint_names: List[str]
    """
    List of all joints in the end effector
    """
    static_joint_states: Dict[GripperState, Dict[str, float]]
    """
    Dictionary of static joint states for the end effector
    """
    end_effector_type: GripperType
    """
    Type of the gripper
    """
    opening_distance: float
    """
    Distance the gripper can open, in cm
    """

    def __init__(self, name: str, start_link: str, tool_frame: str, urdf_object: URDF):
        """
        Initialize the EndEffectorDescription object.

        :param name: Name of the end effector
        :param start_link: Root link of the end effector, every link below this link in the URDF is part of the end effector
        :param tool_frame: Name of the tool frame link in the URDf
        :param urdf_object: URDF object of the robot
        """
        self.name: str = name
        self.start_link: str = start_link
        self.tool_frame: str = tool_frame
        self.urdf_object: URDF = urdf_object
        self.link_names: List[str] = []
        self.joint_names: List[str] = []
        self.static_joint_states: Dict[GripperState, Dict[str, float]] = {}
        self._init_links_joints()

    def _init_links_joints(self):
        """
        Traverses the URDF object to get all links and joints of the end effector below the start link.1
        """
        start_link_obj = self.urdf_object.link_map[self.start_link]
        links = [start_link_obj.name]
        while len(links) != 0:
            link = links.pop()
            self.link_names.append(link)
            if link not in self.urdf_object.child_map:
                continue
            else:
                children = self.urdf_object.child_map[link]
            for joint, link in children:
                self.joint_names.append(joint)
                links.insert(0, link)

    def add_static_joint_states(self, name: GripperState, states: dict):
        """
        Adds static joint states to the end effector. These define a specific configuration of the end effector. Like
        open and close configurations of a gripper.

        :param name: Name of the static joint states
        :param states: Dictionary of joint names and their values
        """
        for joint_name, value in states.items():
            if joint_name not in self.joint_names:
                raise ValueError(f"Joint {joint_name} is not part of the chain")
        self.static_joint_states[name] = states

    @property
    def links(self) -> List[str]:
        """
        Property to get the links of the chain.

        :return: List of link names
        """
        return self.link_names

    @property
    def joints(self) -> List[str]:
        """
        Property to get the joints of the chain.

        :return: List of joint names
        """
        return self.joint_names


##New # Content from: #<src/pycram/fluent.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import operator

from enum import Enum
from threading import Condition, Lock
from uuid import uuid4
from typing_extensions import Any, Optional, List, Callable


class Behavior(Enum):
    """Enumeration which can be passed as argument to the pulsed method of fluents to describe how to handle missed pulses in the whenever macro.

    Fields:
    NEVER -- ignore missed pulses.
    ONCE -- if pulses were missed, execute the body once more in total.
    ALWAYS -- if pulses were missed, execute the body once more for each.
    """
    NEVER = 1
    ONCE = 2
    ALWAYS = 3


class Fluent:
    """Implementation of fluents.

    Fluents are thread-safe proxy objects which are used as variables with changing value. This allows threads to
    observe them and wait for (specific) changes.
    One can also observe fluents created by the pulsed method of a fluent. These change their value from None to True
    whenever the parent gets pulsed (or changes its value and thus gets pulsed).

    Fluents can be combined to fluent networks which allows to express complex conditions. A network updates its value
    whenever one of the fluents it is constructed from changes its value.
    The most important comparison and math operators (<, <=, ==, !=, >, >=, +, -, *, /) are overloaded to construct a
    fluent network whenever they are called with at least one fluent as parameter. In addition the comparison operators
    IS and IS_NOT as well as the logical operators AND, OR and NOT are defined as methods. This is necessary because
    these operators can't be overloaded. Fluents constructed by comparison or logical operators have the value True or
    None instead of False, so that they can be used with the wait_for method because it blocks until a value is not None.
    User defined operators can be created by passing a function as the fluents value.
    """

    def __init__(self, value: Optional[Any] = None, name: str = None):
        """Create a new fluent.

        :param value:  the value of the fluent which can also be a function to create user defined operators (default is None).
        :param name: the name of the fluent (default is a random string).
        """
        self._cv: Condition = Condition()
        self._mutex: Lock = Lock()
        self._pulses: int = 0
        self._children: List[Fluent] = []
        self._handle_missed = Behavior.NEVER
        self._value: Any = value
        self._whenever_cbs = []

        if name is not None:
            self.name: str = name
        else:
            self.name: str = str(uuid4())

    def pulsed(self, handle_missed: Behavior = 2) -> Fluent:
        """Create a fluent which changes its value from None to True whenever the parent gets pulsed.

        :param handle_missed: see the docstring of the Behavior enumeration to find out more (default is Behavior.ONCE).
        """
        fluent = Fluent()

        def value():
            if fluent._pulses != 0:
                return True
            else:
                return None

        fluent.set_value(value)
        fluent._handle_missed = handle_missed
        self.add_child(fluent)
        return fluent

    def pulse(self) -> None:
        """Pulse a fluent without changing its value."""
        for child in self._children:
            with child._mutex:
                child._pulses += 1

            child.pulse()
        for callback in self._whenever_cbs:
            callback(self.get_value())
            with self._mutex:
                self._pulses -= 1
            if self._handle_missed == Behavior.NEVER:
                with self._mutex:
                    self._pulses = 0
            elif self._handle_missed == Behavior.ONCE:
                callback(self.get_value())
                with self._mutex:
                    self._pulses = 0
            elif self._handle_missed == Behavior.ALWAYS:
                with self._mutex:
                    for i in range(self._pulses):
                        callback(self.get_value())
        with self._cv:
            self._cv.notify()

    def whenever(self, callback: Callable) -> None:
        """
        Registers a callback which is called everytime this Fluent is pulsed. The callback should be a Callable. When
        the callback is called it gets the current value of this Fluent as an argument.

        :param callback: The callback which should be called when pulsed as a Callable.
        """
        self._whenever_cbs.append(callback)

    def add_child(self, child: Fluent) -> None:
        """Add a child to the fluent which gets pulsed whenever this fluent gets pulsed, too.

        :param child: the child to add.
        """
        self._children.append(child)

    def get_value(self) -> Any:
        """Return the value of the fluent."""
        with self._mutex:
            if callable(self._value):
                return self._value()

            return self._value

    def set_value(self, value: Any) -> None:
        """Change the value of the fluent.
        Changing the value will also pulse the fluent.

        :param value: the new value of the fluent.
        """
        with self._mutex:
            self._value = value

        self.pulse()

    def wait_for(self, timeout: Optional[float] = None):
        """Block the current thread if the value of the fluent is None, until it is not None or until it timed out.

        If the fluent was created by the pulsed method of a fluent, the method blocks until the parent gets pulsed.

        The return value is the last return value of the predicate (value is not None) and will evaluate to False if the method timed out.

        :param timeout: the maximum time to wait (default is None).
        """
        with self._cv:
            return self._cv.wait_for(lambda: self.get_value() is not None, timeout)

    def _compare(self, operator, other: Fluent) -> Fluent:
        """This is a helper method for internal usage only.

        Create a fluent which value is a function returning True or None depending on the given comparison operator applied to the operands.

        :param operator: the comparison operator to apply.
        :param other: the other operand.
        """
        fluent = Fluent()

        if type(other) == Fluent:
            def value():
                if operator(self.get_value(), other.get_value()):
                    return True
                else:
                    return None

            other.add_child(fluent)
        else:
            def value():
                if operator(self.get_value(), other):
                    return True
                else:
                    return None

        self.add_child(fluent)
        fluent.set_value(value)
        return fluent

    def __lt__(self, other: Fluent) -> Fluent:
        """Overload the < comparsion operator.

        :param other: -- the other operand.
        """
        return self._compare(operator.lt, other)

    def __leq__(self, other: Fluent) -> Fluent:
        """Overload the <= comparsion operator.

        :param other: the other operand.
        """
        return self._compare(operator.leq, other)

    def __eq__(self, other: Fluent) -> Fluent:
        """Overload the == comparsion operator.

        :param other: the other operand.
        """
        return self._compare(operator.eq, other)

    def __ne__(self, other: Fluent) -> Fluent:
        """Overload the != comparsion operator.

        :param other: the other operand.
        """
        return self._compare(operator.ne, other)

    def IS(self, other: Fluent) -> Fluent:
        """Create a fluent which value is True if the value of its parent is the value of the given operand, None otherwise.

        :param other: -- the other operand which can also be a fluent.
        """
        return self._compare(operator.is_, other)

    def IS_NOT(self, other: Fluent) -> Fluent:
        """Create a fluent which value is True if the value of its parent is not the value of the given operand, None otherwise.

        :param other: -- the other operand which can also be a fluent.
        """
        return self._compare(operator.is_not, other)

    def __gt__(self, other: Fluent) -> Fluent:
        """Overload the > comparison operator.

        :param other: the other operand.
        """
        return self._compare(operator.gt, other)

    def __geq__(self, other: Fluent) -> Fluent:
        """Overload the >= comparison operator.

        :param other: the other operand.
        """
        return self._compare(operator.geq, other)

    def _math(self, operator: Callable, operand: Fluent, other: Fluent) -> Fluent:
        """This is a helper method for internal usage only.

        Create a fluent which value is a function returning the value of the given math operator applied to the operands.

        :param operator: the math operator to apply.
        :param operand: the first operand.
        :param other: the other operand.
        """
        fluent = Fluent()

        if type(operand) == Fluent:
            if type(other) == Fluent:
                value = lambda: operator(operand.get_value(), other.get_value())
                other.add_child(fluent)
            else:
                value = lambda: operator(operand.get_value(), other)

            operand.add_child(fluent)
        else:
            value = lambda: operator(operand, other.get_value())
            other.add_child(fluent)

        fluent.set_value(value)
        return fluent

    def __add__(self, other: Fluent) -> Fluent:
        """Overload the + math operator.

        :parm other: the other operand.
        """
        return self._math(operator.add, self, other)

    def __radd__(self, other: Fluent) -> Fluent:
        """Overload the + math operator with the first operand not being a fluent.

        :param other: the other operand.
        """
        return self._math(operator.add, other, self)

    def __sub__(self, other: Fluent) -> Fluent:
        """Overload the - math operator.

        :param other: the other operand.
        """
        return self._math(operator.sub, self, other)

    def __rsub__(self, other: Fluent) -> Fluent:
        """Overload the - math operator with the first operand not being a fluent.

        :param other: the other operand.
        """
        return self._math(operator.sub, other, self)

    def __mul__(self, other: Fluent) -> Fluent:
        """Overload the * math operator.

        :param other: the other operand.
        """
        return self._math(operator.mul, self, other)

    def __rmul__(self, other: Fluent) -> Fluent:
        """Overload the * math operator with the first operand not being a fluent.

        :param other: the other operand.
        """
        return self._math(operator.mul, other, self)

    def __truediv__(self, other: Fluent) -> Fluent:
        """Overload the / math operator.

        :param other: the other operand.
        """
        return self._math(operator.truediv, self, other)

    def __rtruediv__(self, other) -> Fluent:
        """Overload the / math operator with the first operand not being a fluent.

        :param other: the other operand.
        """
        return self._math(operator.truediv, other, self)

    def AND(self, other: Fluent) -> Fluent:
        """Create a fluent which value is True if both, the value of its parent and the other operand express True, None otherwise.

        :param other: the other operand which can also be a fluent.
        """
        fluent = Fluent()

        if type(other) == Fluent:
            def value():
                if self.get_value() and other.get_value():
                    return True
                else:
                    return None

            other.add_child(fluent)
        else:
            def value():
                if self.get_value() and other:
                    return True
                else:
                    return None

        self.add_child(fluent)
        fluent.set_value(value)
        return fluent

    def OR(self, other: Fluent) -> Fluent:
        """Create a fluent which value is True if either the value of its parent or the other operand express True, None otherwise.

        :param other: the other operand which can also be a fluent.
        """
        fluent = Fluent()

        if type(other) == Fluent:
            def value():
                if self.get_value() or other.get_value():
                    return True
                else:
                    return None

            other.add_child(fluent)
        else:
            def value():
                if self.get_value() or other:
                    return True
                else:
                    return None

        self.add_child(fluent)
        fluent.set_value(value)
        return fluent

    def NOT(self) -> Fluent:
        """Create a fluent which value is True if the value of its parent expresses False, None otherwise."""
        def value():
            if not self.get_value():
                return True
            else:
                return None

        fluent = Fluent(value)
        self.add_child(fluent)
        return fluent


##New # Content from: #<src/pycram/failure_handling.py>#
from .datastructures.enums import State
from .designator import DesignatorDescription
from .plan_failures import PlanFailure
from threading import Lock
from typing_extensions import Union, Tuple, Any, List
from .language import Language, Monitor


class FailureHandling(Language):
    """
    Base class for failure handling mechanisms in automated systems or workflows.

    This class provides a structure for implementing different strategies to handle
    failures that may occur during the execution of a plan or process. It is designed
    to be extended by subclasses that implement specific failure handling behaviors.
    """

    def __init__(self, designator_description: Union[DesignatorDescription, Monitor]):
        """
        Initializes a new instance of the FailureHandling class.

        :param Union[DesignatorDescription, Monitor] designator_description: The description or context of the task
        or process for which the failure handling is being set up.
        """
        self.designator_description = designator_description

    def perform(self):
        """
        Abstract method to perform the failure handling mechanism.

        This method should be overridden in subclasses to implement the specific
        behavior for handling failures.

        :raises NotImplementedError: If the method is not implemented in a subclass.
        """
        raise NotImplementedError()


class Retry(FailureHandling):
    """
    A subclass of FailureHandling that implements a retry mechanism.

    This class represents a specific failure handling strategy where the system
    attempts to retry a failed action a certain number of times before giving up.
    """
    max_tries: int
    """
    The maximum number of attempts to retry the action.
    """

    def __init__(self, designator_description: DesignatorDescription, max_tries: int = 3):
        """
        Initializes a new instance of the Retry class.

        :param designator_description: The description or context of the task or process for which the retry mechanism is being set up.
        :param max_tries: The maximum number of attempts to retry. Defaults to 3.
        """
        super().__init__(designator_description)
        self.max_tries = max_tries

    def perform(self) -> Tuple[State, List[Any]]:
        """
        Implementation of the retry mechanism.

        This method attempts to perform the action specified in the designator_description.
        If the action fails, it is retried up to max_tries times. If all attempts fail,
        the last exception is raised.

        :raises PlanFailure: If all retry attempts fail.
        """
        tries = 0
        for action in iter(self.designator_description):
            tries += 1
            try:
                action.perform()
                break
            except PlanFailure as e:
                if tries >= self.max_tries:
                    raise e


class RetryMonitor(FailureHandling):
    """
    A subclass of FailureHandling that implements a retry mechanism that works with a Monitor.

    This class represents a specific failure handling strategy that allows us to retry a demo that is
    being monitored, in case that monitoring condition is triggered.
    """
    max_tries: int
    """
    The maximum number of attempts to retry the action.
    """
    recovery: dict
    """
    A dictionary that maps exception types to recovery actions
    """

    def __init__(self, designator_description: Monitor, max_tries: int = 3, recovery: dict = None):
        """
        Initializes a new instance of the RetryMonitor class.
        :param Monitor designator_description: The Monitor instance to be used.
        :param int max_tries: The maximum number of attempts to retry. Defaults to 3.
        :param dict recovery: A dictionary that maps exception types to recovery actions. Defaults to None.
        """
        super().__init__(designator_description)
        self.max_tries = max_tries
        self.lock = Lock()
        if recovery is None:
            self.recovery = {}
        else:
            if not isinstance(recovery, dict):
                raise ValueError(
                    "Recovery must be a dictionary with exception types as keys and Language instances as values.")
            for key, value in recovery.items():
                if not issubclass(key, BaseException):
                    raise TypeError("Keys in the recovery dictionary must be exception types.")
                if not isinstance(value, Language):
                    raise TypeError("Values in the recovery dictionary must be instances of the Language class.")
            self.recovery = recovery

    def perform(self) -> Tuple[State, List[Any]]:
        """
        This method attempts to perform the Monitor + plan specified in the designator_description. If the action
        fails, it is retried up to max_tries times. If all attempts fail, the last exception is raised. In every
        loop, we need to clear the kill_event, and set all relevant 'interrupted' variables to False, to make sure
        the Monitor and plan are executed properly again.

        :raises PlanFailure: If all retry attempts fail.

        :return: The state of the execution performed, as well as a flattened list of the
        results, in the correct order
        """

        def reset_interrupted(child):
            child.interrupted = False
            try:
                for sub_child in child.children:
                    reset_interrupted(sub_child)
            except AttributeError:
                pass

        def flatten(result):
            flattened_list = []
            if result:
                for item in result:
                    if isinstance(item, list):
                        flattened_list.extend(item)
                    else:
                        flattened_list.append(item)
                return flattened_list
            return None

        status, res = None, None
        with self.lock:
            tries = 0
            while True:
                self.designator_description.kill_event.clear()
                self.designator_description.interrupted = False
                for child in self.designator_description.children:
                    reset_interrupted(child)
                try:
                    status, res = self.designator_description.perform()
                    break
                except PlanFailure as e:
                    tries += 1
                    if tries >= self.max_tries:
                        raise e
                    exception_type = type(e)
                    if exception_type in self.recovery:
                        self.recovery[exception_type].perform()
        return status, flatten(res)


##New # Content from: #<src/pycram/pose_generator_and_validator.py>#
import tf
import numpy as np

from .datastructures.world import World
from .world_concepts.world_object import Object
from .world_reasoning import contact
from .costmaps import Costmap
from .local_transformer import LocalTransformer
from .datastructures.pose import Pose, Transform
from .robot_description import RobotDescription
from .external_interfaces.ik import request_ik
from .plan_failures import IKError
from .utils import _apply_ik
from typing_extensions import Tuple, List, Union, Dict, Iterable


class PoseGenerator:
    """
    Crates pose candidates from a given costmap. The generator
    selects the highest values, amount is given by number_of_sample, and returns the corresponding positions.
    Orientations are calculated such that the Robot faces the center of the costmap.
    """

    current_orientation_generator = None
    """
    If no orientation generator is given, this generator is used to generate the orientation of the robot.
    """
    override_orientation_generator = None
    """
    Override the orientation generator with a custom generator, which will be used regardless of the current_orientation_generator.
    """

    def __init__(self, costmap: Costmap, number_of_samples=100, orientation_generator=None):
        """
        :param costmap: The costmap from which poses should be sampled.
        :param number_of_samples: The number of samples from the costmap that should be returned at max
        :param orientation_generator: function that generates an orientation given a position and the origin of the costmap
        """

        if not PoseGenerator.current_orientation_generator:
            PoseGenerator.current_orientation_generator = PoseGenerator.generate_orientation

        self.costmap = costmap
        self.number_of_samples = number_of_samples
        self.orientation_generator = orientation_generator if orientation_generator else PoseGenerator.current_orientation_generator
        if PoseGenerator.override_orientation_generator:
            self.orientation_generator = PoseGenerator.override_orientation_generator

    def __iter__(self) -> Iterable:
        """
        A generator that crates pose candidates from a given costmap. The generator
        selects the highest 100 values and returns the corresponding positions.
        Orientations are calculated such that the Robot faces the center of the costmap.

        :Yield: A tuple of position and orientation
        """

        # Determines how many positions should be sampled from the costmap
        if self.number_of_samples == -1:
            self.number_of_samples = self.costmap.map.flatten().shape[0]
        indices = np.argpartition(self.costmap.map.flatten(), -self.number_of_samples)[-self.number_of_samples:]
        indices = np.dstack(np.unravel_index(indices, self.costmap.map.shape)).reshape(self.number_of_samples, 2)

        height = self.costmap.map.shape[0]
        width = self.costmap.map.shape[1]
        center = np.array([height // 2, width // 2])
        for ind in indices:
            if self.costmap.map[ind[0]][ind[1]] == 0:
                continue
            # The position is calculated by creating a vector from the 2D position in the costmap (given by x and y)
            # and the center of the costmap (since this is the origin). This vector is then turned into a transformation
            # and muiltiplied with the transformation of the origin.
            vector_to_origin = (center - ind) * self.costmap.resolution
            point_to_origin = Transform([*vector_to_origin, 0], frame="point", child_frame="origin")
            origin_to_map = self.costmap.origin.to_transform("origin").invert()
            point_to_map = point_to_origin * origin_to_map
            map_to_point = point_to_map.invert()

            orientation = self.orientation_generator(map_to_point.translation_as_list(), self.costmap.origin)
            yield Pose(map_to_point.translation_as_list(), orientation)

    @staticmethod
    def height_generator() -> float:
        pass

    @staticmethod
    def generate_orientation(position: List[float], origin: Pose) -> List[float]:
        """
        This method generates the orientation for a given position in a costmap. The
        orientation is calculated such that the robot faces the origin of the costmap.
        This generation is done by simply calculating the arctan between the position,
        in the costmap, and the origin of the costmap.

        :param position: The position in the costmap. This position is already converted to the world coordinate frame.
        :param origin: The origin of the costmap. This is also the point which the robot should face.
        :return: A quaternion of the calculated orientation
        """
        angle = np.arctan2(position[1] - origin.position.y, position[0] - origin.position.x) + np.pi
        quaternion = list(tf.transformations.quaternion_from_euler(0, 0, angle, axes="sxyz"))
        return quaternion


def visibility_validator(pose: Pose,
                         robot: Object,
                         object_or_pose: Union[Object, Pose],
                         world: World) -> bool:
    """
    This method validates if the robot can see the target position from a given
    pose candidate. The target position can either be a position, in world coordinate
    system, or an object in the World. The validation is done by shooting a
    ray from the camera to the target position and checking that it does not collide
    with anything else.

    :param pose: The pose candidate that should be validated
    :param robot: The robot object for which this should be validated
    :param object_or_pose: The target position or object for which the pose candidate should be validated.
    :param world: The World instance in which this should be validated.
    :return: True if the target is visible for the robot, None in any other case.
    """
    robot_pose = robot.get_pose()
    if isinstance(object_or_pose, Object):
        robot.set_pose(pose)
        camera_pose = robot.get_link_pose(RobotDescription.current_robot_description.get_camera_frame())
        robot.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))
        ray = world.ray_test(camera_pose.position_as_list(), object_or_pose.get_position_as_list())
        res = ray == object_or_pose.id
    else:
        robot.set_pose(pose)
        camera_pose = robot.get_link_pose(RobotDescription.current_robot_description.get_camera_frame())
        robot.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))
        # TODO: Check if this is correct
        ray = world.ray_test(camera_pose.position_as_list(), object_or_pose)
        res = ray == -1
    robot.set_pose(robot_pose)
    return res


def _in_contact(robot: Object, obj: Object, allowed_collision: Dict[Object, List[str]],
                allowed_robot_links: List[str]) -> bool:
    """
    This method checks if a given robot is in contact with a given object.

    :param robot: The robot object that should be checked for contact.
    :param obj: The object that should be checked for contact with the robot.
    :param allowed_collision: A dictionary that contains the allowed collisions for links of each object in the world.
    :param allowed_robot_links: A list of links of the robot that are allowed to be in contact with the object.
    :return: True if the robot is in contact with the object and False otherwise.
    """
    in_contact, contact_links = contact(robot, obj, return_links=True)
    allowed_links = allowed_collision[obj] if obj in allowed_collision.keys() else []

    if in_contact:
        for link in contact_links:
            if link[0].name in allowed_robot_links or link[1].name in allowed_links:
                in_contact = False
                # TODO: in_contact is never set to True after it was set to False is that correct?
                # TODO: If it is correct, then this loop should break after the first contact is found
    return in_contact


def reachability_validator(pose: Pose,
                           robot: Object,
                           target: Union[Object, Pose],
                           allowed_collision: Dict[Object, List] = None) -> Tuple[bool, List]:
    """
    This method validates if a target position is reachable for a pose candidate.
    This is done by asking the ik solver if there is a valid solution if the
    robot stands at the position of the pose candidate. if there is a solution
    the validator returns True and False in any other case.

    :param pose: The pose candidate for which the reachability should be validated
    :param robot: The robot object in the World for which the reachability should be validated.
    :param target: The target position or object instance which should be the target for reachability.
    :param allowed_collision: dict of objects with which the robot is allowed to collide each object correlates to a list of links of which this object consists
    :return: True if the target is reachable for the robot and False in any other case.
    """
    if type(target) == Object:
        target = target.get_pose()

    robot.set_pose(pose)
    # manipulator_descs = list(
    #    filter(lambda chain: isinstance(chain[1], ManipulatorDescription), robot_description.chains.items()))
    manipulator_descs = RobotDescription.current_robot_description.get_manipulator_chains()

    # TODO Make orientation adhere to grasping orientation
    res = False
    arms = []
    for description in manipulator_descs:
        retract_target_pose = LocalTransformer().transform_pose(target, robot.get_link_tf_frame(description.end_effector.tool_frame))
        retract_target_pose.position.x -= 0.07  # Care hard coded value copied from PlaceAction class

        # retract_pose needs to be in world frame?
        retract_target_pose = LocalTransformer().transform_pose(retract_target_pose, "map")

        joints = description.joints
        tool_frame = description.end_effector.tool_frame

        # TODO Make orientation adhere to grasping orientation
        in_contact = False

        joint_state_before_ik = robot.get_positions_of_all_joints()
        try:
            # test the possible solution and apply it to the robot
            pose, joint_states = request_ik(target, robot, joints, tool_frame)
            robot.set_pose(pose)
            robot.set_joint_positions(joint_states)
            # _apply_ik(robot, resp, joints)

            in_contact = collision_check(robot, allowed_collision)
            if not in_contact:  # only check for retract pose if pose worked
                pose, joint_states = request_ik(retract_target_pose, robot, joints, tool_frame)
                robot.set_pose(pose)
                robot.set_joint_positions(joint_states)
                # _apply_ik(robot, resp, joints)
                in_contact = collision_check(robot, allowed_collision)
            if not in_contact:
                arms.append(description.arm_type)
        except IKError:
            pass
        finally:
            robot.set_joint_positions(joint_state_before_ik)
    if arms:
        res = True
    return res, arms


def collision_check(robot: Object, allowed_collision: Dict[Object, List]):
    """
    This method checks if a given robot collides with any object within the world
    which it is not allowed to collide with.
    This is done checking iterating over every object within the world and checking
    if the robot collides with it. Careful the floor will be ignored.
    If there is a collision with an object that was not within the allowed collision
    list the function returns True else it will return False

    :param robot: The robot object in the (Bullet)World where it should be checked if it collides with something
    :param allowed_collision: dict of objects with which the robot is allowed to collide each object correlates to a list of links of which this object consists
    :return: True if the target is reachable for the robot and False in any other case.
    """
    in_contact = False
    allowed_robot_links = []
    if robot in allowed_collision.keys():
        allowed_robot_links = allowed_collision[robot]

    for obj in World.current_world.objects:
        if obj.name == "floor":
            continue
        in_contact= _in_contact(robot, obj, allowed_collision, allowed_robot_links)

    return in_contact




##New # Content from: #<src/pycram/process_module.py>#
"""Implementation of process modules.

Classes:
ProcessModule -- implementation of process modules.
"""
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations
import inspect
import threading
import time
from abc import ABC
from typing_extensions import Callable, Type, Any, Union

import rospy

from .language import Language
from .robot_description import RobotDescription
from typing_extensions import TYPE_CHECKING
from .datastructures.enums import ExecutionType

if TYPE_CHECKING:
    from .designators.motion_designator import BaseMotion


class ProcessModule:
    """
    Implementation of process modules. Process modules are the part that communicate with the outer world to execute
     designators.
    """
    execution_delay = False
    """
    Adds a delay of 0.5 seconds after executing a process module, to make the execution in simulation more realistic
    """
    block_list = []
    """
    List of thread ids for which no Process Modules should be executed. This is used as an interrupt mechanism for 
    Designators
    """

    def __init__(self, lock):
        """Create a new process module."""
        self._lock = lock

    def _execute(self, designator: BaseMotion) -> Any:
        """
        Helper method for internal usage only.
        This method is to be overwritten instead of the execute method.
        """
        pass

    def execute(self, designator: BaseMotion) -> Any:
        """
        Execute the given designator. If there is already another process module of the same kind the `self._lock` will
        lock this thread until the execution of that process module is finished. This implicitly queues the execution of
        process modules.

        :param designator: The designator to execute.
        :return: Return of the Process Module if there is any
        """
        if threading.get_ident() in Language.block_list:
            return None
        with self._lock:
            ret = self._execute(designator)
            if ProcessModule.execution_delay:
                time.sleep(0.5)

        return ret


class RealRobot:
    """
    Management class for executing designators on the real robot. This is intended to be used in a with environment.
    When importing this class an instance is imported instead.

    Example:

    .. code-block:: python

        with real_robot:
            some designators
    """

    def __init__(self):
        self.pre: str = ""
        self.pre_delay: bool = False

    def __enter__(self):
        """
        Entering function for 'with' scope, saves the previously set :py:attr:`~ProcessModuleManager.execution_type` and
        sets it to 'real'
        """
        self.pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = ExecutionType.REAL
        self.pre_delay = ProcessModule.execution_delay
        ProcessModule.execution_delay = False

    def __exit__(self, _type, value, traceback):
        """
        Exit method for the 'with' scope, sets the :py:attr:`~ProcessModuleManager.execution_type` to the previously
        used one.
        """
        ProcessModuleManager.execution_type = self.pre
        ProcessModule.execution_delay = self.pre_delay

    def __call__(self):
        return self


class SimulatedRobot:
    """
    Management class for executing designators on the simulated robot. This is intended to be used in
    a with environment. When importing this class an instance is imported instead.

    Example:

    .. code-block:: python

        with simulated_robot:
            some designators
    """

    def __init__(self):
        self.pre: str = ""

    def __enter__(self):
        """
        Entering function for 'with' scope, saves the previously set :py:attr:`~ProcessModuleManager.execution_type` and
        sets it to 'simulated'
        """
        self.pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = ExecutionType.SIMULATED

    def __exit__(self, _type, value, traceback):
        """
        Exit method for the 'with' scope, sets the :py:attr:`~ProcessModuleManager.execution_type` to the previously
        used one.
        """
        ProcessModuleManager.execution_type = self.pre

    def __call__(self):
        return self


class SemiRealRobot:
    """
    Management class for executing designators on the semi-real robot. This is intended to be used in a with environment.
    When importing this class an instance is imported instead.

    Example:

    .. code-block:: python

        with semi_real_robot:
            some designators
    """

    def __init__(self):
        self.pre: str = ""

    def __enter__(self):
        """
        Entering function for 'with' scope, saves the previously set :py:attr:`~ProcessModuleManager.execution_type` and
        sets it to 'semi_real'
        """
        self.pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = ExecutionType.SEMI_REAL

    def __exit__(self, type, value, traceback):
        """
        Exit method for the 'with' scope, sets the :py:attr:`~ProcessModuleManager.execution_type` to the previously
        used one.
        """
        ProcessModuleManager.execution_type = self.pre

    def __call__(self):
        return self


def with_real_robot(func: Callable) -> Callable:
    """
    Decorator to execute designators in the decorated class on the real robot.

    Example:

    .. code-block:: python

        @with_real_robot
        def plan():
            some designators

    :param func: Function this decorator is annotating
    :return: The decorated function wrapped into the decorator
    """

    def wrapper(*args, **kwargs):
        pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = ExecutionType.REAL
        ret = func(*args, **kwargs)
        ProcessModuleManager.execution_type = pre
        return ret

    return wrapper


def with_simulated_robot(func: Callable) -> Callable:
    """
    Decorator to execute designators in the decorated class on the simulated robot.

    Example:

    .. code-block:: python

        @with_simulated_robot
        def plan():
            some designators

    :param func: Function this decorator is annotating
    :return: The decorated function wrapped into the decorator
    """

    def wrapper(*args, **kwargs):
        pre = ProcessModuleManager.execution_type
        ProcessModuleManager.execution_type = ExecutionType.Simulated
        ret = func(*args, **kwargs)
        ProcessModuleManager.execution_type = pre
        return ret

    return wrapper


# These are imported, so they don't have to be initialized when executing with
simulated_robot = SimulatedRobot()
real_robot = RealRobot()
semi_real_robot = SemiRealRobot()


class ProcessModuleManager(ABC):
    """
    Base class for managing process modules, any new process modules have to implement this class to register the
    Process Modules
    """
    execution_type = None
    """
    Whether the robot for which the process module is intended for is real or a simulated one
    """
    available_pms = []
    """
    List of all available Process Module Managers
    """
    _instance = None
    """
    Singelton instance of this Process Module Manager
    """

    def __new__(cls, *args, **kwargs):
        """
        Creates a new instance if :py:attr:`~ProcessModuleManager._instance` is None, otherwise the instance
        in :py:attr:`~ProcessModuleManager._instance` is returned.
        :return: Singelton instance of this Process Module Manager
        """
        if not cls._instance:
            cls._instance = super(ProcessModuleManager, cls).__new__(cls)
            return cls._instance
        else:
            return cls._instance

    def __init__(self, robot_name):
        """
        Registers the Process modules for this robot. The name of the robot has to match the name given in the robot
        description.

        :param robot_name: Name of the robot for which these Process Modules are intended
        """
        self.robot_name = robot_name
        ProcessModuleManager.available_pms.append(self)

    @staticmethod
    def get_manager() -> Union[ProcessModuleManager, None]:
        """
        Returns the Process Module manager for the currently loaded robot or None if there is no Manager.

        :return: ProcessModuleManager instance of the current robot
        """
        manager = None
        _default_manager = None
        if not ProcessModuleManager.execution_type:
            rospy.logerr(
                f"No execution_type is set, did you use the with_simulated_robot or with_real_robot decorator?")
            return

        for pm_manager in ProcessModuleManager.available_pms:
            if pm_manager.robot_name == RobotDescription.current_robot_description.name:
                manager = pm_manager
            if pm_manager.robot_name == "default":
                _default_manager = pm_manager

        if manager:
            return manager
        elif _default_manager:
            rospy.logwarn_once(f"No Process Module Manager found for robot: '{RobotDescription.current_robot_description.name}'"
                               f", using default process modules")
            return _default_manager
        else:
            rospy.logerr(f"No Process Module Manager found for robot: '{RobotDescription.current_robot_description.name}'"
                         f", and no default process modules available")
            return None

    def navigate(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for navigating the robot with respect to
         the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for navigating
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def pick_up(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for picking up with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for picking up an object
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def place(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for placing with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for placing an Object
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def looking(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for looking at a point with respect to
         the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for looking at a specific point
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def detecting(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for detecting an object with respect to
         the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for detecting an object
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def move_tcp(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for moving the Tool Center Point with respect to
         the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for moving the TCP
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def move_arm_joints(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for moving the joints of the robot arm
        with respect to the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for moving the arm joints
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def world_state_detecting(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for detecting an object using the world state with respect to the
        :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for world state detecting
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def move_joints(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for moving any joint of the robot with respect to the
        :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for moving joints
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def move_gripper(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for moving the gripper with respect to
         the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for moving the gripper
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def open(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for opening drawers with respect to
         the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for opening drawers
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")

    def close(self) -> Type[ProcessModule]:
        """
        Returns the Process Module for closing drawers with respect to
         the :py:attr:`~ProcessModuleManager.execution_type`

        :return: The Process Module for closing drawers
        """
        raise NotImplementedError(
            f"There are no Process Modules for '{inspect.currentframe().f_code.co_name}' for robot '{self.robot_name}'")


##New # Content from: #<src/pycram/helper.py>#
"""Implementation of helper functions and classes for internal usage only.

Classes:
Singleton -- implementation of singleton metaclass
"""
class Singleton(type):
    """
    Metaclass for singletons
    """

    _instances = {}
    """
    Dictionary of singleton child classes inheriting from this metaclass, keyed by child class objects.
    """

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

##New # Content from: #<src/pycram/cache_manager.py>#
import glob
import os
import pathlib

from typing_extensions import List, TYPE_CHECKING

if TYPE_CHECKING:
    from .description import ObjectDescription


class CacheManager:

    """
    The CacheManager is responsible for caching object description files and managing the cache directory.
    """

    mesh_extensions: List[str] = [".obj", ".stl"]
    """
    The file extensions of mesh files.
    """

    def __init__(self, cache_dir: str, data_directory: List[str]):
        """
        Initializes the CacheManager.

        :param cache_dir: The directory where the cached files are stored.
        :param data_directory: The directory where all resource files are stored.
        """
        self.cache_dir = cache_dir
        self.data_directory = data_directory

    def update_cache_dir_with_object(self, path: str, ignore_cached_files: bool,
                                     object_description: 'ObjectDescription', object_name: str) -> str:
        """
        Checks if the file is already in the cache directory, if not it will be preprocessed and saved in the cache.

        :param path: The path of the file to preprocess and save in the cache directory.
        :param ignore_cached_files: If True, the file will be preprocessed and saved in the cache directory even if it
         is already cached.
        :param object_description: The object description of the file.
        :param object_name: The name of the object.
        """
        path_object = pathlib.Path(path)
        extension = path_object.suffix

        self.create_cache_dir_if_not_exists()

        # save correct path in case the file is already in the cache directory
        cache_path = self.cache_dir + object_description.get_file_name(path_object, extension, object_name)

        if not self.is_cached(path, object_description) or ignore_cached_files:
            # if file is not yet cached preprocess the description file and save it in the cache directory.
            path = self.look_for_file_in_data_dir(path_object)
            self.generate_description_and_write_to_cache(path, object_name, extension, cache_path, object_description)

        return cache_path

    def generate_description_and_write_to_cache(self, path: str, name: str, extension: str, cache_path: str,
                                                object_description: 'ObjectDescription') -> None:
        """
        Generates the description from the file at the given path and writes it to the cache directory.

        :param path: The path of the file to preprocess.
        :param name: The name of the object.
        :param extension: The file extension of the file to preprocess.
        :param cache_path: The path of the file in the cache directory.
        :param object_description: The object description of the file.
        """
        description_string = object_description.generate_description_from_file(path, name, extension)
        self.write_to_cache(description_string, cache_path)

    @staticmethod
    def write_to_cache(description_string: str, cache_path: str) -> None:
        """
        Writes the description string to the cache directory.

        :param description_string: The description string to write to the cache directory.
        :param cache_path: The path of the file in the cache directory.
        """
        with open(cache_path, "w") as file:
            file.write(description_string)

    def look_for_file_in_data_dir(self, path_object: pathlib.Path) -> str:
        """
        Looks for a file in the data directory of the World. If the file is not found in the data directory, this method
        raises a FileNotFoundError.

        :param path_object: The pathlib object of the file to look for.
        """
        name = path_object.name
        for data_dir in self.data_directory:
            data_path = pathlib.Path(data_dir).joinpath("**")
            for file in glob.glob(str(data_path), recursive=True):
                file_path = pathlib.Path(file)
                if file_path.name == name:
                    print(f"Found file {name} in {file_path}")
                    return str(file_path)

        raise FileNotFoundError(
            f"File {name} could not be found in the resource directory {self.data_directory}")

    def create_cache_dir_if_not_exists(self):
        """
        Creates the cache directory if it does not exist.
        """
        if not pathlib.Path(self.cache_dir).exists():
            os.mkdir(self.cache_dir)

    def is_cached(self, path: str, object_description: 'ObjectDescription') -> bool:
        """
        Checks if the file in the given path is already cached or if
        there is already a cached file with the given name, this is the case if a .stl, .obj file or a description from
        the parameter server is used.

        :param path: The path of the file to check.
        :param object_description: The object description of the file.
        :return: True if there already exists a cached file, False in any other case.
        """
        return True if self.check_with_extension(path) else self.check_without_extension(path, object_description)

    def check_with_extension(self, path: str) -> bool:
        """
        Checks if the file in the given ath exists in the cache directory including file extension.

        :param path: The path of the file to check.
        """
        file_name = pathlib.Path(path).name
        full_path = pathlib.Path(self.cache_dir + file_name)
        return full_path.exists()

    def check_without_extension(self, path: str, object_description: 'ObjectDescription') -> bool:
        """
        Checks if the file in the given path exists in the cache directory without file extension,
        the extension is added after the file name manually in this case.

        :param path: The path of the file to check.
        :param object_description: The object description of the file.
        """
        file_stem = pathlib.Path(path).stem
        full_path = pathlib.Path(self.cache_dir + file_stem + object_description.get_file_extension())
        return full_path.exists()


##New # Content from: #<src/pycram/language.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

from queue import Queue
import rospy
from typing_extensions import Iterable, Optional, Callable, Dict, Any, List, Union, Tuple
from anytree import NodeMixin, Node, PreOrderIter

from pycram.datastructures.enums import State
import threading

from .fluent import Fluent
from .plan_failures import PlanFailure, NotALanguageExpression
from .external_interfaces import giskard


class Language(NodeMixin):
    """
    Parent class for language expressions. Implements the operators as well as methods to reduce the resulting language
    tree.
    """
    parallel_blocklist = ["PickUpAction", "PlaceAction", "OpenAction", "CloseAction", "TransportAction", "GraspingAction"]
    do_not_use_giskard = ["SetGripperAction", "MoveGripperMotion", "DetectAction", "DetectingMotion"]
    block_list: List[int] = []
    """List of thread ids which should be blocked from execution."""

    def __init__(self, parent: NodeMixin = None, children: Iterable[NodeMixin] = None):
        """
        Default constructor for anytree nodes. If the parent is none this is the root node.

        :param parent: The parent node of this node
        :param children: All children of this node as a tuple oder iterable
        """
        self.parent = parent
        self.exceptions = {}
        self.state = None
        self.executing_thread = {}
        self.threads: List[threading.Thread] = []
        self.interrupted = False
        self.name = self.__class__.__name__
        if children:
            self.children: Language = children

    def resolve(self) -> Language:
        """
        Dummy method for compatability to designator descriptions

        :return: self reference
        """
        return self

    def perform(self):
        """
        This method should be overwritten in subclasses and implement the behaviour of the language expression regarding
        each child.
        """
        raise NotImplementedError

    def __add__(self, other: Language) -> Sequential:
        """
        Language expression for sequential execution.

        :param other: Another Language expression, either a designator or language expression
        :return: A :func:`~Sequential` object which is the new root node of the language tree
        """
        if not issubclass(other.__class__, Language):
            raise NotALanguageExpression(
                f"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \nThe object '{other}' does not inherit from the Language class.")
        return Sequential(parent=None, children=(self, other)).simplify()

    def __sub__(self, other: Language) -> TryInOrder:
        """
        Language expression for try in order.

        :param other: Another Language expression, either a designator or language expression
        :return: A :func:`~TryInOrder` object which is the new root node of the language tree
        """
        if not issubclass(other.__class__, Language):
            raise NotALanguageExpression(
                f"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \nThe object '{other}' does not inherit from the Language class.")
        return TryInOrder(parent=None, children=(self, other)).simplify()

    def __or__(self, other: Language) -> Parallel:
        """
        Language expression for parallel execution.

        :param other: Another Language expression, either a designator or language expression
        :return: A :func:`~Parallel` object which is the new root node of the language tree
        """
        if not issubclass(other.__class__, Language):
            raise NotALanguageExpression(
                f"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \nThe object '{other}' does not inherit from the Language class.")
        if self.__class__.__name__ in self.parallel_blocklist or other.__class__.__name__ in self.parallel_blocklist:
            raise AttributeError(
                f"You can not execute the Designator {self if self.__class__.__name__ in self.parallel_blocklist else other} in a parallel language expression.")

        return Parallel(parent=None, children=(self, other)).simplify()

    def __xor__(self, other: Language) -> TryAll:
        """
        Language expression for try all execution.

        :param other: Another Language expression, either a designator or language expression
        :return: A :func:`~TryAll` object which is the new root node of the language tree
        """
        if not issubclass(other.__class__, Language):
            raise NotALanguageExpression(
                f"Only classes that inherit from the Language class can be used with the plan language, these are usually Designators or Code objects. \nThe object '{other}' does not inherit from the Language class.")
        if self.__class__.__name__ in self.parallel_blocklist or other.__class__.__name__ in self.parallel_blocklist:
            raise AttributeError(
                f"You can not execute the Designator {self if self.__class__.__name__ in self.parallel_blocklist else other} in a try all language expression.")
        return TryAll(parent=None, children=(self, other)).simplify()

    def __rshift__(self, other: Language):
        """
        Operator for Monitors, this always makes the Monitor the parent of the other expression.
        
        :param other: Another Language expression
        :return: The Monitor which is now the new root node.
        """
        if isinstance(self, Monitor) and isinstance(other, Monitor):
            raise AttributeError("You can't attach a Monitor to another Monitor.")
        if isinstance(self, Monitor):
            self.children = [other]
            return self
        elif isinstance(other, Monitor):
            other.children = [self]
            return other

    def __mul__(self, other: int):
        """
        Language expression for Repeated execution. The other attribute of this operator has to be an integer.

        :param other: An integer which states how often the Language expression should be repeated
        :return: A :func:`~Repeat` object which is the new root node of the language tree
        """
        if not isinstance(other, int):
            raise AttributeError("Repeat can only be used in combination with integers")
        return Repeat(parent=None, children=[self], repeat=other)

    def __rmul__(self, other: int):
        """
        Language expression for Repeated execution. The other attribute of this operator has to be an integer. This is
        the reversed operator of __mul__ which allows to write:

        .. code-block:: python
        
            2 * ParkAction()

        :param other: An integer which states how often the Language expression should be repeated
        :return: A :func:`~Repeat` object which is the new root node of the language tree
        """
        if not isinstance(other, int):
            raise AttributeError("Repeat can only be used in combination with integers")
        return Repeat(parent=None, children=[self], repeat=other)

    def simplify(self) -> Language:
        """
        Simplifies the language tree by merging which have a parent-child relation and are of the same type.

        .. code-block::

            <pycram.new_language.Parallel>
            ├── <pycram.new_language.Parallel>
            │   ├── <pycram.designators.action_designator.NavigateAction>
            │   └── <pycram.designators.action_designator.MoveTorsoAction>
            └── <pycram.designators.action_designator.DetectAction>

            would be simplified to:

           <pycram.new_language.Parallel>
            ├── <pycram.designators.action_designator.NavigateAction>
            ├── <pycram.designators.action_designator.MoveTorsoAction>
            └── <pycram.designators.action_designator.DetectAction>

        """
        for node in PreOrderIter(self.root):
            for child in node.children:
                if isinstance(child, Monitor):
                    continue
                if type(node) is type(child):
                    self.merge_nodes(node, child)
        return self.root

    @staticmethod
    def merge_nodes(node1: Node, node2: Node) -> None:
        """
        Merges node1 with node2 in a tree. The children of node2 will be re-parented to node1 and node2 will be deleted
        from the tree.

        :param node1: Node that should be left in the tree
        :param node2: Node which children should be appended to node1 and then deleted
        """
        node2.parent = None
        node1.children = node2.children + node1.children

    def interrupt(self) -> None:
        """
        Base method for interrupting the execution of Language expression. To be overwritten in a sub-class.
        """
        raise NotImplementedError


class Repeat(Language):
    """
    Executes all children a given number of times.
    """
    def perform(self):
        """
        Behaviour of repeat, executes all children in a loop as often as stated on initialization.

        :return:
        """
        for i in range(self.repeat):
            for child in self.children:
                if self.interrupted:
                    return
                try:
                    child.resolve().perform()
                except PlanFailure as e:
                    self.root.exceptions[self] = e

    def __init__(self, parent: NodeMixin = None, children: Iterable[NodeMixin] = None, repeat: int = 1):
        """
        Initializes the Repeat expression with a parent and children for the language tree construction and a number
        which states how often the children should be executed.

        :param parent: Parent node of this node, if None this will be the root node
        :param children: A list of children of this node
        :param repeat: An integer of how often the children should be executed.
        """
        super().__init__(parent, children)
        self.repeat: int = repeat

    def interrupt(self) -> None:
        """
        Stops the execution of this language expression by setting the ``interrupted`` variable to True, adding this
        thread to the block_list in ProcessModule and interrupting the current giskard goal
        """
        self.interrupted = True
        self.block_list.append(threading.get_ident())
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class Monitor(Language):
    """
    Monitors a Language Expression and interrupts it when the given condition is evaluated to True.

    Behaviour:
        This Monitor is attached to a language expression, when perform on this Monitor is called it will start a new
        thread which continuously checks if the condition is True. When the condition is True the interrupt function of
        the child will be called.
    """
    def __init__(self, condition: Union[Callable, Fluent] = None):
        """
        When initializing a Monitor a condition must be provided. The condition is a callable or a Fluent which returns \
        True or False.

        :param condition: The condition upon which the Monitor should interrupt the attached language expression.
        """
        super().__init__(None, None)
        self.kill_event = threading.Event()
        self.exception_queue = Queue()
        if callable(condition):
            self.condition = Fluent(condition)
        elif isinstance(condition, Fluent):
            self.condition = condition
        else:
            raise AttributeError("The condition of a Monitor has to be a Callable or a Fluent")

    def perform(self) -> Tuple[State, Any]:
        """
        Behavior of the Monitor, starts a new Thread which checks the condition and then performs the attached language
        expression

        :return: The state of the attached language expression, as well as a list of the results of the children
        """
        def check_condition():
            while not self.kill_event.is_set():
                try:
                    cond = self.condition.get_value()
                    if cond:
                        for child in self.children:
                            try:
                                child.interrupt()
                            except NotImplementedError:
                                pass
                        if isinstance(cond, type) and issubclass(cond, Exception):
                            self.exception_queue.put(cond)
                        else:
                            self.exception_queue.put(PlanFailure("Condition met in Monitor"))
                        return
                except Exception as e:
                    self.exception_queue.put(e)
                    return
                rospy.sleep(0.1)

        t = threading.Thread(target=check_condition)
        t.start()
        try:
            state, result = self.children[0].perform()
            if not self.exception_queue.empty():
                raise self.exception_queue.get()
        finally:
            self.kill_event.set()
            t.join()
        return state, result

    def interrupt(self) -> None:
        """
        Calls interrupt for each child
        """
        for child in self.children:
            child.interrupt()


class Sequential(Language):
    """
    Executes all children sequentially, an exception while executing a child does not terminate the whole process.
    Instead, the exception is saved to a list of all exceptions thrown during execution and returned.

    Behaviour:
        Returns a tuple containing the final state of execution (SUCCEEDED, FAILED) and a list of results from each
        child's perform() method. The state is :py:attr:`~State.SUCCEEDED` *iff* all children are executed without
        exception. In any other case the State :py:attr:`~State.FAILED` will be returned.
    """

    def perform(self) -> Tuple[State, List[Any]]:
        """
        Behaviour of Sequential, calls perform() on each child sequentially

        :return: The state and list of results according to the behaviour described in :func:`Sequential`
        """
        children_return_values = [None] * len(self.children)
        try:
            for index, child in enumerate(self.children):
                if self.interrupted:
                    if threading.get_ident() in self.block_list:
                        self.block_list.remove(threading.get_ident())
                    return State.FAILED, children_return_values
                self.root.executing_thread[child] = threading.get_ident()
                ret_val = child.resolve().perform()
                if isinstance(ret_val, tuple):
                    child_state, child_result = ret_val
                    children_return_values[index] = child_result
                else:
                    children_return_values[index] = ret_val
        except PlanFailure as e:
            self.root.exceptions[self] = e
            return State.FAILED, children_return_values
        return State.SUCCEEDED, children_return_values

    def interrupt(self) -> None:
        """
        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True and calling
        interrupt on the current giskard goal.
        """
        self.interrupted = True
        self.block_list.append(threading.get_ident())
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class TryInOrder(Language):
    """
    Executes all children sequentially, an exception while executing a child does not terminate the whole process.
    Instead, the exception is saved to a list of all exceptions thrown during execution and returned.

    Behaviour:
        Returns a tuple containing the final state of execution (SUCCEEDED, FAILED) and a list of results from each
        child's perform() method. The state is :py:attr:`~State.SUCCEEDED` if one or more children are executed without
        exception. In the case that all children could not be executed the State :py:attr:`~State.FAILED` will be returned.
    """

    def perform(self) -> Tuple[State, List[Any]]:
        """
        Behaviour of TryInOrder, calls perform() on each child sequentially and catches raised exceptions.

        :return: The state and list of results according to the behaviour described in :func:`TryInOrder`
        """
        failure_list = []
        children_return_values = [None] * len(self.children)
        for index, child in enumerate(self.children):
            if self.interrupted:
                if threading.get_ident() in self.block_list:
                    self.block_list.remove(threading.get_ident())
                return State.INTERRUPTED, children_return_values
            try:
                ret_val = child.resolve().perform()
                if isinstance(ret_val, tuple):
                    child_state, child_result = ret_val
                    children_return_values[index] = child_result
                else:
                    children_return_values[index] = ret_val
            except PlanFailure as e:
                failure_list.append(e)
        if len(failure_list) > 0:
            self.root.exceptions[self] = failure_list
        if len(failure_list) == len(self.children):
            self.root.exceptions[self] = failure_list
            return State.FAILED, children_return_values
        else:
            return State.SUCCEEDED, children_return_values

    def interrupt(self) -> None:
        """
        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding
        the current thread to the block_list in Language and interrupting the current giskard goal.
        """
        self.interrupted = True
        self.block_list.append(threading.get_ident())
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class Parallel(Language):
    """
    Executes all children in parallel by creating a thread per children and executing them in the respective thread. All
    exceptions during execution will be caught, saved to a list and returned upon end.

    Behaviour:
        Returns a tuple containing the final state of execution (SUCCEEDED, FAILED) and a list of results from
        each child's perform() method. The state is :py:attr:`~State.SUCCEEDED` *iff* all children could be executed without
        an exception. In any other case the State :py:attr:`~State.FAILED` will be returned.

    """

    def perform(self) -> Tuple[State, List[Any]]:
        """
        Behaviour of Parallel, creates a new thread for each child and calls perform() of the child in the respective
        thread.

        :return: The state and list of results according to the behaviour described in :func:`Parallel`

        """
        results = [None] * len(self.children)
        self.threads: List[threading.Thread] = []
        state = State.SUCCEEDED
        results_lock = threading.Lock()

        def lang_call(child_node, index):
            nonlocal state
            if ("DesignatorDescription" in [cls.__name__ for cls in child_node.__class__.__mro__]
                    and self.__class__.__name__ not in self.do_not_use_giskard):
                if self not in giskard.par_threads.keys():
                    giskard.par_threads[self] = [threading.get_ident()]
                else:
                    giskard.par_threads[self].append(threading.get_ident())
            try:
                self.root.executing_thread[child] = threading.get_ident()
                result = child_node.resolve().perform()
                if isinstance(result, tuple):
                    child_state, child_result = result
                    with results_lock:
                        results[index] = child_result
                else:
                    with results_lock:
                        results[index] = result
            except PlanFailure as e:
                nonlocal state
                with results_lock:
                    state = State.FAILED
                if self in self.root.exceptions.keys():
                    self.root.exceptions[self].append(e)
                else:
                    self.root.exceptions[self] = [e]

        for index, child in enumerate(self.children):
            if self.interrupted:
                state = State.FAILED
                break
            t = threading.Thread(target=lambda: lang_call(child, index))
            t.start()
            self.threads.append(t)
        for thread in self.threads:
            thread.join()
        with results_lock:
            for thread in self.threads:
                if thread.ident in self.block_list:
                    self.block_list.remove(thread.ident)
        if self in self.root.exceptions.keys() and len(self.root.exceptions[self]) != 0:
            state = State.FAILED
        return state, results

    def interrupt(self) -> None:
        """
        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding the
        thread id of all parallel execution threads to the block_list in Language and interrupting the current giskard
        goal.
        """
        self.interrupted = True
        self.block_list += [t.ident for t in self.threads]
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class TryAll(Language):
    """
    Executes all children in parallel by creating a thread per children and executing them in the respective thread. All
    exceptions during execution will be caught, saved to a list and returned upon end.

    Behaviour:
        Returns a tuple containing the final state of execution (SUCCEEDED, FAILED) and a list of results from each
        child's perform() method. The state is :py:attr:`~State.SUCCEEDED` if one or more children could be executed
        without raising an exception. If all children fail the State :py:attr:`~State.FAILED` will be returned.
    """

    def perform(self) -> Tuple[State, List[Any]]:
        """
        Behaviour of TryAll, creates a new thread for each child and executes all children in their respective threads.

        :return: The state and list of results according to the behaviour described in :func:`TryAll`
        """
        results = [None] * len(self.children)
        results_lock = threading.Lock()
        state = State.SUCCEEDED
        self.threads: List[threading.Thread] = []
        failure_list = []

        def lang_call(child_node, index):
            if ("DesignatorDescription" in [cls.__name__ for cls in child_node.__class__.__mro__]
                    and self.__class__.__name__ not in self.do_not_use_giskard):
                if self not in giskard.par_threads.keys():
                    giskard.par_threads[self] = [threading.get_ident()]
                else:
                    giskard.par_threads[self].append(threading.get_ident())
            try:
                result = child_node.resolve().perform()
                if isinstance(result, tuple):
                    child_state, child_result = result
                    with results_lock:
                        results[index] = child_result
                else:
                    with results_lock:
                        results[index] = result
            except PlanFailure as e:
                failure_list.append(e)
                if self in self.root.exceptions.keys():
                    self.root.exceptions[self].append(e)
                else:
                    self.root.exceptions[self] = [e]
        for index, child in enumerate(self.children):
            if self.interrupted:
                state = State.FAILED
                break
            t = threading.Thread(target=lambda: lang_call(child, index))
            self.threads.append(t)
            t.start()
        for thread in self.threads:
            thread.join()
        with results_lock:
            for thread in self.threads:
                if thread.ident in self.block_list:
                    self.block_list.remove(thread.ident)
        if len(self.children) == len(failure_list):
            self.root.exceptions[self] = failure_list
            state = State.FAILED
        return state, results

    def interrupt(self) -> None:
        """
        Interrupts the execution of this language expression by setting the ``interrupted`` variable to True, adding the
        thread id of all parallel execution threads to the block_list in Language and interrupting the current giskard
        """
        self.interrupted = True
        self.block_list += [t.ident for t in self.threads]
        if giskard.giskard_wrapper:
            giskard.giskard_wrapper.interrupt()


class Code(Language):
    """
    Executable code block in a plan.

    :ivar function: The function (plan) that was called
    :ivar kwargs: Dictionary holding the keyword arguments of the function
    """

    def __init__(self, function: Optional[Callable] = None,
                 kwargs: Optional[Dict] = None):
        """
        Initialize a code call

        :param function: The function that was called
        :param kwargs: The keyword arguments of the function as dict
        """
        self.function: Callable = function

        if kwargs is None:
            kwargs = dict()
        self.kwargs: Dict[str, Any] = kwargs
        self.perform = self.execute

    def execute(self) -> Any:
        """
        Execute the code with its arguments

        :returns: State.SUCCEEDED, and anything that the function associated with this object will return.
        """
        child_state = State.SUCCEEDED
        ret_val = self.function(**self.kwargs)
        if isinstance(ret_val, tuple):
            child_state, child_result = ret_val
        else:
            child_result = ret_val

        return child_state, child_result

    def interrupt(self) -> None:
        raise NotImplementedError




##New # Content from: #<src/pycram/description.py>#
from __future__ import annotations

import logging
import pathlib
from abc import ABC, abstractmethod

import rospy
from geometry_msgs.msg import Point, Quaternion
from typing_extensions import Tuple, Union, Any, List, Optional, Dict, TYPE_CHECKING

from .datastructures.enums import JointType
from .local_transformer import LocalTransformer
from .datastructures.pose import Pose, Transform
from .datastructures.world import WorldEntity
from .datastructures.dataclasses import JointState, AxisAlignedBoundingBox, Color, LinkState, VisualShape

if TYPE_CHECKING:
    from .world_concepts.world_object import Object


class EntityDescription(ABC):

    """
    A class that represents a description of an entity. This can be a link, joint or object description.
    """

    @property
    @abstractmethod
    def origin(self) -> Pose:
        """
        Returns the origin of this entity.
        """
        pass

    @property
    @abstractmethod
    def name(self) -> str:
        """
        Returns the name of this entity.
        """
        pass


class LinkDescription(EntityDescription):
    """
    A class that represents a link description of an object.
    """

    def __init__(self, parsed_link_description: Any):
        self.parsed_description = parsed_link_description

    @property
    @abstractmethod
    def geometry(self) -> Union[VisualShape, None]:
        """
        Returns the geometry type of the collision element of this link.
        """
        pass


class JointDescription(EntityDescription):
    """
    A class that represents the description of a joint.
    """

    def __init__(self, parsed_joint_description: Any):
        self.parsed_description = parsed_joint_description

    @property
    @abstractmethod
    def type(self) -> JointType:
        """
        :return: The type of this joint.
        """
        pass

    @property
    @abstractmethod
    def axis(self) -> Point:
        """
        :return: The axis of this joint, for example the rotation axis for a revolute joint.
        """
        pass

    @property
    @abstractmethod
    def has_limits(self) -> bool:
        """
        Checks if this joint has limits.

        :return: True if the joint has limits, False otherwise.
        """
        pass

    @property
    def limits(self) -> Tuple[float, float]:
        """
        :return: The lower and upper limits of this joint.
        """
        lower, upper = self.lower_limit, self.upper_limit
        if lower > upper:
            lower, upper = upper, lower
        return lower, upper

    @property
    @abstractmethod
    def lower_limit(self) -> Union[float, None]:
        """
        :return: The lower limit of this joint, or None if the joint has no limits.
        """
        pass

    @property
    @abstractmethod
    def upper_limit(self) -> Union[float, None]:
        """
        :return: The upper limit of this joint, or None if the joint has no limits.
        """
        pass

    @property
    @abstractmethod
    def parent_link_name(self) -> str:
        """
        :return: The name of the parent link of this joint.
        """
        pass

    @property
    @abstractmethod
    def child_link_name(self) -> str:
        """
        :return: The name of the child link of this joint.
        """
        pass

    @property
    def damping(self) -> float:
        """
        :return: The damping of this joint.
        """
        raise NotImplementedError

    @property
    def friction(self) -> float:
        """
        :return: The friction of this joint.
        """
        raise NotImplementedError


class ObjectEntity(WorldEntity):
    """
    An abstract base class that represents a physical part/entity of an Object.
    This can be a link or a joint of an Object.
    """

    def __init__(self, _id: int, obj: Object):
        WorldEntity.__init__(self, _id, obj.world)
        self.object: Object = obj

    @property
    @abstractmethod
    def pose(self) -> Pose:
        """
        :return: The pose of this entity relative to the world frame.
        """
        pass

    @property
    def transform(self) -> Transform:
        """
        Returns the transform of this entity.

        :return: The transform of this entity.
        """
        return self.pose.to_transform(self.tf_frame)

    @property
    @abstractmethod
    def tf_frame(self) -> str:
        """
        Returns the tf frame of this entity.

        :return: The tf frame of this entity.
        """
        pass

    @property
    def object_id(self) -> int:
        """
        :return: the id of the object to which this entity belongs.
        """
        return self.object.id


class Link(ObjectEntity, LinkDescription, ABC):
    """
    Represents a link of an Object in the World.
    """

    def __init__(self, _id: int, link_description: LinkDescription, obj: Object):
        ObjectEntity.__init__(self, _id, obj)
        LinkDescription.__init__(self, link_description.parsed_description)
        self.local_transformer: LocalTransformer = LocalTransformer()
        self.constraint_ids: Dict[Link, int] = {}
        self._update_pose()

    @property
    def current_state(self) -> LinkState:
        return LinkState(self.constraint_ids.copy())

    @current_state.setter
    def current_state(self, link_state: LinkState) -> None:
        self.constraint_ids = link_state.constraint_ids

    def add_fixed_constraint_with_link(self, child_link: 'Link') -> int:
        """
        Adds a fixed constraint between this link and the given link, used to create attachments for example.

        :param child_link: The child link to which a fixed constraint should be added.
        :return: The unique id of the constraint.
        """
        constraint_id = self.world.add_fixed_constraint(self,
                                                        child_link,
                                                        child_link.get_transform_from_link(self))
        self.constraint_ids[child_link] = constraint_id
        child_link.constraint_ids[self] = constraint_id
        return constraint_id

    def remove_constraint_with_link(self, child_link: 'Link') -> None:
        """
        Removes the constraint between this link and the given link.

        :param child_link: The child link of the constraint that should be removed.
        """
        self.world.remove_constraint(self.constraint_ids[child_link])
        del self.constraint_ids[child_link]
        if self in child_link.constraint_ids.keys():
            del child_link.constraint_ids[self]

    @property
    def is_root(self) -> bool:
        """
        Returns whether this link is the root link of the object.

        :return: True if this link is the root link, False otherwise.
        """
        return self.object.get_root_link_id() == self.id

    def update_transform(self, transform_time: Optional[rospy.Time] = None) -> None:
        """
        Updates the transformation of this link at the given time.

        :param transform_time: The time at which the transformation should be updated.
        """
        self.local_transformer.update_transforms([self.transform], transform_time)

    def get_transform_to_link(self, link: 'Link') -> Transform:
        """
        Returns the transformation from this link to the given link.

        :param link: The link to which the transformation should be returned.
        :return: A Transform object with the transformation from this link to the given link.
        """
        return link.get_transform_from_link(self)

    def get_transform_from_link(self, link: 'Link') -> Transform:
        """
        Returns the transformation from the given link to this link.

        :param link: The link from which the transformation should be returned.
        :return: A Transform object with the transformation from the given link to this link.
        """
        return self.get_pose_wrt_link(link).to_transform(self.tf_frame)

    def get_pose_wrt_link(self, link: 'Link') -> Pose:
        """
        Returns the pose of this link with respect to the given link.

        :param link: The link with respect to which the pose should be returned.
        :return: A Pose object with the pose of this link with respect to the given link.
        """
        return self.local_transformer.transform_pose(self.pose, link.tf_frame)

    def get_axis_aligned_bounding_box(self) -> AxisAlignedBoundingBox:
        """
        Returns the axis aligned bounding box of this link.

        :return: An AxisAlignedBoundingBox object with the axis aligned bounding box of this link.
        """
        return self.world.get_link_axis_aligned_bounding_box(self)

    @property
    def position(self) -> Point:
        """
        The getter for the position of the link relative to the world frame.

        :return: A Point object containing the position of the link relative to the world frame.
        """
        return self.pose.position

    @property
    def position_as_list(self) -> List[float]:
        """
        The getter for the position of the link relative to the world frame as a list.

        :return: A list containing the position of the link relative to the world frame.
        """
        return self.pose.position_as_list()

    @property
    def orientation(self) -> Quaternion:
        """
        The getter for the orientation of the link relative to the world frame.

        :return: A Quaternion object containing the orientation of the link relative to the world frame.
        """
        return self.pose.orientation

    @property
    def orientation_as_list(self) -> List[float]:
        """
        The getter for the orientation of the link relative to the world frame as a list.

        :return: A list containing the orientation of the link relative to the world frame.
        """
        return self.pose.orientation_as_list()

    def _update_pose(self) -> None:
        """
        Updates the current pose of this link from the world.
        """
        self._current_pose = self.world.get_link_pose(self)

    @property
    def pose(self) -> Pose:
        """
        The pose of the link relative to the world frame.

        :return: A Pose object containing the pose of the link relative to the world frame.
        """
        return self._current_pose

    @property
    def pose_as_list(self) -> List[List[float]]:
        """
        The pose of the link relative to the world frame as a list.

        :return: A list containing the position and orientation of the link relative to the world frame.
        """
        return self.pose.to_list()

    def get_origin_transform(self) -> Transform:
        """
        Returns the transformation between the link frame and the origin frame of this link.
        """
        return self.origin.to_transform(self.tf_frame)

    @property
    def color(self) -> Color:
        """
        The getter for the rgba_color of this link.

        :return: A Color object containing the rgba_color of this link.
        """
        return self.world.get_link_color(self)

    @color.setter
    def color(self, color: Color) -> None:
        """
        The setter for the color of this link, could be rgb or rgba.

        :param color: The color as a list of floats, either rgb or rgba.
        """
        self.world.set_link_color(self, color)

    @property
    def origin_transform(self) -> Transform:
        """
        :return: The transform from world to origin of entity.
        """
        return self.origin.to_transform(self.tf_frame)

    @property
    def tf_frame(self) -> str:
        """
        The name of the tf frame of this link.
        """
        return f"{self.object.tf_frame}/{self.name}"

    def __eq__(self, other):
        return self.id == other.id and self.object == other.object and self.name == other.name

    def __copy__(self):
        return Link(self.id, self, self.object)

    def __hash__(self):
        return hash((self.id, self.object, self.name))


class RootLink(Link, ABC):
    """
    Represents the root link of an Object in the World.
    It differs from the normal AbstractLink class in that the pose ande the tf_frame is the same as that of the object.
    """

    def __init__(self, obj: Object):
        super().__init__(obj.get_root_link_id(), obj.get_root_link_description(), obj)

    @property
    def tf_frame(self) -> str:
        """
        Returns the tf frame of the root link, which is the same as the tf frame of the object.
        """
        return self.object.tf_frame

    def _update_pose(self) -> None:
        self._current_pose = self.object.get_pose()

    def __copy__(self):
        return RootLink(self.object)


class Joint(ObjectEntity, JointDescription, ABC):
    """
    Represents a joint of an Object in the World.
    """

    def __init__(self, _id: int,
                 joint_description: JointDescription,
                 obj: Object):
        ObjectEntity.__init__(self, _id, obj)
        JointDescription.__init__(self, joint_description.parsed_description)
        self._update_position()

    @property
    def tf_frame(self) -> str:
        """
        The tf frame of a joint is the tf frame of the child link.
        """
        return self.child_link.tf_frame

    @property
    def pose(self) -> Pose:
        """
        Returns the pose of this joint. The pose is the pose of the child link of this joint.

        :return: The pose of this joint.
        """
        return self.child_link.pose

    def _update_position(self) -> None:
        """
        Updates the current position of the joint from the physics simulator.
        """
        self._current_position = self.world.get_joint_position(self)

    @property
    def parent_link(self) -> Link:
        """
        Returns the parent link of this joint.

        :return: The parent link as a AbstractLink object.
        """
        return self.object.get_link(self.parent_link_name)

    @property
    def child_link(self) -> Link:
        """
        Returns the child link of this joint.

        :return: The child link as a AbstractLink object.
        """
        return self.object.get_link(self.child_link_name)

    @property
    def position(self) -> float:
        return self._current_position

    def reset_position(self, position: float) -> None:
        self.world.reset_joint_position(self, position)
        self._update_position()

    def get_object_id(self) -> int:
        """
        Returns the id of the object to which this joint belongs.

        :return: The integer id of the object to which this joint belongs.
        """
        return self.object.id

    @position.setter
    def position(self, joint_position: float) -> None:
        """
        Sets the position of the given joint to the given joint pose. If the pose is outside the joint limits,
         an error will be printed. However, the joint will be set either way.

        :param joint_position: The target pose for this joint
        """
        # TODO Limits for rotational (infinite) joints are 0 and 1, they should be considered separately
        if self.has_limits:
            low_lim, up_lim = self.limits
            if not low_lim <= joint_position <= up_lim:
                logging.warning(
                    f"The joint position has to be within the limits of the joint. The joint limits for {self.name}"
                    f" are {low_lim} and {up_lim}")
                logging.warning(f"The given joint position was: {joint_position}")
                # Temporarily disabled because kdl outputs values exciting joint limits
                # return
        self.reset_position(joint_position)

    def enable_force_torque_sensor(self) -> None:
        self.world.enable_joint_force_torque_sensor(self.object, self.id)

    def disable_force_torque_sensor(self) -> None:
        self.world.disable_joint_force_torque_sensor(self.object, self.id)

    def get_reaction_force_torque(self) -> List[float]:
        return self.world.get_joint_reaction_force_torque(self.object, self.id)

    def get_applied_motor_torque(self) -> float:
        return self.world.get_applied_joint_motor_torque(self.object, self.id)

    @property
    def current_state(self) -> JointState:
        return JointState(self.position)

    @current_state.setter
    def current_state(self, joint_state: JointState) -> None:
        """
        Updates the current state of this joint from the given joint state if the position is different.

        :param joint_state: The joint state to update from.
        """
        if self._current_position != joint_state.position:
            self.position = joint_state.position

    def __copy__(self):
        return Joint(self.id, self, self.object)

    def __eq__(self, other):
        return self.id == other.id and self.object == other.object and self.name == other.name

    def __hash__(self):
        return hash((self.id, self.object, self.name))


class ObjectDescription(EntityDescription):

    """
    A class that represents the description of an object.
    """

    mesh_extensions: Tuple[str] = (".obj", ".stl", ".dae")
    """
    The file extensions of the mesh files that can be used to generate a description file.
    """

    class Link(Link, ABC):
        ...

    class RootLink(RootLink, ABC):
        ...

    class Joint(Joint, ABC):
        ...

    def __init__(self, path: Optional[str] = None):
        """
        :param path: The path of the file to update the description data from.
        """
        if path:
            self.update_description_from_file(path)
        else:
            self._parsed_description = None

    def update_description_from_file(self, path: str) -> None:
        """
        Updates the description of this object from the file at the given path.

        :param path: The path of the file to update from.
        """
        self._parsed_description = self.load_description(path)

    @property
    def parsed_description(self) -> Any:
        """
        Return the object parsed from the description file.
        """
        return self._parsed_description

    @parsed_description.setter
    def parsed_description(self, parsed_description: Any):
        """
        :param parsed_description: The parsed description object (depends on the description file type).
        """
        self._parsed_description = parsed_description

    @abstractmethod
    def load_description(self, path: str) -> Any:
        """
        Loads the description from the file at the given path.

        :param path: The path to the source file, if only a filename is provided then the resources directories will be
         searched.
        """
        pass

    def generate_description_from_file(self, path: str, name: str, extension: str) -> str:
        """
        Generates and preprocesses the description from the file at the given path and returns the preprocessed
        description as a string.

        :param path: The path of the file to preprocess.
        :param name: The name of the object.
        :param extension: The file extension of the file to preprocess.
        :return: The processed description string.
        """
        description_string = None

        if extension in self.mesh_extensions:
            description_string = self.generate_from_mesh_file(path, name)
        elif extension == self.get_file_extension():
            description_string = self.generate_from_description_file(path)
        else:
            try:
                # Using the description from the parameter server
                description_string = self.generate_from_parameter_server(path)
            except KeyError:
                logging.warning(f"Couldn't find dile data in the ROS parameter server")
        if description_string is None:
            logging.error(f"Could not find file with path {path} in the resources directory nor"
                          f" in the ros parameter server.")
            raise FileNotFoundError

        return description_string

    def get_file_name(self, path_object: pathlib.Path, extension: str, object_name: str) -> str:
        """
        Returns the file name of the description file.

        :param path_object: The path object of the description file or the mesh file.
        :param extension: The file extension of the description file or the mesh file.
        :param object_name: The name of the object.
        :return: The file name of the description file.
        """
        if extension in self.mesh_extensions:
            file_name = path_object.stem + self.get_file_extension()
        elif extension == self.get_file_extension():
            file_name = path_object.name
        else:
            file_name = object_name + self.get_file_extension()

        return file_name

    @classmethod
    @abstractmethod
    def generate_from_mesh_file(cls, path: str, name: str) -> str:
        """
        Generates a description file from one of the mesh types defined in the mesh_extensions and
        returns the path of the generated file.

        :param path: The path to the .obj file.
        :param name: The name of the object.
        :return: The path of the generated description file.
        """
        pass

    @classmethod
    @abstractmethod
    def generate_from_description_file(cls, path: str) -> str:
        """
        Preprocesses the given file and returns the preprocessed description string.

        :param path: The path of the file to preprocess.
        :return: The preprocessed description string.
        """
        pass

    @classmethod
    @abstractmethod
    def generate_from_parameter_server(cls, name: str) -> str:
        """
        Preprocesses the description from the ROS parameter server and returns the preprocessed description string.

        :param name: The name of the description on the parameter server.
        :return: The preprocessed description string.
        """
        pass

    @property
    @abstractmethod
    def links(self) -> List[LinkDescription]:
        """
        :return: A list of links descriptions of this object.
        """
        pass

    @abstractmethod
    def get_link_by_name(self, link_name: str) -> LinkDescription:
        """
        :return: The link description with the given name.
        """
        pass

    @property
    @abstractmethod
    def joints(self) -> List[JointDescription]:
        """
        :return: A list of joints descriptions of this object.
        """
        pass

    @abstractmethod
    def get_joint_by_name(self, joint_name: str) -> JointDescription:
        """
        :return: The joint description with the given name.
        """
        pass

    @abstractmethod
    def get_root(self) -> str:
        """
        :return: the name of the root link of this object.
        """
        pass

    @abstractmethod
    def get_chain(self, start_link_name: str, end_link_name: str) -> List[str]:
        """
        :return: the chain of links from 'start_link_name' to 'end_link_name'.
        """
        pass

    @staticmethod
    @abstractmethod
    def get_file_extension() -> str:
        """
        :return: The file extension of the description file.
        """
        pass


##New # Content from: #<src/pycram/local_transformer.py>#
import sys
import logging

if 'world' in sys.modules:
    logging.warning("(publisher) Make sure that you are not loading this module from pycram.world.")
import rospy

from tf import TransformerROS
from rospy import Duration

from geometry_msgs.msg import TransformStamped
from .datastructures.pose import Pose, Transform
from typing_extensions import List, Optional, Union, Iterable


class LocalTransformer(TransformerROS):
    """
    This class allows to use the TF class TransformerROS without using the ROS
    network system or the topic /tf, where transforms are usually published to.
    Instead, a local transformer is saved and allows to publish local transforms,
    as well the use of TFs convenient lookup functions (see functions below).

    This class uses the robots (currently only one! supported) URDF file to
    initialize the tfs for the robot. Moreover, the function update_local_transformer_from_btr
    updates these tfs by copying the tfs state from the world.

    This class extends the TransformerRos, you can find documentation for TransformerROS here:
    `TFDoc <http://wiki.ros.org/tf/TfUsingPython>`_
    """

    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized: return
        super().__init__(interpolate=True, cache_time=Duration(10))
        # Since this file can't import world.py this holds the reference to the current_world
        self.world = None
        # TODO: Ask Jonas if this is still needed
        self.prospection_world = None

        # If the singelton was already initialized
        self._initialized = True

    def transform_to_object_frame(self, pose: Pose,
                                  world_object: 'world_concepts.world_object.Object', link_name: str = None) -> Union[
        Pose, None]:
        """
        Transforms the given pose to the coordinate frame of the given World object. If no link name is given the
        base frame of the Object is used, otherwise the link frame is used as target for the transformation.

        :param pose: Pose that should be transformed
        :param world_object: BulletWorld Object in which frame the pose should be transformed
        :param link_name: A link of the BulletWorld Object which will be used as target coordinate frame instead
        :return: The new pose the in coordinate frame of the object
        """
        if link_name:
            target_frame = world_object.get_link_tf_frame(link_name)
        else:
            target_frame = world_object.tf_frame
        return self.transform_pose(pose, target_frame)

    def update_transforms_for_objects(self, source_object_name: str, target_object_name: str) -> None:
        """
        Updates the transforms for objects affected by the transformation. The objects are identified by their names.

        :param source_object_name: Name of the object of the source frame
        :param target_object_name: Name of the object of the target frame
        """
        source_object = self.world.get_object_by_name(source_object_name)
        target_object = self.world.get_object_by_name(target_object_name)
        for obj in {source_object, target_object}:
            if obj:
                obj.update_link_transforms()

    def transform_pose(self, pose: Pose, target_frame: str) -> Optional[Pose]:
        """
        Transforms a given pose to the target frame after updating the transforms for all objects in the current world.

        :param pose: Pose that should be transformed
        :param target_frame: Name of the TF frame into which the Pose should be transformed
        :return: A transformed pose in the target frame
        """
        self.update_transforms_for_objects(self.get_object_name_for_frame(pose.frame),
                                           self.get_object_name_for_frame(target_frame))

        copy_pose = pose.copy()
        copy_pose.header.stamp = rospy.Time(0)
        if not self.canTransform(target_frame, pose.frame, rospy.Time(0)):
            rospy.logerr(
                f"Can not transform pose: \n {pose}\n to frame: {target_frame}.\n Maybe try calling 'update_transforms_for_object'")
            return
        new_pose = super().transformPose(target_frame, copy_pose)

        copy_pose.pose = new_pose.pose
        copy_pose.header.frame_id = new_pose.header.frame_id
        copy_pose.header.stamp = rospy.Time.now()

        return Pose(*copy_pose.to_list(), frame=new_pose.header.frame_id)

    def get_object_name_for_frame(self, frame: str) -> str:
        """
        Returns the name of the object that is associated with the given frame.

        :param frame: The frame for which the object name should be returned
        :return: The name of the object associated with the frame
        """
        return frame.split("/")[0]

    def lookup_transform_from_source_to_target_frame(self, source_frame: str, target_frame: str,
                                                     time: Optional[rospy.rostime.Time] = None) -> Transform:
        """
        Update the transforms for all world objects then Look up for the latest known transform that transforms a point
         from source frame to target frame. If no time is given the last common time between the two frames is used.

        :param source_frame: The frame in which the point is currently represented
        :param target_frame: The frame in which the point should be represented
        :param time: Time at which the transform should be looked up
        :return: The transform from source_frame to target_frame
        """
        self.update_transforms_for_objects(self.get_object_name_for_frame(source_frame),
                                           self.get_object_name_for_frame(target_frame))

        tf_time = time if time else self.getLatestCommonTime(source_frame, target_frame)
        translation, rotation = self.lookupTransform(source_frame, target_frame, tf_time)
        return Transform(translation, rotation, source_frame, target_frame)

    def update_transforms(self, transforms: Iterable[Transform], time: rospy.Time = None) -> None:
        """
        Updates transforms by updating the time stamps of the header of each transform. If no time is given the current
        time is used.
        """
        time = time if time else rospy.Time.now()
        for transform in transforms:
            transform.header.stamp = time
            self.setTransform(transform)

    def get_all_frames(self) -> List[str]:
        """
        Returns all know coordinate frames as a list with human-readable entries.

        :return: A list of all know coordinate frames.
        """
        frames = self.allFramesAsString().split("\n")
        frames.remove("")
        return frames

    def transformPose(self, target_frame, ps) -> Pose:
        """
        Alias for :func:`~LocalTransformer.transform_pose_to_target_frame` to avoid confusion since a similar method
         exists in the super class.
        """
        return self.transform_pose(ps, target_frame)


##New # Content from: #<src/pycram/tasktree.py>#
"""Implementation of TaskTrees using anytree."""

# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

from typing_extensions import TYPE_CHECKING

import datetime
import inspect
import logging
from typing_extensions import List, Optional, Callable

import anytree
import sqlalchemy.orm.session
import tqdm

from .datastructures.world import World
from .orm.tasktree import TaskTreeNode as ORMTaskTreeNode
from .orm.base import ProcessMetaData
from .plan_failures import PlanFailure
from .datastructures.enums import TaskStatus
from .datastructures.dataclasses import Color

if TYPE_CHECKING:
    from .designators.performables import Action


class NoOperation:

    def perform(self):
        ...

    def __repr__(self):
        return "NoOperation"


class TaskTreeNode(anytree.NodeMixin):
    """
    TaskTreeNode represents one function that was called during a pycram plan.
    Additionally, meta information is stored.
    """

    action: Optional[Action]
    """
    The action and that is performed or None if nothing was performed
    """

    status: TaskStatus
    """
    The status of the node from the TaskStatus enum.
    """

    start_time: Optional[datetime.datetime]
    """
    The starting time of the function, optional
    """

    end_time: Optional[datetime.datetime]
    """
    The ending time of the function, optional
    """

    """
    The reason why this task failed, optional
    """

    def __init__(self, action: Optional[Action] = NoOperation(), parent: Optional[TaskTreeNode] = None,
                 children: Optional[List[TaskTreeNode]] = None, reason: Optional[Exception] = None):
        """
        Create a TaskTreeNode

        :param action: The action and that is performed, defaults to None
        :param parent: The parent function of this function. None if this the parent, optional
        :param children: An iterable of TaskTreeNode with the ordered children, optional
        """
        super().__init__()

        if action is None:
            action = NoOperation()

        self.action = action
        self.status = TaskStatus.CREATED
        self.start_time = None
        self.end_time = None
        self.parent = parent
        self.reason: Optional[Exception] = reason

        if children:
            self.children = children

    @property
    def name(self):
        return str(self)

    def __str__(self):
        return "Code: %s \n " \
               "Status: %s \n " \
               "start_time: %s \n " \
               "end_time: %s \n " \
               "" % (str(self.action), self.start_time, self.status, self.end_time)

    def __repr__(self):
        return str(self.action.__class__.__name__)

    def __len__(self):
        """Get the number of nodes that are in this subtree."""
        return 1 + sum([len(child) for child in self.children])

    def to_sql(self) -> ORMTaskTreeNode:
        """Convert this object to the corresponding object in the pycram.orm package.

        :returns:  corresponding pycram.orm.task.TaskTreeNode object
        """

        if self.reason:
            reason = type(self.reason).__name__
        else:
            reason = None

        return ORMTaskTreeNode(self.start_time, self.end_time, self.status.name, reason)

    def insert(self, session: sqlalchemy.orm.session.Session, recursive: bool = True,
               parent: Optional[TaskTreeNode] = None, use_progress_bar: bool = True,
               progress_bar: Optional[tqdm.tqdm] = None) -> ORMTaskTreeNode:
        """
        Insert this node into the database.

        :param session: The current session with the database.
        :param recursive: Rather if the entire tree should be inserted or just this node, defaults to True
        :param parent: The parent node, defaults to None
        :param use_progress_bar: Rather to use a progressbar or not
        :param progress_bar: The progressbar to update. If a progress bar is desired and this is None, a new one will be
            created.

        :return: The ORM object that got inserted
        """
        if use_progress_bar:
            if not progress_bar:
                progress_bar = tqdm.tqdm(desc="Inserting TaskTree into database", leave=True, position=0,
                                         total=len(self) if recursive else 1)

        # convert self to orm object
        node = self.to_sql()

        # insert action if possible
        if getattr(self.action, "insert", None):
            action = self.action.insert(session)
            node.action = action
        else:
            action = None
            node.action = None

        # get and set metadata
        metadata = ProcessMetaData().insert(session)
        node.process_metadata = metadata

        # set node parent
        node.parent = parent

        # add the node to the session; note that the instance is not yet committed to the db, but rather in a
        # pending state
        session.add(node)

        if progress_bar:
            progress_bar.update()

        # if recursive, insert all children
        if recursive:
            [child.insert(session, parent=node, use_progress_bar=use_progress_bar, progress_bar=progress_bar)
             for child in self.children]

        # once recursion is done and the root node is reached again, commit the session to the database
        if self.parent is None:
            session.commit()

        return node


class SimulatedTaskTree:
    """TaskTree for execution in a 'new' simulation."""

    def __enter__(self):
        """At the beginning of a with statement the current task tree and world will be suspended and remembered.
        Fresh structures are then available inside the with statement."""
        global task_tree

        self.suspended_tree = task_tree
        self.world_state = World.current_world.save_state()
        self.simulated_root = TaskTreeNode()
        task_tree = self.simulated_root
        World.current_world.add_text("Simulating...", [0, 0, 1.75], color=Color.from_rgb([0, 0, 0]),
                                     parent_object_id=1)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        Restore the old state at the end of a with block.
        """
        global task_tree
        task_tree = self.suspended_tree
        World.current_world.restore_state(self.world_state)
        World.current_world.remove_text()


task_tree: Optional[TaskTreeNode] = None
"""Current TaskTreeNode"""


def reset_tree() -> None:
    """
    Reset the current task tree to an empty root (NoOperation) node.
    """
    global task_tree
    task_tree = TaskTreeNode()
    task_tree.start_time = datetime.datetime.now()
    task_tree.status = TaskStatus.RUNNING


reset_tree()


def with_tree(fun: Callable) -> Callable:
    """
    Decorator that records the function name, arguments and execution metadata in the task tree.

    :param fun: The function to record the data from.
    """

    def handle_tree(*args, **kwargs):

        # get the task tree
        global task_tree

        # parse keyword arguments
        keyword_arguments = inspect.getcallargs(fun, *args, **kwargs)

        # try to get self object since this represents the action object
        action = keyword_arguments.get("self", None)

        # create the task tree node
        task_tree = TaskTreeNode(action, parent=task_tree)

        # Try to execute the task
        try:
            task_tree.status = TaskStatus.CREATED
            task_tree.start_time = datetime.datetime.now()
            result = fun(*args, **kwargs)

            # if it succeeded set the flag
            task_tree.status = TaskStatus.SUCCEEDED

        # iff a PlanFailure occurs
        except PlanFailure as e:

            # log the error and set the flag
            logging.exception("Task execution failed at %s. Reason %s" % (repr(task_tree), e))
            task_tree.reason = e
            task_tree.status = TaskStatus.FAILED
            raise e
        finally:
            # set and time and update current node pointer
            task_tree.end_time = datetime.datetime.now()
            task_tree = task_tree.parent
        return result

    return handle_tree


##New # Content from: #<src/pycram/world_reasoning.py>#
from typing_extensions import List, Tuple, Optional, Union, Dict

import numpy as np

from .external_interfaces.ik import try_to_reach, try_to_reach_with_grasp
from .datastructures.pose import Pose, Transform
from .robot_description import RobotDescription
from .world_concepts.world_object import Object
from .datastructures.world import World, UseProspectionWorld


def stable(obj: Object) -> bool:
    """
    Checks if an object is stable in the world. Stable meaning that it's position will not change after simulating
    physics in the World. This will be done by simulating the world for 10 seconds and compare
    the previous coordinates with the coordinates after the simulation.

    :param obj: The object which should be checked
    :return: True if the given object is stable in the world False else
    """
    prospection_obj = World.current_world.get_prospection_object_for_object(obj)
    with UseProspectionWorld():
        coords_prev = prospection_obj.get_position_as_list()
        World.current_world.set_gravity([0, 0, -9.8])

        World.current_world.simulate(2)
        coords_past = prospection_obj.get_position_as_list()

        coords_prev = list(map(lambda n: round(n, 3), coords_prev))
        coords_past = list(map(lambda n: round(n, 3), coords_past))
        return coords_past == coords_prev


def contact(
        object1: Object,
        object2: Object,
        return_links: bool = False) -> Union[bool, Tuple[bool, List]]:
    """
    Checks if two objects are in contact or not. If the links should be returned then the output will also contain a
    list of tuples where the first element is the link name of 'object1' and the second element is the link name of
    'object2'.

    :param object1: The first object
    :param object2: The second object
    :param return_links: If the respective links on the objects that are in contact should be returned.
    :return: True if the two objects are in contact False else. If links should be returned a list of links in contact
    """

    with UseProspectionWorld():
        prospection_obj1 = World.current_world.get_prospection_object_for_object(object1)
        prospection_obj2 = World.current_world.get_prospection_object_for_object(object2)

        World.current_world.perform_collision_detection()
        con_points = World.current_world.get_contact_points_between_two_objects(prospection_obj1, prospection_obj2)

        if return_links:
            contact_links = []
            for point in con_points:
                contact_links.append((prospection_obj1.get_link_by_id(point[3]),
                                      prospection_obj2.get_link_by_id(point[4])))
            return con_points != (), contact_links

        else:
            return con_points != ()


def get_visible_objects(
        camera_pose: Pose,
        front_facing_axis: Optional[List[float]] = None) -> Tuple[np.ndarray, Pose]:
    """
    Returns a segmentation mask of the objects that are visible from the given camera pose and the front facing axis.

    :param camera_pose: The pose of the camera in world coordinate frame.
    :param front_facing_axis: The axis, of the camera frame, which faces to the front of the robot. Given as list of xyz
    :return: A segmentation mask of the objects that are visible and the pose of the point at exactly 2 meters in front of the camera in the direction of the front facing axis with respect to the world coordinate frame.
    """
    front_facing_axis = RobotDescription.current_robot_description.get_default_camera().front_facing_axis

    world_to_cam = camera_pose.to_transform("camera")

    cam_to_point = Transform(list(np.multiply(front_facing_axis, 2)), [0, 0, 0, 1], "camera",
                             "point")
    target_point = (world_to_cam * cam_to_point).to_pose()

    seg_mask = World.current_world.get_images_for_target(target_point, camera_pose)[2]

    return seg_mask, target_point


def visible(
        obj: Object,
        camera_pose: Pose,
        front_facing_axis: Optional[List[float]] = None,
        threshold: float = 0.8) -> bool:
    """
    Checks if an object is visible from a given position. This will be achieved by rendering the object
    alone and counting the visible pixel, then rendering the complete scene and compare the visible pixels with the
    absolut count of pixels.

    :param obj: The object for which the visibility should be checked
    :param camera_pose: The pose of the camera in map frame
    :param front_facing_axis: The axis, of the camera frame, which faces to the front of the robot. Given as list of xyz
    :param threshold: The minimum percentage of the object that needs to be visible for this method to return true.
    :return: True if the object is visible from the camera_position False if not
    """
    with UseProspectionWorld():
        prospection_obj = World.current_world.get_prospection_object_for_object(obj)
        if World.robot:
            prospection_robot = World.current_world.get_prospection_object_for_object(World.robot)

        state_id = World.current_world.save_state()
        for obj in World.current_world.objects:
            if obj == prospection_obj or (World.robot and obj == prospection_robot):
                continue
            else:
                obj.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]), set_attachments=False)

        seg_mask, target_point = get_visible_objects(camera_pose, front_facing_axis)
        max_pixel = np.array(seg_mask == prospection_obj.id).sum()

        World.current_world.restore_state(state_id)

        if max_pixel == 0:
            # Object is not visible
            return False

        seg_mask = World.current_world.get_images_for_target(target_point, camera_pose)[2]
        real_pixel = np.array(seg_mask == prospection_obj.id).sum()

        return real_pixel / max_pixel > threshold > 0


def occluding(
        obj: Object,
        camera_pose: Pose,
        front_facing_axis: Optional[List[float]] = None) -> List[Object]:
    """
    Lists all objects which are occluding the given object. This works similar to 'visible'.
    First the object alone will be rendered and the position of the pixels of the object in the picture will be saved.
    After that the complete scene will be rendered and the previous saved pixel positions will be compared to the
    actual pixels, if in one pixel another object is visible ot will be saved as occluding.

    :param obj: The object for which occlusion should be checked
    :param camera_pose: The pose of the camera in world coordinate frame
    :param front_facing_axis: The axis, of the camera frame, which faces to the front of the robot. Given as list of xyz
    :return: A list of occluding objects
    """

    with UseProspectionWorld():
        state_id = World.current_world.save_state()
        for other_obj in World.current_world.objects:
            if other_obj.name == World.current_world.robot.name:
                continue
            elif obj.get_pose() == other_obj.get_pose():
                obj = other_obj
            else:
                other_obj.set_pose(Pose([100, 100, 0], [0, 0, 0, 1]))

        seg_mask, target_point = get_visible_objects(camera_pose, front_facing_axis)

        # All indices where the object that could be occluded is in the image
        # [0] at the end is to reduce by one dimension because dstack adds an unnecessary dimension
        pix = np.dstack(np.nonzero(seg_mask == obj.id))[0]

        World.current_world.restore_state(state_id)

        occluding_obj_ids = []
        seg_mask = World.current_world.get_images_for_target(target_point, camera_pose)[2]
        for c in pix:
            if not seg_mask[c[0]][c[1]] == obj.id:
                occluding_obj_ids.append(seg_mask[c[0]][c[1]])

        occ_objects = list(set(map(World.current_world.get_object_by_id, occluding_obj_ids)))
        occ_objects = list(map(World.current_world.get_object_for_prospection_object, occ_objects))

        return occ_objects


def reachable(
        pose_or_object: Union[Object, Pose],
        robot: Object,
        gripper_name: str,
        threshold: float = 0.01) -> bool:
    """
    Checks if the robot can reach a given position. To determine this the inverse kinematics are
    calculated and applied. Afterward the distance between the position and the given end effector is calculated, if
    it is smaller than the threshold the reasoning query returns True, if not it returns False.

    :param pose_or_object: The position and rotation or Object for which reachability should be checked or an Object
    :param robot: The robot that should reach for the position
    :param gripper_name: The name of the end effector
    :param threshold: The threshold between the end effector and the position.
    :return: True if the end effector is closer than the threshold to the target position, False in every other case
    """

    prospection_robot = World.current_world.get_prospection_object_for_object(robot)
    with UseProspectionWorld():
        target_pose = try_to_reach(pose_or_object, prospection_robot, gripper_name)

        if not target_pose:
            return False

        gripper_pose = prospection_robot.get_link_pose(gripper_name)
        diff = target_pose.dist(gripper_pose)

    return diff < threshold


def blocking(
        pose_or_object: Union[Object, Pose],
        robot: Object,
        gripper_name: str,
        grasp: str = None) -> Union[List[Object], None]:
    """
    Checks if any objects are blocking another object when a robot tries to pick it. This works
    similar to the reachable predicate. First the inverse kinematics between the robot and the object will be
    calculated and applied. Then it will be checked if the robot is in contact with any object except the given one.
    If the given pose or Object is not reachable None will be returned

    :param pose_or_object: The object or pose for which blocking objects should be found
    :param robot: The robot Object who reaches for the object
    :param gripper_name: The name of the end effector of the robot
    :param grasp: The grasp type with which the object should be grasped
    :return: A list of objects the robot is in collision with when reaching for the specified object or None if the pose or object is not reachable.
    """

    prospection_robot = World.current_world.get_prospection_object_for_object(robot)
    with UseProspectionWorld():
        if grasp:
            try_to_reach_with_grasp(pose_or_object, prospection_robot, gripper_name, grasp)
        else:
            try_to_reach(pose_or_object, prospection_robot, gripper_name)

        block = []
        for obj in World.current_world.objects:
            if contact(prospection_robot, obj):
                block.append(World.current_world.get_object_for_prospection_object(obj))
    return block


def supporting(
        object1: Object,
        object2: Object) -> bool:
    """
    Checks if one object is supporting another object. An object supports another object if they are in
    contact and the second object is above the first one. (e.g. a Bottle will be supported by a table)

    :param object1: Object that is supported
    :param object2: Object that supports the first object
    :return: True if the second object is in contact with the first one and the second is above the first else False
    """
    return contact(object1, object2) and object2.get_position().z > object1.get_position().z


def link_pose_for_joint_config(
        obj: Object,
        joint_config: Dict[str, float],
        link_name: str) -> Pose:
    """
    Returns the pose a link would be in if the given joint configuration would be applied to the object.
    This is done by using the respective object in the prospection world and applying the joint configuration
    to this one. After applying the joint configuration the link position is taken from there.

    :param obj: Object of which the link is a part
    :param joint_config: Dict with the goal joint configuration
    :param link_name: Name of the link for which the pose should be returned
    :return: The pose of the link after applying the joint configuration
    """
    prospection_object = World.current_world.get_prospection_object_for_object(obj)
    with UseProspectionWorld():
        for joint, pose in joint_config.items():
            prospection_object.set_joint_position(joint, pose)
        return prospection_object.get_link_pose(link_name)


##New # Content from: #<src/pycram/costmaps.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

from typing_extensions import Tuple, List, Optional

import matplotlib.pyplot as plt
from dataclasses import dataclass

import numpy as np
import psutil
import rospy
from matplotlib import colors
from nav_msgs.msg import OccupancyGrid, MapMetaData

from .datastructures.world import UseProspectionWorld
from .world_concepts.world_object import Object
from .description import Link
from .local_transformer import LocalTransformer
from .datastructures.pose import Pose, Transform
from .datastructures.world import World
from .datastructures.dataclasses import AxisAlignedBoundingBox, BoxVisualShape, Color

import pybullet as p


@dataclass
class Rectangle:
    """
    A rectangle that is described by a lower and upper x and y value.
    """
    x_lower: float
    x_upper: float
    y_lower: float
    y_upper: float

    def translate(self, x: float, y: float):
        """Translate the rectangle by x and y"""
        self.x_lower += x
        self.x_upper += x
        self.y_lower += y
        self.y_upper += y

    def scale(self, x_factor: float, y_factor: float):
        """Scale the rectangle by x_factor and y_factor"""
        self.x_lower *= x_factor
        self.x_upper *= x_factor
        self.y_lower *= y_factor
        self.y_upper *= y_factor


class Costmap:
    """
    The base class of all Costmaps which implements the visualization of costmaps
    in the World.
    """

    def __init__(self, resolution: float,
                 height: int,
                 width: int,
                 origin: Pose,
                 map: np.ndarray,
                 world: Optional[World] = None):
        """
        The constructor of the base class of all Costmaps.

        :param resolution: The distance in metre in the real-world which is
         represented by a single entry in the costmap.
        :param height: The height of the costmap.
        :param width: The width of the costmap.
        :param origin: The origin of the costmap, in world coordinate frame. The origin of the costmap is located in the
         centre of the costmap.
        :param map: The costmap represents as a 2D numpy array.
        :param world: The World for which the costmap should be created.
        """
        self.world = world if world else World.current_world
        self.resolution: float = resolution
        self.size: int = height
        self.height: int = height
        self.width: int = width
        local_transformer = LocalTransformer()
        self.origin: Pose = local_transformer.transform_pose(origin, 'map')
        self.map: np.ndarray = map
        self.vis_ids: List[int] = []

    def visualize(self) -> None:
        """
        Visualizes a costmap in the BulletWorld, the visualisation works by
        subdividing the costmap in rectangles which are then visualized as pybullet
        visual shapes.
        """
        if self.vis_ids != []:
            return

        # working on a copy of the costmap, since found rectangles are deleted
        map = np.copy(self.map)
        curr_width = 0
        curr_height = 0
        curr_pose = []
        boxes = []
        # Finding all rectangles in the costmap
        for i in range(0, map.shape[0]):
            for j in range(0, map.shape[1]):
                if map[i][j] > 0:
                    curr_width = self._find_consectuive_line((i, j), map)
                    curr_pose = (i, j)
                    curr_height = self._find_max_box_height((i, j), curr_width, map)
                    avg = np.average(map[i:i + curr_height, j:j + curr_width])
                    boxes.append([curr_pose, curr_height, curr_width, avg])
                    map[i:i + curr_height, j:j + curr_width] = 0
        cells = []
        # Creation of the visual shapes, for documentation of the visual shapes
        # please look here: https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit#heading=h.q1gn7v6o58bf
        for box in boxes:
            visual = p.createVisualShape(p.GEOM_BOX,
                                         halfExtents=[(box[1] * self.resolution) / 2, (box[2] * self.resolution) / 2,
                                                      0.001],
                                         rgbaColor=[1, 0, 0, 0.6],
                                         visualFramePosition=[(box[0][0] + box[1] / 2) * self.resolution,
                                                              (box[0][1] + box[2] / 2) * self.resolution, 0.])
            cells.append(visual)
        # Set to 127 for since this is the maximal amount of links in a multibody
        for cell_parts in self._chunks(cells, 127):
            # Dummy paramater since these are needed to spawn visual shapes as a
            # multibody.
            link_poses = [[0, 0, 0] for c in cell_parts]
            link_orientations = [[0, 0, 0, 1] for c in cell_parts]
            link_masses = [1.0 for c in cell_parts]
            link_parent = [0 for c in cell_parts]
            link_joints = [p.JOINT_FIXED for c in cell_parts]
            link_collision = [-1 for c in cell_parts]
            link_joint_axis = [[1, 0, 0] for c in cell_parts]
            # The position at which the multibody will be spawned. Offset such that
            # the origin referes to the centre of the costmap.
            # origin_pose = self.origin.position_as_list()
            # base_pose = [origin_pose[0] - self.height / 2 * self.resolution,
            #              origin_pose[1] - self.width / 2 * self.resolution, origin_pose[2]]

            offset = [[-self.height / 2 * self.resolution, -self.width / 2 * self.resolution, 0.05], [0, 0, 0, 1]]
            new_pose = p.multiplyTransforms(self.origin.position_as_list(), self.origin.orientation_as_list(),
                                            offset[0], offset[1])

            map_obj = p.createMultiBody(baseVisualShapeIndex=-1, linkVisualShapeIndices=cell_parts,
                                        basePosition=new_pose[0], baseOrientation=new_pose[1], linkPositions=link_poses,
                                        # [0, 0, 1, 0]
                                        linkMasses=link_masses, linkOrientations=link_orientations,
                                        linkInertialFramePositions=link_poses,
                                        linkInertialFrameOrientations=link_orientations, linkParentIndices=link_parent,
                                        linkJointTypes=link_joints, linkJointAxis=link_joint_axis,
                                        linkCollisionShapeIndices=link_collision)
            self.vis_ids.append(map_obj)

    def _chunks(self, lst: List, n: int) -> List:
        """
        Yield successive n-sized chunks from lst.

        :param lst: The list from which chunks should be yielded
        :param n: Size of the chunks
        :return: A list of size n from lst
        """
        for i in range(0, len(lst), n):
            yield lst[i:i + n]

    def close_visualization(self) -> None:
        """
        Removes the visualization from the World.
        """
        for v_id in self.vis_ids:
            self.world.remove_object_by_id(v_id)
        self.vis_ids = []

    def _find_consectuive_line(self, start: Tuple[int, int], map: np.ndarray) -> int:
        """
        Finds the number of consecutive entries in the costmap which are greater
        than zero.

        :param start: The indices in the costmap from which the consecutive line should be found.
        :param map: The costmap in which the line should be found.
        :return: The length of the consecutive line of entries greater than zero.
        """
        width = map.shape[1]
        lenght = 0
        for i in range(start[1], width):
            if map[start[0]][i] > 0:
                lenght += 1
            else:
                return lenght
        return lenght

    def _find_max_box_height(self, start: Tuple[int, int], length: int, map: np.ndarray) -> int:
        """
        Finds the maximal height for a rectangle with a given width in a costmap.
        The method traverses one row at a time and checks if all entries for the
        given width are greater than zero. If an entry is less or equal than zero
        the height is returned.

        :param start: The indices in the costmap from which the method should start.
        :param length: The given width for the rectangle
        :param map: The costmap in which should be searched.
        :return: The height of the rectangle.
        """
        height, width = map.shape
        curr_height = 1
        for i in range(start[0], height):
            for j in range(start[1], start[1] + length):
                if map[i][j] <= 0:
                    return curr_height
            curr_height += 1
        return curr_height

    def merge(self, other_cm: Costmap) -> Costmap:
        """
        Merges the values of two costmaps and returns a new costmap that has for
        every cell the merged values of both inputs. To merge two costmaps they
        need to fulfill 3 constrains:

        1. They need to have the same size
        2. They need to have the same x and y coordinates in the origin
        3. They need to have the same resolution

        If any of these constrains is not fulfilled a ValueError will be raised.

        :param other_cm: The other costmap with which this costmap should be merged.
        :return: A new costmap that contains the merged values
        """
        if self.size != other_cm.size:
            raise ValueError("You can only merge costmaps of the same size.")
        elif self.origin.position.x != other_cm.origin.position.x or self.origin.position.y != other_cm.origin.position.y \
                or self.origin.orientation != other_cm.origin.orientation:
            raise ValueError("To merge costmaps, the x and y coordinate as well as the orientation must be equal.")
        elif self.resolution != other_cm.resolution:
            raise ValueError("To merge two costmaps their resolution must be equal.")
        new_map = np.zeros((self.height, self.width))
        # A nunpy array of the positions where both costmaps are greater than 0
        merge = np.logical_and(self.map > 0, other_cm.map > 0)
        new_map[merge] = self.map[merge] * other_cm.map[merge]
        new_map = (new_map / np.max(new_map)).reshape((self.height, self.width))
        return Costmap(self.resolution, self.height, self.width, self.origin, new_map)

    def __add__(self, other: Costmap) -> Costmap:
        """
        Overloading of the "+" operator for merging of Costmaps. Furthermore, checks if 'other' is actual a Costmap and
        raises a ValueError if this is not the case. Please check :func:`~Costmap.merge` for further information of merging.

        :param other: Another Costmap
        :return: A new Costmap that contains the merged values from this Costmap and the other Costmap
        """
        if isinstance(other, Costmap):
            return self.merge(other)
        else:
            raise ValueError(f"Can only combine two costmaps other type was {type(other)}")

    def partitioning_rectangles(self) -> List[Rectangle]:
        """
        Partition the map attached to this costmap into rectangles. The rectangles are axis aligned, exhaustive and
        disjoint sets.

        :return: A list containing the partitioning rectangles
        """
        ocm_map = np.copy(self.map)
        origin = np.array([self.height / 2, self.width / 2]) * -1
        rectangles = []

        # for every index pair (i, j) in the occupancy costmap
        for i in range(0, self.map.shape[0]):
            for j in range(0, self.map.shape[1]):

                # if this index has not been used yet
                if ocm_map[i][j] > 0:
                    curr_width = self._find_consectuive_line((i, j), ocm_map)
                    curr_pose = (i, j)
                    curr_height = self._find_max_box_height((i, j), curr_width, ocm_map)

                    # calculate the rectangle in the costmap
                    x_lower = curr_pose[0]
                    x_upper = curr_pose[0] + curr_height
                    y_lower = curr_pose[1]
                    y_upper = curr_pose[1] + curr_width

                    # mark the found rectangle as occupied
                    ocm_map[i:i + curr_height, j:j + curr_width] = 0

                    # transform rectangle to map space
                    rectangle = Rectangle(x_lower, x_upper, y_lower, y_upper)
                    rectangle.translate(*origin)
                    rectangle.scale(self.resolution, self.resolution)
                    rectangles.append(rectangle)

        return rectangles


class OccupancyCostmap(Costmap):
    """
    The occupancy Costmap represents a map of the environment where obstacles or
    positions which are inaccessible for a robot have a value of -1.
    """

    def __init__(self, distance_to_obstacle: float,
                 from_ros: Optional[bool] = False,
                 size: Optional[int] = 100,
                 resolution: Optional[float] = 0.02,
                 origin: Optional[Pose] = None,
                 world: Optional[World] = None):
        """
        Constructor for the Occupancy costmap, the actual costmap is received
        from the ROS map_server and wrapped by this class. Meta-data about the
        costmap is also received from the map_server.

        :param distance_to_obstacle: The distance by which the obstacles should be
            inflated. Meaning that obstacles in the costmap are growing bigger by this
            distance.
        :param from_ros: This determines if the Occupancy map should be created
            from the map provided by the ROS map_server or from the World.
            If True then the map from the ROS map_server will be used otherwise
            the Occupancy map will be created from the World.
        :param size: The length of the side of the costmap. The costmap will be created
            as a square. This will only be used if from_ros is False.
        :param resolution: The resolution of this costmap. This determines how much
            meter one pixel in the costmap represents. This is only used if from_ros
            is False.
        :param origin: This determines the origin of the costmap. The origin will
            be in the middle of the costmap. This parameter is only used if from_ros
            is False.
        """
        self.world = world if world else World.current_world
        if from_ros:
            meta = self._get_map_metadata()
            self.original_map = np.reshape(self._get_map(), (meta.height, meta.width))
            self.meta_origin = [meta.origin.position.x, meta.origin.position.y, meta.origin.position.z]
            self.resolution = meta.resolution
            self.height = meta.height
            self.width = meta.width
            # Nunber of cells that have to be between a valid cell and an obstacle
            self.distance_obstacle = max(int(distance_to_obstacle / self.resolution), 1)
            Costmap.__init__(self, meta.resolution, meta.height, meta.width,
                             self._calculate_diff_origin(meta.height, meta.width),
                             np.rot90(np.flip(self._convert_map(self.original_map), 0)))
        else:
            self.size = size
            self.origin = Pose() if not origin else origin
            self.resolution = resolution
            self.distance_obstacle = max(int(distance_to_obstacle / self.resolution), 1)
            self.map = self._create_from_world(size, resolution)
            Costmap.__init__(self, resolution, size, size, self.origin, self.map)

    def _calculate_diff_origin(self, height: int, width: int) -> Pose:
        """
        Calculates the difference between the origin of the costmap
        as stated by the meta-data and the actual middle of the costmap which
        is used by PyCRAM to visualize the costmap. The origin as stated by the
        meta-data refers to the position of the global coordinate frame with
        the bottom left corner as reference.

        :param height: The height of the costmap
        :param width: The width of the costmap
        :return: The difference between the actual origin and center of the costmap
        """
        actual_origin = [int(height / 2) * self.resolution, int(width / 2) * self.resolution, 0]
        origin = np.array(self.meta_origin) + np.array(actual_origin)
        return Pose(origin.tolist())

    @staticmethod
    def _get_map() -> np.ndarray:
        """
        Receives the map array from the map_server converts it and into a numpy array.

        :return: The costmap as a numpy array.
        """
        print("Waiting for Map")
        map = rospy.wait_for_message("/map", OccupancyGrid)
        print("Recived Map")
        return np.array(map.data)

    @staticmethod
    def _get_map_metadata() -> MapMetaData:
        """
        Receives the meta-data about the costmap from the map_server and returns it.
        The meta-data contains things like, height, width, origin and resolution.

        :return: The meta-data for the costmap array.
        """
        print("Waiting for Map Meta Data")
        meta = rospy.wait_for_message("/map_metadata", MapMetaData)
        print("Recived Meta Data")
        return meta

    def _convert_map(self, map: np.ndarray) -> np.ndarray:
        """
        Converts the Occupancy Map received from ROS to be more consistent
        with how PyCRAM handles its costmap. Every possible cell for a robot to stand
        is set to one while anything else is set to zero. Additionally, this method
        also takes into account the distance_to_obstacle parameter and sets cell values
        that are too close to an obstacle to 0.

        :param map: The map that should be converted. Represented as 2d numpy array
        :return: The converted map. Represented as 2d numpy array.
        """
        map = np.pad(map, (int(self.distance_obstacle / 2), int(self.distance_obstacle / 2)))

        sub_shape = (self.distance_obstacle, self.distance_obstacle)
        view_shape = tuple(np.subtract(map.shape, sub_shape) + 1) + sub_shape
        strides = map.strides + map.strides

        sub_matrices = np.lib.stride_tricks.as_strided(map, view_shape, strides)
        sub_matrices = sub_matrices.reshape(sub_matrices.shape[:-2] + (-1,))
        sum = np.sum(sub_matrices, axis=2)
        return (sum == 0).astype('int16')

    def create_sub_map(self, sub_origin: Pose, size: int) -> Costmap:
        """
        Creates a smaller map from the overall occupancy map, the new map is centered
        around the point specified by "sub_origin" and has the size "size". The
        resolution of the costmap stays the same for the sub costmap.

        :param sub_origin: The point in global coordinate frame, around which the sub costmap should be centered.
        :param size: The size the sub costmap should have.
        :return: The sub costmap, represented as 2d numpy array.
        """
        # To ensure this is a numpy array
        sub_origin = np.array(sub_origin.position_as_list())
        # Since origin obtained from the meta data uses bottom left corner as reference.
        sub_origin *= -1
        # Calculates origin of sub costmap as vector between origin and given sub_origin
        new_origin = np.array(self.meta_origin) + sub_origin
        # Convert from vector in meter to index values
        new_origin /= self.resolution
        new_origin = np.abs(new_origin)
        # Offset to top left corner, for easier slicing
        new_origin = (new_origin - size / 2).astype(int)

        # slices a submap with size "size" around the given origin
        sub_map = self.original_map[new_origin[1]: new_origin[1] + size,
                  new_origin[0]: new_origin[0] + size]
        # Convert map to fit with the other costmaps
        sub_map = np.rot90(np.flip(self._convert_map(sub_map), 0))
        return Costmap(self.resolution, size, size, Pose(list(sub_origin * -1)), sub_map)

    def _create_from_world(self, size: int, resolution: float) -> np.ndarray:
        """
        Creates an Occupancy Costmap for the specified World.
        This map marks every position as valid that has no object above it. After
        creating the costmap the distance to obstacle parameter is applied.

        :param size: The size of this costmap. The size specifies the length of one side of the costmap. The costmap is created as a square.
        :param resolution: The resolution of this costmap. This determines how much meter a pixel in the costmap represents.
        """
        origin_position = self.origin.position_as_list()
        # Generate 2d grid with indices
        indices = np.concatenate(np.dstack(np.mgrid[int(-size / 2):int(size / 2), int(-size / 2):int(size / 2)]),
                                 axis=0) * resolution + np.array(origin_position[:2])
        # Add the z-coordinate to the grid, which is either 0 or 10
        indices_0 = np.pad(indices, (0, 1), mode='constant', constant_values=5)[:-1]
        indices_10 = np.pad(indices, (0, 1), mode='constant', constant_values=0)[:-1]
        # Zips both arrays such that there are tuples for every coordinate that
        # only differ in the z-coordinate
        rays = np.dstack(np.dstack((indices_0, indices_10))).T

        res = np.zeros(len(rays))
        # Using the World rayTest to check if there is an object above the position
        # if there is no object the position is marked as valid
        # 16383 is the maximal number of rays that can be processed in a batch
        i = 0
        j = 0
        for n in self._chunks(np.array(rays), 16380):
            # with UseProspectionWorld():
            r_t = World.current_world.ray_test_batch(n[:, 0], n[:, 1], num_threads=0)
            while r_t is None:
                r_t = World.current_world.ray_test_batch(n[:, 0], n[:, 1], num_threads=0)
            j += len(n)
            if World.robot:
                attached_objs_id = [o.id for o in self.world.robot.attachments.keys()]
                res[i:j] = [
                    1 if ray[0] == -1 or ray[0] == self.world.robot.id or ray[0] in attached_objs_id else 0 for
                    ray in r_t]
            else:
                res[i:j] = [1 if ray[0] == -1 else 0 for ray in r_t]
            i += len(n)

        res = np.flip(np.reshape(np.array(res), (size, size)))

        map = np.pad(res, (int(self.distance_obstacle / 2), int(self.distance_obstacle / 2)))

        sub_shape = (self.distance_obstacle * 2, self.distance_obstacle * 2)
        view_shape = tuple(np.subtract(map.shape, sub_shape) + 1) + sub_shape
        strides = map.strides + map.strides

        sub_matrices = np.lib.stride_tricks.as_strided(map, view_shape, strides)
        sub_matrices = sub_matrices.reshape(sub_matrices.shape[:-2] + (-1,))

        sum = np.sum(sub_matrices, axis=2)
        map = (sum == (self.distance_obstacle * 2) ** 2).astype('int16')
        # The map loses some size due to the strides and because I dont want to
        # deal with indices outside of the index range
        offset = self.size - map.shape[0]
        odd = 0 if offset % 2 == 0 else 1
        map = np.pad(map, (offset // 2, offset // 2 + odd))

        return np.flip(map)

    def _chunks(self, lst: List, n: int) -> List:
        """
        Yield successive n-sized chunks from lst.

        :param lst: The list from which chunks should be yielded
        :param n: Size of the chunks
        :return: A list of size n from lst
        """
        for i in range(0, len(lst), n):
            yield lst[i:i + n]


class VisibilityCostmap(Costmap):
    """
    A costmap that represents the visibility of a specific point for every position around
    this point. For a detailed explanation on how the creation of the costmap works
    please look here: `PhD Thesis (page 173) <https://mediatum.ub.tum.de/doc/1239461/1239461.pdf>`_
    """

    def __init__(self, min_height: float,
                 max_height: float,
                 size: Optional[int] = 100,
                 resolution: Optional[float] = 0.02,
                 origin: Optional[Pose] = None,
                 world: Optional[World] = None):
        """
        Visibility Costmaps show for every position around the origin pose if the origin can be seen from this pose.
        The costmap is able to deal with height differences of the camera while in a single position, for example, if
        the robot has a movable torso.

        :param min_height: This is the minimal height the camera can be. This parameter
            is mostly relevant if the vertical position of the camera can change.
        :param max_height: This is the maximal height the camera can be. This is
            mostly relevant if teh vertical position of the camera can change.
        :param size: The length of the side of the costmap, the costmap is created
            as a square.
        :param resolution: This parameter specifies how much meter a pixel in the
            costmap represents.
        :param origin: The pose in world coordinate frame around which the
            costmap should be created.
        :param world: The World for which the costmap should be created.
        """
        if (11 * size ** 2 + size ** 3) * 2 > psutil.virtual_memory().available:
            raise OSError("Not enough free RAM to calculate a costmap of this size")

        self.world = world if world else World.current_world
        self.map = np.zeros((size, size))
        self.size = size
        self.resolution = resolution
        # for pr2 = 1.27
        self.max_height: float = max_height
        # for pr2 = 1.6
        self.min_height: float = min_height
        self.origin: Pose = Pose() if not origin else origin
        self._generate_map()
        Costmap.__init__(self, resolution, size, size, self.origin, self.map)

    def _create_images(self) -> List[np.ndarray]:
        """
        Creates four depth images in every direction around the point
        for which the costmap should be created. The depth images are converted
        to metre, meaning that every entry in the depth images represents the
        distance to the next object in metre.

        :return: A list of four depth images, the images are represented as 2D arrays.
        """
        images = []
        camera_pose = self.origin

        with UseProspectionWorld():
            origin_copy = self.origin.copy()
            origin_copy.position.y += 1
            images.append(
                self.world.get_images_for_target(origin_copy, camera_pose, size=self.size)[1])

            origin_copy = self.origin.copy()
            origin_copy.position.x -= 1
            images.append(self.world.get_images_for_target(origin_copy, camera_pose, size=self.size)[1])

            origin_copy = self.origin.copy()
            origin_copy.position.y -= 1
            images.append(self.world.get_images_for_target(origin_copy, camera_pose, size=self.size)[1])

            origin_copy = self.origin.copy()
            origin_copy.position.x += 1
            images.append(self.world.get_images_for_target(origin_copy, camera_pose, size=self.size)[1])

        for i in range(0, 4):
            images[i] = self._depth_buffer_to_meter(images[i])
        return images

    def _depth_buffer_to_meter(self, buffer: np.ndarray) -> np.ndarray:
        """
        Converts the depth images generated by the World to represent
        each position in metre.

        :return: The depth image in metre
        """
        near = 0.2
        far = 100
        return far * near / (far - (far - near) * buffer)

    def _generate_map(self):
        """
        This method generates the resulting density map by using the algorithm explained
        in Lorenz Mösenlechners `PhD Thesis (page 178) <https://mediatum.ub.tum.de/doc/1239461/1239461.pdf>`_
        The resulting map is then saved to :py:attr:`self.map`
        """
        depth_imgs = self._create_images()
        # A 2D array where every cell contains the arctan2 value with respect to
        # the middle of the array. Additionally, the interval is shifted such that
        # it is between 0 and 2pi
        tan = np.arctan2(np.mgrid[-int(self.size / 2): int(self.size / 2), -int(self.size / 2): int(self.size / 2)][0],
                         np.mgrid[-int(self.size / 2): int(self.size / 2), -int(self.size / 2): int(self.size / 2)][
                             1]) + np.pi
        res = np.zeros(tan.shape)

        # Just for completion, since the res array has zeros in every position this
        # operation is not necessary.
        # res[np.logical_and(tan <= np.pi * 0.25, tan >= np.pi * 1.75)] = 0

        # Creates a 2D array which contains the index of the depth image for every
        # coordinate
        res[np.logical_and(tan >= np.pi * 1.25, tan <= np.pi * 1.75)] = 3
        res[np.logical_and(tan >= np.pi * 0.75, tan < np.pi * 1.25)] = 2
        res[np.logical_and(tan >= np.pi * 0.25, tan < np.pi * 0.75)] = 1

        indices = np.dstack(np.mgrid[0: self.size, 0: self.size])
        depth_indices = np.zeros(indices.shape)
        # x-value of index: res == n, :1
        # y-value of index: res == n, 1:2

        # (y, size-x-1) for index between 1.25 pi and 1.75 pi
        depth_indices[res == 3, :1] = indices[res == 3, 1:2]
        depth_indices[res == 3, 1:2] = self.size - indices[res == 3, :1] - 1

        # (size-x-1, y) for index between 0.75 pi and 1.25 pi
        depth_indices[res == 2, :1] = self.size - indices[res == 2, :1] - 1
        depth_indices[res == 2, 1:2] = indices[res == 2, 1:2]

        # (size-y-1, x) for index between 0.25 pi and 0.75 pi
        depth_indices[res == 1, :1] = self.size - indices[res == 1, 1:2] - 1
        depth_indices[res == 1, 1:2] = indices[res == 1, :1]

        # (x, y) for index between 0.25 pi and 1.75 pi
        depth_indices[res == 0, :1] = indices[res == 0, :1]
        depth_indices[res == 0, 1:2] = indices[res == 0, 1:2]

        # Convert back to origin in the middle of the costmap
        depth_indices[:, :, :1] -= self.size / 2
        depth_indices[:, :, 1:2] = np.absolute(self.size / 2 - depth_indices[:, :, 1:2])

        # Sets the y index for the coordinates of the middle of the costmap to 1,
        # the computed value is 0 which would cause an error in the next step where
        # the calculation divides the x coordinates by the y coordinates
        depth_indices[int(self.size / 2), int(self.size / 2), 1] = 1

        # Calculate columns for the respective position in the costmap
        columns = np.around(((depth_indices[:, :, :1] / depth_indices[:, :, 1:2])
                             * (self.size / 2)) + self.size / 2).reshape((self.size, self.size)).astype('int16')

        # An array with size * size that contains the euclidean distance to the
        # origin (in the middle of the costmap) from every cell
        distances = np.maximum(np.linalg.norm(np.dstack(np.mgrid[-int(self.size / 2): int(self.size / 2), \
                                                        -int(self.size / 2): int(self.size / 2)]), axis=2), 0.001)

        # Row ranges
        # Calculation of the ranges of coordinates in the row which have to be
        # taken into account. The range is from r_min to r_max.
        # These are two arrays with shape: size*size, the r_min constrains the beginning
        # of the range for every coordinate and r_max contains the end for each
        # coordinate
        r_min = (np.arctan((self.min_height - self.origin.position.z) / distances) * self.size) + self.size / 2
        r_max = (np.arctan((self.max_height - self.origin.position.z) / distances) * self.size) + self.size / 2

        r_min = np.minimum(np.around(r_min), self.size - 1).astype('int16')
        r_max = np.minimum(np.around(r_max), self.size - 1).astype('int16')

        rs = np.dstack((r_min, r_max + 1)).reshape((self.size ** 2, 2))
        r = np.arange(self.size)
        # Calculates a mask from the r_min and r_max values. This mask is for every
        # coordinate respectively and determines which values from the computed column
        # of the depth image should be taken into account for the costmap.
        # A Mask of a single coordinate has the length of the column of the depth image
        # and together with the computed column at this coordinate determines which
        # values of the depth image make up the value of the visibility costmap at this
        # point.
        mask = ((rs[:, 0, None] <= r) & (rs[:, 1, None] > r)).reshape((self.size, self.size, self.size))

        values = np.zeros((self.size, self.size))
        map = np.zeros((self.size, self.size))
        # This is done to iterate over the depth images one at a time
        for i in range(4):
            row_masks = mask[res == i].T
            # This statement does several things, first it takes the values from
            # the depth image for this quarter of the costmap. The values taken are
            # the complete columns of the depth image (which where computed beforehand)
            # and checks if the values in them are greater than the distance to the
            # respective coordinates. This does not take the row ranges into account.
            values = depth_imgs[i][:, columns[res == i].flatten()] > \
                     np.tile(distances[res == i][:, None], (1, self.size)).T * self.resolution
            # This applies the created mask of the row ranges to the values of
            # the columns which are compared in the previous statement
            masked = np.ma.masked_array(values, mask=~row_masks)
            # The calculated values are added to the costmap
            map[res == i] = np.sum(masked, axis=0)
        map /= np.max(map)
        # Weird flipping shit so that the map fits the orientation of the visualization.
        # the costmap in itself is consistent and just needs to be flipped to fit the world coordinate system
        map = np.flip(map, axis=0)
        map = np.flip(map)
        self.map = map


class GaussianCostmap(Costmap):
    """
    Gaussian Costmaps are 2D gaussian distributions around the origin with the given mean and sigma
    """

    def __init__(self, mean: int, sigma: float, resolution: Optional[float] = 0.02,
                 origin: Optional[Pose] = None):
        """
        This Costmap creates a 2D gaussian distribution around the origin with
        the specified size.

        :param mean: The mean input for the gaussian distribution, this also specifies
            the length of the side of the resulting costmap. The costmap is Created
            as a square.
        :param sigma: The sigma input for the gaussian distribution.
        :param resolution: The resolution of the costmap, this specifies how much
            meter a pixel represents.
        :param origin: The origin of the costmap around which it will be created.
        """
        self.gau: np.ndarray = self._gaussian_window(mean, sigma)
        self.map: np.ndarray = np.outer(self.gau, self.gau)
        self.size: float = mean
        self.origin: Pose = Pose() if not origin else origin
        Costmap.__init__(self, resolution, mean, mean, self.origin, self.map)

    def _gaussian_window(self, mean: int, std: float) -> np.ndarray:
        """
        This method creates a window of values with a gaussian distribution of
        size "mean" and standart deviation "std".
        Code from `Scipy <https://github.com/scipy/scipy/blob/v0.14.0/scipy/signal/windows.py#L976>`_
        """
        n = np.arange(0, mean) - (mean - 1.0) / 2.0
        sig2 = 2 * std * std
        w = np.exp(-n ** 2 / sig2)
        return w


class SemanticCostmap(Costmap):
    """
    Semantic Costmaps represent a 2D distribution over a link of an Object. An example of this would be a Costmap for a
    table surface.
    """

    def __init__(self, object, urdf_link_name, size=100, resolution=0.02, world=None):
        """
        Creates a semantic costmap for the given parameter. The semantic costmap will be on top of the link of the given
        Object.

        :param object: The object of which the link is a part
        :param urdf_link_name: The link name, as stated in the URDF
        :param resolution: Resolution of the final costmap
        :param world: The World from which the costmap should be created
        """
        self.world: World = world if world else World.current_world
        self.object: Object = object
        self.link: Link = object.get_link(urdf_link_name)
        self.resolution: float = resolution
        self.origin: Pose = object.get_link_pose(urdf_link_name)
        self.height: int = 0
        self.width: int = 0
        self.map: np.ndarray = []
        self.generate_map()

        Costmap.__init__(self, resolution, self.height, self.width, self.origin, self.map)

    def generate_map(self) -> None:
        """
        Generates the semantic costmap according to the provided parameters. To do this the axis aligned bounding box (AABB)
        for the link name will be used. Height and width of the final Costmap will be the x and y sizes of the AABB.
        """
        min_p, max_p = self.get_aabb_for_link().get_min_max_points()
        self.height = int((max_p.x - min_p.x) // self.resolution)
        self.width = int((max_p.y - min_p.y) // self.resolution)
        self.map = np.ones((self.height, self.width))

    def get_aabb_for_link(self) -> AxisAlignedBoundingBox:
        """
        Returns the axis aligned bounding box (AABB) of the link provided when creating this costmap. To try and let the
        AABB as close to the actual object as possible, the Object will be rotated such that the link will be in the
        identity orientation.

        :return: Two points in world coordinate space, which span a rectangle
        """
        prospection_object = World.current_world.get_prospection_object_for_object(self.object)
        with UseProspectionWorld():
            prospection_object.set_orientation(Pose(orientation=[0, 0, 0, 1]))
            link_pose_trans = self.link.transform
            inverse_trans = link_pose_trans.invert()
            prospection_object.set_orientation(inverse_trans.to_pose())
            return self.link.get_axis_aligned_bounding_box()


cmap = colors.ListedColormap(['white', 'black', 'green', 'red', 'blue'])


# Mainly used for debugging
# Data is 2d array
def plot_grid(data: np.ndarray) -> None:
    """
    An auxiliary method only used for debugging, it will plot a 2D numpy array using MatplotLib.
    """
    rows = data.shape[0]
    cols = data.shape[1]
    fig, ax = plt.subplots()
    ax.imshow(data, cmap=cmap)
    # draw gridlines
    # ax.grid(which='major', axis='both', linestyle='-', rgba_color='k', linewidth=1)
    ax.set_xticks(np.arange(0.5, rows, 1));
    ax.set_yticks(np.arange(0.5, cols, 1));
    plt.tick_params(axis='both', labelsize=0, length=0)
    # fig.set_size_inches((8.5, 11), forward=False)
    # plt.savefig(saveImageName + ".png", dpi=500)
    plt.show()


##New # Content from: #<src/pycram/plan_failures.py>#
class PlanFailure(Exception):
    """Implementation of plan failures."""

    def __init__(self, *args, **kwargs):
        """Create a new plan failure."""
        Exception.__init__(self, *args, **kwargs)


class NotALanguageExpression(PlanFailure):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class FailureDiagnosis(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class LowLevelFailure(FailureDiagnosis):
    """Failure thrown by low-level modules: robot or projection PMs."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ActionlibActionTimeout(LowLevelFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class HighLevelFailure(FailureDiagnosis):
    """Failure thrown by high-level modules, i.e. plans."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class DeliveringFailed(HighLevelFailure):
    """Thrown when delivering plan completely gives up."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ManipulationLowLevelFailure(LowLevelFailure):
    """Thrown when a low-level, i.e. hardware related, failure is detected in a manipulation action."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class EnvironmentManipulationGoalNotReached(ManipulationLowLevelFailure):
    """Thrown when door / drawer opening / closing goal is still not reached."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class EnvironmentManipulationImpossible(HighLevelFailure):
    """Thrown when environment manipulation cannot be achieved."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class EnvironmentUnreachable(HighLevelFailure):
    """Thrown when environment manipulation in collision or unreachable."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class FetchingFailed(HighLevelFailure):
    """Thrown when fetching plan completely gives up."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class GripperLowLevelFailure(LowLevelFailure):
    """Thrown when a failure involving the gripper hardware occurs."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class GripperClosedCompletely(GripperLowLevelFailure):
    """Thrown when the gripper closed completely, despite not being expected to do so (e.g. because it should have
    grasped something)."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class GripperGoalNotReached(GripperLowLevelFailure):
    """Thrown when the gripper does not reach its goal."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class LookingHighLevelFailure(HighLevelFailure):
    """High-level failure produced when looking for an object, i.e. it is not a hardware issue but one relating to
    the looking task, its parameters, and how they relate to the environment."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ManipulationGoalInCollision(HighLevelFailure):
    """Thrown when executing a manipulation action results in a collision."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ManipulationGoalNotReached(ManipulationLowLevelFailure):
    """Thrown when after executing the action, goal is still not reached."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class IKError(PlanFailure):
    """Thrown when no inverse kinematics solution could be found"""
    def __init__(self, pose, base_frame, tip_frame):
        self.message = "Position {} in frame '{}' is not reachable for end effector: '{}'".format(pose, base_frame, tip_frame)
        super(IKError, self).__init__(self.message)


class ManipulationPoseUnreachable(ManipulationLowLevelFailure):
    """Thrown when no IK solution can be found."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationHighLevelFailure(HighLevelFailure):
    """High-level failure produced while navigating the robot, i.e. it is not a hardware issue but one relating to
    the navigation task, its parameters, and how they relate to the environment."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationGoalInCollision(NavigationHighLevelFailure):
    """Navigation goal cannot be reached because the goal itself is already occupied by some other object."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationLowLevelFailure(LowLevelFailure):
    """Low-level failure produced while navigating the robot, i.e. some kind of hardware issue."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationGoalNotReached(NavigationLowLevelFailure):
    """Thrown when the base moved as a result of the navigation action but the goal was not reached."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class NavigationPoseUnreachable(NavigationLowLevelFailure):
    """Thrown when the goal pose for navigation is computed to be unreachable."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectNowhereToBeFound(HighLevelFailure):
    """Thrown when the robot cannot find an object of a given description in its surroundings."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectUndeliverable(HighLevelFailure):
    """Thrown when no base positioning can assure a reachable pose to place the object from."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectUnfetchable(HighLevelFailure):
    """Thrown when no base positioning can assure a reachable pose to grasp the object from."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectUnreachable(HighLevelFailure):
    """Thrown when no IK found for particular base pose."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class PerceptionLowLevelFailure(LowLevelFailure):
    """Low-level failure produced while perceiving, i.e. some kind of hardware issue."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class PerceptionObjectNotFound(PerceptionLowLevelFailure):
    """Thrown when an attempt to find an object by perception fails -- and this can still be interpreted as the robot
    not looking in the right direction, as opposed to the object being absent."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class PerceptionObjectNotInWorld(PerceptionLowLevelFailure):
    """Thrown when an attempt to find an object by perception fails -- and this is because the object can be assumed
    absent or perhaps is known absent because of the setup of a simulation."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SearchingFailed(HighLevelFailure):
    """Thrown when searching plan completely gives up."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class TorsoLowLevelFailure(LowLevelFailure):
    """Low-level failure produced while moving the torso, i.e. some kind of hardware issue."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class TorsoGoalNotReached(TorsoLowLevelFailure):
    """Thrown when the torso moved as a result of a torso action but the goal was not reached."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class TorsoGoalUnreachable(TorsoLowLevelFailure):
    """Thrown when the goal for the torso is computed to be unreachable."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class Task(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class Grasping(Task):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class Looking(Task):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectPoseMisestimation(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SuccessfulCompletion(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectNotFound(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class LocomotorFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ArmFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectLost(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SensorFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class IllPosedGoalFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class CapabilityAbsenceFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ReachabilityFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class TorsoFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ConfigurationNotReached(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class Timeout(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class EndEffectorFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ObjectUnavailable(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SustainedFailure(PlanFailure):
    """"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class ReasoningError(PlanFailure):
    def __init__(*args, **kwargs):
        super().__init__(*args, **kwargs)


class CollisionError(PlanFailure):
    def __init__(*args, **kwargs):
        super().__init__(*args, **kwargs)


##New # Content from: #<src/pycram/ros/tf_broadcaster.py>#
import time
import rospy
import threading
import atexit

from ..datastructures.pose import Pose
from ..datastructures.world import World
from tf2_msgs.msg import TFMessage


class TFBroadcaster:
    """
    Broadcaster that publishes TF frames for every object in the World.
    """
    def __init__(self, projection_namespace= ExecutionType.SIMULATED, odom_frame="odom", interval=0.1):
        """
        The broadcaster prefixes all published TF messages with a projection namespace to distinguish between the TF
        frames from the simulation and the one from the real robot.

        :param projection_namespace: Name with which the TF frames should be prefixed
        :param odom_frame: Name of the statically published odom frame
        :param interval: Interval at which the TFs should be published, in seconds
        """
        self.world = World.current_world

        self.tf_static_publisher = rospy.Publisher("/tf_static", TFMessage, queue_size=10)
        self.tf_publisher = rospy.Publisher("/tf", TFMessage, queue_size=10)
        self.thread = threading.Thread(target=self._publish, daemon=True)
        self.kill_event = threading.Event()
        self.interval = interval

        # Namespaces
        self.projection_namespace = projection_namespace
        self.odom_frame = odom_frame

        self.thread.start()

        atexit.register(self._stop_publishing)

    def update(self):
        """
        Updates the TFs for the static odom frame and all objects currently in the World.
        """
        # Update static odom
        self._update_static_odom()
        # Update pose of objects which are possibly attached on the robot
        self._update_objects()

    def _update_objects(self) -> None:
        """
        Publishes the current pose of all objects in the World. As well as the poses of all links of these objects.
        """
        for obj in self.world.objects:
            pose = obj.get_pose()
            pose.header.stamp = rospy.Time.now()
            self._publish_pose(obj.tf_frame, pose)
            for link in obj.link_name_to_id.keys():
                link_pose = obj.get_link_pose(link)
                link_pose.header.stamp = rospy.Time.now()
                self._publish_pose(obj.get_link_tf_frame(link), link_pose)

    def _update_static_odom(self) -> None:
        """
        Publishes a static odom frame to the tf_static topic.
        """
        self._publish_pose(self.odom_frame,
                           Pose([0, 0, 0], [0, 0, 0, 1]), static=True)

    def _publish_pose(self, child_frame_id: str, pose: Pose, static=False) -> None:
        """
        Publishes the given pose to the ROS TF topic. First the pose is converted to a Transform between pose.frame and
        the given child_frame_id. Afterward, the frames of the Transform are prefixed with the projection namespace.

        :param child_frame_id: Name of the TF frame which the pose points to
        :param pose: Pose that should be published
        :param static: If the pose should be published to the tf_static topic
        """
        frame_id = pose.frame
        if frame_id != child_frame_id:
            tf_stamped = pose.to_transform(child_frame_id)
            tf_stamped.frame = self.projection_namespace + "/" + tf_stamped.frame
            tf_stamped.child_frame_id = self.projection_namespace + "/" + tf_stamped.child_frame_id
            tf2_msg = TFMessage()
            tf2_msg.transforms.append(tf_stamped)
            if static:
                self.tf_static_publisher.publish(tf2_msg)
            else:
                self.tf_publisher.publish(tf2_msg)

    def _publish(self) -> None:
        """
        Constantly publishes the positions of all objects in the World.
        """
        while not self.kill_event.is_set():
            self.update()
            time.sleep(self.interval)

    def _stop_publishing(self) -> None:
        """
        Called when the process ends, sets the kill_event which terminates the thread that publishes to the TF topic.
        """
        self.kill_event.set()
        self.thread.join()


##New # Content from: #<src/pycram/ros/force_torque_sensor.py>#
import atexit
import time
import threading

import rospy

from geometry_msgs.msg import WrenchStamped
from std_msgs.msg import Header
from ..datastructures.world import World


class ForceTorqueSensor:
    """
    Simulated force-torque sensor for a joint with a given name.
    Reads simulated forces and torques at that joint from world and publishes geometry_msgs/Wrench messages
    to the given topic.
    """
    def __init__(self, joint_name, fts_topic="/pycram/fts", interval=0.1):
        """
        The given joint_name has to be part of :py:attr:`~pycram.world.World.robot` otherwise a
        RuntimeError will be raised.

        :param joint_name: Name of the joint for which force-torque should be simulated
        :param fts_topic: Name of the ROS topic to which should be published
        :param interval: Interval at which the messages should be published, in seconds
        """
        self.world = World.current_world
        self.fts_joint_idx = None
        self.joint_name = joint_name
        if joint_name in self.world.robot.joint_name_to_id.keys():
            self.fts_joint_idx = self.world.robot.joint_name_to_id[joint_name]
        else:
            raise RuntimeError(f"Could not register ForceTorqueSensor: Joint {joint_name}"
                               f" does not exist in robot object")
        self.world.enable_joint_force_torque_sensor(self.world.robot, self.fts_joint_idx)

        self.fts_pub = rospy.Publisher(fts_topic, WrenchStamped, queue_size=10)
        self.interval = interval
        self.kill_event = threading.Event()

        self.thread = threading.Thread(target=self._publish)
        self.thread.start()

        atexit.register(self._stop_publishing)

    def _publish(self) -> None:
        """
        Continuously publishes the force-torque values for the simulated joint. Values are published as long as the
        kill_event is not set.
        """
        seq = 0
        while not self.kill_event.is_set():
            joint_ft = self.world.get_joint_reaction_force_torque(self.world.robot, self.fts_joint_idx)
            h = Header()
            h.seq = seq
            h.stamp = rospy.Time.now()
            h.frame_id = self.joint_name

            wrench_msg = WrenchStamped()
            wrench_msg.header = h
            wrench_msg.wrench.force.x = joint_ft[0]
            wrench_msg.wrench.force.y = joint_ft[1]
            wrench_msg.wrench.force.z = joint_ft[2]

            wrench_msg.wrench.torque.x = joint_ft[3]
            wrench_msg.wrench.torque.y = joint_ft[4]
            wrench_msg.wrench.torque.z = joint_ft[5]

            self.fts_pub.publish(wrench_msg)
            seq += 1
            time.sleep(self.interval)

    def _stop_publishing(self) -> None:
        """
        Sets the kill_event and therefore terminates the Thread publishing the force-torque values as well as join the
        threads.
        """
        self.kill_event.set()
        self.thread.join()


##New # Content from: #<src/pycram/ros/robot_state_updater.py>#
import rospy
import atexit
import tf
import time 

from geometry_msgs.msg import TransformStamped
from sensor_msgs.msg import JointState
from ..datastructures.world import World
from ..robot_descriptions import robot_description
from ..datastructures.pose import Pose


class RobotStateUpdater:
    """
    Updates the robot in the World with information of the real robot published to ROS topics.
    Infos used to update the robot are:

        * The current pose of the robot
        * The current joint state of the robot
    """

    def __init__(self, tf_topic: str, joint_state_topic: str):
        """
        The robot state updater uses a TF topic and a joint state topic to get the current state of the robot.

        :param tf_topic: Name of the TF topic, needs to publish geometry_msgs/TransformStamped
        :param joint_state_topic: Name of the joint state topic, needs to publish sensor_msgs/JointState
        """
        self.tf_listener = tf.TransformListener()
        time.sleep(1)
        self.tf_topic = tf_topic
        self.joint_state_topic = joint_state_topic

        self.tf_timer = rospy.Timer(rospy.Duration.from_sec(0.1), self._subscribe_tf)
        self.joint_state_timer = rospy.Timer(rospy.Duration.from_sec(0.1), self._subscribe_joint_state)

        atexit.register(self._stop_subscription)

    def _subscribe_tf(self, msg: TransformStamped) -> None:
        """
        Callback for the TF timer, will do a lookup of the transform between map frame and the robot base frame.

        :param msg: TransformStamped message published to the topic
        """
        trans, rot = self.tf_listener.lookupTransform("/map", robot_description.base_frame, rospy.Time(0))
        World.robot.set_pose(Pose(trans, rot))

    def _subscribe_joint_state(self, msg: JointState) -> None:
        """
        Sets the current joint configuration of the robot in the world to the configuration published on the
        topic. Since this uses rospy.wait_for_message which can have errors when used with threads there might be an
        attribute error in the rospy implementation.

        :param msg: JointState message published to the topic.
        """
        try:
            msg = rospy.wait_for_message(self.joint_state_topic, JointState)
            for name, position in zip(msg.name, msg.position):
                World.robot.set_joint_position(name, position)
        except AttributeError:
            pass

    def _stop_subscription(self) -> None:
        """
        Stops the Timer for TF and joint states and therefore the updating of the robot in the world.
        """
        self.tf_timer.shutdown()
        self.joint_state_timer.shutdown()


##New # Content from: #<src/pycram/ros/viz_marker_publisher.py>#
import atexit
import threading
import time
from typing import List, Optional, Tuple

import rospy
from geometry_msgs.msg import Vector3
from std_msgs.msg import ColorRGBA
from visualization_msgs.msg import Marker, MarkerArray

from ..datastructures.dataclasses import BoxVisualShape, CylinderVisualShape, MeshVisualShape, SphereVisualShape
from ..datastructures.pose import Pose, Transform
from ..designator import ObjectDesignatorDescription
from ..datastructures.world import World


class VizMarkerPublisher:
    """
    Publishes an Array of visualization marker which represent the situation in the World
    """

    def __init__(self, topic_name="/pycram/viz_marker", interval=0.1):
        """
        The Publisher creates an Array of Visualization marker with a Marker for each link of each Object in the
        World. This Array is published with a rate of interval.

        :param topic_name: The name of the topic to which the Visualization Marker should be published.
        :param interval: The interval at which the visualization marker should be published, in seconds.
        """
        self.topic_name = topic_name
        self.interval = interval

        self.pub = rospy.Publisher(self.topic_name, MarkerArray, queue_size=10)

        self.thread = threading.Thread(target=self._publish)
        self.kill_event = threading.Event()
        self.main_world = World.current_world if not World.current_world.is_prospection_world else World.current_world.world_sync.world

        self.thread.start()
        atexit.register(self._stop_publishing)

    def _publish(self) -> None:
        """
        Constantly publishes the Marker Array. To the given topic name at a fixed rate.
        """
        while not self.kill_event.is_set():
            marker_array = self._make_marker_array()

            self.pub.publish(marker_array)
            time.sleep(self.interval)

    def _make_marker_array(self) -> MarkerArray:
        """
        Creates the Marker Array to be published. There is one Marker for link for each object in the Array, each Object
        creates a name space in the visualization Marker. The type of Visualization Marker is decided by the collision
        tag of the URDF.

        :return: An Array of Visualization Marker
        """
        marker_array = MarkerArray()
        for obj in self.main_world.objects:
            if obj.name == "floor":
                continue
            for link in obj.link_name_to_id.keys():
                geom = obj.get_link_geometry(link)
                if not geom:
                    continue
                msg = Marker()
                msg.header.frame_id = "map"
                msg.ns = obj.name
                msg.id = obj.link_name_to_id[link]
                msg.type = Marker.MESH_RESOURCE
                msg.action = Marker.ADD
                link_pose = obj.get_link_transform(link)
                if obj.get_link_origin(link) is not None:
                    link_origin = obj.get_link_origin_transform(link)
                else:
                    link_origin = Transform()
                link_pose_with_origin = link_pose * link_origin
                msg.pose = link_pose_with_origin.to_pose().pose

                color = [1, 1, 1, 1] if obj.link_name_to_id[link] == -1 else obj.get_link_color(link).get_rgba()

                msg.color = ColorRGBA(*color)
                msg.lifetime = rospy.Duration(1)

                if isinstance(geom, MeshVisualShape):
                    msg.type = Marker.MESH_RESOURCE
                    msg.mesh_resource = "file://" + geom.file_name
                    msg.scale = Vector3(1, 1, 1)
                    msg.mesh_use_embedded_materials = True
                elif isinstance(geom, CylinderVisualShape):
                    msg.type = Marker.CYLINDER
                    msg.scale = Vector3(geom.radius * 2, geom.radius * 2, geom.length)
                elif isinstance(geom, BoxVisualShape):
                    msg.type = Marker.CUBE
                    msg.scale = Vector3(*geom.size)
                elif isinstance(geom, SphereVisualShape):
                    msg.type = Marker.SPHERE
                    msg.scale = Vector3(geom.radius * 2, geom.radius * 2, geom.radius * 2)

                marker_array.markers.append(msg)
        return marker_array

    def _stop_publishing(self) -> None:
        """
        Stops the publishing of the Visualization Marker update by setting the kill event and collecting the thread.
        """
        self.kill_event.set()
        self.thread.join()


class ManualMarkerPublisher:
    """
    Class to manually add and remove marker of objects and poses.
    """

    def __init__(self, topic_name: str = '/pycram/manual_marker', interval: float = 0.1):
        """
        The Publisher creates an Array of Visualization marker with a marker for a pose or object.
        This Array is published with a rate of interval.

        :param topic_name: Name of the marker topic
        :param interval: Interval at which the marker should be published
        """
        self.start_time = None
        self.marker_array_pub = rospy.Publisher(topic_name, MarkerArray, queue_size=10)

        self.marker_array = MarkerArray()
        self.marker_overview = {}
        self.current_id = 0

        self.interval = interval
        self.log_message = None

    def publish(self, pose: Pose, color: Optional[List] = None, bw_object: Optional[ObjectDesignatorDescription] = None,
                name: Optional[str] = None):
        """
        Publish a pose or an object into the MarkerArray.
        Priorities to add an object if possible

        :param pose: Pose of the marker
        :param color: Color of the marker if no object is given
        :param bw_object: Object to add as a marker
        :param name: Name of the marker
        """

        if color is None:
            color = [1, 0, 1, 1]

        self.start_time = time.time()
        thread = threading.Thread(target=self._publish, args=(pose, bw_object, name, color))
        thread.start()
        rospy.loginfo(self.log_message)
        thread.join()

    def _publish(self, pose: Pose, bw_object: Optional[ObjectDesignatorDescription] = None, name: Optional[str] = None,
                 color: Optional[List] = None):
        """
        Publish the marker into the MarkerArray
        """
        stop_thread = False
        duration = 2

        while not stop_thread:
            if time.time() - self.start_time > duration:
                stop_thread = True
            if bw_object is None:
                self._publish_pose(name=name, pose=pose, color=color)
            else:
                self._publish_object(name=name, pose=pose, bw_object=bw_object)

            rospy.sleep(self.interval)

    def _publish_pose(self, name: str, pose: Pose, color: Optional[List] = None):
        """
        Publish a Pose as a marker

        :param name: Name of the marker
        :param pose: Pose of the marker
        :param color: Color of the marker
        """

        if name is None:
            name = 'pose_marker'

        if name in self.marker_overview.keys():
            self._update_marker(self.marker_overview[name], new_pose=pose)
            return

        color_rgba = ColorRGBA(*color)
        self._make_marker_array(name=name, marker_type=Marker.ARROW, marker_pose=pose,
                                marker_scales=(0.05, 0.05, 0.05), color_rgba=color_rgba)
        self.marker_array_pub.publish(self.marker_array)
        self.log_message = f"Pose '{name}' published"

    def _publish_object(self, name: Optional[str], pose: Pose, bw_object: ObjectDesignatorDescription):
        """
        Publish an Object as a marker

        :param name: Name of the marker
        :param pose: Pose of the marker
        :param bw_object: ObjectDesignatorDescription for the marker
        """

        bw_real = bw_object.resolve()

        if name is None:
            name = bw_real.name

        if name in self.marker_overview.keys():
            self._update_marker(self.marker_overview[name], new_pose=pose)
            return

        path = bw_real.world_object.root_link.geometry.file_name

        self._make_marker_array(name=name, marker_type=Marker.MESH_RESOURCE, marker_pose=pose,
                                path_to_resource=path)

        self.marker_array_pub.publish(self.marker_array)
        self.log_message = f"Object '{name}' published"

    def _make_marker_array(self, name, marker_type: int, marker_pose: Pose, marker_scales: Tuple = (1.0, 1.0, 1.0),
                           color_rgba: ColorRGBA = ColorRGBA(*[1.0, 1.0, 1.0, 1.0]),
                           path_to_resource: Optional[str] = None):
        """
        Create a Marker and add it to the MarkerArray

        :param name: Name of the Marker
        :param marker_type: Type of the marker to create
        :param marker_pose: Pose of the marker
        :param marker_scales: individual scaling of the markers axes
        :param color_rgba: Color of the marker as RGBA
        :param path_to_resource: Path to the resource of a Bulletworld object
        """

        frame_id = marker_pose.header.frame_id
        new_marker = Marker()
        new_marker.id = self.current_id
        new_marker.header.frame_id = frame_id
        new_marker.ns = name
        new_marker.header.stamp = rospy.Time.now()
        new_marker.type = marker_type
        new_marker.action = Marker.ADD
        new_marker.pose = marker_pose.pose
        new_marker.scale.x = marker_scales[0]
        new_marker.scale.y = marker_scales[1]
        new_marker.scale.z = marker_scales[2]
        new_marker.color.a = color_rgba.a
        new_marker.color.r = color_rgba.r
        new_marker.color.g = color_rgba.g
        new_marker.color.b = color_rgba.b

        if path_to_resource is not None:
            new_marker.mesh_resource = 'file://' + path_to_resource

        self.marker_array.markers.append(new_marker)
        self.marker_overview[name] = new_marker.id
        self.current_id += 1

    def _update_marker(self, marker_id: int, new_pose: Pose) -> bool:
        """
        Update an existing marker to a new pose

        :param marker_id: id of the marker that should be updated
        :param new_pose: Pose where the updated marker is set

        :return: True if update was successful, False otherwise
        """

        # Find the marker with the specified ID
        for marker in self.marker_array.markers:
            if marker.id == marker_id:
                # Update successful
                marker.pose = new_pose
                self.log_message = f"Marker '{marker.ns}' updated"
                self.marker_array_pub.publish(self.marker_array)
                return True

        # Update was not successful
        rospy.logwarn(f"Marker {marker_id} not found for update")
        return False

    def remove_marker(self, bw_object: Optional[ObjectDesignatorDescription] = None, name: Optional[str] = None):
        """
        Remove a marker by object or name

        :param bw_object: Object which marker should be removed
        :param name: Name of object that should be removed
        """

        if bw_object is not None:
            bw_real = bw_object.resolve()
            name = bw_real.name

        if name is None:
            rospy.logerr('No name for object given, cannot remove marker')
            return

        marker_id = self.marker_overview.pop(name)

        for marker in self.marker_array.markers:
            if marker.id == marker_id:
                marker.action = Marker.DELETE

        self.marker_array_pub.publish(self.marker_array)
        self.marker_array.markers.pop(marker_id)

        rospy.loginfo(f"Removed Marker '{name}'")

    def clear_all_marker(self):
        """
        Clear all existing markers
        """
        for marker in self.marker_array.markers:
            marker.action = Marker.DELETE

        self.marker_overview = {}
        self.marker_array_pub.publish(self.marker_array)

        rospy.loginfo('Removed all markers')


##New # Content from: #<src/pycram/ros/joint_state_publisher.py>#
import time
import threading
import atexit

import rospy

from sensor_msgs.msg import JointState
from std_msgs.msg import Header
from ..datastructures.world import World


class JointStatePublisher:
    """
    Joint state publisher for the robot currently loaded in the World
    """
    def __init__(self, joint_state_topic="/pycram/joint_state", interval=0.1):
        """
        Robot object is from :py:attr:`~pycram.world.World.robot` and current joint states are published to
        the given joint_state_topic as a JointState message.

        :param joint_state_topic: Topic name to which the joint states should be published
        :param interval: Interval at which the joint states should be published, in seconds
        """
        self.world = World.current_world

        self.joint_state_pub = rospy.Publisher(joint_state_topic, JointState, queue_size=10)
        self.interval = interval
        self.kill_event = threading.Event()
        self.thread = threading.Thread(target=self._publish)
        self.thread.start()

        atexit.register(self._stop_publishing)

    def _publish(self) -> None:
        """
        Publishes the current joint states of the :py:attr:`~pycram.world.World.robot` in an infinite loop.
        The joint states are published as long as the kill_event is not set by :py:meth:`~JointStatePublisher._stop_publishing`
        """
        robot = World.robot
        joint_names = [joint_name for joint_name in robot.joint_name_to_id.keys()]
        seq = 0

        while not self.kill_event.is_set():
            current_joint_states = [robot.get_joint_position(joint_name) for joint_name in joint_names]
            h = Header()
            h.stamp = rospy.Time.now()
            h.seq = seq
            h.frame_id = ""
            joint_state_msg = JointState()
            joint_state_msg.header = h
            joint_state_msg.name = joint_names
            joint_state_msg.position = current_joint_states
            # joint_state_msg.velocity = [joint_state[1] for joint_state in current_joint_states]
            self.joint_state_pub.publish(joint_state_msg)
            seq += 1
            time.sleep(self.interval)

    def _stop_publishing(self) -> None:
        """
        Sets the kill_event to terminate the publishing thread and joins the thread.
        """
        self.kill_event.set()
        self.thread.join()


##New # Content from: #<src/pycram/process_modules/boxy_process_modules.py>#
from threading import Lock
import numpy as np
from .. import world_reasoning as btr
from ..utils import _apply_ik
from ..designators.motion_designator import *
from ..datastructures.enums import JointType
from ..external_interfaces.ik import request_ik

from ..datastructures.world import World
from ..local_transformer import LocalTransformer
from ..process_module import ProcessModule, ProcessModuleManager
from ..robot_description import RobotDescription
from ..world_concepts.world_object import Object


class BoxyNavigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig: MoveMotion):
        robot = World.robot
        robot.set_pose(desig.target)


class BoxyOpen(ProcessModule):
    """
    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.
    """

    def _execute(self, desig: OpeningMotion):
        part_of_object = desig.object_part.world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)

        _move_arm_tcp(goal_pose, World.robot, desig.arm)

        desig.object_part.world_object.set_joint_position(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[1])


class BoxyClose(ProcessModule):
    """
    Low-level implementation that lets the robot close a grasped container, in simulation
    """
    def _execute(self, desig: ClosingMotion):
        part_of_object = desig.object_part.world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)

        _move_arm_tcp(goal_pose, World.robot, desig.arm)

        desig.object_part.world_object.set_joint_position(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[0])


class BoxyParkArms(ProcessModule):
    """
    This process module is for moving the arms in a parking position.
    It is currently not used.
    """

    def _execute(self, desig):
        solutions = desig.reference()
        if solutions['cmd'] == 'park':
            _park_arms()


class BoxyMoveHead(ProcessModule):
    """
    This process module moves the head to look at a specific point in the world coordinate frame.
    This point can either be a position or an object.
    """

    def _execute(self, desig):
        target = desig.target
        robot = World.robot

        local_transformer = LocalTransformer()

        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame("neck_shoulder_link"))

        if pose_in_shoulder.position.x >= 0 and pose_in_shoulder.position.x >= abs(pose_in_shoulder.position.y):
            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain("neck", "front"))
        if pose_in_shoulder.position.y >= 0 and pose_in_shoulder.position.y >= abs(pose_in_shoulder.position.x):
            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain("neck", "neck_right"))
        if pose_in_shoulder.position.x <= 0 and abs(pose_in_shoulder.position.x) > abs(pose_in_shoulder.position.y):
            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain("neck", "back"))
        if pose_in_shoulder.position.y <= 0 and abs(pose_in_shoulder.position.y) > abs(pose_in_shoulder.position.x):
            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain("neck", "neck_left"))

        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame("neck_shoulder_link"))

        new_pan = np.arctan2(pose_in_shoulder.position.y, pose_in_shoulder.position.x)

        robot.set_joint_position("neck_shoulder_pan_joint",
                                 new_pan + robot.get_joint_position("neck_shoulder_pan_joint"))


class BoxyMoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only move one gripper at a time.
    """

    def _execute(self, desig):
        robot = World.robot
        gripper = desig.gripper
        motion = desig.motion
        robot.set_joint_positions(RobotDescription.current_robot_description.kinematic_chains[gripper].get_static_gripper_state(motion))


class BoxyDetecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """

    def _execute(self, desig):
        robot = World.robot
        object_type = desig.object_type
        # Should be "wide_stereo_optical_frame"
        cam_frame_name = RobotDescription.current_robot_description.get_camera_frame()
        # should be [0, 0, 1]
        front_facing_axis = RobotDescription.current_robot_description.get_default_camera().front_facing_axis

        objects = World.current_world.get_object_by_type(object_type)
        for obj in objects:
            if btr.visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):
                return obj


class BoxyMoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig: MoveTCPMotion):
        target = desig.target
        robot = World.robot

        _move_arm_tcp(target, robot, desig.arm)


class BoxyMoveArmJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig: MoveArmJointsMotion):

        robot = World.robot
        if desig.right_arm_poses:
            robot.set_joint_positions(desig.right_arm_poses)
        if desig.left_arm_poses:
            robot.set_joint_positions(desig.left_arm_poses)


class BoxyWorldStateDetecting(ProcessModule):
    """
    This process module detectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig: WorldStateDetectingMotion):
        obj_type = desig.object_type
        return list(filter(lambda obj: obj.type == obj_type, World.current_world.objects))[0]


def _move_arm_tcp(target: Pose, robot: Object, arm: Arms) -> None:
    gripper = RobotDescription.current_robot_description.get_arm_chain(arm).get_tool_frame()

    joints = RobotDescription.current_robot_description.get_arm_chain(arm).joints

    inv = request_ik(target, robot, joints, gripper)
    _apply_ik(robot, inv)


class BoxyManager(ProcessModuleManager):

    def __init__(self):
        super().__init__("boxy")
        self._navigate_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return BoxyNavigation(self._navigate_lock)

    def looking(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return BoxyMoveHead(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return BoxyDetecting(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return BoxyMoveTCP(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return BoxyMoveArmJoints(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return BoxyWorldStateDetecting(self._world_state_detecting_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return BoxyMoveGripper(self._move_gripper_lock)


##New # Content from: #<src/pycram/process_modules/pr2_process_modules.py>#
from threading import Lock
from typing_extensions import Any

import actionlib

from .. import world_reasoning as btr
import numpy as np
import rospy

from ..process_module import ProcessModule, ProcessModuleManager
from ..external_interfaces.ik import request_ik
from ..utils import _apply_ik
from ..local_transformer import LocalTransformer
from ..designators.object_designator import ObjectDesignatorDescription
from ..designators.motion_designator import MoveMotion, LookingMotion, \
    DetectingMotion, MoveTCPMotion, MoveArmJointsMotion, WorldStateDetectingMotion, MoveJointsMotion, \
    MoveGripperMotion, OpeningMotion, ClosingMotion
from ..robot_description import RobotDescription
from ..datastructures.world import World
from ..world_concepts.world_object import Object
from ..datastructures.pose import Pose
from ..datastructures.enums import JointType, ObjectType, Arms, ExecutionType
from ..external_interfaces import giskard
from ..external_interfaces.robokudo import *

try:
    from pr2_controllers_msgs.msg import Pr2GripperCommandGoal, Pr2GripperCommandAction, Pr2
except ImportError:
    pass


class Pr2Navigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig: MoveMotion):
        robot = World.robot
        robot.set_pose(desig.target)


class Pr2MoveHead(ProcessModule):
    """
        This process module moves the head to look at a specific point in the world coordinate frame.
        This point can either be a position or an object.
        """

    def _execute(self, desig: LookingMotion):
        target = desig.target
        robot = World.robot

        local_transformer = LocalTransformer()
        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_pan_link"))
        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_tilt_link"))

        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)
        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1

        current_pan = robot.get_joint_position("head_pan_joint")
        current_tilt = robot.get_joint_position("head_tilt_joint")

        robot.set_joint_position("head_pan_joint", new_pan + current_pan)
        robot.set_joint_position("head_tilt_joint", new_tilt + current_tilt)


class Pr2MoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only moved one gripper at a time.
    """

    def _execute(self, desig: MoveGripperMotion):
        robot = World.robot
        motion = desig.motion
        for joint, state in RobotDescription.current_robot_description.get_arm_chain(
                desig.gripper).get_static_gripper_state(motion).items():
            robot.set_joint_position(joint, state)


class Pr2Detecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """

    def _execute(self, desig: DetectingMotion):
        robot = World.robot
        object_type = desig.object_type
        # Should be "wide_stereo_optical_frame"
        cam_frame_name = RobotDescription.current_robot_description.get_camera_frame()
        # should be [0, 0, 1]
        camera_description = RobotDescription.current_robot_description.cameras[
            list(RobotDescription.current_robot_description.cameras.keys())[0]]
        front_facing_axis = camera_description.front_facing_axis

        objects = World.current_world.get_object_by_type(object_type)
        for obj in objects:
            if btr.visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):
                return obj


class Pr2MoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig: MoveTCPMotion):
        target = desig.target
        robot = World.robot

        _move_arm_tcp(target, robot, desig.arm)


class Pr2MoveArmJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig: MoveArmJointsMotion):

        robot = World.robot
        if desig.right_arm_poses:
            robot.set_joint_positions(desig.right_arm_poses)
        if desig.left_arm_poses:
            robot.set_joint_positions(desig.left_arm_poses)


class PR2MoveJoints(ProcessModule):
    """
    Process Module for generic joint movements, is not confined to the arms but can move any joint of the robot
    """

    def _execute(self, desig: MoveJointsMotion):
        robot = World.robot
        robot.set_joint_positions(dict(zip(desig.names, desig.positions)))


class Pr2WorldStateDetecting(ProcessModule):
    """
    This process module detectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig: WorldStateDetectingMotion):
        obj_type = desig.object_type
        return list(filter(lambda obj: obj.obj_type == obj_type, World.current_world.objects))[0]


class Pr2Open(ProcessModule):
    """
    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.
    """

    def _execute(self, desig: OpeningMotion):
        part_of_object = desig.object_part.world_object

        container_joint = part_of_object.find_joint_above_link(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)

        _move_arm_tcp(goal_pose, World.robot, desig.arm)

        desig.object_part.world_object.set_joint_position(container_joint,
                                                          part_of_object.get_joint_limits(
                                                              container_joint)[1] - 0.05)


class Pr2Close(ProcessModule):
    """
    Low-level implementation that lets the robot close a grasped container, in simulation
    """

    def _execute(self, desig: ClosingMotion):
        part_of_object = desig.object_part.world_object

        container_joint = part_of_object.find_joint_above_link(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = btr.link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)

        _move_arm_tcp(goal_pose, World.robot, desig.arm)

        desig.object_part.world_object.set_joint_position(container_joint,
                                                          part_of_object.get_joint_limits(
                                                              container_joint)[0])


def _move_arm_tcp(target: Pose, robot: Object, arm: Arms) -> None:
    gripper = RobotDescription.current_robot_description.get_arm_chain(arm).get_tool_frame()

    joints = RobotDescription.current_robot_description.get_arm_chain(arm).joints

    inv = request_ik(target, robot, joints, gripper)
    _apply_ik(robot, inv)


###########################################################
########## Process Modules for the Real PR2 ###############
###########################################################


class Pr2NavigationReal(ProcessModule):
    """
    Process module for the real PR2 that sends a cartesian goal to giskard to move the robot base
    """

    def _execute(self, designator: MoveMotion) -> Any:
        rospy.logdebug(f"Sending goal to giskard to Move the robot")
        giskard.achieve_cartesian_goal(designator.target, RobotDescription.current_robot_description.base_link, "map")


class Pr2MoveHeadReal(ProcessModule):
    """
    Process module for the real robot to move that such that it looks at the given position. Uses the same calculation
    as the simulated one
    """

    def _execute(self, desig: LookingMotion):
        target = desig.target
        robot = World.robot

        local_transformer = LocalTransformer()
        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_pan_link"))
        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_tilt_link"))

        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)
        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1

        current_pan = robot.get_joint_position("head_pan_joint")
        current_tilt = robot.get_joint_position("head_tilt_joint")

        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal({"head_pan_joint": new_pan + current_pan,
                                    "head_tilt_joint": new_tilt + current_tilt})


class Pr2DetectingReal(ProcessModule):
    """
    Process Module for the real Pr2 that tries to detect an object fitting the given object description. Uses Robokudo
    for perception of the environment.
    """

    def _execute(self, designator: DetectingMotion) -> Any:
        query_result = query(ObjectDesignatorDescription(types=[designator.object_type]))
        # print(query_result)
        obj_pose = query_result["ClusterPoseBBAnnotator"]

        lt = LocalTransformer()
        obj_pose = lt.transform_pose(obj_pose, World.robot.get_link_tf_frame("torso_lift_link"))
        obj_pose.orientation = [0, 0, 0, 1]
        obj_pose.position.x += 0.05

        world_obj = World.current_world.get_object_by_type(designator.object_type)
        if world_obj:
            world_obj[0].set_pose(obj_pose)
            return world_obj[0]
        elif designator.object_type == ObjectType.JEROEN_CUP:
            cup = Object("cup", ObjectType.JEROEN_CUP, "jeroen_cup.stl", pose=obj_pose)
            return cup
        elif designator.object_type == ObjectType.BOWL:
            bowl = Object("bowl", ObjectType.BOWL, "bowl.stl", pose=obj_pose)
            return bowl

        return world_obj[0]


class Pr2MoveTCPReal(ProcessModule):
    """
    Moves the tool center point of the real PR2 while avoiding all collisions
    """

    def _execute(self, designator: MoveTCPMotion) -> Any:
        lt = LocalTransformer()
        pose_in_map = lt.transform_pose(designator.target, "map")

        if designator.allow_gripper_collision:
            giskard.allow_gripper_collision(designator.arm)
        giskard.achieve_cartesian_goal(pose_in_map, RobotDescription.current_robot_description.get_arm_chain(
            designator.arm).get_tool_frame(),
                                       "torso_lift_link")
        # robot_description.base_link)


class Pr2MoveArmJointsReal(ProcessModule):
    """
    Moves the arm joints of the real PR2 to the given configuration while avoiding all collisions
    """

    def _execute(self, designator: MoveArmJointsMotion) -> Any:
        joint_goals = {}
        if designator.left_arm_poses:
            joint_goals.update(designator.left_arm_poses)
        if designator.right_arm_poses:
            joint_goals.update(designator.right_arm_poses)
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal(joint_goals)


class Pr2MoveJointsReal(ProcessModule):
    """
    Moves any joint using giskard, avoids all collisions while doint this.
    """

    def _execute(self, designator: MoveJointsMotion) -> Any:
        name_to_position = dict(zip(designator.names, designator.positions))
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal(name_to_position)


class Pr2MoveGripperReal(ProcessModule):
    """
    Opens or closes the gripper of the real PR2, gripper uses an action server for this instead of giskard 
    """

    def _execute(self, designator: MoveGripperMotion) -> Any:
        def activate_callback():
            rospy.loginfo("Started gripper Movement")

        def done_callback(state, result):
            rospy.loginfo(f"Reached goal {designator.motion}: {result.reached_goal}")

        def feedback_callback(msg):
            pass

        goal = Pr2GripperCommandGoal()
        goal.command.position = 0.0 if designator.motion == "close" else 0.1
        goal.command.max_effort = 50.0
        if designator.gripper == "right":
            controller_topic = "r_gripper_controller/gripper_action"
        else:
            controller_topic = "l_gripper_controller/gripper_action"
        client = actionlib.SimpleActionClient(controller_topic, Pr2GripperCommandAction)
        rospy.loginfo("Waiting for action server")
        client.wait_for_server()
        client.send_goal(goal, active_cb=activate_callback, done_cb=done_callback, feedback_cb=feedback_callback)
        wait = client.wait_for_result()


class Pr2OpenReal(ProcessModule):
    """
    Tries to open an already grasped container
    """

    def _execute(self, designator: OpeningMotion) -> Any:
        giskard.achieve_open_container_goal(
            RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),
            designator.object_part.name)


class Pr2CloseReal(ProcessModule):
    """
    Tries to close an already grasped container
    """

    def _execute(self, designator: ClosingMotion) -> Any:
        giskard.achieve_close_container_goal(
            RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),
            designator.object_part.name)


class Pr2Manager(ProcessModuleManager):

    def __init__(self):
        super().__init__("pr2")
        self._navigate_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return Pr2Navigation(self._navigate_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2NavigationReal(self._navigate_lock)

    def looking(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return Pr2MoveHead(self._looking_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2MoveHeadReal(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return Pr2Detecting(self._detecting_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2DetectingReal(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return Pr2MoveTCP(self._move_tcp_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2MoveTCPReal(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return Pr2MoveArmJoints(self._move_arm_joints_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2MoveArmJointsReal(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if (ProcessModuleManager.execution_type == ExecutionType.SIMULATED or
                ProcessModuleManager.execution_type == ExecutionType.REAL):
            return Pr2WorldStateDetecting(self._world_state_detecting_lock)

    def move_joints(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return PR2MoveJoints(self._move_joints_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2MoveJointsReal(self._move_joints_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return Pr2MoveGripper(self._move_gripper_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2MoveGripperReal(self._move_gripper_lock)

    def open(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return Pr2Open(self._open_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2OpenReal(self._open_lock)

    def close(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return Pr2Close(self._close_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return Pr2CloseReal(self._close_lock)


##New # Content from: #<src/pycram/process_modules/stretch_process_modules.py>#
from typing import Any

import rospy

from ..external_interfaces.robokudo import *
from ..utils import _apply_ik
from ..external_interfaces import giskard
from .default_process_modules import *
from ..datastructures.world import World
from ..designators.motion_designator import *
from ..external_interfaces.ik import request_giskard_ik
from ..robot_description import RobotDescription


class StretchNavigate(DefaultNavigation):
    """
    Process module for the simulated Stretch that sends a cartesian goal to the robot to move the robot base
    """
    pass


class StretchMoveHead(ProcessModule):
    """
    Process module for the simulated Stretch that moves the head such that it looks at the given position
    """

    def _execute(self, designator: MoveMotion) -> Any:
        target = designator.target
        robot = World.robot

        local_transformer = LocalTransformer()
        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame("link_head_pan"))

        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)
        current_pan = robot.get_joint_position("joint_head_pan")

        robot.set_joint_position("joint_head_pan", new_pan + current_pan)

        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame("link_head_tilt"))
        new_tilt = np.arctan2(-pose_in_tilt.position.y,
                              np.sqrt(pose_in_tilt.position.z ** 2 + pose_in_tilt.position.x ** 2)) * -1
        current_tilt = robot.get_joint_position("joint_head_tilt")

        robot.set_joint_position("joint_head_tilt", new_tilt + current_tilt)


class StretchMoveGripper(DefaultMoveGripper):
    """
    Process module for the simulated Stretch that opens or closes the gripper
    """
    pass


class StretchDetecting(DefaultDetecting):
    """
    Process Module for the simulated Stretch that tries to detect an object fitting the given object description
    """
    pass


class StretchMoveTCP(DefaultMoveTCP):
    """
    Process module for the simulated Stretch that moves the tool center point of the robot
    """
    pass


class StretchMoveArmJoints(DefaultMoveArmJoints):
    """
    Process module for the simulated Stretch that moves the arm joints of the robot
    """
    pass


class StretchMoveJoints(DefaultMoveJoints):
    """
    Process module for the simulated Stretch that moves any joint of the robot
    """
    pass


class StretchWorldStateDetecting(DefaultWorldStateDetecting):
    """
    Process Module for the simulated Stretch that tries to detect an object using the world state
    """
    pass


class StretchOpen(ProcessModule):
    """
    Process module for the simulated Stretch that opens an already grasped container
    """

    def _execute(self, desig: OpeningMotion):
        part_of_object = desig.object_part.world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)

        _move_arm_tcp(goal_pose, World.robot, desig.arm)

        desig.object_part.world_object.set_joint_position(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[1] - 0.05)


class StretchClose(ProcessModule):
    """
    Process module for the simulated Stretch that closes an already grasped container
    """

    def _execute(self, desig: ClosingMotion):
        part_of_object = desig.object_part.world_object

        container_joint = part_of_object.find_joint_above(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)

        _move_arm_tcp(goal_pose, World.robot, desig.arm)

        desig.object_part.world_object.set_joint_position(container_joint,
                                                       part_of_object.get_joint_limits(
                                                           container_joint)[0])


def _move_arm_tcp(target: Pose, robot: Object, arm: Arms) -> None:
    gripper = RobotDescription.current_robot_description.get_arm_chain(arm).get_tool_frame()

    # inv = request_ik(target, robot, joints, gripper)
    pose, joint_states = request_giskard_ik(target, robot, gripper)
    robot.set_pose(pose)
    robot.set_joint_positions(joint_states)


###########################################################
########## Process Modules for the Real Stretch ###########
###########################################################


class StretchNavigationReal(ProcessModule):
    """
    Process module for the real Stretch that sends a cartesian goal to giskard to move the robot base
    """

    def _execute(self, designator: MoveMotion) -> Any:
        rospy.logdebug(f"Sending goal to giskard to Move the robot")
        giskard.achieve_cartesian_goal(designator.target, RobotDescription.current_robot_description.base_link, "map")


class StretchMoveHeadReal(ProcessModule):
    """
    Process module for the real robot to move that such that it looks at the given position. Uses the same calculation
    as the simulated one
    """

    def _execute(self, desig: LookingMotion):
        target = desig.target
        robot = World.robot

        local_transformer = LocalTransformer()
        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_pan_link"))

        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)

        current_pan = robot.get_joint_position("joint_head_pan")
        current_tilt = robot.get_joint_position("joint_head_tilt")

        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal({"head_pan_joint": new_pan + current_pan})

        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame("head_tilt_link"))
        new_tilt = np.arctan2(-pose_in_tilt.position.y,
                              np.sqrt(pose_in_tilt.position.z ** 2 + pose_in_tilt.position.x ** 2)) * -1
        current_tilt = robot.get_joint_position("joint_head_tilt")
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal({"head_tilt_joint": new_tilt + current_tilt})


class StretchDetectingReal(ProcessModule):
    """
    Process Module for the real Stretch that tries to detect an object fitting the given object description. Uses Robokudo
    for perception of the environment.
    """

    def _execute(self, designator: DetectingMotion) -> Any:
        query_result = query(ObjectDesignatorDescription(types=[designator.object_type]))
        # print(query_result)
        obj_pose = query_result["ClusterPoseBBAnnotator"]

        lt = LocalTransformer()
        obj_pose = lt.transform_pose(obj_pose, World.robot.get_link_tf_frame("torso_lift_link"))
        obj_pose.orientation = [0, 0, 0, 1]
        obj_pose.position.x += 0.05

        bullet_obj = World.current_world.get_objects_by_type(designator.object_type)
        if bullet_obj:
            bullet_obj[0].set_pose(obj_pose)
            return bullet_obj[0]
        elif designator.object_type == ObjectType.JEROEN_CUP:
            cup = Object("cup", ObjectType.JEROEN_CUP, "jeroen_cup.stl", pose=obj_pose)
            return cup
        elif designator.object_type == ObjectType.BOWL:
            bowl = Object("bowl", ObjectType.BOWL, "bowl.stl", pose=obj_pose)
            return bowl

        return bullet_obj[0]


class StretchMoveTCPReal(ProcessModule):
    """
    Moves the tool center point of the real Stretch while avoiding all collisions
    """

    def _execute(self, designator: MoveTCPMotion) -> Any:
        lt = LocalTransformer()
        pose_in_map = lt.transform_pose(designator.target, "map")

        if designator.allow_gripper_collision:
            giskard.allow_gripper_collision(designator.arm)
        giskard.achieve_cartesian_goal(pose_in_map, RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),
                                       RobotDescription.current_robot_description.base_link)


class StretchMoveArmJointsReal(ProcessModule):
    """
    Moves the arm joints of the real Stretch to the given configuration while avoiding all collisions
    """

    def _execute(self, designator: MoveArmJointsMotion) -> Any:
        joint_goals = {}
        if designator.left_arm_poses:
            joint_goals.update(designator.left_arm_poses)
        if designator.right_arm_poses:
            joint_goals.update(designator.right_arm_poses)
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal(joint_goals)


class StretchMoveJointsReal(ProcessModule):
    """
    Moves any joint using giskard, avoids all collisions while doint this.
    """

    def _execute(self, designator: MoveJointsMotion) -> Any:
        name_to_position = dict(zip(designator.names, designator.positions))
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal(name_to_position)


class StretchMoveGripperReal(ProcessModule):
    """
    Opens or closes the gripper of the real Stretch, gripper uses an action server for this instead of giskard
    """

    def _execute(self, designator: MoveGripperMotion) -> Any:
        chain = RobotDescription.current_robot_description.get_arm_chain(designator.gripper).get_static_gripper_state(designator.motion)
        giskard.achieve_joint_goal(chain)


class StretchOpenReal(ProcessModule):
    """
    Tries to open an already grasped container
    """

    def _execute(self, designator: OpeningMotion) -> Any:
        giskard.achieve_open_container_goal(RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),
                                            designator.object_part.name)


class StretchCloseReal(ProcessModule):
    """
    Tries to close an already grasped container
    """

    def _execute(self, designator: ClosingMotion) -> Any:
            giskard.achieve_close_container_goal(RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),
                                             designator.object_part.name)


class StretchManager(ProcessModuleManager):
    def __init__(self):
        super().__init__("stretch_description")
        self._navigate_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchNavigate(self._navigate_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchNavigationReal(self._navigate_lock)

    def looking(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchMoveHead(self._looking_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchMoveHeadReal(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchDetecting(self._detecting_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchDetectingReal(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchMoveTCP(self._move_tcp_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchMoveTCPReal(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchMoveArmJoints(self._move_arm_joints_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchMoveArmJointsReal(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED or ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchWorldStateDetecting(self._world_state_detecting_lock)

    def move_joints(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchMoveJoints(self._move_joints_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchMoveJointsReal(self._move_joints_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchMoveGripper(self._move_gripper_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchMoveGripperReal(self._move_gripper_lock)

    def open(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchOpen(self._open_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchOpenReal(self._open_lock)

    def close(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return StretchClose(self._close_lock)
        elif ProcessModuleManager.execution_type ==  ExecutionType.REAL:
            return StretchCloseReal(self._close_lock)


##New # Content from: #<src/pycram/process_modules/hsrb_process_modules.py>#
import numpy as np
import rospy
from threading import Lock
from typing_extensions import Any

from ..datastructures.enums import ExecutionType
from ..external_interfaces.tmc import tmc_gripper_control, tmc_talk
from ..robot_description import RobotDescription
from ..process_module import ProcessModule
from ..local_transformer import LocalTransformer
from ..designators.motion_designator import *
from ..external_interfaces import giskard
from ..datastructures.world import World
from pydub import AudioSegment
from pydub.playback import play
from gtts import gTTS

import io


class HSRBNavigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig: MoveMotion):
        robot = World.robot
        robot.set_pose(desig.target)


class HSRBDetecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """
   # pass
    def _execute(self, desig: DetectingMotion) -> Any:
        pass


###########################################################
########## Process Modules for the Real HSRB ###############
###########################################################


class HSRBNavigationReal(ProcessModule):
    """
    Process module for the real HSRB that sends a cartesian goal to giskard to move the robot base
    """

    def _execute(self, designator: MoveMotion) -> Any:
        rospy.logdebug(f"Sending goal to giskard to Move the robot")
        # giskard.achieve_cartesian_goal(designator.target, robot_description.base_link, "map")
        # todome fix this
        # queryPoseNav(designator.target)


class HSRBMoveHeadReal(ProcessModule):
    """
    Process module for the real HSRB that sends a pose goal to giskard to move the robot head
    """

    def _execute(self, desig: LookingMotion):
        target = desig.target
        giskard.move_head_to_pose(target)


class HSRBDetectingReal(ProcessModule):
    """
    Process Module for the real HSRB that tries to detect an object fitting the given object description. Uses Robokudo
    for perception of the environment.
    """

    def _execute(self, desig: DetectingMotion) -> Any:
        pass


class HSRBMoveTCPReal(ProcessModule):
    """
    Moves the tool center point of the real HSRB while avoiding all collisions via giskard
    """

    def _execute(self, designator: MoveTCPMotion) -> Any:
        lt = LocalTransformer()
        pose_in_map = lt.transform_pose(designator.target, "map")
        giskard.avoid_all_collisions()
        if designator.allow_gripper_collision:
            giskard.allow_gripper_collision(designator.arm)
        giskard.achieve_cartesian_goal(pose_in_map, RobotDescription.current_robot_description.get_arm_chain(
            designator.arm).get_tool_frame(), "map")


class HSRBMoveArmJointsReal(ProcessModule):
    """
    Moves the arm joints of the real HSRB to the given configuration while avoiding all collisions via giskard
    """

    def _execute(self, designator: MoveArmJointsMotion) -> Any:
        joint_goals = {}
        if designator.left_arm_poses:
            joint_goals.update(designator.left_arm_poses)
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal(joint_goals)


class HSRBMoveJointsReal(ProcessModule):
    """
    Moves any joint using giskard, avoids all collisions while doint this.
    """

    def _execute(self, designator: MoveJointsMotion) -> Any:
        name_to_position = dict(zip(designator.names, designator.positions))
        giskard.avoid_all_collisions()
        giskard.achieve_joint_goal(name_to_position)


class HSRBMoveGripperReal(ProcessModule):
    """
     Opens or closes the gripper of the real HSRB with the help of giskard.
     """

    def _execute(self, designator: MoveGripperMotion) -> Any:
        tmc_gripper_control(designator)


class HSRBOpenReal(ProcessModule):
    """
    This process Modules tries to open an already grasped container via giskard
    """

    def _execute(self, designator: OpeningMotion) -> Any:
        giskard.achieve_open_container_goal(
            RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),
            designator.object_part.name)


class HSRBCloseReal(ProcessModule):
    """
    This process module executes close a an already grasped container via giskard
    """

    def _execute(self, designator: ClosingMotion) -> Any:
        giskard.achieve_close_container_goal(
            RobotDescription.current_robot_description.get_arm_chain(designator.arm).get_tool_frame(),
            designator.object_part.name)


class HSRBTalkReal(ProcessModule):
    """
    Let the robot speak over tmc interface.
    """

    def _execute(self, designator: TalkingMotion) -> Any:
        tmc_talk(designator)


###########################################################
########## Process Modules for the Semi Real HSRB ###############
###########################################################
class HSRBNavigationSemiReal(ProcessModule):
    """
    Process module for the real HSRB that sends a cartesian goal to giskard to move the robot base
    """

    def _execute(self, designator: MoveMotion) -> Any:
        rospy.logdebug(f"Sending goal to giskard to Move the robot")
        giskard.teleport_robot(designator.target)


class HSRBTalkSemiReal(ProcessModule):
    """
    Low Level implementation to let the robot talk using gTTS and pydub.
    """

    def _execute(self, designator: TalkingMotion) -> Any:
        """
        Convert text to speech using gTTS, modify the pitch and play it without saving to disk.
        """
        sentence = designator.cmd
        # Create a gTTS object
        tts = gTTS(text=sentence, lang='en', slow=False)

        # Save the speech to an in-memory file
        mp3_fp = io.BytesIO()
        tts.write_to_fp(mp3_fp)
        mp3_fp.seek(0)

        # Load the audio into pydub from the in-memory file
        audio = AudioSegment.from_file(mp3_fp, format="mp3")

        # Speed up the audio slightly
        faster_audio = audio.speedup(playback_speed=1.2)

        # Play the modified audio
        play(faster_audio)


###########################################################
########## HSRB MANAGER ###############
###########################################################
class HSRBManager(ProcessModuleManager):

    def __init__(self):
        super().__init__("hsrb")
        self._navigate_lock = Lock()
        self._pick_up_lock = Lock()
        self._place_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()
        self._talk_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return HSRBNavigation(self._navigate_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBNavigationReal(self._navigate_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBNavigationSemiReal(self._navigate_lock)

    def looking(self):
        if ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBMoveHeadReal(self._looking_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBMoveHeadReal(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type == ExecutionType.SIMULATED:
            return HSRBDetecting(self._detecting_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBDetectingReal(self._detecting_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBDetecting(self._detecting_lock)

    def move_tcp(self):
        if  ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBMoveTCPReal(self._move_tcp_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBMoveTCPReal(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBMoveArmJointsReal(self._move_arm_joints_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBMoveArmJointsReal(self._move_arm_joints_lock)

    def move_joints(self):
        if ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBMoveJointsReal(self._move_joints_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBMoveJointsReal(self._move_joints_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBMoveGripperReal(self._move_gripper_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBMoveGripperReal(self._move_gripper_lock)

    def open(self):
        if ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBOpenReal(self._open_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBOpenReal(self._open_lock)

    def close(self):
        if ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBCloseReal(self._close_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBCloseReal(self._close_lock)

    def talk(self):
        if ProcessModuleManager.execution_type == ExecutionType.REAL:
            return HSRBTalkReal(self._talk_lock)
        elif ProcessModuleManager.execution_type == ExecutionType.SEMI_REAL:
            return HSRBTalkSemiReal(self._talk_lock)


##New # Content from: #<src/pycram/process_modules/donbot_process_modules.py>#
from threading import Lock

import numpy as np

from ..worlds.bullet_world import World
from ..designators.motion_designator import MoveArmJointsMotion, WorldStateDetectingMotion
from ..local_transformer import LocalTransformer
from ..process_module import ProcessModule, ProcessModuleManager
from ..robot_description import RobotDescription
from ..process_modules.pr2_process_modules import Pr2Detecting as DonbotDetecting, _move_arm_tcp
from ..datastructures.enums import Arms


def _park_arms(arm):
    """
    Defines the joint poses for the parking positions of the arm of Donbot and applies them to the
    in the World defined robot.
    :return: None
    """

    robot = World.robot
    if arm == "left":
        for joint, pose in RobotDescription.current_robot_description.get_static_joint_chain("left", "park").items():
            robot.set_joint_position(joint, pose)


class DonbotNavigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig):
        robot = World.robot
        robot.set_pose(desig.target)


class DonbotPlace(ProcessModule):
    """
    This process module places an object at the given position in world coordinate frame.
    """

    def _execute(self, desig):
        obj = desig.object.world_object
        robot = World.robot

        # Transformations such that the target position is the position of the object and not the tcp
        object_pose = obj.get_pose()
        local_tf = LocalTransformer()
        tcp_to_object = local_tf.transform_pose(object_pose,
                                                robot.get_link_tf_frame(RobotDescription.current_robot_description.kinematic_chains["left"].get_tool_frame()))
        target_diff = desig.target.to_transform("target").inverse_times(tcp_to_object.to_transform("object")).to_pose()

        _move_arm_tcp(target_diff, robot, Arms.LEFT)
        robot.detach(obj)


class DonbotMoveHead(ProcessModule):
    """
    This process module moves the head to look at a specific point in the world coordinate frame.
    This point can either be a position or an object.
    """

    def _execute(self, desig):
        target = desig.target
        robot = World.robot

        local_transformer = LocalTransformer()

        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame("ur5_shoulder_link"))

        if pose_in_shoulder.position.x >= 0 and pose_in_shoulder.position.x >= abs(pose_in_shoulder.position.y):
            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain("left", "front"))
        if pose_in_shoulder.position.y >= 0 and pose_in_shoulder.position.y >= abs(pose_in_shoulder.position.x):
            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain("left", "arm_right"))
        if pose_in_shoulder.position.x <= 0 and abs(pose_in_shoulder.position.x) > abs(pose_in_shoulder.position.y):
            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain("left", "back"))
        if pose_in_shoulder.position.y <= 0 and abs(pose_in_shoulder.position.y) > abs(pose_in_shoulder.position.x):
            robot.set_joint_positions(RobotDescription.current_robot_description.get_static_joint_chain("left", "arm_left"))

        pose_in_shoulder = local_transformer.transform_pose(target, robot.get_link_tf_frame("ur5_shoulder_link"))

        new_pan = np.arctan2(pose_in_shoulder.position.y, pose_in_shoulder.position.x)

        robot.set_joint_position("ur5_shoulder_pan_joint", new_pan + robot.get_joint_position("ur5_shoulder_pan_joint"))


class DonbotMoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only move one gripper at a time.
    """

    def _execute(self, desig):
        robot = World.robot
        gripper = desig.gripper
        motion = desig.motion
        robot.set_joint_positions(RobotDescription.current_robot_description.get_arm_chain(gripper).get_static_gripper_state(motion))


class DonbotMoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig):
        target = desig.target
        robot = World.robot

        _move_arm_tcp(target, robot, desig.arm)


class DonbotMoveJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig: MoveArmJointsMotion):
        robot = World.robot
        if desig.left_arm_poses:
            robot.set_joint_positions(desig.left_arm_poses)


class DonbotWorldStateDetecting(ProcessModule):
    """
    This process module detectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig: WorldStateDetectingMotion):
        obj_type = desig.object_type
        return list(filter(lambda obj: obj.type == obj_type, World.current_world.objects))[0]


class DonbotManager(ProcessModuleManager):

    def __init__(self):
        super().__init__("iai_donbot")
        self._navigate_lock = Lock()
        self._pick_up_lock = Lock()
        self._place_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DonbotNavigation(self._navigate_lock)

    def place(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DonbotPlace(self._place_lock)

    def looking(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DonbotMoveHead(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DonbotDetecting(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DonbotMoveTCP(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DonbotMoveJoints(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DonbotWorldStateDetecting(self._world_state_detecting_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DonbotMoveGripper(self._move_gripper_lock)


##New # Content from: #<src/pycram/process_modules/default_process_modules.py>#
from threading import Lock

import numpy as np

from ..datastructures.enums import JointType
from ..external_interfaces.ik import request_ik
from ..utils import _apply_ik
from ..process_module import ProcessModule
from ..robot_description import RobotDescription
from ..local_transformer import LocalTransformer
from ..designators.motion_designator import *
from ..world_reasoning import visible, link_pose_for_joint_config
from ..world_concepts.world_object import Object
from ..datastructures.world import World

class DefaultNavigation(ProcessModule):
    """
    The process module to move the robot from one position to another.
    """

    def _execute(self, desig: MoveMotion):
        robot = World.robot
        robot.set_pose(desig.target)

class DefaultMoveHead(ProcessModule):
    """
    This process module moves the head to look at a specific point in the world coordinate frame.
    This point can either be a position or an object.
    """

    def _execute(self, desig: LookingMotion):
        target = desig.target
        robot = World.robot

        local_transformer = LocalTransformer()

        pan_link = RobotDescription.current_robot_description.kinematic_chains["neck"].links[0]
        tilt_link = RobotDescription.current_robot_description.kinematic_chains["neck"].links[1]

        pan_joint = RobotDescription.current_robot_description.kinematic_chains["neck"].joints[0]
        tilt_joint = RobotDescription.current_robot_description.kinematic_chains["neck"].joints[1]
        pose_in_pan = local_transformer.transform_pose(target, robot.get_link_tf_frame(pan_link))
        pose_in_tilt = local_transformer.transform_pose(target, robot.get_link_tf_frame(tilt_link))

        new_pan = np.arctan2(pose_in_pan.position.y, pose_in_pan.position.x)
        new_tilt = np.arctan2(pose_in_tilt.position.z, pose_in_tilt.position.x ** 2 + pose_in_tilt.position.y ** 2) * -1

        current_pan = robot.get_joint_position(pan_joint)
        current_tilt = robot.get_joint_position(tilt_joint)

        robot.set_joint_position(pan_joint, new_pan + current_pan)
        robot.set_joint_position(tilt_joint, new_tilt + current_tilt)


class DefaultMoveGripper(ProcessModule):
    """
    This process module controls the gripper of the robot. They can either be opened or closed.
    Furthermore, it can only moved one gripper at a time.
    """

    def _execute(self, desig: MoveGripperMotion):
        robot = World.robot
        gripper = desig.gripper
        motion = desig.motion
        for joint, state in RobotDescription.current_robot_description.get_arm_chain(gripper).get_static_gripper_state(motion).items():
            robot.set_joint_position(joint, state)


class DefaultDetecting(ProcessModule):
    """
    This process module tries to detect an object with the given type. To be detected the object has to be in
    the field of view of the robot.
    """

    def _execute(self, desig: DetectingMotion):
        robot = World.robot
        object_type = desig.object_type
        # Should be "wide_stereo_optical_frame"
        cam_frame_name = RobotDescription.current_robot_description.get_camera_frame()
        # should be [0, 0, 1]
        front_facing_axis = RobotDescription.current_robot_description.get_default_camera().front_facing_axis

        objects = World.current_world.get_object_by_type(object_type)
        for obj in objects:
            if visible(obj, robot.get_link_pose(cam_frame_name), front_facing_axis):
                return obj


class DefaultMoveTCP(ProcessModule):
    """
    This process moves the tool center point of either the right or the left arm.
    """

    def _execute(self, desig: MoveTCPMotion):
        target = desig.target
        robot = World.robot

        _move_arm_tcp(target, robot, desig.arm)


class DefaultMoveArmJoints(ProcessModule):
    """
    This process modules moves the joints of either the right or the left arm. The joint states can be given as
    list that should be applied or a pre-defined position can be used, such as "parking"
    """

    def _execute(self, desig: MoveArmJointsMotion):

        robot = World.robot
        if desig.right_arm_poses:
            for joint, pose in desig.right_arm_poses.items():
                robot.set_joint_position(joint, pose)
        if desig.left_arm_poses:
            for joint, pose in desig.left_arm_poses.items():
                robot.set_joint_position(joint, pose)


class DefaultMoveJoints(ProcessModule):
    def _execute(self, desig: MoveJointsMotion):
        robot = World.robot
        for joint, pose in zip(desig.names, desig.positions):
            robot.set_joint_position(joint, pose)


class DefaultWorldStateDetecting(ProcessModule):
    """
    This process moduledetectes an object even if it is not in the field of view of the robot.
    """

    def _execute(self, desig: WorldStateDetectingMotion):
        obj_type = desig.object_type
        return list(filter(lambda obj: obj.type == obj_type, World.current_world.objects))[0]


class DefaultOpen(ProcessModule):
    """
    Low-level implementation of opening a container in the simulation. Assumes the handle is already grasped.
    """

    def _execute(self, desig: OpeningMotion):
        part_of_object = desig.object_part.world_object

        container_joint = part_of_object.find_joint_above_link(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[1] - 0.05}, desig.object_part.name)

        _move_arm_tcp(goal_pose, World.robot, desig.arm)

        desig.object_part.world_object.set_joint_position(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[1])


class DefaultClose(ProcessModule):
    """
    Low-level implementation that lets the robot close a grasped container, in simulation
    """
    def _execute(self, desig: ClosingMotion):
        part_of_object = desig.object_part.world_object

        container_joint = part_of_object.find_joint_above_link(desig.object_part.name, JointType.PRISMATIC)

        goal_pose = link_pose_for_joint_config(part_of_object, {
            container_joint: part_of_object.get_joint_limits(container_joint)[0]}, desig.object_part.name)

        _move_arm_tcp(goal_pose, World.robot, desig.arm)

        desig.object_part.world_object.set_joint_position(container_joint,
                                                              part_of_object.get_joint_limits(
                                                                  container_joint)[0])


def _move_arm_tcp(target: Pose, robot: Object, arm: Arms) -> None:
    gripper = RobotDescription.current_robot_description.get_arm_chain(arm).get_tool_frame()

    joints = RobotDescription.current_robot_description.get_arm_chain(arm).joints

    inv = request_ik(target, robot, joints, gripper)
    _apply_ik(robot, inv)


class DefaultManager(ProcessModuleManager):

    def __init__(self):
        super().__init__("default")
        self._navigate_lock = Lock()
        self._looking_lock = Lock()
        self._detecting_lock = Lock()
        self._move_tcp_lock = Lock()
        self._move_arm_joints_lock = Lock()
        self._world_state_detecting_lock = Lock()
        self._move_joints_lock = Lock()
        self._move_gripper_lock = Lock()
        self._open_lock = Lock()
        self._close_lock = Lock()

    def navigate(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultNavigation(self._navigate_lock)

    def looking(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultMoveHead(self._looking_lock)

    def detecting(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultDetecting(self._detecting_lock)

    def move_tcp(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultMoveTCP(self._move_tcp_lock)

    def move_arm_joints(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultMoveArmJoints(self._move_arm_joints_lock)

    def world_state_detecting(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultWorldStateDetecting(self._world_state_detecting_lock)

    def move_joints(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultMoveJoints(self._move_joints_lock)

    def move_gripper(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultMoveGripper(self._move_gripper_lock)

    def open(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultOpen(self._open_lock)

    def close(self):
        if ProcessModuleManager.execution_type ==  ExecutionType.SIMULATED:
            return DefaultClose(self._close_lock)


##New # Content from: #<src/pycram/robot_descriptions/ur5_description.py>#
import rospkg
from ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \
    RobotDescriptionManager
from ..datastructures.enums import Arms, Grasp, GripperState

rospack = rospkg.RosPack()
filename = rospack.get_path('pycram') + '/resources/robots/' + "ur5_robotiq" + '.urdf'

ur5_description = RobotDescription("ur5_robotiq", "world", "base_link", "ee_link",
                                   filename)

################################## Arm ##################################
arm = KinematicChainDescription("manipulator", "base_link", "wrist_3_link", ur5_description.urdf_object, arm_type=Arms.RIGHT)

arm.add_static_joint_states("home", {'shoulder_pan_joint': 0.0,
                                     'shoulder_lift_joint': 0.0,
                                     'elbow_joint': 0.0,
                                     'wrist_1_joint': 0.0,
                                     'wrist_2_joint': 0.0,
                                     'wrist_3_joint': 0.0})

ur5_description.add_kinematic_chain_description(arm)

################################## Gripper ##################################
gripper = EndEffectorDescription("gripper", "robotiq_85_base_link", "robotiq_85_right_finger_link",
                                 ur5_description.urdf_object)

gripper.add_static_joint_states(GripperState.OPEN, {'robotiq_85_left_finger_joint': 0.0,
                                         'robotiq_85_right_finger_joint': 0.0,
                                         'robotiq_85_left_inner_knuckle_joint': 0.0,
                                         'robotiq_85_right_inner_knuckle_joint': 0.0,
                                         'robotiq_85_left_finger_tip_joint': 0.0,
                                         'robotiq_85_right_finger_tip_joint': 0.0})
gripper.add_static_joint_states(GripperState.CLOSE, {'robotiq_85_left_finger_joint': 1,
                                          'robotiq_85_right_finger_joint': 1,
                                          'robotiq_85_left_inner_knuckle_joint': 1.0,
                                          'robotiq_85_right_inner_knuckle_joint': 1.0,
                                          'robotiq_85_left_finger_tip_joint': 1.0,
                                          'robotiq_85_right_finger_tip_joint': 1.0})

arm.end_effector = gripper

# Add to RobotDescriptionManager
rdm = RobotDescriptionManager()
rdm.register_description(ur5_description)


##New # Content from: #<src/pycram/robot_descriptions/stretch_description.py>#
import rospkg

from ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \
    CameraDescription, RobotDescriptionManager
from ..datastructures.enums import GripperState, Arms, Grasp

rospack = rospkg.RosPack()
filename = rospack.get_path('pycram') + '/resources/robots/' + "stretch_description" + '.urdf'

stretch_description = RobotDescription("stretch_description", "base_link", "link_lift", "joint_lift", filename)

################################## Right Arm ##################################
arm_description = KinematicChainDescription("arm", "link_mast", "link_wrist_roll", stretch_description.urdf_object,
                                            arm_type=Arms.RIGHT)

arm_description.add_static_joint_states("park", {'joint_lift': 0.0,
                                                 'joint_arm_l3': 0.0,
                                                 'joint_arm_l2': 0.0,
                                                 'joint_arm_l1': 0.0,
                                                 'joint_arm_l0': 0.0,
                                                 'joint_wrist_yaw': 0.0,
                                                 'joint_wrist_pitch': 0.0,
                                                 'joint_wrist_roll': 0.0})

stretch_description.add_kinematic_chain_description(arm_description)

################################## Right Gripper ##################################
gripper_description = EndEffectorDescription("arm", "link_straight_gripper", "link_grasp_center",
                                             stretch_description.urdf_object)

gripper_description.add_static_joint_states(GripperState.OPEN, {'joint_gripper_finger_left': 0.59,
                                                                'joint_gripper_finger_right': 0.59})
gripper_description.add_static_joint_states(GripperState.CLOSE, {'joint_gripper_finger_left': 0.0,
                                                                 'joint_gripper_finger_right': 0.0})

arm_description.end_effector = gripper_description

################################## Neck ##################################
neck = KinematicChainDescription("neck", "link_head", "link_head_tilt", stretch_description.urdf_object)

stretch_description.add_kinematic_chain_description(neck)

################################## Camera ##################################
realsense_color = CameraDescription("camera_color_optical_frame", "camera_color_optical_frame", 1.322, 1.322)
realsense_depth = CameraDescription("camera_depth_optical_frame", "camera_depth_optical_frame", 1.307, 1.307)
realsense_infra1 = CameraDescription("camera_infra1_optical_frame", "camera_infra1_optical_frame", 1.307, 1.307)
realsense_infra2 = CameraDescription("camera_infra2_optical_frame", "camera_infra2_optical_frame", 1.257, 1.257)

stretch_description.add_camera_description(realsense_color)
stretch_description.add_camera_description(realsense_depth)
stretch_description.add_camera_description(realsense_infra1)
stretch_description.add_camera_description(realsense_infra2)

################################## Grasps ##################################
stretch_description.add_grasp_orientations({Grasp.FRONT: [0, 0, 0, 1],
                                            Grasp.LEFT: [0, 0, -1, 1],
                                            Grasp.RIGHT: [0, 0, 1, 1],
                                            Grasp.TOP: [0, 1, 0, 1]})

# Add to RobotDescriptionManager
rdm = RobotDescriptionManager()
rdm.register_description(stretch_description)


##New # Content from: #<src/pycram/robot_descriptions/donbot_description.py>#
import rospkg
from ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \
    RobotDescriptionManager, CameraDescription
from ..datastructures.enums import Arms, Grasp, GripperState

rospack = rospkg.RosPack()
filename = rospack.get_path('pycram') + '/resources/robots/' + "iai_donbot" + '.urdf'

donbot_description = RobotDescription("iai_donbot", "base_link", "ur5_base_link", "arm_base_mounting_joint",
                                      filename)

################################## Right Arm ##################################
right_arm = KinematicChainDescription("right_arm", "ur5_base_link", "ur5_wrist_3_link", donbot_description.urdf_object, arm_type=Arms.RIGHT)

right_arm.add_static_joint_states("park", {'ur5_shoulder_pan_joint': 3.23,
                                           'ur5_shoulder_lift_joint': -1.51,
                                           'ur5_elbow_joint': -0.79,
                                           'ur5_wrist_1_joint': -2.33,
                                           'ur5_wrist_2_joint': 1.57,
                                           'ur5_wrist_3_joint': -1.65})

donbot_description.add_kinematic_chain_description(right_arm)

################################## Right Gripper ##################################

right_gripper = EndEffectorDescription("right_gripper", "gripper_base_link", "gripper_tool_frame",
                                       donbot_description.urdf_object)

right_gripper.add_static_joint_states(GripperState.OPEN, {'gripper_joint': 0.0})
right_gripper.add_static_joint_states(GripperState.CLOSE, {'gripper_joint': 0.2})

right_arm.end_effector = right_gripper

################################## Camera ##################################
camera = CameraDescription("camera_link", "camera_link", 0.75049, 0.5, 1.2)
donbot_description.add_camera_description(camera)

################################## Neck ##################################
donbot_description.add_kinematic_chain("neck", "ur5_base_link", "ur5_base_link")

# Add to RobotDescriptionManager
rdm = RobotDescriptionManager()
rdm.register_description(donbot_description)


##New # Content from: #<src/pycram/robot_descriptions/hsrb_description.py>#
import rospkg

from ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \
    RobotDescriptionManager, CameraDescription
from ..datastructures.enums import GripperState, Grasp, Arms

rospack = rospkg.RosPack()
filename = rospack.get_path('pycram') + '/resources/robots/' + "hsrb" + '.urdf'

hsrb_description = RobotDescription("hsrb", "base_link", "arm_lift_link", "arm_lift_joint",
                                    filename)

################################## Left Arm ##################################
left_arm = KinematicChainDescription("left_arm", "arm_lift_link", "hand_palm_link",
                                     hsrb_description.urdf_object, arm_type=Arms.LEFT)

left_arm.add_static_joint_states("park", {'arm_flex_joint': 0.0,
                                          'arm_roll_joint': 1.5,
                                          'wrist_flex_joint': -1.85,
                                          'wrist_roll_joint': 0.0})
hsrb_description.add_kinematic_chain_description(left_arm)

################################## Left Gripper ##################################
left_gripper = EndEffectorDescription("left_gripper", "wrist_roll_link", "hand_gripper_tool_frame",
                                      hsrb_description.urdf_object)

left_gripper.add_static_joint_states(GripperState.OPEN, {'hand_l_proximal_joint': 0.3,
                                                         'hand_r_proximal_joint': 0.3,
                                                         'hand_motor_joint': 0.3})
left_gripper.add_static_joint_states(GripperState.CLOSE, {'hand_l_proximal_joint': 0.0,
                                                          'hand_r_proximal_joint': 0.0,
                                                          'hand_motor_joint': 0.0})

left_arm.end_effector = left_gripper

################################## Camera ##################################

head_center_camera = CameraDescription("head_center_camera_frame", "head_center_camera_frame", 0.99483, 0.75049)
head_r_camera = CameraDescription("head_r_stereo_camera_link", "head_r_stereo_camera_link", 0.99483, 0.75049)
head_l_camera = CameraDescription("head_l_stereo_camera_link", "head_l_stereo_camera_link", 0.99483, 0.75049)
head_rgbd_camera = CameraDescription("head_rgbd_sensor_link", "head_rgbd_sensor_link", 0.99483, 0.75049)
hand_camera = CameraDescription("hand_camera_frame", "hand_camera_frame", 0.99483, 0.75049)

hsrb_description.add_camera_description(head_center_camera)
hsrb_description.add_camera_description(head_r_camera)
hsrb_description.add_camera_description(head_l_camera)
hsrb_description.add_camera_description(head_rgbd_camera)
hsrb_description.add_camera_description(hand_camera)

################################## Neck ##################################
neck = KinematicChainDescription("neck", "head_pan_link", "head_tilt_link",
                                 hsrb_description.urdf_object)

################################## Grasps ##################################
hsrb_description.add_grasp_orientations(
    {Grasp.FRONT: [-1, 0, -1, 0],
     Grasp.LEFT: [0, -1, 1, 0],
     Grasp.RIGHT: [0, -1, -1, 0.0],
     Grasp.TOP: [-1, 0, 0, 0]})

hsrb_description.add_kinematic_chain_description(neck)

# Add to RobotDescriptionManager
rdm = RobotDescriptionManager()
rdm.register_description(hsrb_description)


##New # Content from: #<src/pycram/robot_descriptions/tiago_description.py>#
import rospkg
from ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \
    RobotDescriptionManager, CameraDescription
from ..datastructures.enums import GripperState, Arms, Grasp

rospack = rospkg.RosPack()
filename = rospack.get_path('pycram') + '/resources/robots/' + "tiago_dual" + '.urdf'

tiago_description = RobotDescription("tiago_dual", "base_link", "torso_lift_link", "torso_lift_joint",
                                     filename)

################################## Left Arm ##################################
left_arm = KinematicChainDescription("left_arm", "torso_lift_link", "arm_left_7_link",
                                     tiago_description.urdf_object, arm_type=Arms.LEFT)

left_arm.add_static_joint_states("park", {'arm_left_1_joint': 0.27,
                                          'arm_left_2_joint': -1.07,
                                          'arm_left_3_joint': 1.5,
                                          'arm_left_4_joint': 1.96,
                                          'arm_left_5_joint': -2.0,
                                          'arm_left_6_joint': 1.2,
                                          'arm_left_7_joint': 0.5})

tiago_description.add_kinematic_chain_description(left_arm)

################################## Left Gripper ##################################
left_gripper = EndEffectorDescription("left_gripper", "gripper_left_link", "gripper_left_tool_link",
                                      tiago_description.urdf_object)

left_gripper.add_static_joint_states(GripperState.OPEN, {'gripper_left_left_finger_joint': 0.048,
                                                         'gripper_left_right_finger_joint': 0.048})

left_gripper.add_static_joint_states(GripperState.CLOSE, {'gripper_left_left_finger_joint': 0.0,
                                                          'gripper_left_right_finger_joint': 0.0})

left_arm.end_effector = left_gripper

################################## Right Arm ##################################
right_arm = KinematicChainDescription("right_arm", "torso_lift_link", "arm_right_7_link",
                                      tiago_description.urdf_object, arm_type=Arms.RIGHT)

right_arm.add_static_joint_states("park", {'arm_right_1_joint': 0.27,
                                           'arm_right_2_joint': -1.07,
                                           'arm_right_3_joint': 1.5,
                                           'arm_right_4_joint': 2.0,
                                           'arm_right_5_joint': -2.0,
                                           'arm_right_6_joint': 1.2,
                                           'arm_right_7_joint': 0.5})

tiago_description.add_kinematic_chain_description(right_arm)

################################## Right Gripper ##################################
right_gripper = EndEffectorDescription("right_gripper", "gripper_right_link", "gripper_right_tool_link",
                                       tiago_description.urdf_object)

right_gripper.add_static_joint_states(GripperState.OPEN, {'gripper_right_left_finger_joint': 0.048,
                                                          'gripper_right_right_finger_joint': 0.048})

right_gripper.add_static_joint_states(GripperState.CLOSE, {'gripper_right_left_finger_joint': 0.0,
                                                           'gripper_right_right_finger_joint': 0.0})

right_arm.end_effector = right_gripper

################################## Camera ##################################
camera = CameraDescription("xtion_optical_frame", "xtion_optical_frame", 0.99483, 0.75049, 1.0665, 1.4165)
tiago_description.add_camera_description(camera)

################################## Neck ##################################
tiago_description.add_kinematic_chain("neck", "torso_lift_link", "head_2_link")

################################# Grasps ##################################
tiago_description.add_grasp_orientations({Grasp.FRONT: [0, 0, 0, 1],
                                          Grasp.LEFT: [0, 0, -1, 1],
                                          Grasp.RIGHT: [0, 0, 1, 1],
                                          Grasp.TOP: [0, 1, 0, 1]})

# Add to RobotDescriptionManager
rdm = RobotDescriptionManager()
rdm.register_description(tiago_description)


##New # Content from: #<src/pycram/robot_descriptions/pr2_description.py>#
from ..robot_description import RobotDescription, KinematicChainDescription, EndEffectorDescription, \
    RobotDescriptionManager, CameraDescription
from ..datastructures.enums import Arms, Grasp, GripperState, GripperType
import rospkg

rospack = rospkg.RosPack()
filename = rospack.get_path('pycram') + '/resources/robots/' + "pr2" + '.urdf'

pr2_description = RobotDescription("pr2", "base_link", "torso_lift_link", "torso_lift_joint",
                                   filename)

################################## Left Arm ##################################
left_arm = KinematicChainDescription("left", "torso_lift_link", "l_wrist_roll_link",
                                     pr2_description.urdf_object, arm_type=Arms.LEFT)
left_arm.add_static_joint_states("park", {'l_shoulder_pan_joint': 1.712,
                                          'l_shoulder_lift_joint': -0.264,
                                          'l_upper_arm_roll_joint': 1.38,
                                          'l_elbow_flex_joint': -2.12,
                                          'l_forearm_roll_joint': 16.996,
                                          'l_wrist_flex_joint': -0.073,
                                          'l_wrist_roll_joint': 0.0})
pr2_description.add_kinematic_chain_description(left_arm)

################################## Left Gripper ##################################
left_gripper = EndEffectorDescription("left_gripper", "l_gripper_palm_link", "l_gripper_tool_frame",
                                      pr2_description.urdf_object)
left_gripper.add_static_joint_states(GripperState.OPEN, {'l_gripper_l_finger_joint': 0.548,
                                              'l_gripper_r_finger_joint': 0.548})
left_gripper.add_static_joint_states(GripperState.CLOSE, {'l_gripper_l_finger_joint': 0.0,
                                               'l_gripper_r_finger_joint': 0.0})
left_gripper.end_effector_type = GripperType.PARALLEL
left_gripper.opening_distance = 0.548
left_arm.end_effector = left_gripper

################################## Right Arm ##################################
right_arm = KinematicChainDescription("right", "torso_lift_link", "r_wrist_roll_link",
                                      pr2_description.urdf_object, arm_type=Arms.RIGHT)
right_arm.add_static_joint_states("park", {'r_shoulder_pan_joint': -1.712,
                                           'r_shoulder_lift_joint': -0.256,
                                           'r_upper_arm_roll_joint': -1.463,
                                           'r_elbow_flex_joint': -2.12,
                                           'r_forearm_roll_joint': 1.766,
                                           'r_wrist_flex_joint': -0.07,
                                           'r_wrist_roll_joint': 0.051})
pr2_description.add_kinematic_chain_description(right_arm)

################################## Right Gripper ##################################
right_gripper = EndEffectorDescription("right_gripper", "r_gripper_palm_link", "r_gripper_tool_frame",
                                       pr2_description.urdf_object)
right_gripper.add_static_joint_states(GripperState.OPEN, {'r_gripper_l_finger_joint': 0.548,
                                               'r_gripper_r_finger_joint': 0.548})
right_gripper.add_static_joint_states(GripperState.CLOSE, {'r_gripper_l_finger_joint': 0.0,
                                                'r_gripper_r_finger_joint': 0.0})
right_gripper.end_effector_type = GripperType.PARALLEL
right_gripper.opening_distance = 0.548
right_arm.end_effector = right_gripper


################################## Camera ##################################
camera = CameraDescription("kinect_camera", "wide_stereo_optical_frame", 1.27,
                           1.60, 0.99483, 0.75049)
pr2_description.add_camera_description(camera)

################################## Neck ##################################
pr2_description.add_kinematic_chain("neck", "head_pan_link", "head_tilt_link")

################################# Grasps ##################################
pr2_description.add_grasp_orientations({Grasp.FRONT: [0, 0, 0, 1],
                                        Grasp.LEFT: [0, 0, -1, 1],
                                        Grasp.RIGHT: [0, 0, 1, 1],
                                        Grasp.TOP: [0, 1, 0, 1]})

# Add to RobotDescriptionManager
rdm = RobotDescriptionManager()
rdm.register_description(pr2_description)


##New # Content from: #<src/pycram/robot_descriptions/turtlebot_description.py>#
import rospkg

from pycram.robot_description import RobotDescriptionManager, RobotDescription

# Description for turtlebot3_waffle_pi
rospack = rospkg.RosPack()
filename = rospack.get_path('pycram') + '/resources/robots/' + "turtlebot" + '.urdf'

turtlebot = RobotDescription("turtlebot", "world", "base_link", "base_joint",
                             filename)

# Add to RobotDescriptionManager
rdm = RobotDescriptionManager()
rdm.register_description(turtlebot)


##New # Content from: #<src/pycram/robot_descriptions/boxy_description.py>#
import rospkg
from ..robot_description import RobotDescription, CameraDescription, KinematicChainDescription, \
    EndEffectorDescription, RobotDescriptionManager
from ..datastructures.enums import Arms, Grasp, GripperState

rospack = rospkg.RosPack()
filename = rospack.get_path('pycram') + '/resources/robots/' + "boxy" + '.urdf'

boxy_description = RobotDescription("boxy", "base_link", "triangle_base_link", "triangle_base_joint",
                                    filename)

################################## Right Arm ##################################
right_arm = KinematicChainDescription("right_arm", "calib_right_arm_base_link", "right_arm_7_link",
                                      boxy_description.urdf_object, arm_type=Arms.RIGHT)

right_arm.add_static_joint_states("park", {"right_arm_0_joint": 1.858,
                                           "right_arm_1_joint": -0.70571,
                                           "right_arm_2_joint": -0.9614,
                                           "right_arm_3_joint": 0.602,
                                           "right_arm_4_joint": 2.5922,
                                           "right_arm_5_joint": 1.94065,
                                           "right_arm_6_joint": 1.28735})

boxy_description.add_kinematic_chain_description(right_arm)

################################## Right Gripper ##################################

right_gripper = EndEffectorDescription("right_gripper", "right_gripper_base_link", "right_gripper_tool_frame",
                                       boxy_description.urdf_object)

right_gripper.add_static_joint_states(GripperState.OPEN, {"right_gripper_joint": 0.548})
right_gripper.add_static_joint_states(GripperState.CLOSE, {"right_gripper_joint": 0.0})

right_arm.end_effector = right_gripper

################################## Left Arm ##################################
left_arm = KinematicChainDescription("left_arm", "calib_left_arm_base_link", "left_arm_7_link",
                                     boxy_description.urdf_object, arm_type=Arms.LEFT)

left_arm.add_static_joint_states("park", {"left_arm_0_joint": -1.858,
                                          "left_arm_1_joint": 0.70571,
                                          "left_arm_2_joint": 0.9614,
                                          "left_arm_3_joint": -0.602,
                                          "left_arm_4_joint": -2.5922,
                                          "left_arm_5_joint": -1.94065,
                                          "left_arm_6_joint": -1.28735})

boxy_description.add_kinematic_chain_description(left_arm)

################################## Left Gripper ##################################

left_gripper = EndEffectorDescription("left_gripper", "left_gripper_base_link", "left_gripper_tool_frame",
                                      boxy_description.urdf_object)

left_gripper.add_static_joint_states(GripperState.OPEN, {"left_gripper_joint": 0.548})
left_gripper.add_static_joint_states(GripperState.CLOSE, {"left_gripper_joint": 0.0})

left_arm.end_effector = left_gripper

################################## Camera ##################################
camera = CameraDescription("head_mount_kinect2_rgb_optical_frame", "head_mount_kinect2_rgb_optical_frame",
                           2.5, 0.99483, 0.75049)
boxy_description.add_camera_description(camera)

################################## Neck ##################################
boxy_description.add_kinematic_chain("neck", "neck_base_link", "neck_wrist_3_link")

################################# Grasps ##################################
boxy_description.add_grasp_orientations({Grasp.LEFT: [1, 0, 0, 1],
                                         Grasp.TOP: [1, 1, 0, 0],
                                         Grasp.RIGHT: [0, 1, 1, 0],
                                         Grasp.FRONT: [1, 0, 1, 0]})

# Add to RobotDescriptionManager
rdm = RobotDescriptionManager()
rdm.register_description(boxy_description)


##New # Content from: #<src/pycram/ontology/ontology_common.py>#
from __future__ import annotations

import itertools
from typing import Callable, Dict, List, Optional, Type, TYPE_CHECKING
import rospy

from ..helper import Singleton
if TYPE_CHECKING:
    from ..designator import DesignatorDescription

from owlready2 import issubclass, Thing

ONTOLOGY_SQL_BACKEND_FILE_EXTENSION = ".sqlite3"
ONTOLOGY_OWL_FILE_EXTENSION = ".owl"


class OntologyConceptHolderStore(object, metaclass=Singleton):
    """
    Singleton class storing all instances of `OntologyConceptHolder`
    """

    def __init__(self):
        """
        Initialize the OntologyConceptHolderStore
        """
        # Dictionary of all ontology concept holders, keyed by concept names
        self.__all_ontology_concept_holders: Dict[str, OntologyConceptHolder] = {}

    def add_ontology_concept_holder(self, ontology_concept_name: str, ontology_concept_holder: OntologyConceptHolder)\
            -> bool:
        """
        Add an ontology concept to the store

        :param ontology_concept_name: Name of the ontology concept to be removed
        :return: True if the ontology concept can be added into the concept store (if not already existing), otherwise False
        """
        if ontology_concept_name in self.__all_ontology_concept_holders:
            rospy.logerr(f"OntologyConceptHolder for `{ontology_concept_name}` was already created!")
            return False
        else:
            self.__all_ontology_concept_holders.setdefault(ontology_concept_name, ontology_concept_holder)
            return True

    def remove_ontology_concept(self, ontology_concept_name: str) -> bool:
        """
        Remove an ontology concept from the store

        :param ontology_concept_name: Name of the ontology concept to be removed
        :return: True if the ontology concept can be removed from the concept store (if existing), otherwise False
        """
        if ontology_concept_name in self.__all_ontology_concept_holders:
            del self.__all_ontology_concept_holders[ontology_concept_name]
            return True
        return False

    def get_ontology_concepts_by_class(self, ontology_concept_class: Type[Thing]) -> List[Thing]:
        """
        Get a list of ontology concepts for a given class

        :param ontology_concept_class: An ontology concept class
        :return: A list of ontology concepts of which the type is either the given class or its subclass
        """
        return list(itertools.chain(
            *[concept_holder.ontology_concept
              for concept_holder in self.__all_ontology_concept_holders.values()
              if issubclass(concept_holder.ontology_concept, ontology_concept_class)]))

    def get_ontology_concept_by_name(self, ontology_concept_name: str) -> Optional[Thing]:
        """
        Get the ontology concept of a given name if exists, otherwise None

        :param ontology_concept_name: Name of an ontology concept
        :return: The ontology concept of a given name if exists or None otherwise
        """
        concept_holder = self.__all_ontology_concept_holders.get(ontology_concept_name)
        return concept_holder.ontology_concept if concept_holder else None

    def get_ontology_concept_holders_by_class(self, ontology_concept_class: Type[Thing]) \
            -> List[OntologyConceptHolder]:
        """
        Get a list of ontology concept holders for a given ontology concept class

        :param ontology_concept_class: An ontology concept class
        :return: A list of ontology concept holders as instances of a given ontology concept class
        """
        return [concept_holder for concept_holder in self.__all_ontology_concept_holders.values()
                if isinstance(concept_holder.ontology_concept, ontology_concept_class)]

    def get_ontology_concept_holder_by_name(self, ontology_concept_name: str) -> Optional[OntologyConceptHolder]:
        """
        Get the ontology concept holder for one of a given name if exists, otherwise None

        :param ontology_concept_name: Name of an ontology concept
        :return: The ontology concept holder for one of a given name if exists, otherwise None
        """
        return self.__all_ontology_concept_holders.get(ontology_concept_name)

    @staticmethod
    def get_ontology_concepts_of_designator(designator: DesignatorDescription) -> List[Thing]:
        """
        Get the corresponding ontology concepts for a given designator

        :param designator: A designator associated with an ontology concept
        :return: A list of ontology concepts corresponding with a given designator
        """
        return [concept_holder.ontology_concept for concept_holder in designator.ontology_concept_holders]

    def get_designators_of_ontology_concept(self, ontology_concept_name: str) -> List[DesignatorDescription]:
        """
        Get the corresponding designators associated with a given ontology concept

        :param ontology_concept_name: An ontology concept name
        :return: A list of designators corresponding to a given ontology concept
        """
        return self.__all_ontology_concept_holders[ontology_concept_name].designators \
            if ontology_concept_name in self.__all_ontology_concept_holders else []


class OntologyConceptHolder(object):
    """
    Wrapper of an ontology concept that is either dynamically created or loaded from an ontology.
    NOTE: Since an ontology concept class, after being saved into an ontology file, must be reusable in the next time
    the ontology is loaded, there must be no other attributes of it that should be created aside from ones inherited from `owlready2.Thing`!

    :ivar ontology_concept: An ontology concept, either dynamically created, or loaded from an ontology
    """

    def __init__(self, ontology_concept: Thing):
        """
        Initialize a holder of a given ontology concept instance

        :param ontology_concept: An ontology concept instance
        """

        #: An ontology concept, either dynamically created, or loaded from an ontology
        self.ontology_concept: Thing = ontology_concept
        #: List of designators associated with this ontology concept
        self.designators: List[DesignatorDescription] = []
        # A callable used to resolve the designators to whatever of interest, like designators or their resolving results
        self.resolve: Optional[Callable] = None

        #: The store for all OntologyConceptHolder instances
        self.concept_holder_store: OntologyConceptHolderStore = OntologyConceptHolderStore()
        self.concept_holder_store.add_ontology_concept_holder(ontology_concept.name, self)

    @property
    def name(self) -> str:
        """
        Get name of the ontology concept owned by this holder

        :return: Ontology concept name
        """
        return self.ontology_concept.name if self.ontology_concept else ""

    def get_default_designator(self) -> Optional[DesignatorDescription]:
        """
        Get the first element of designators if there is, else None

        :return: The first designator associated with the ontology concept held by this holder if exists or None
        """
        return self.designators[0] if len(self.designators) > 0 else None

    def has_designator(self, designator) -> bool:
        """
        Check whether this ontology concept holder has a given designator registered with its ontology concept

        :return: True if a given designator was registered by this ontology concept holder, either by itself or under another of the same name
        """
        if designator in self.designators:
            return True
        if not hasattr(designator, "name"):
            return False
        for our_designator in self.designators:
            if hasattr(our_designator, "name") and (getattr(our_designator, "name") == getattr(designator, "name")):
                return True
        return False

    def __eq__(self, other: OntologyConceptHolder) -> bool:
        """
        Equality check based on name of the ontology concept

        :param other: Other ontology concept instance to check against
        :return: True if the ontology concept of the other holder has the same name with the current one, otherwise False
        """
        return ((self.ontology_concept == other.ontology_concept) or
                (self.ontology_concept.name == other.ontology_concept.name))


##New # Content from: #<src/pycram/ontology/ontology.py>#
from __future__ import annotations

import inspect
import itertools
import logging
import os.path

from pathlib import Path
from typing import Callable, Dict, List, Optional, Type, Tuple, Union

import rospy

from owlready2 import (Namespace, Ontology, World as OntologyWorld, Thing, EntityClass, Imp,
                       Property, ObjectProperty, OwlReadyError, types,
                       onto_path, default_world, get_namespace, get_ontology, destroy_entity,
                       sync_reasoner_pellet, sync_reasoner_hermit,
                       OwlReadyOntologyParsingError)
from owlready2.class_construct import GeneralClassAxiom

from ..datastructures.enums import ObjectType
from ..helper import Singleton
from ..designator import DesignatorDescription, ObjectDesignatorDescription

from ..ontology.ontology_common import (OntologyConceptHolderStore, OntologyConceptHolder,
                                        ONTOLOGY_SQL_BACKEND_FILE_EXTENSION)

SOMA_HOME_ONTOLOGY_IRI = "http://www.ease-crc.org/ont/SOMA-HOME.owl"
SOMA_ONTOLOGY_IRI = "http://www.ease-crc.org/ont/SOMA.owl"
SOMA_ONTOLOGY_NAMESPACE = "SOMA"
DUL_ONTOLOGY_NAMESPACE = "DUL"


class OntologyManager(object, metaclass=Singleton):
    """
    Singleton class as the adapter accessing data of an OWL ontology, largely based on owlready2.
    """

    def __init__(self, main_ontology_iri: Optional[str] = None, ontology_search_path: Optional[str] = None,
                 use_global_default_world: bool = True):
        """
        Create the singleton object of OntologyManager class

        :param main_ontology_iri: Ontology IRI (Internationalized Resource Identifier), either a URL to a remote OWL file or the full name path of a local one
        :param ontology_search_path: directory path from which a possibly existing ontology is searched. This is appended to `owlready2.onto_path`, a global variable containing a list of directories for searching local copies of ontologies (similarly to python `sys.path` for modules/packages). If not specified, the path is "$HOME/ontologies"
        :param use_global_default_world: whether or not using the owlready2-provided global default persistent world
        """
        if not ontology_search_path:
            ontology_search_path = f"{Path.home()}/ontologies"
        Path(ontology_search_path).mkdir(parents=True, exist_ok=True)
        onto_path.append(ontology_search_path)

        #: A dictionary of OWL ontologies, keyed by ontology name (same as its namespace name), eg. 'SOMA'
        self.ontologies: Dict[str, Ontology] = {}

        #: The main ontology instance created by Ontology Manager at initialization as the result of loading from `main_ontology_iri`
        self.main_ontology: Optional[Ontology] = None

        #: The SOMA ontology instance, referencing :attr:`main_ontology` in case of ontology loading from `SOMA.owl`.
        # Ref: http://www.ease-crc.org/ont/SOMA.owl
        self.soma: Optional[Ontology] = None

        #: The DUL ontology instance, referencing :attr:`main_ontology` in case of ontology loading from `DUL.owl`.
        # Ref: http://www.ease-crc.org/ont/DUL.owl
        self.dul: Optional[Ontology] = None

        #: The main ontology world, the placeholder of triples created in :attr:`main_ontology`.
        # Ref: https://owlready2.readthedocs.io/en/latest/world.html
        self.main_ontology_world: Optional[OntologyWorld] = None

        #: Ontology IRI (Internationalized Resource Identifier), either a URL to a remote OWL file or the full name path of a local one
        # Ref: https://owlready2.readthedocs.io/en/latest/onto.html
        self.main_ontology_iri: str = main_ontology_iri if main_ontology_iri else SOMA_HOME_ONTOLOGY_IRI

        #: Namespace of the main ontology
        self.main_ontology_namespace: Optional[Namespace] = None

        # Create the main ontology world holding triples
        self.create_main_ontology_world(use_global_default_world=use_global_default_world)

        # Create the main ontology & its namespace, fetching :attr:`soma`, :attr:`dul` if loading from SOMA ontology
        self.create_main_ontology()

    @staticmethod
    def print_ontology_class(ontology_class: Type[Thing]):
        """
        Print information (ancestors, super classes, subclasses, properties, etc.) of an ontology class

        :param ontology_class: An ontology class
        """
        if ontology_class is None:
            return
        rospy.loginfo(f"{ontology_class} {type(ontology_class)}")
        rospy.loginfo(f"Defined class: {ontology_class.get_defined_class()}")
        rospy.loginfo(f"Super classes: {ontology_class.is_a}")
        rospy.loginfo(f"Equivalent to: {EntityClass.get_equivalent_to(ontology_class)}")
        rospy.loginfo(f"Indirectly equivalent to: {ontology_class.get_indirect_equivalent_to()}")
        rospy.loginfo(f"Ancestors: {list(ontology_class.ancestors())}")
        rospy.loginfo(f"Subclasses: {list(ontology_class.subclasses())}")
        rospy.loginfo(f"Disjoint unions: {ontology_class.get_disjoint_unions()}")
        rospy.loginfo(f"Properties: {list(ontology_class.get_class_properties())}")
        rospy.loginfo(f"Indirect Properties: {list(ontology_class.INDIRECT_get_class_properties())}")
        rospy.loginfo(f"Instances: {list(ontology_class.instances())}")
        rospy.loginfo(f"Direct Instances: {list(ontology_class.direct_instances())}")
        rospy.loginfo(f"Inverse Restrictions: {list(ontology_class.inverse_restrictions())}")
        rospy.loginfo("-------------------")

    @staticmethod
    def print_ontology_property(ontology_property: Property):
        """
        Print information (subjects, objects, relations, etc.) of an ontology property

        :param ontology_property: An ontology property
        """
        if ontology_property is None:
            return
        property_class = type(ontology_property)
        rospy.loginfo(f"{ontology_property} {property_class}")
        rospy.loginfo(f"Relations: {list(ontology_property.get_relations())}")
        rospy.loginfo(f"Domain: {ontology_property.get_domain()}")
        rospy.loginfo(f"Range: {ontology_property.get_range()}")
        if hasattr(property_class, "_equivalent_to"):
            rospy.loginfo(f"Equivalent classes: {EntityClass.get_equivalent_to(property_class)}")
        if hasattr(property_class, "_indirect"):
            rospy.loginfo(f"Indirectly equivalent classes: {EntityClass.get_indirect_equivalent_to(property_class)}")
        rospy.loginfo(f"Property chain: {ontology_property.get_property_chain()}")
        rospy.loginfo(f"Class property type: {ontology_property.get_class_property_type()}")
        rospy.loginfo("-------------------")

    @staticmethod
    def get_default_ontology_search_path() -> Optional[str]:
        """
        Get the first ontology search path from owlready2.onto_path

        :return: the path to the ontology search path if existing, otherwise None
        """
        if onto_path:
            return onto_path[0]
        else:
            rospy.logerr("No ontology search path has been configured!")
            return None

    def get_main_ontology_dir(self) -> Optional[str]:
        """
        Get path to the directory of :attr:`main_ontology_iri` if it is a local absolute path,
        otherwise path to the default ontology search directory

        :return: the path to the directory of the main ontology IRI
        """
        return os.path.dirname(self.main_ontology_iri) if os.path.isabs(
            self.main_ontology_iri) else self.get_default_ontology_search_path()

    def create_main_ontology_world(self, use_global_default_world: bool = True) -> None:
        """
        Create the main ontology world, either reusing the owlready2-provided global default ontology world or create a new one
        A backend sqlite3 file of same name with `main_ontology` is also created at the same folder with :attr:`main_ontology_iri`
        (if it is a local absolute path). The file is automatically registered as cache for the main ontology world.

        :param use_global_default_world: whether or not using the owlready2-provided global default persistent world
        """
        self.main_ontology_world = self.create_ontology_world(
            sql_backend_filename=os.path.join(self.get_main_ontology_dir(),
                                              f"{Path(self.main_ontology_iri).stem}{ONTOLOGY_SQL_BACKEND_FILE_EXTENSION}"),
            use_global_default_world=use_global_default_world)

    @staticmethod
    def create_ontology_world(use_global_default_world: bool = False,
                              sql_backend_filename: Optional[str] = None) -> OntologyWorld:
        """
        Either reuse the owlready2-provided global default ontology world or create a new one

        :param use_global_default_world: whether or not using the owlready2-provided global default persistent world
        :param sql_backend_filename: a full file path (no need to already exist) being used as SQL backend for the ontology world. If None, memory is used instead
        :return: owlready2-provided global default ontology world or a newly created ontology world
        """
        world = default_world
        sql_backend_path_valid = sql_backend_filename and os.path.isabs(sql_backend_filename)
        sql_backend_name = sql_backend_filename if sql_backend_path_valid else "memory"
        if use_global_default_world:
            # Reuse default world
            if sql_backend_path_valid:
                world.set_backend(filename=sql_backend_filename, exclusive=False, enable_thread_parallelism=True)
            else:
                world.set_backend(exclusive=False, enable_thread_parallelism=True)
            rospy.loginfo(f"Using global default ontology world with SQL backend: {sql_backend_name}")
        else:
            # Create a new world with parallelized file parsing enabled
            if sql_backend_path_valid:
                world = OntologyWorld(filename=sql_backend_filename, exclusive=False, enable_thread_parallelism=True)
            else:
                world = OntologyWorld(exclusive=False, enable_thread_parallelism=True)
            rospy.loginfo(f"Created a new ontology world with SQL backend: {sql_backend_name}")
        return world

    def create_main_ontology(self) -> bool:
        """
        Load ontologies from :attr:`main_ontology_iri` to :attr:`main_ontology_world`
        If `main_ontology_iri` is a remote URL, Owlready2 first searches for a local copy of the OWL file (from `onto_path`),
        if not found, tries to download it from the Internet.

        :return: True if loading succeeds
        """
        ontology_info = self.load_ontology(self.main_ontology_iri)
        if ontology_info:
            self.main_ontology, self.main_ontology_namespace = ontology_info
            if self.main_ontology and self.main_ontology.loaded:
                self.soma = self.ontologies.get(SOMA_ONTOLOGY_NAMESPACE)
                self.dul = self.ontologies.get(DUL_ONTOLOGY_NAMESPACE)
        return ontology_info is not None

    def load_ontology(self, ontology_iri: str) -> Optional[Tuple[Ontology, Namespace]]:
        """
        Load an ontology from an IRI

        :param ontology_iri: An ontology IRI
        :return: A tuple including an ontology instance & its namespace
        """
        if not ontology_iri:
            rospy.logerr("Ontology IRI is empty")
            return None

        is_local_ontology_iri = not (ontology_iri.startswith("http:") or ontology_iri.startswith("https:"))

        # If `ontology_iri` is a local path
        if is_local_ontology_iri and not Path(ontology_iri).exists():
            # -> Create an empty ontology file if not existing
            with open(ontology_iri, 'w'):
                pass

        # Load ontology from `ontology_iri`
        ontology = None
        try:
            if self.main_ontology_world:
                ontology = self.main_ontology_world.get_ontology(ontology_iri).load(reload_if_newer=True)
            else:
                ontology = get_ontology(ontology_iri).load(reload_if_newer=True)
        except OwlReadyOntologyParsingError as error:
            rospy.logwarn(error)
            if is_local_ontology_iri:
                rospy.logerr(f"Main ontology failed being loaded from {ontology_iri}")
            else:
                rospy.logwarn(f"Main ontology failed being downloaded from the remote {ontology_iri}")
            return None

        # Browse loaded `ontology`, fetching sub-ontologies
        ontology_namespace = get_namespace(ontology_iri)
        if ontology and ontology.loaded:
            rospy.loginfo(
                f'Ontology [{ontology.base_iri}]\'s name: {ontology.name} has been loaded')
            rospy.loginfo(f'- main namespace: {ontology_namespace.name}')
            rospy.loginfo(f'- loaded ontologies:')

            def fetch_ontology(ontology__):
                self.ontologies[ontology__.name] = ontology__
                rospy.loginfo(ontology__.base_iri)

            self.browse_ontologies(ontology, condition=None, func=lambda ontology__: fetch_ontology(ontology__))
        else:
            rospy.logerr(f"Ontology [{ontology.base_iri}]\'s name: {ontology.name} failed being loaded")
        return ontology, ontology_namespace

    def initialized(self) -> bool:
        """
        Check if the main ontology has been loaded

        :return: True if loaded, otherwise False
        """
        return hasattr(self, "main_ontology") and self.main_ontology and self.main_ontology.loaded

    @staticmethod
    def browse_ontologies(ontology: Ontology,
                          condition: Optional[Callable] = None, func: Optional[Callable] = None, **kwargs) -> None:
        """
        Browse the loaded ontologies (including the main and imported ones), doing operations based on a condition.

        :param ontology: An ontology instance as the result of ontology loading
        :param condition: a Callable condition that if not None needs to be passed before doing operations, otherwise just always carry the operations
        :param func: a Callable specifying the operations to perform on all the loaded ontologies if condition is None, otherwise only the first ontology which meets the condition
        """
        if ontology is None:
            rospy.logerr(f"Ontology {ontology=} is None!")
            return
        elif not ontology.loaded:
            rospy.logerr(f"Ontology {ontology} was not loaded!")
            return

        will_do_func = func is not None
        # No condition: Do func for all ontologies
        if condition is None:
            if will_do_func:
                func(ontology, **kwargs)
                for sub_onto in ontology.get_imported_ontologies():
                    func(sub_onto, **kwargs)
        # Else: Only do func for the first ontology which meets the condition
        elif condition(ontology, **kwargs):
            if will_do_func: func(ontology, **kwargs)
        else:
            for sub_onto in ontology.get_imported_ontologies():
                if condition(sub_onto, **kwargs) and will_do_func:
                    func(sub_onto, **kwargs)
                    break

    def save(self, target_filename: Optional[str] = None, overwrite: bool = False) -> bool:
        """
        Save :attr:`main_ontology` to a file on disk, also caching :attr:`main_ontology_world` to a sqlite3 file

        :param target_filename: full name path of a file which the ontologies are saved into.
        :param overwrite: overwrite an existing file if it exists. If empty, they are saved to the same original OWL file from which the main ontology was loaded, or a file at the same folder with ontology search path specified at constructor if it was loaded from a remote IRI.
        :return: True if the ontology was successfully saved, False otherwise
        """

        # Save ontologies to OWL
        is_current_ontology_local = os.path.isfile(self.main_ontology_iri)
        current_ontology_filename = self.main_ontology_iri if is_current_ontology_local \
            else f"{self.get_main_ontology_dir()}/{Path(self.main_ontology_iri).name}"
        save_to_same_file = is_current_ontology_local and (target_filename == current_ontology_filename)
        if save_to_same_file and not overwrite:
            rospy.logerr(
                f"Ontologies cannot be saved to the originally loaded [{target_filename}] if not by overwriting")
            return False
        else:
            save_filename = target_filename if target_filename else current_ontology_filename
            self.main_ontology.save(save_filename)
            if save_to_same_file and overwrite:
                rospy.logwarn(f"Main ontology {self.main_ontology.name} has been overwritten to {save_filename}")
            else:
                rospy.loginfo(f"Main ontology {self.main_ontology.name} has been saved to {save_filename}")

            # Commit the whole graph data of the current ontology world, saving it into SQLite3, to be reused the next time
            # the ontologies are loaded
            main_ontology_sql_filename = self.main_ontology_world.filename
            self.main_ontology_world.save()
            if os.path.isfile(main_ontology_sql_filename):
                rospy.loginfo(
                    f"Main ontology world for {self.main_ontology.name} has been cached and saved to SQL: {main_ontology_sql_filename}")
            #else: it could be using memory cache as SQL backend
            return True

    def create_ontology_concept_class(self, class_name: str,
                                      ontology_parent_concept_class: Optional[Thing] = None,
                                      ontology: Optional[Ontology] = None) \
            -> Optional[Type[Thing]]:
        """
        Create a new concept class in a given ontology

        :param class_name: A given name to the new class
        :param ontology_parent_concept_class: An optional parent ontology class of the new class
        :param ontology: an owlready2.Ontology in which the concept class is created
        :return: The created ontology class
        """
        ontology = ontology if ontology else self.main_ontology
        ontology_concept_class = self.get_ontology_class_by_ontology(ontology, class_name)
        if ontology_concept_class:
            return ontology_concept_class

        if getattr(ontology, class_name, None):
            rospy.logerr(f"Ontology concept class {ontology.name}.{class_name} already exists")
            return None

        with ontology:
            return types.new_class(class_name, (Thing, ontology_parent_concept_class,)
            if inspect.isclass(ontology_parent_concept_class) else (Thing,))

    def create_ontology_property_class(self, class_name: str,
                                       ontology_parent_property_class: Optional[Type[Property]] = None,
                                       ontology: Optional[Ontology] = None) \
            -> Optional[Type[Property]]:
        """
        Create a new property class in a given ontology

        :param class_name: A given name to the new class
        :param ontology_parent_property_class: An optional parent ontology property class of the new class
        :param ontology: an owlready2.Ontology in which the concept class is created
        :return: The created ontology class
        """
        ontology = ontology if ontology else self.main_ontology
        parent_class = ontology_parent_property_class if (ontology_parent_property_class and
                                                          issubclass(ontology_parent_property_class,
                                                                     Property)) \
            else None

        if getattr(ontology, class_name, None):
            rospy.logerr(f"Ontology property class {ontology.name}.{class_name} already exists")
            return None

        with ontology:
            return types.new_class(class_name, (parent_class,) if parent_class else (Property,))

    def get_ontology_classes_by_condition(self, condition: Callable, first_match_only=False, **kwargs) \
            -> List[Type[Thing]]:
        """
        Get an ontology class by a given condition

        :param condition: condition of searching
        :param first_match_only: whether to only fetch the first class matching the given condition
        :return: The ontology class satisfying the given condition if found else None
        """
        out_classes = []
        for ontology_class in list(self.main_ontology.classes()):
            if condition(ontology_class, **kwargs):
                out_classes.append(ontology_class)
                if first_match_only:
                    return out_classes

        for sub_onto in self.main_ontology.get_imported_ontologies():
            for sub_ontology_class in list(sub_onto.classes()):
                if condition(sub_ontology_class, **kwargs):
                    out_classes.append(sub_ontology_class)
                    if first_match_only:
                        return out_classes

        if not out_classes:
            rospy.loginfo(f"No class with {kwargs} is found in the ontology {self.main_ontology}")
        return out_classes

    @staticmethod
    def get_ontology_class_by_ontology(ontology: Ontology, class_name: str) -> Optional[Type[Thing]]:
        """
        Get an ontology class if it exists in a given ontology

        :param ontology: an ontology instance
        :param class_name: name of the searched-for ontology class
        :return: The ontology class if it exists under the namespace of the given ontology, None otherwise
        """
        return getattr(ontology, class_name, None) if ontology else None

    def get_ontology_class(self, class_name: str) -> Optional[Type[Thing]]:
        """
        Get an ontology class by name

        :param class_name: name of the searched-for ontology class
        :return: The ontology class of the given name if existing else None
        """

        def is_matching_class_name(ontology_class: Type[Thing], ontology_class_name: str):
            return ontology_class.name == ontology_class_name

        found_classes = self.get_ontology_classes_by_condition(condition=is_matching_class_name,
                                                               ontology_class_name=class_name,
                                                               first_match_only=True)
        return found_classes[0] if len(found_classes) > 0 else None

    def get_ontology_classes_by_namespace(self, ontology_namespace: str) -> List[Type[Thing]]:
        """
        Get all ontologies classes by namespace

        :param ontology_namespace: namespace of the searched-for ontology classes
        :return: A list of the ontology classes under the given namespace
        """

        def is_matching_ontology_namespace(ontology_class: Type[Thing], ontology_namespace_: str):
            return ontology_class.namespace.name == ontology_namespace_

        return self.get_ontology_classes_by_condition(condition=is_matching_ontology_namespace,
                                                      ontology_namespace_=ontology_namespace)

    def get_ontology_classes_by_subname(self, class_subname: str) -> List[Type[Thing]]:
        """
        Get all ontologies classes by subname

        :param class_subname: a string as part of the full names of the searched-for ontology classes
        :return: A list of the ontology classes of which the name contains the given subname
        """

        def is_matching_class_subname(ontology_class: Type[Thing], ontology_class_subname: str):
            return ontology_class_subname.lower() in ontology_class.name.lower()

        return self.get_ontology_classes_by_condition(condition=is_matching_class_subname,
                                                      ontology_class_subname=class_subname)

    def get_ontology_descendant_classes(self, ancestor_class: Type[Thing], class_subname: str = "") \
            -> List[Type[Thing]]:
        """
        Get ontology descendant classes of an ancestor class given descendant class subname

        :param class_subname: a string as part of the ancestor class full name
        :return: A list of the ontology descendant classes
        """
        return [ontology_class for ontology_class in self.main_ontology.classes()
                if (class_subname.lower() in ontology_class.name.lower()) and
                (ancestor_class in ontology_class.ancestors())]

    def get_ontology_general_class_axioms(self, ontology: Optional[Ontology] = None) -> List[GeneralClassAxiom]:
        """
        Get general class axioms of an ontology
        Ref: https://owlready2.readthedocs.io/en/latest/general_class_axioms.html

        :param ontology: an ontology instance
        :return: A list of ontology axioms in the ontology
        """
        ontology = ontology if ontology else self.main_ontology
        return list(ontology.general_class_axioms())

    def create_ontology_triple_classes(self, subject_class_name: str, object_class_name: str,
                                       predicate_class_name: str, inverse_predicate_class_name: Optional[str] = None,
                                       predicate_python_attribute_name: Optional[str] = None,
                                       inverse_predicate_python_attribute_name: Optional[str] = None,
                                       ontology_subject_parent_class: Optional[Type[Thing]] = None,
                                       ontology_object_parent_class: Optional[Type[Union[Thing, object]]] = None,
                                       ontology_property_parent_class: Type[Property] = ObjectProperty,
                                       ontology_inverse_property_parent_class: Type[Property] = ObjectProperty,
                                       ontology: Optional[Ontology] = None) -> bool:
        """
        Dynamically create ontology triple classes under same namespace with the main ontology,
        as known as {subject, predicate, object}, with the relations among them

        :param subject_class_name: name of the subject class
        :param object_class_name: name of the object class
        :param predicate_class_name: name of predicate class, also used as a Python attribute of the subject class to query object instances
        :param predicate_python_attribute_name: python attribute name designated for the predicate instance
        :param inverse_predicate_class_name: name of inverse predicate
        :param inverse_predicate_python_attribute_name: python attribute name designated for the inverse predicate instance
        :param ontology_subject_parent_class: a parent class of the subject class
        :param ontology_object_parent_class: a parent class of the object class
        :param ontology_property_parent_class: a parent ontology property class, default: owlready2.ObjectProperty
        :param ontology_inverse_property_parent_class: a parent ontology inverse property class, default: owlready2.ObjectProperty
        :param ontology: an owlready2.Ontology in which triples are created
        :return: True if the ontology triple classes are created successfully
        """

        if not predicate_python_attribute_name:
            predicate_python_attribute_name = predicate_class_name
        if not inverse_predicate_python_attribute_name:
            inverse_predicate_python_attribute_name = inverse_predicate_class_name
        ontology = ontology if ontology else self.main_ontology

        # This context manager ensures all classes created here-in share the same namepsace with `self.main_ontology`
        with ontology:
            # Subject
            ontology_subject_class = self.create_ontology_concept_class(subject_class_name,
                                                                        ontology_subject_parent_class,
                                                                        ontology=ontology)
            if not ontology_subject_class:
                rospy.logerr(f"{ontology.name}: Failed creating ontology subject class named {subject_class_name}")
                return False

            # Object
            if not ontology_object_parent_class or issubclass(ontology_object_parent_class, Thing):
                ontology_object_class = self.create_ontology_concept_class(object_class_name,
                                                                           ontology_object_parent_class,
                                                                           ontology=ontology) \
                    if (object_class_name != subject_class_name) else ontology_subject_class
            else:
                ontology_object_class = ontology_object_parent_class

            if not ontology_object_class:
                rospy.logerr(f"{ontology.name}: Failed creating ontology object class named {object_class_name}")
                return False

            # Predicate
            ontology_predicate_class = self.create_ontology_property_class(predicate_class_name,
                                                                           ontology_property_parent_class,
                                                                           ontology=ontology)
            if not ontology_predicate_class:
                rospy.logerr(f"{ontology.name}: Failed creating ontology predicate class named {predicate_class_name}")
                return False
            ontology_predicate_class.domain = [ontology_subject_class]
            ontology_predicate_class.range = [ontology_object_class]
            ontology_predicate_class.python_name = predicate_python_attribute_name

            # Inverse Predicate
            if inverse_predicate_class_name:
                ontology_inverse_predicate_class = self.create_ontology_property_class(inverse_predicate_class_name,
                                                                                       ontology_inverse_property_parent_class,
                                                                                       ontology=ontology)
                if not ontology_inverse_predicate_class:
                    rospy.logerr(
                        f"{ontology.name}: Failed creating ontology inverse-predicate class named {inverse_predicate_class_name}")
                    return False
                ontology_inverse_predicate_class.inverse_property = ontology_predicate_class
                ontology_inverse_predicate_class.domain = [ontology_object_class]
                ontology_inverse_predicate_class.range = [ontology_subject_class]
                ontology_inverse_predicate_class.python_name = inverse_predicate_python_attribute_name
        return True

    def create_ontology_linked_designator(self, designator_class: Type[DesignatorDescription],
                                          ontology_concept_name: str,
                                          object_name: str,
                                          ontology_parent_class: Optional[Type[Thing]] = None) \
            -> Optional[DesignatorDescription]:
        """
        Create a designator linked to a given ontology concept

        :param designator_class: A given designator class
        :param ontology_concept_name: Ontology concept name
        :param object_name: Name of object in case of the designator to be created is an Object Designator
        :param ontology_parent_class: Parent ontology class from which the class of designator inherits
        :return: A designator associated with an ontology concept
        """
        ontology_concept_class = self.create_ontology_concept_class(ontology_concept_name, ontology_parent_class)
        return self.create_ontology_linked_designator_by_concept(designator_class=designator_class,
                                                                 ontology_concept_class=ontology_concept_class,
                                                                 object_name=object_name)

    def create_ontology_linked_designator_by_concept(self, designator_class: Type[DesignatorDescription],
                                                     ontology_concept_class: Type[Thing],
                                                     object_name: str) \
            -> Optional[DesignatorDescription]:
        """
        Create a designator that belongs to a given ontology concept class

        :param designator_class: A given designator class
        :param ontology_concept_class: An ontology concept class with which the output designator is associated
        :param object_name: Name of object in case of the designator to be created is an Object Designator
        :return: An object designator associated with the given ontology concept class if created successfully (not already exists), None otherwise
        """
        ontology_concept_name = f'{object_name}_concept'
        if len(OntologyConceptHolderStore().get_designators_of_ontology_concept(ontology_concept_name)) > 0:
            rospy.logerr(
                f"A designator named [{object_name}] is already created for ontology concept [{ontology_concept_name}]")
            return None

        # Create a designator of `designator_class`
        is_object_designator = issubclass(designator_class, ObjectDesignatorDescription)
        if is_object_designator:
            if not object_name:
                rospy.logerr(
                    f"An empty object name was given as creating its Object designator for ontology concept class [{ontology_concept_class.name}]")
                return None
            designator = designator_class(names=[object_name])
        else:
            designator = designator_class()

        # Link designator with an ontology concept of `ontology_concept_class`
        ontology_concept_holder = OntologyConceptHolderStore().get_ontology_concept_holder_by_name(
            ontology_concept_name)
        if ontology_concept_holder is None:
            ontology_concept_holder = OntologyConceptHolder(ontology_concept_class(name=ontology_concept_name,
                                                                                   namespace=self.main_ontology))
        self.set_ontology_concept_designator_connection(designator, ontology_concept_holder)
        return designator

    @staticmethod
    def set_ontology_concept_designator_connection(designator: DesignatorDescription,
                                                   ontology_concept_holder: OntologyConceptHolder) -> None:
        """
        Set two-way connection between a designator and an ontology concept

        :param designator: Designator
        :param ontology_concept_holder: Ontology concept holder
        """
        if ontology_concept_holder not in designator.ontology_concept_holders:
            designator.ontology_concept_holders.append(ontology_concept_holder)

        if not ontology_concept_holder.has_designator(designator):
            ontology_concept_holder.designators.append(designator)

    @staticmethod
    def set_ontology_relation(subject_designator: DesignatorDescription,
                              object_designator: DesignatorDescription,
                              predicate_name: str) -> bool:
        """
        Set ontology relation between subject and object designators

        :param subject_designator: An object designator as the ontology subject
        :param object_designator: An object designator as the ontology object
        :param predicate_name: Name of the predicate
        :return: True if the relation is set, False otherwise
        """
        for subject_concept_holder in subject_designator.ontology_concept_holders:
            subject_concept = subject_concept_holder.ontology_concept
            if hasattr(subject_concept, predicate_name):
                object_concepts_list = getattr(subject_concept, predicate_name)
                object_concepts_names = [concept.name for concept in object_concepts_list]
                for holder in object_designator.ontology_concept_holders:
                    if holder.ontology_concept.name not in object_concepts_names:
                        object_concepts_list.append(holder.ontology_concept)
                return True
            else:
                rospy.logerr(f"Ontology concept [{subject_concept.name}] has no predicate named [{predicate_name}]")
                return False

    @staticmethod
    def get_designators_by_subject_predicate(subject: DesignatorDescription,
                                             predicate_name: str) -> List[DesignatorDescription]:
        """
        Get list of designators of an ontology-object concept given a subject designator and predicate

        :param subject: The ontology-subject designator
        :param predicate_name: The ontology-predicate name of the relation
        :return: List of object designators
        """
        return list(itertools.chain(
            *[OntologyConceptHolderStore().get_designators_of_ontology_concept(object_concept.name)
              for subject_concept_holder in subject.ontology_concept_holders
              for object_concept in getattr(subject_concept_holder.ontology_concept, predicate_name, [])]))

    def create_ontology_object_designator_from_type(self, object_type: ObjectType,
                                                    ontology_concept_class: Type[Thing]) \
            -> Optional[ObjectDesignatorDescription]:
        """
        Create an object designator associated with an ontology concept class from a given object type

        :param object_type: An enumerated type of object
        :param ontology_concept_class: An ontology concept class
        :return: An object designator if created successfully (if not already existing), otherwise None
        """
        object_type_name = object_type.name.lower()
        object_designator = \
            self.create_ontology_linked_designator_by_concept(designator_class=ObjectDesignatorDescription,
                                                              ontology_concept_class=ontology_concept_class,
                                                              object_name=object_type_name)
        object_designator.types = [object_type_name]
        return object_designator

    @staticmethod
    def destroy_ontology_class(ontology_class, destroy_instances: bool = True):
        """
        Destroy all classes of an ontology

        :param ontology_class: The ontology class to be destroyed
        :param destroy_instances: Whether to destroy instances of those ontology classes
        """
        if destroy_instances:
            for ontology_individual in ontology_class.instances():
                destroy_entity(ontology_individual)
            OntologyConceptHolderStore().remove_ontology_concept(ontology_class.name)
        destroy_entity(ontology_class)

    def create_rule_reflexivity(self, ontology_concept_class_name: str,
                                predicate_name: str,
                                ontology: Optional[Ontology] = None) -> Imp:
        """
        Create the rule of reflexivity for a given ontology concept class.
        Same effect is obtained by creating a dynamic ontology predicate class, subclassing owlready2.ReflexiveProperty.
        Ref: https://en.wikipedia.org/wiki/Reflexive_relation

        :param ontology_concept_class_name: Name of the ontology concept class having the relation defined
        :param predicate_name: Name of the ontology predicate signifying the reflexive relation
        :param ontology: The ontology for which the rule is created
        :return: Rule of transitivity
        """
        ontology = ontology if ontology else self.main_ontology
        with ontology:
            rule = Imp()
            rule.set_as_rule(f"""{ontology_concept_class_name}(?a)
                                 -> {predicate_name}(?a, ?a)""")
            return rule

    def create_rule_symmetry(self, ontology_concept_class_name: str,
                             predicate_name: str,
                             ontology: Optional[Ontology] = None) -> Imp:
        """
        Create the rule of transitivity for a given ontology concept class.
        Same effect is obtained by creating a dynamic ontology predicate class, subclassing owlready2.SymmetricProperty.
        Ref: https://en.wikipedia.org/wiki/Symmetric_relation

        :param ontology_concept_class_name: Name of the ontology concept class having the relation defined
        :param predicate_name: Name of the ontology predicate signifying the symmetric relation
        :param ontology: The ontology for which the rule is created
        :return: Rule of symmetry
        """
        ontology = ontology if ontology else self.main_ontology
        with ontology:
            rule = Imp()
            rule.set_as_rule(f"""{ontology_concept_class_name}(?a), {ontology_concept_class_name}(?b),
                                 {predicate_name}(?a, ?b)
                                 -> {predicate_name}(?b, ?a)""")
            return rule

    def create_rule_transitivity(self, ontology_concept_class_name: str,
                                 predicate_name: str,
                                 ontology: Optional[Ontology] = None) -> Imp:
        """
        Create the rule of transitivity for a given ontology concept class.
        Same effect is obtained by creating a dynamic ontology predicate class, subclassing owlready2.TransitiveProperty.
        Ref:
        - https://en.wikipedia.org/wiki/Transitive_relation
        - https://owlready2.readthedocs.io/en/latest/properties.html#obtaining-indirect-relations-considering-subproperty-transitivity-etc

        :param ontology_concept_class_name: Name of the ontology concept class having the relation defined
        :param predicate_name: Name of the ontology predicate signifying the transitive relation
        :param ontology: The ontology for which the rule is created
        :return: Rule of transitivity
        """
        ontology = ontology if ontology else self.main_ontology
        with ontology:
            rule = Imp()
            rule.set_as_rule(
                f"""{ontology_concept_class_name}(?a), {ontology_concept_class_name}(?b), {ontology_concept_class_name}(?c),
                                 {predicate_name}(?a, ?b),
                                 {predicate_name}(?b, ?c)
                                 -> {predicate_name}(?a, ?c)""")
            return rule

    def reason(self, world: OntologyWorld = None, use_pellet_reasoner: bool = True) -> bool:
        """
        Run the reasoning on a given ontology world or :attr:`main_ontology_world` with Pellet or HermiT reasoner,
        the two currently supported by owlready2
        - By default, the reasoning works on `owlready2.default_world`
        - The reasoning also automatically save ontologies (to either in-memory cache or a temporary sqlite3 file)
        Ref:
        - https://owlready2.readthedocs.io/en/latest/reasoning.html
        - https://owlready2.readthedocs.io/en/latest/rule.html
        - https://www.researchgate.net/publication/200758993_Benchmarking_OWL_reasoners
        - https://www.researchgate.net/publication/345959058_OWL2Bench_A_Benchmark_for_OWL_2_Reasoners

        :param world: An owlready2.World to reason about. If None, use :attr:`main_ontology_world`
        :param use_pellet_reasoner: Use Pellet reasoner, otherwise HermiT
        :return: True if the reasoning was successful, otherwise False
        """
        reasoner_name = None
        reasoning_world = world if world else self.main_ontology_world
        try:
            if use_pellet_reasoner:
                reasoner_name = "Pellet"
                sync_reasoner_pellet(x=reasoning_world, infer_property_values=True,
                                     infer_data_property_values=True)
            else:
                reasoner_name = "HermiT"
                sync_reasoner_hermit(x=reasoning_world, infer_property_values=True)
        except OwlReadyError as error:
            rospy.logerr(f"{reasoner_name} reasoning failed: {error}")
            return False
        rospy.loginfo(f"{reasoner_name} reasoning finishes!")
        return True


##New # Content from: #<src/pycram/orm/action_designator.py>#
from typing_extensions import Optional

from .base import RobotState, Designator, MapperArgsMixin, PoseMixin
from .object_designator import ObjectMixin
from ..datastructures.enums import Arms, GripperState, Grasp
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import ForeignKey


class Action(MapperArgsMixin, Designator):
    """ORM class of pycram.designators.action_designator.ActionDesignator.
    The purpose of this class is to correctly map the inheritance from the action designator class into the database.
    Inheritance is implemented as Joined Table Inheritance (see https://docs.sqlalchemy.org/en/20/orm/inheritance.html)
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), primary_key=True, init=False)
    dtype: Mapped[str] = mapped_column("action_dtype", init=False)
    robot_state_id: Mapped[int] = mapped_column(ForeignKey(f"{RobotState.__tablename__}.id"), init=False)
    robot_state: Mapped[RobotState] = relationship(init=False)


class ParkArmsAction(Action):
    """ORM Class of pycram.designators.action_designator.ParkArmsDesignator."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms] = mapped_column(default=None)


class NavigateAction(PoseMixin, Action):
    """ORM Class of pycram.designators.action_designator.NavigateAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)


class MoveTorsoAction(Action):
    """ORM Class of pycram.designators.action_designator.MoveTorsoAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    position: Mapped[Optional[float]] = mapped_column(default=None)


class SetGripperAction(Action):
    """ORM Class of pycram.designators.action_designator.SetGripperAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    gripper: Mapped[Arms]
    motion: Mapped[GripperState]


class Release(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.Release."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    gripper: Mapped[Arms] = mapped_column(init=False)


class GripAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.GripAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    gripper: Mapped[Arms] = mapped_column(init=False)
    effort: Mapped[float] = mapped_column(init=False)
    # TODO grasped_object


class PickUpAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.PickUpAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]
    grasp: Mapped[Grasp]


class PlaceAction(PoseMixin, ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.PlaceAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]


class TransportAction(PoseMixin, ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.TransportAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]


class LookAtAction(PoseMixin, Action):
    """ORM Class of pycram.designators.action_designator.LookAtAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)


class DetectAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.DetectAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)


class OpenAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.OpenAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]
    # distance: Mapped[float] = mapped_column(init=False)


class CloseAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.CloseAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]


class GraspingAction(ObjectMixin, Action):
    """ORM Class of pycram.designators.action_designator.GraspingAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]


class FaceAtAction(PoseMixin, Action):
    """ORM Class of pycram.designators.action_designator.FaceAtAction."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Action.__tablename__}.id'), primary_key=True, init=False)


##New # Content from: #<src/pycram/orm/utils.py>#
import traceback
import rospy
import sqlalchemy
import pycram.orm.base
from pycram.designators.object_designator import *
import json

from pycram.designators.action_designator import *
import pycram.orm


def write_database_to_file(in_sessionmaker: sqlalchemy.orm.sessionmaker, filename: str,
                           b_write_to_console: bool = False):
    """
    Writes all Tables stored within the given session into a local file. File will be written in JSON Format

    :param in_sessionmaker: sessionmaker that allows us to access the Database
    :param filename: Filename of the logfile
    :param b_write_to_console: enables writing to the console. Default false
    """
    with in_sessionmaker() as session:
        with open("whatever.txt", "w") as f:
            to_json_dict = dict()
            for table in pycram.orm.base.Base.metadata.sorted_tables:
                list_of_row = list()
                for column_object in session.query(table).all():
                    list_of_row.append(column_object)
                to_json_dict[table.name] = list_of_row
            json_data_dict = json.dumps(to_json_dict, default=str)
            f.write(json_data_dict)


def print_database(in_sessionmaker: sqlalchemy.orm.sessionmaker):
    """
    Prints all ORM Class data within the given Session.

    :param in_sessionmaker: Database Session which should be printed
    """
    with in_sessionmaker() as session:
        for table in pycram.orm.base.Base.metadata.sorted_tables:
            try:
                smt = sqlalchemy.select('*').select_from(table)
                result = session.execute(smt).all()
                rospy.loginfo("Table: {}\tcontent:{}".format(table, result))
            except sqlalchemy.exc.ArgumentError as e:
                rospy.logwarn(e)


def update_primary_key(source_session_maker: sqlalchemy.orm.sessionmaker,
                       destination_session_maker: sqlalchemy.orm.sessionmaker):
    """
    Updates all the primary keys of the database associated with the destination engine, so that there will be no
    problems when merging it into the source database. In order to achieve this the highest id value of the source
    engine is searched and the primary keys of the destination database will get all the values following that.
    Cascading triggers in the database will take care of the rest. Careful 2023 this will not work in
    memory databases as there are no triggers.

    :param source_session_maker: Session maker of the source data_base
    :param destination_session_maker: Session maker of the destination data_base
    """
    destination_session = destination_session_maker()
    source_session = source_session_maker()
    sortedTables = pycram.orm.base.Base.metadata.sorted_tables
    for table in sortedTables:
        try:
            list_of_primary_keys_of_this_table = table.primary_key.columns.values()
            for key in list_of_primary_keys_of_this_table:
                all_source_key_values = []
                all_destination_key_values = []
                for key_value_row in source_session.query(key).all():
                    all_source_key_values.append(key_value_row[0])  # get all values of key from source session
                for key_value_row in destination_session.query(key).all():
                    all_destination_key_values.append(key_value_row[0])  # get all values of key from source session

                highest_free_key_value = max(max(all_source_key_values, default=0),
                                             max(all_destination_key_values, default=0)) + 1
                results = destination_session.execute(sqlalchemy.select(table))
                for column_object in results:  # iterate over all columns
                    if column_object.__getattr__(key.name) in all_source_key_values:
                        rospy.loginfo(
                            "Found primary_key collision in table {} value: {} max value in memory {}".format(table,
                                                                                                              column_object.__getattr__(
                                                                                                                  key.name),
                                                                                                              highest_free_key_value))
                        mini_dict = dict()
                        mini_dict[key.name] = highest_free_key_value
                        update_statement = sqlalchemy.update(table).where(
                            table.c.id == column_object.__getattr__(key)).values(mini_dict)
                        destination_session.execute(update_statement)
                        highest_free_key_value += 1
            destination_session.commit()  # commit after every table
        except AttributeError as e:
            rospy.logwarn("Possible found abstract ORM class {}".format(e.__name__))
            rospy.logwarn(e)
    destination_session.close()


def copy_database(source_session_maker: sqlalchemy.orm.sessionmaker,
                  destination_session_maker: sqlalchemy.orm.sessionmaker):
    """
    Iterates through all tables within tht source database and merges them into the destination database. Careful
    this function does not check if there are any primary key collisions or updates any data.

     .. note::
        Ignores all previously detached data, could result in loss of information. During testing database objects
        sometimes had a detached twin. As a possible feature in the future it maybe useful to give the user an
        opportunity to decide what happens with the detached objects. Careful this could lead to duplicated data in the
        destination database.

    :param source_session_maker: Sessionmaker of the source database
    :param destination_session_maker: Sessionmaker of the destination database
    """

    with source_session_maker() as source_session, destination_session_maker() as destination_session:
        sorted_tables = pycram.orm.base.Base.metadata.sorted_tables
        for table in sorted_tables:
            for value in source_session.query(table).all():
                insert_statement = sqlalchemy.insert(table).values(value)
                destination_session.execute(insert_statement)
            destination_session.commit()  # commit after every table


def update_primary_key_constrains(session_maker: sqlalchemy.orm.sessionmaker):
    '''
    Iterates through all tables related to any ORM Class and sets in their corresponding foreign keys in the given
    endpoint to "ON UPDATE CASCADING".

        .. note::
            Careful currently only works on postgres databases.

    :param session_maker:
    :return: empty
    '''
    with session_maker() as session:
        for table in pycram.orm.base.Base.metadata.sorted_tables:
            try:
                foreign_key_statement = sqlalchemy.text(
                    "SELECT con.oid, con.conname, con.contype, con.confupdtype, con.confdeltype, con.confmatchtype, pg_get_constraintdef(con.oid) FROM pg_catalog.pg_constraint con INNER JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid INNER JOIN pg_catalog.pg_namespace nsp ON nsp.oid = connamespace WHERE rel.relname = '{}';".format(
                        table))
                response = session.execute(foreign_key_statement)
                rospy.loginfo(25 * '~' + "{}".format(table) + 25 * '~')
                for line in response:
                    if line.conname.endswith("fkey"):
                        if 'a' in line.confupdtype:  # a --> no action | if there is no action we set it to cascading
                            # Assumes there aren't any other constraints
                            drop_statement = sqlalchemy.text(
                                "alter table \"{}\" drop constraint \"{}\";".format(table,
                                                                                    line.conname))
                            drop_response = session.execute(
                                drop_statement)  # There is no real data coming back for this
                            alter_statement = sqlalchemy.text(
                                "alter table \"{}\" add constraint {} {} on update cascade;".format(
                                    table,
                                    line.conname,
                                    line.pg_get_constraintdef))
                            alter_response = session.execute(
                                alter_statement)  # There is no real data coming back for this
                            session.commit()
            except AttributeError:
                rospy.loginfo("Attribute Error: {} has no attribute __tablename__".format(table))


def migrate_neems(source_session_maker: sqlalchemy.orm.sessionmaker,
                  destination_session_maker: sqlalchemy.orm.sessionmaker):
    """
        Merges the database connected to the source session maker into the database connected to the destination session
        maker. Will first update the primary constrains inside the destination database (if needed). Afterwards
        updates the primary keys within the destination database (as there are cascading updates now) and then merges
        the source database into the destination.

         .. note::
            Assumes the destination database is a postgres database

        :param source_session_maker: Sessionmaker of the source database
        :param destination_session_maker: Sessionmaker of the destination database
        """

    update_primary_key_constrains(destination_session_maker)
    update_primary_key(source_session_maker, destination_session_maker)
    copy_database(source_session_maker, destination_session_maker)


##New # Content from: #<src/pycram/orm/object_designator.py>#
from dataclasses import field
from typing import Optional

from pycram.orm.base import Base, MapperArgsMixin, PoseMixin, Pose
from sqlalchemy.orm import Mapped, mapped_column, declared_attr, relationship, MappedAsDataclass
from sqlalchemy import ForeignKey
from pycram.datastructures.enums import ObjectType


class ObjectMixin(MappedAsDataclass):
    """
    ObjectMixin holds a foreign key column and its relationship to the referenced table.
    For information about Mixins, see https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/mixins.html
    """

    __abstract__ = True
    object_to_init: bool = field(default=False, init=False)

    @declared_attr
    def object_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=self.object_to_init)

    @declared_attr
    def object(self):
        return relationship(Object.__tablename__, init=False)


class Object(PoseMixin, Base):
    """ORM class of pycram.designators.object_designator.ObjectDesignator"""

    dtype: Mapped[str] = mapped_column(init=False)
    obj_type: Mapped[Optional[ObjectType]]
    name: Mapped[str]

    __mapper_args__ = {
        "polymorphic_identity": "Object",
        "polymorphic_on": "dtype",
    }


class ObjectPart(Object):
    """ORM Class of pycram.designators.object_designator.LocatedObject."""

    id: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), primary_key=True, init=False)
    # part_of: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=False)

    __mapper_args__ = {
        "polymorphic_identity": "ObjectPart",
        "inherit_condition": Object.id == id
    }


class BelieveObject(MapperArgsMixin, Object):

    id: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), primary_key=True, init=False)


##New # Content from: #<src/pycram/orm/base.py>#
"""Implementation of base classes for orm modelling."""
import datetime
import getpass
import os
from dataclasses import field
from typing import Optional

import git
import rospkg
import sqlalchemy.sql.functions
from sqlalchemy import ForeignKey, String
from sqlalchemy.orm import DeclarativeBase, Mapped, MappedAsDataclass, mapped_column, Session, relationship, \
    declared_attr

from ..datastructures.enums import ObjectType


def get_pycram_version_from_git() -> Optional[str]:
    """
    Get the PyCRAM commit hash that is used to run this version.

    This assumes that you have gitpython installed and that the PyCRAM git repository on your system can be found
    with "roscd pycram".
    """

    r = rospkg.RosPack()
    repo = git.Repo(path=r.get_path('pycram'))
    return repo.head.object.hexsha


class _Base(DeclarativeBase, MappedAsDataclass):
    """Dummy class"""
    type_annotation_map = {
        str: String(255)
    }

    id: Mapped[int] = mapped_column(autoincrement=True, primary_key=True, init=False, nullable=False)
    """Unique integer ID as auto incremented primary key."""

    @declared_attr
    def __tablename__(self):
        return self.__name__


class Base(_Base):
    """
    Base class to add orm functionality to all pycram mappings
    """
    __abstract__ = True

    @declared_attr
    def process_metadata_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{ProcessMetaData.__tablename__}.id'), default=None, init=False)
    """Related MetaData Object to store information about the context of this experiment."""

    @declared_attr
    def process_metadata(self):
        return relationship(ProcessMetaData.__tablename__)
    """model relationship between foreign key in ProcessMetaData table and the ids of all inheriting
    tables"""


class MapperArgsMixin(MappedAsDataclass):
    """
    MapperArgsMixin stores __mapper_args__ information for certain subclass-tables.
    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html
    """

    __abstract__ = True

    @declared_attr
    def __mapper_args__(self):
        return {"polymorphic_identity": self.__tablename__}


class PositionMixin(MappedAsDataclass):
    """
    PositionMixin holds a foreign key column and its relationship to the referenced table.
    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html
    """

    __abstract__ = True
    position_to_init: bool = field(default=False, init=False)

    @declared_attr
    def position_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{Position.__tablename__}.id'), init=self.position_to_init)

    @declared_attr
    def position(self):
        return relationship(Position.__tablename__, init=False)


class QuaternionMixin(MappedAsDataclass):
    """
    QuaternionMixin holds a foreign key column and its relationship to the referenced table.
    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html
    """

    __abstract__ = True
    orientation_to_init: bool = field(default=False, init=False)

    @declared_attr
    def orientation_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{Quaternion.__tablename__}.id'), init=self.orientation_to_init)

    @declared_attr
    def orientation(self):
        return relationship(Quaternion.__tablename__, init=False)


class PoseMixin(MappedAsDataclass):
    """
    PoseMixin holds a foreign key column and its relationship to the referenced table.
    For information about Mixins, see https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html
    """

    __abstract__ = True
    pose_to_init: bool = field(default=False, init=False)

    @declared_attr
    def pose_id(self) -> Mapped[int]:
        return mapped_column(ForeignKey(f'{Pose.__tablename__}.id'), init=self.pose_to_init)

    @declared_attr
    def pose(self):
        return relationship(Pose.__tablename__, init=False)


class ProcessMetaData(_Base):
    """
    ProcessMetaData stores information about the context of this experiment.

    This class is a singleton and only one MetaData can exist per session.
    """

    created_at: Mapped[datetime.datetime] = mapped_column(server_default=sqlalchemy.sql.functions.current_timestamp(),
                                                          init=False)
    """The timestamp where this row got created. This is an aid for versioning."""

    created_by: Mapped[str] = mapped_column(default=getpass.getuser(), init=False)
    """The user that created the experiment."""

    description: Mapped[str] = mapped_column(init=False)
    """A description of the purpose (?) of this experiment."""

    pycram_version: Mapped[str] = mapped_column(default=get_pycram_version_from_git(),
                                                nullable=True, init=False)
    """The PyCRAM version used to generate this row."""

    _self = None
    """The singleton instance."""

    def __new__(cls):
        if cls._self is None:
            cls._self = super().__new__(cls)
        return cls._self

    def committed(self):
        """Return if this object is in the database or not."""
        return self.id is not None

    def insert(self, session: Session):
        """Insert this into the database using the session. Skipped if it already is inserted."""
        if not self.committed():
            session.add(self)
        return self

    @classmethod
    def reset(cls):
        """Reset the singleton instance to None, s. t. next time the class is called a new instance is created."""
        cls._self = None


class Designator(Base):
    """ORM Class holding every performed action and motion serving as every performables and motions root."""

    @declared_attr
    def dtype(self) -> Mapped[str]:
        return mapped_column(String(255), nullable=False, init=False)

    @declared_attr
    def __mapper_args__(self):
        return {
            "polymorphic_on": "dtype",
        }


class Position(Base):
    """ORM Class for 3D positions."""

    x: Mapped[float]
    y: Mapped[float]
    z: Mapped[float]


class Quaternion(Base):
    """ORM Class for Quaternions."""

    x: Mapped[float]
    y: Mapped[float]
    z: Mapped[float]
    w: Mapped[float]


class Pose(PositionMixin, QuaternionMixin, Base):
    """ORM Class for Poses."""

    time: Mapped[datetime.datetime]
    frame: Mapped[str]


class Color(Base):
    """ORM Class for Colors."""

    r: Mapped[float]
    g: Mapped[float]
    b: Mapped[float]
    alpha: Mapped[float]


class RobotState(PoseMixin, Base):
    """ORM Representation of a robots state."""

    torso_height: Mapped[float]
    """The torso height of the robot."""

    type: Mapped[ObjectType]
    """The type of the robot."""


##New # Content from: #<src/pycram/orm/views.py>#
from sqlalchemy.orm import declarative_base
from typing_extensions import Union
import sqlalchemy.orm
from sqlalchemy import table, inspect, event, select, engine, MetaData, Select, TableClause, ExecutableDDLElement
from sqlalchemy.ext.compiler import compiles
from .action_designator import PickUpAction
from .base import Position, RobotState, Pose, Base, Quaternion
from .object_designator import Object
from .tasktree import TaskTreeNode


class CreateView(ExecutableDDLElement):
    """
    Class that is used to create a view. Every instance will be compiled into a SQL CREATE VIEW statement.
    """

    def __init__(self, name: str, selectable: Select):
        self.name = name
        self.selectable = selectable


class DropView(ExecutableDDLElement):
    """
    Class that is used to drop a view. Every instance will be compiled into a SQL DROP VIEW statement.
    """

    def __init__(self, name: str):
        self.name = name


@compiles(CreateView)
def _create_view(element: CreateView, compiler, **kw) -> str:
    """
    Compiles a CreateView instance into a SQL CREATE VIEW statement.
    :param element: CreateView instance
    :param compiler: compiler
    :param kw: keyword arguments
    :return: SQL CREATE VIEW statement
    """

    return "CREATE VIEW %s AS %s" % (
        element.name,
        compiler.sql_compiler.process(element.selectable, literal_binds=True),
    )


@compiles(DropView)
def _drop_view(element: DropView, compiler, **kw) -> str:
    """
    Compiles a DropView instance into a SQL DROP VIEW statement.
    :param element: DropView instance
    :param compiler: compiler
    :param kw: keyword arguments
    :return: SQL DROP VIEW statement
    """
    return "DROP VIEW %s" % element.name


def view_exists(ddl: Union[CreateView, DropView], target, connection: engine, **kw) -> bool:
    """
    Check if a view exists.
    :param ddl: ddl instance
    :param target: target object
    :param connection: connection
    :param kw: keyword arguments
    :return: True if the view exists, False otherwise
    """

    return ddl.name in inspect(connection).get_view_names()


def view_doesnt_exist(ddl: Union[CreateView, DropView], target, connection: engine, **kw) -> bool:
    """
    Check if a view does not exist.
    :param ddl: ddl instance
    :param target: target object
    :param connection: connection
    :param kw: keyword arguments
    :return: True if the view does not exist, False otherwise
    """

    return not view_exists(ddl, target, connection, **kw)


def view(name: str, metadata: MetaData, selectable: Select) -> TableClause:
    """
    Function used to control view creation and deletion. It will listen to the after_create and before_drop events
    of the metadata object in order to either create or drop the view. The view needs to have a column id.
    """
    view = table(name)

    view._columns._populate_separate_keys(
        col._make_proxy(view) for col in selectable.selected_columns
    )

    event.listen(metadata, "after_create", CreateView(name, selectable).execute_if(callable_=view_doesnt_exist))
    event.listen(metadata, "before_drop", DropView(name).execute_if(callable_=view_exists))

    return view


base = declarative_base(metadata=Base.metadata)


class PickUpWithContextView(base):
    """
    View for pickup performables with context.
    """

    __robot_position: Position = sqlalchemy.orm.aliased(Position, flat=True)
    """
    3D Vector of robot position
    """

    __robot_pose: Pose = sqlalchemy.orm.aliased(Pose, flat=True)
    """
    Complete robot pose
    """

    __object_position: Position = sqlalchemy.orm.aliased(Position, flat=True)
    """
    3D Vector for object position
    """

    __relative_x = (__robot_position.x - __object_position.x)
    """
    Distance on x axis between robot and object
    """

    __relative_y = (__robot_position.y - __object_position.y)
    """
    Distance on y axis between robot and object
    """

    __table__ = view("PickUpWithContextView", Base.metadata,
                     (select(PickUpAction.id.label("id"), PickUpAction.arm.label("arm"),
                             PickUpAction.grasp.label("grasp"), RobotState.torso_height.label("torso_height"),
                             __relative_x.label("relative_x"), __relative_y.label("relative_y"),
                             Quaternion.x.label("quaternion_x"), Quaternion.y.label("quaternion_y"),
                             Quaternion.z.label("quaternion_z"), Quaternion.w.label("quaternion_w"),
                             Object.obj_type.label("obj_type"), TaskTreeNode.status.label("status"))
                      .join(TaskTreeNode.action.of_type(PickUpAction))
                      .join(PickUpAction.robot_state)
                      .join(__robot_pose, RobotState.pose)
                      .join(__robot_position, __robot_pose.position)
                      .join(Pose.orientation)
                      .join(PickUpAction.object)
                      .join(Object.pose)
                      .join(__object_position, Pose.position)))


##New # Content from: #<src/pycram/orm/motion_designator.py>#
"""
This module defines a set of ORM classes related to motion designators in the pycram framework.

Each motion designator class has its own table in the database with columns representing its attributes.
The MotionDesignator class is the base class that defines the polymorphic behavior of all other motion designator
classes.
"""
from typing_extensions import Optional

from .base import MapperArgsMixin, Designator, PoseMixin
from .object_designator import Object
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import ForeignKey

from ..datastructures.enums import ObjectType, Arms, GripperState


class Motion(MapperArgsMixin, Designator):
    """
    ORM class of pycram.designators.motion_designator.MotionDesignatorDescription

    :ivar id: (Integer) Auto-incrementing primary key
    :ivar dtype: (String) Polymorphic discriminator
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), primary_key=True, init=False)
    dtype: Mapped[str] = mapped_column("motion_dtype", init=False)


class MoveMotion(PoseMixin, Motion):
    """
    ORM class of pycram.designators.motion_designator.MoveMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)


class AccessingMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.AccessingMotion

    :ivar arm: (String) Name of the arm used
    :ivar gripper: (String) Name of the gripper used
    :ivar distance: (Float) Distance from the drawer to the robot
    :ivar drawer_joint:
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    part_of: Mapped[int] = mapped_column(ForeignKey(f'{Object.__tablename__}.id'), init=False)
    object: Mapped[Object] = relationship(init=False)
    arm: Mapped[Arms] = mapped_column(init=False)
    gripper: Mapped[str] = mapped_column(init=False)
    distance: Mapped[float] = mapped_column(init=False)
    drawer_joint: Mapped[str] = mapped_column(init=False)
    drawer_handle: Mapped[str] = mapped_column(init=False)


class MoveTCPMotion(PoseMixin, Motion):
    """
    ORM class of pycram.designators.motion_designator.MoveTCPMotion

    :ivar arm: String specifying which arm to move the TCP of
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]
    allow_gripper_collision: Mapped[Optional[bool]]


class LookingMotion(PoseMixin, Motion):
    """
    ORM class of pycram.designators.motion_designator.LookingMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)


class MoveGripperMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.MoveGripperMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    motion: Mapped[GripperState]
    gripper: Mapped[Arms]
    allow_gripper_collision: Mapped[Optional[bool]]


class DetectingMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.DetectingMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    object_type: Mapped[ObjectType]


class WorldStateDetectingMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.WorldStateDetectingMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    object_type: Mapped[str] = mapped_column(init=False)


class OpeningMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.OpeningMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]


class ClosingMotion(Motion):
    """
    ORM class of pycram.designators.motion_designator.ClosingMotion
    """

    id: Mapped[int] = mapped_column(ForeignKey(f'{Motion.__tablename__}.id'), primary_key=True, init=False)
    arm: Mapped[Arms]


##New # Content from: #<src/pycram/orm/tasktree.py>#
"""Implementation of ORM classes associated with pycram.task."""
from typing_extensions import Optional
from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base, Designator
from pycram.datastructures.enums import TaskStatus
import datetime


class TaskTreeNode(Base):
    """ORM equivalent of pycram.task.TaskTreeNode."""

    id: Mapped[int] = mapped_column(autoincrement=True, primary_key=True, init=False)

    action_id: Mapped[Optional[int]] = mapped_column(ForeignKey(f'{Designator.__tablename__}.id'), init=False)
    action: Mapped[Optional[Designator]] = relationship(init=False)

    start_time: Mapped[datetime.datetime]
    end_time: Mapped[Optional[datetime.datetime]]

    status: Mapped[TaskStatus]
    reason: Mapped[Optional[str]]

    parent_id: Mapped[Optional[int]] = mapped_column(ForeignKey("TaskTreeNode.id"), init=False)
    parent: Mapped[Optional["TaskTreeNode"]] = relationship(init=False, remote_side=[id])




##New # Content from: #<src/pycram/external_interfaces/move_base.py>#
import sys

import rospy
import actionlib
import rosnode
from geometry_msgs.msg import PoseStamped
from typing import Callable

try:
    from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
except ModuleNotFoundError as e:
    rospy.logwarn(f"Could not import MoveBase messages, Navigation interface could not be initialized")


# Global variables for shared resources
nav_action_client = None
is_init = False


def create_nav_action_client() -> actionlib.SimpleActionClient:
    """Creates a new action client for the move_base interface."""
    client = actionlib.SimpleActionClient("move_base", MoveBaseAction)
    rospy.loginfo("Waiting for move_base action server")
    client.wait_for_server()
    return client


def init_nav_interface(func: Callable) -> Callable:
    """Ensures initialization of the navigation interface before function execution."""

    def wrapper(*args, **kwargs):
        global is_init
        global nav_action_client

        if is_init:
            return func(*args, **kwargs)

        if "move_base_msgs" not in sys.modules:
            rospy.logwarn("Could not initialize the navigation interface: move_base_msgs not imported")
            return

        if "/move_base" in rosnode.get_node_names():
            nav_action_client = create_nav_action_client()
            rospy.loginfo("Successfully initialized navigation interface")
            is_init = True
        else:
            rospy.logwarn("Move_base is not running, could not initialize navigation interface")
            return

        return func(*args, **kwargs)

    return wrapper


@init_nav_interface
def query_pose_nav(navpose: PoseStamped):
    """Sends a goal to the move_base service, initiating robot navigation to a given pose."""
    global nav_action_client
    global query_result

    def active_callback():
        rospy.loginfo("Sent query to move_base")

    def done_callback(state, result):
        rospy.loginfo("Finished moving")
        global query_result
        query_result = result

    goal_msg = MoveBaseGoal()
    goal_msg.target_pose = navpose
    nav_action_client.send_goal(goal_msg, active_cb=active_callback, done_cb=done_callback)

    nav_action_client.wait_for_result()

    return query_result


def cancel_nav():
    """Cancels the current navigation goal."""
    global nav_action_client
    nav_action_client.cancel_all_goals()


##New # Content from: #<src/pycram/external_interfaces/giskard.py>#
import json
import threading
import time

import rospy
import sys
import rosnode

from ..datastructures.enums import JointType, ObjectType
from ..datastructures.pose import Pose
# from ..robot_descriptions import robot_description
from ..datastructures.world import World
from ..datastructures.dataclasses import MeshVisualShape
from ..world_concepts.world_object import Object
# from ..robot_description import ManipulatorDescription
from ..robot_description import RobotDescription

from typing_extensions import List, Dict, Callable, Optional
from geometry_msgs.msg import PoseStamped, PointStamped, QuaternionStamped, Vector3Stamped
from threading import Lock, RLock

try:
    from giskardpy.python_interface.old_python_interface import OldGiskardWrapper as GiskardWrapper
    from giskard_msgs.msg import WorldBody, MoveResult, CollisionEntry
    #from giskard_msgs.srv import UpdateWorldRequest, UpdateWorld, UpdateWorldResponse, RegisterGroupResponse
except ModuleNotFoundError as e:
    rospy.logwarn("Failed to import Giskard messages, the real robot will not be available")

giskard_wrapper = None
giskard_update_service = None
is_init = False

number_of_par_goals = 0
giskard_lock = Lock()
giskard_rlock = RLock()
with giskard_rlock:
    par_threads = {}
    par_motion_goal = {}


def thread_safe(func: Callable) -> Callable:
    """
    Adds thread safety to a function via a decorator. This uses the giskard_lock

    :param func: Function that should be thread safe
    :return: A function with thread safety
    """

    def wrapper(*args, **kwargs):
        with giskard_rlock:
            return func(*args, **kwargs)

    return wrapper


def init_giskard_interface(func: Callable) -> Callable:
    """
    Checks if the ROS messages are available and if giskard is running, if that is the case the interface will be
    initialized.

    :param func: Function this decorator should be wrapping
    :return: A callable function which initializes the interface and then calls the wrapped function
    """

    def wrapper(*args, **kwargs):
        global giskard_wrapper
        global giskard_update_service
        global is_init
        if is_init and "/giskard" in rosnode.get_node_names():
            return func(*args, **kwargs)
        elif is_init and "/giskard" not in rosnode.get_node_names():
            rospy.logwarn("Giskard node is not available anymore, could not initialize giskard interface")
            is_init = False
            giskard_wrapper = None
            return

        if "giskard_msgs" not in sys.modules:
            rospy.logwarn("Could not initialize the Giskard interface since the giskard_msgs are not imported")
            return

        if "/giskard" in rosnode.get_node_names():
            giskard_wrapper = GiskardWrapper()
            giskard_update_service = rospy.ServiceProxy("/giskard/update_world", UpdateWorld)
            rospy.loginfo_once("Successfully initialized Giskard interface")
            is_init = True
        else:
            rospy.logwarn("Giskard is not running, could not initialize Giskard interface")
            return
        return func(*args, **kwargs)

    return wrapper


# Believe state management between pycram and giskard


@init_giskard_interface
def initial_adding_objects() -> None:
    """
    Adds object that are loaded in the World to the Giskard belief state, if they are not present at the moment.
    """
    groups = giskard_wrapper.get_group_names()
    for obj in World.current_world.objects:
        if obj is World.robot or obj is World.current_world.get_prospection_object_for_object(World.robot):
            continue
        name = obj.name
        if name not in groups:
            spawn_object(obj)


@init_giskard_interface
def removing_of_objects() -> None:
    """
    Removes objects that are present in the Giskard belief state but not in the World from the Giskard belief state.
    """
    groups = giskard_wrapper.get_group_names()
    object_names = list(
        map(lambda obj: object_names.name, World.current_world.objects))
    diff = list(set(groups) - set(object_names))
    for grp in diff:
        giskard_wrapper.remove_group(grp)


@init_giskard_interface
def sync_worlds() -> None:
    """
    Synchronizes the World and the Giskard belief state, this includes adding and removing objects to the Giskard
    belief state such that it matches the objects present in the World and moving the robot to the position it is
    currently at in the World.
    """
    add_gripper_groups()
    world_object_names = set()
    for obj in World.current_world.objects:
        if obj.name != RobotDescription.current_robot_description.name and obj.obj_type != ObjectType.ROBOT and len(obj.link_name_to_id) != 1:
            world_object_names.add(obj.name)
        if obj.name == RobotDescription.current_robot_description.name or obj.obj_type == ObjectType.ROBOT:
            joint_config = obj.get_positions_of_all_joints()
            non_fixed_joints = list(filter(lambda joint: joint.type != JointType.FIXED, obj.joints.values()))
            joint_config_filtered = {joint.name: joint_config[joint.name] for joint in non_fixed_joints}

            giskard_wrapper.monitors.add_set_seed_configuration(joint_config_filtered,
                                                                RobotDescription.current_robot_description.name)
            giskard_wrapper.monitors.add_set_seed_odometry(_pose_to_pose_stamped(obj.get_pose()),
                                                           RobotDescription.current_robot_description.name)
    giskard_object_names = set(giskard_wrapper.get_group_names())
    robot_name = {RobotDescription.current_robot_description.name}
    if not world_object_names.union(robot_name).issubset(giskard_object_names):
        giskard_wrapper.clear_world()
    initial_adding_objects()


@init_giskard_interface
def update_pose(object: Object) -> 'UpdateWorldResponse':
    """
    Sends an update message to giskard to update the object position. Might not work when working on the real robot just
    in standalone mode.

    :param object: Object that should be updated
    :return: An UpdateWorldResponse
    """
    return giskard_wrapper.update_group_pose(object.name)


@init_giskard_interface
def spawn_object(object: Object) -> None:
    """
    Spawns a World Object in the giskard belief state.

    :param object: World object that should be spawned
    """
    if len(object.link_name_to_id) == 1:
        geometry = object.get_link_geometry(object.root_link_name)
        if isinstance(geometry, MeshVisualShape):
            filename = geometry.file_name
            spawn_mesh(object.name, filename, object.get_pose())
    else:
        spawn_urdf(object.name, object.path, object.get_pose())


@init_giskard_interface
def remove_object(object: Object) -> 'UpdateWorldResponse':
    """
    Removes an object from the giskard belief state.

    :param object: The World Object that should be removed
    """
    return giskard_wrapper.remove_group(object.name)


@init_giskard_interface
def spawn_urdf(name: str, urdf_path: str, pose: Pose) -> 'UpdateWorldResponse':
    """
    Spawns an URDF in giskard's belief state.

    :param name: Name of the URDF
    :param urdf_path: Path to the URDF file
    :param pose: Pose in which the URDF should be spawned
    :return: An UpdateWorldResponse message
    """
    urdf_string = ""
    with open(urdf_path) as f:
        urdf_string = f.read()

    return giskard_wrapper.add_urdf(name, urdf_string, pose)


@init_giskard_interface
def spawn_mesh(name: str, path: str, pose: Pose) -> 'UpdateWorldResponse':
    """
    Spawns a mesh into giskard's belief state

    :param name: Name of the mesh
    :param path: Path to the mesh file
    :param pose: Pose in which the mesh should be spawned
    :return: An UpdateWorldResponse message
    """
    return giskard_wrapper.add_mesh(name, path, pose)


# Sending Goals to Giskard

@thread_safe
def _manage_par_motion_goals(goal_func, *args) -> Optional['MoveResult']:
    """
    Manages multiple goals that should be executed in parallel. The current sequence of motion goals is saved and the
    parallel motion goal is loaded if there is one, then the new motion goal given by ``goal_func`` is added to the
    parallel motion goal. If this was the last motion goal for the parallel motion goal it is then executed.

    :param goal_func: Function which adds a new motion goal to the giskard_wrapper
    :param args: Arguments for the ``goal_func`` function
    :return: MoveResult of the execution if there was an execution, True if a new motion goal was added to the giskard_wrapper and None in any other case
    """
    # key is the instance of the parallel language element, value is a list of threads that should be executed in
    # parallel
    for key, value in par_threads.items():
        # if the current thread is in the list of threads that should be executed in parallel backup the current list
        # of motion goals and monitors
        if threading.get_ident() in value:
            tmp_goals = giskard_wrapper.motion_goals.get_goals()
            tmp_monitors = giskard_wrapper.monitors.get_monitors()

            if key in par_motion_goal.keys():
                # giskard_wrapper.cmd_seq = par_motion_goal[key]
                giskard_wrapper.motion_goals._goals = par_motion_goal[key][0]
                giskard_wrapper.monitors._monitors = par_motion_goal[key][1]
            else:
                giskard_wrapper.clear_motion_goals_and_monitors()

            goal_func(*args)

            # Check if there are multiple constraints that use the same joint, if this is the case the
            used_joints = set()
            for cmd in giskard_wrapper.motion_goals.get_goals():
                par_value_pair = json.loads(cmd.kwargs)
                if "tip_link" in par_value_pair.keys() and "root_link" in par_value_pair.keys():
                    if par_value_pair["tip_link"] == robot_description.base_link:
                        continue
                    chain = World.robot.description.get_chain(par_value_pair["root_link"],
                                                              par_value_pair["tip_link"])
                    if set(chain).intersection(used_joints) != set():
                        giskard_wrapper.motion_goals._goals = tmp_goals
                        giskard_wrapper.monitors._monitors = tmp_monitors
                        raise AttributeError(
                            f"The joint(s) {set(chain).intersection(used_joints)} is used by multiple Designators")
                    else:
                        [used_joints.add(joint) for joint in chain]

                elif "goal_state" in par_value_pair.keys():
                    if set(par_value_pair["goal_state"].keys()).intersection(used_joints) != set():
                        giskard_wrapper.motion_goals._goals = tmp_goals
                        giskard_wrapper.monitors._monitors = tmp_monitors
                        raise AttributeError(
                            f"The joint(s) {set(par_value_pair['goal_state'].keys()).intersection(used_joints)} is used by multiple Designators")
                    else:
                        [used_joints.add(joint) for joint in par_value_pair["goal_state"].keys()]

            par_threads[key].remove(threading.get_ident())
            # If this is the last thread that should be executed in parallel, execute the complete sequence of motion
            # goals
            if len(par_threads[key]) == 0:
                if key in par_motion_goal.keys():
                    del par_motion_goal[key]
                del par_threads[key]
                # giskard_wrapper.add_default_end_motion_conditions()
                res = giskard_wrapper.execute()
                giskard_wrapper.motion_goals._goals = tmp_goals
                giskard_wrapper.monitors._monitors = tmp_monitors
                return res
            # If there are still threads that should be executed in parallel, save the current state of motion goals and
            # monitors.
            else:
                par_motion_goal[key] = [giskard_wrapper.motion_goals.get_goals(),
                                        giskard_wrapper.monitors.get_monitors()]
                giskard_wrapper.motion_goals._goals = tmp_goals
                giskard_wrapper.monitors._monitors = tmp_monitors
                return True


@init_giskard_interface
@thread_safe
def achieve_joint_goal(goal_poses: Dict[str, float]) -> 'MoveResult':
    """
    Takes a dictionary of joint position that should be achieved, the keys in the dictionary are the joint names and
    values are the goal joint positions.

    :param goal_poses: Dictionary with joint names and position goals
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_joint_goal, goal_poses)
    if par_return:
        return par_return

    giskard_wrapper.set_joint_goal(goal_poses)
    # giskard_wrapper.add_default_end_motion_conditions()
    return giskard_wrapper.execute()


@init_giskard_interface
@thread_safe
def achieve_cartesian_goal(goal_pose: Pose, tip_link: str, root_link: str, position_threshold: float = 0.02, orientation_threshold: float = 0.02) -> 'MoveResult':
    """
    Takes a cartesian position and tries to move the tip_link to this position using the chain defined by
    tip_link and root_link.

    :param goal_pose: The position which should be achieved with tip_link
    :param tip_link: The end link of the chain as well as the link which should achieve the goal_pose
    :param root_link: The starting link of the chain which should be used to achieve this goal
    :param position_threshold: Position distance at which the goal is successfully reached
    :param orientation_threshold: Orientation distance at which the goal is successfully reached
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_cart_goal, _pose_to_pose_stamped(goal_pose),
                                          tip_link, root_link)
    if par_return:
        return par_return

    cart_monitor1 = giskard_wrapper.monitors.add_cartesian_pose(root_link=root_link, tip_link=tip_link,
                                                                goal_pose=_pose_to_pose_stamped(goal_pose),
                                                                position_threshold=position_threshold, orientation_threshold=orientation_threshold,
                                                                name='cart goal 1')
    end_monitor = giskard_wrapper.monitors.add_local_minimum_reached(start_condition=cart_monitor1)

    giskard_wrapper.motion_goals.add_cartesian_pose(name='g1', root_link=root_link, tip_link=tip_link,
                                                    goal_pose=_pose_to_pose_stamped(goal_pose),
                                                    end_condition=cart_monitor1)

    giskard_wrapper.monitors.add_end_motion(start_condition=end_monitor)
    giskard_wrapper.motion_goals.avoid_all_collisions()
    giskard_wrapper.motion_goals.allow_collision(group1='gripper', group2=CollisionEntry.ALL)
    return giskard_wrapper.execute()


@init_giskard_interface
@thread_safe
def achieve_straight_cartesian_goal(goal_pose: Pose, tip_link: str,
                                    root_link: str) -> 'MoveResult':
    """
    Takes a cartesian position and tries to move the tip_link to this position in a straight line, using the chain
    defined by tip_link and root_link.

    :param goal_pose: The position which should be achieved with tip_link
    :param tip_link: The end link of the chain as well as the link which should achieve the goal_pose
    :param root_link: The starting link of the chain which should be used to achieve this goal
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_straight_cart_goal, _pose_to_pose_stamped(goal_pose),
                                          tip_link, root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_straight_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)
    # giskard_wrapper.add_default_end_motion_conditions()
    return giskard_wrapper.execute()


@init_giskard_interface
@thread_safe
def achieve_translation_goal(goal_point: List[float], tip_link: str, root_link: str) -> 'MoveResult':
    """
    Tries to move the tip_link to the position defined by goal_point using the chain defined by root_link and
    tip_link. Since goal_point only defines the position but no rotation, rotation is not taken into account.

    :param goal_point: The goal position of the tip_link
    :param tip_link: The link which should be moved to goal_point as well as the end of the used chain
    :param root_link: The start link of the chain
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_translation_goal, make_point_stamped(goal_point),
                                          tip_link, root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_translation_goal(make_point_stamped(goal_point), tip_link, root_link)
    # giskard_wrapper.add_default_end_motion_conditions()
    return giskard_wrapper.execute()


@init_giskard_interface
@thread_safe
def achieve_straight_translation_goal(goal_point: List[float], tip_link: str, root_link: str) -> 'MoveResult':
    """
    Tries to move the tip_link to the position defined by goal_point in a straight line, using the chain defined by
    root_link and tip_link. Since goal_point only defines the position but no rotation, rotation is not taken into account.

    :param goal_point: The goal position of the tip_link
    :param tip_link: The link which should be moved to goal_point as well as the end of the used chain
    :param root_link: The start link of the chain
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_straight_translation_goal,
                                          make_point_stamped(goal_point),
                                          tip_link, root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_straight_translation_goal(make_point_stamped(goal_point), tip_link, root_link)
    # giskard_wrapper.add_default_end_motion_conditions()
    return giskard_wrapper.execute()


@init_giskard_interface
@thread_safe
def achieve_rotation_goal(quat: List[float], tip_link: str, root_link: str) -> 'MoveResult':
    """
    Tries to bring the tip link into the rotation defined by quat using the chain defined by root_link and
    tip_link.

    :param quat: The rotation that should be achieved, given as a quaternion
    :param tip_link: The link that should be in the rotation defined by quat
    :param root_link: The start link of the chain
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_rotation_goal, make_quaternion_stamped(quat),
                                          tip_link, root_link)
    if par_threads:
        return par_return

    giskard_wrapper.set_rotation_goal(make_quaternion_stamped(quat), tip_link, root_link)
    # giskard_wrapper.add_default_end_motion_conditions()
    return giskard_wrapper.execute()


@init_giskard_interface
@thread_safe
def achieve_align_planes_goal(goal_normal: List[float], tip_link: str, tip_normal: List[float],
                              root_link: str) -> 'MoveResult':
    """
    Tries to align the plane defined by tip normal with goal_normal using the chain between root_link and
    tip_link.

    :param goal_normal: The goal plane, given as a list of XYZ
    :param tip_link: The end link of the chain that should be used.
    :param tip_normal: The plane that should be aligned with goal_normal, given as a list of XYZ
    :param root_link: The starting link of the chain that should be used.
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_align_planes_goal, make_vector_stamped(goal_normal),
                                          tip_link, make_vector_stamped(tip_normal), root_link)
    if par_return:
        return par_return

    giskard_wrapper.set_align_planes_goal(make_vector_stamped(goal_normal), tip_link,
                                          make_vector_stamped(tip_normal),
                                          root_link)
    # giskard_wrapper.add_default_end_motion_conditions()
    return giskard_wrapper.execute()


@init_giskard_interface
@thread_safe
def achieve_open_container_goal(tip_link: str, environment_link: str) -> 'MoveResult':
    """
    Tries to open a container in an environment, this only works if the container was added as a URDF. This goal assumes
    that the handle was already grasped. Can only handle container with 1 DOF

    :param tip_link: The End effector that should open the container
    :param environment_link: The name of the handle for this container.
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_open_container_goal, tip_link, environment_link)
    if par_return:
        return par_return
    giskard_wrapper.set_open_container_goal(tip_link, environment_link)
    # giskard_wrapper.add_default_end_motion_conditions()
    return giskard_wrapper.execute()


@init_giskard_interface
@thread_safe
def achieve_close_container_goal(tip_link: str, environment_link: str) -> 'MoveResult':
    """
    Tries to close a container, this only works if the container was added as a URDF. Assumes that the handle of the
    container was already grasped. Can only handle container with 1 DOF.

    :param tip_link: Link name that should be used to close the container.
    :param environment_link: Name of the handle
    :return: MoveResult message for this goal
    """
    sync_worlds()
    par_return = _manage_par_motion_goals(giskard_wrapper.set_close_container_goal, tip_link, environment_link)
    if par_return:
        return par_return

    giskard_wrapper.set_close_container_goal(tip_link, environment_link)
    # giskard_wrapper.add_default_end_motion_conditions()
    return giskard_wrapper.execute()


# Projection Goals


@init_giskard_interface
def projection_cartesian_goal(goal_pose: Pose, tip_link: str, root_link: str) -> 'MoveResult':
    """
    Tries to move the tip_link to the position defined by goal_pose using the chain defined by tip_link and root_link.
    The goal_pose is projected to the closest point on the robot's workspace.

    :param goal_pose: The position which should be achieved with tip_link
    :param tip_link: The end link of the chain as well as the link which should achieve the goal_pose
    :param root_link: The starting link of the chain which should be used to achieve this goal
    :return: MoveResult message for this goal
    """
    sync_worlds()
    giskard_wrapper.set_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)
    return giskard_wrapper.projection()


@init_giskard_interface
def projection_cartesian_goal_with_approach(approach_pose: Pose, goal_pose: Pose, tip_link: str, root_link: str,
                                            robot_base_link: str) -> 'MoveResult':
    """
    Tries to achieve the goal_pose using the chain defined by tip_link and root_link. The approach_pose is used to drive
    the robot to a pose close the actual goal pose, the robot_base_link is used to define the base link of the robot.

    :param approach_pose: Pose near the goal_pose
    :param goal_pose: Pose to which the tip_link should be moved
    :param tip_link: The link which should be moved to goal_pose, usually the tool frame
    :param root_link: The start of the link chain which should be used for planning
    :param robot_base_link: The base link of the robot
    :return: A trajectory calculated to move the tip_link to the goal_pose
    """
    sync_worlds()
    giskard_wrapper.allow_all_collisions()
    giskard_wrapper.set_cart_goal(_pose_to_pose_stamped(approach_pose), robot_base_link, "map")
    giskard_wrapper.projection()
    giskard_wrapper.avoid_all_collisions()
    giskard_wrapper.set_cart_goal(_pose_to_pose_stamped(goal_pose), tip_link, root_link)
    return giskard_wrapper.projection()


@init_giskard_interface
def projection_joint_goal(goal_poses: Dict[str, float], allow_collisions: bool = False) -> 'MoveResult':
    """
    Tries to achieve the joint goal defined by goal_poses, the goal_poses are projected to the closest point on the
    robot's workspace.

    :param goal_poses: Dictionary with joint names and position goals
    :param allow_collisions: If all collisions should be allowed for this goal
    :return: MoveResult message for this goal
    """
    sync_worlds()
    if allow_collisions:
        giskard_wrapper.allow_all_collisions()
    giskard_wrapper.set_joint_goal(goal_poses)
    return giskard_wrapper.projection()


# Managing collisions

@init_giskard_interface
def allow_gripper_collision(gripper: str) -> None:
    """
    Allows the specified gripper to collide with anything.

    :param gripper: The gripper which can collide, either 'right', 'left' or 'all'
    """
    add_gripper_groups()
    for gripper_group in get_gripper_group_names():
        if gripper in gripper_group or gripper == "all":
            giskard_wrapper.allow_collision(gripper_group, CollisionEntry.ALL)


@init_giskard_interface
def get_gripper_group_names() -> List[str]:
    """
    Returns a list of groups that are registered in giskard which have 'gripper' in their name.

    :return: The list of gripper groups
    """
    groups = giskard_wrapper.get_group_names()
    return list(filter(lambda elem: "gripper" in elem, groups))


@init_giskard_interface
def add_gripper_groups() -> None:
    """
    Adds the gripper links as a group for collision avoidance.

    :return: Response of the RegisterGroup Service
    """
    with giskard_lock:
        for name in giskard_wrapper.get_group_names():
            if "gripper" in name:
                return
        for description in RobotDescription.current_robot_description.get_manipulator_chains():
            giskard_wrapper.register_group(description.name + "_gripper", description.start_link, RobotDescription.current_robot_description.name)


@init_giskard_interface
def avoid_all_collisions() -> None:
    """
    Will avoid all collision for the next goal.
    """
    giskard_wrapper.avoid_all_collisions()


@init_giskard_interface
def allow_self_collision() -> None:
    """
    Will allow the robot collision with itself.
    """
    giskard_wrapper.allow_self_collision()


@init_giskard_interface
def avoid_collisions(object1: Object, object2: Object) -> None:
    """
    Will avoid collision between the two objects for the next goal.

    :param object1: The first World Object
    :param object2: The second World Object
    """
    giskard_wrapper.avoid_collision(-1, object1.name, object2.name)


# Creating ROS messages

@init_giskard_interface
def make_world_body(object: Object) -> 'WorldBody':
    """
    Creates a WorldBody message for a World Object. The WorldBody will contain the URDF of the World Object

    :param object: The World Object
    :return: A WorldBody message for the World Object
    """
    urdf_string = ""
    with open(object.path) as f:
        urdf_sting = f.read()
    urdf_body = WorldBody()
    urdf_body.type = WorldBody.URDF_BODY
    urdf_body.urdf = urdf_string

    return urdf_body


def make_point_stamped(point: List[float]) -> PointStamped:
    """
    Creates a PointStamped message for the given position in world coordinate frame.

    :param point: XYZ coordinates of the point
    :return: A PointStamped message
    """
    msg = PointStamped()
    msg.header.stamp = rospy.Time.now()
    msg.header.frame_id = "map"

    msg.point.x = point[0]
    msg.point.y = point[1]
    msg.point.z = point[2]

    return msg


def make_quaternion_stamped(quaternion: List[float]) -> QuaternionStamped:
    """
    Creates a QuaternionStamped message for the given quaternion.

    :param quaternion: The quaternion as a list of xyzw
    :return: A QuaternionStamped message
    """
    msg = QuaternionStamped()
    msg.header.stamp = rospy.Time.now()
    msg.header.frame_id = "map"

    msg.quaternion.x = quaternion[0]
    msg.quaternion.y = quaternion[1]
    msg.quaternion.z = quaternion[2]
    msg.quaternion.w = quaternion[3]

    return msg


def make_vector_stamped(vector: List[float]) -> Vector3Stamped:
    """
    Creates a Vector3Stamped message, this is similar to PointStamped but represents a vector instead of a point.

    :param vector: The vector given as xyz in world frame
    :return: A Vector3Stamped message
    """
    msg = Vector3Stamped()
    msg.header.stamp = rospy.Time.now()
    msg.header.frame_id = "map"

    msg.vector.x = vector[0]
    msg.vector.y = vector[1]
    msg.vector.z = vector[2]

    return msg


def _pose_to_pose_stamped(pose: Pose) -> PoseStamped:
    """
    Transforms a PyCRAM pose to a PoseStamped message, this is necessary since Giskard NEEDS a PoseStamped message
    otherwise it will crash.

    :param pose: PyCRAM pose that should be converted
    :return: An equivalent PoseStamped message
    """
    ps = PoseStamped()
    ps.pose = pose.pose
    ps.header = pose.header

    return ps


##New # Content from: #<src/pycram/external_interfaces/knowrob.py>#
import logging
import os
import sys
import rosservice

from typing_extensions import Dict, List, Union

SCRIPT_DIR = os.path.abspath(os.path.dirname(__file__))
sys.path.append(os.path.join(SCRIPT_DIR, os.pardir, os.pardir, "neem-interface", "src"))

if 'rosprolog/query' in rosservice.get_service_list():
    from neem_interface_python.neem_interface import NEEMInterface
    from neem_interface_python.rosprolog_client import Prolog, PrologException, atom

    neem_interface = NEEMInterface()
    prolog = Prolog()

else:
    logging.warning("No KnowRob services found, knowrob is not available")


#logging.setLoggerClass(logging.Logger)
logger = logging.getLogger(__name__)
from pycram import ch

logger.addHandler(ch)
logger.setLevel(logging.DEBUG)


def all_solutions(q):
    logging.info(q)
    r = prolog.all_solutions(q)
    return r


def once(q) -> Union[List, Dict]:
    r = all_solutions(q)
    if len(r) == 0:
        return []
    return r[0]


def load_beliefstate(path: str):
    logging.info(f"Restoring beliefstate from {path}")
    once(f"remember('{path}')")


def clear_beliefstate():
    logging.info("Clearing beliefstate")
    once("mem_clear_memory")


def load_owl(path, ns_alias=None, ns_url=None):
    """
    Example: load_owl("package://external_interfaces/owl/maps/iai_room_v1.owl", "map", "http://knowrob.org/kb/v1/IAI-Kitchen.owl#")
    :param str path: path to log folder
    :rtype: bool
    """
    if ns_alias is None or ns_url is None:            # Load without namespace
        q = "load_owl('{}')".format(path)
    else:
        q = "load_owl('{0}', [namespace({1},'{2}')])".format(path, ns_alias, ns_url)
    try:
        once(q)
        return True
    except PrologException as e:
        logging.warning(e)
        return False


def new_iri(owl_class: str):
    res = once(f"kb_call(new_iri(IRI, {owl_class}))")
    return res["IRI"]


def object_type(object_iri: str) -> str:
    """
    :param object_iri: The name (identifier) of the object individual in the KnowRob knowledge base
    """
    res = once(f"kb_call(instance_of({atom(object_iri)}, Class))")
    return res["Class"]


def instances_of(type_: str) -> List[str]:
    """
    :param type_: An object type (i.e. class)
    """
    all_sols = all_solutions(f"kb_call(instance_of(Individual, {atom(type_)}))")
    return [sol["Individual"] for sol in all_sols]


def object_pose(object_iri: str, reference_cs: str = "world", timestamp=None) -> List[float]:
    """
    :param object_iri: The name (identifier) of the object individual in the KnowRob knowledge base
    :param reference_cs: The coordinate system relative to which the pose should be defined
    """
    if timestamp is None:
        res = once(f"mem_tf_get({atom(object_iri)}, {atom(reference_cs)}, Pos, Ori)")
    else:
        res = once(f"mem_tf_get({atom(object_iri)}, {atom(reference_cs)}, Pos, Ori, {timestamp})")
    pos = res["Pos"]
    ori = res["Ori"]
    return pos + ori


def grasp_pose(object_iri: str) -> List[float]:
    query = f"""
    kb_call(has_grasp_point({atom(object_iri)}, GraspPointName)),
    mem_tf_get(GraspPointName, world, Pos, Ori)
    """
    res = once(query)
    pos = res["Pos"]
    ori = res["Ori"]
    return pos + ori


def knowrob_string_to_pose(pose_as_string: str) -> List[float]:
    reference_frame = ""
    for i, char in enumerate(pose_as_string[1:-1]):
        if char == ",":
            break
        reference_frame += char
    pos, ori = pose_as_string[1+i+2:-2].split("],[")
    xyz = list(map(float, pos.split(",")))
    qxyzw = list(map(float, ori.split(",")))
    return xyz + qxyzw

##New # Content from: #<src/pycram/external_interfaces/tmc.py>#
import rospy
from typing_extensions import Optional

from ..datastructures.enums import GripperState
from ..designators.motion_designator import MoveGripperMotion, TalkingMotion

is_init = False


def init_tmc_interface():
    global is_init
    if is_init:
        return
    try:
        from tmc_control_msgs.msg import GripperApplyEffortActionGoal
        from tmc_msgs.msg import Voice
        is_init = True
        rospy.loginfo("Successfully initialized tmc interface")
    except ModuleNotFoundError as e:
        rospy.logwarn(f"Could not import TMC messages, tmc interface could not be initialized")


def tmc_gripper_control(designator: MoveGripperMotion, topic_name: Optional[str] = '/hsrb/gripper_controller/grasp/goal'):
    """
    Publishes a message to the gripper controller to open or close the gripper for the HSR.

    :param designator: The designator containing the motion to be executed
    :param topic_name: The topic name to publish the message to
    """
    if (designator.motion == GripperState.OPEN):
        pub_gripper = rospy.Publisher(topic_name, GripperApplyEffortActionGoal,
                                      queue_size=10)
        rate = rospy.Rate(10)
        msg = GripperApplyEffortActionGoal()
        msg.goal.effort = 0.8
        pub_gripper.publish(msg)

    elif (designator.motion == GripperState.CLOSE):
        pub_gripper = rospy.Publisher(topic_name, GripperApplyEffortActionGoal,
                                      queue_size=10)
        rate = rospy.Rate(10)
        msg = GripperApplyEffortActionGoal()
        msg.goal.effort = -0.8
        pub_gripper.publish(msg)


def tmc_talk(designator: TalkingMotion, topic_name: Optional[str] = '/talk_request'):
    """
    Publishes a sentence to the talk_request topic of the HSRB robot

    :param designator: The designator containing the sentence to be spoken
    :param topic_name: The topic name to publish the sentence to
    """
    pub = rospy.Publisher(topic_name, Voice, queue_size=10)
    texttospeech = Voice()
    # language 1 = english (0 = japanese)
    texttospeech.language = 1
    texttospeech.sentence = designator.cmd

    pub.publish(texttospeech)


##New # Content from: #<src/pycram/external_interfaces/robokudo.py>#
import sys
from threading import Lock, RLock
from typing import Any

import actionlib
import rosnode
import rospy
from geometry_msgs.msg import PointStamped
from typing_extensions import List, Callable, Optional

from ..datastructures.pose import Pose
from ..designator import ObjectDesignatorDescription

try:
    from robokudo_msgs.msg import ObjectDesignator as robokudo_ObjectDesignator
    from robokudo_msgs.msg import QueryAction, QueryGoal, QueryResult
except ModuleNotFoundError as e:
    rospy.logwarn("Failed to import Robokudo messages, the real robot will not be available")

is_init = False

number_of_par_goals = 0
robokudo_lock = Lock()
robokudo_rlock = RLock()
with robokudo_rlock:
    par_threads = {}
    par_motion_goal = {}


def thread_safe(func: Callable) -> Callable:
    """
    Adds thread safety to a function via a decorator. This uses the robokudo_lock

    :param func: Function that should be thread safe
    :return: A function with thread safety
    """

    def wrapper(*args, **kwargs):
        with robokudo_rlock:
            return func(*args, **kwargs)

    return wrapper


def init_robokudo_interface(func: Callable) -> Callable:
    """
    Checks if the ROS messages are available and if Robokudo is running, if that is the case the interface will be
    initialized.

    :param func: Function this decorator should be wrapping
    :return: A callable function which initializes the interface and then calls the wrapped function
    """

    def wrapper(*args, **kwargs):
        global is_init
        if is_init and "/robokudo" in rosnode.get_node_names():
            return func(*args, **kwargs)
        elif is_init and "/robokudo" not in rosnode.get_node_names():
            rospy.logwarn("Robokudo node is not available anymore, could not initialize robokudo interface")
            is_init = False
            giskard_wrapper = None
            return

        if "robokudo_msgs" not in sys.modules:
            rospy.logwarn("Could not initialize the Robokudo interface since the robokudo_msgs are not imported")
            return

        if "/robokudo" in rosnode.get_node_names():
            rospy.loginfo_once("Successfully initialized Robokudo interface")
            is_init = True
        else:
            rospy.logwarn("Robokudo is not running, could not initialize Robokudo interface")
            return
        return func(*args, **kwargs)

    return wrapper


@init_robokudo_interface
def send_query(obj_type: Optional[str] = None, region: Optional[str] = None,
               attributes: Optional[List[str]] = None) -> Any:
    """Generic function to send a query to RoboKudo."""
    goal = QueryGoal()

    if obj_type:
        goal.obj.type = obj_type
    if region:
        goal.obj.location = region
    if attributes:
        goal.obj.attribute = attributes

    client = actionlib.SimpleActionClient('robokudo/query', QueryAction)
    rospy.loginfo("Waiting for action server")
    client.wait_for_server()

    query_result = None

    def done_callback(state, result):
        nonlocal query_result
        query_result = result
        rospy.loginfo("Query completed")

    client.send_goal(goal, done_cb=done_callback)
    client.wait_for_result()
    return query_result


@init_robokudo_interface
def query_object(obj_desc: ObjectDesignatorDescription) -> dict:
    """Query RoboKudo for an object that fits the description."""
    goal = QueryGoal()
    goal.obj.uid = str(id(obj_desc))
    goal.obj.type = str(obj_desc.types[0].name)

    result = send_query(obj_type=goal.obj.type)

    pose_candidates = {}
    if result and result.res:
        for i in range(len(result.res[0].pose)):
            pose = Pose.from_pose_stamped(result.res[0].pose[i])
            source = result.res[0].pose_source[0]
            pose_candidates[source] = pose
    return pose_candidates


@init_robokudo_interface
def query_human() -> PointStamped:
    """Query RoboKudo for human detection and return the detected human's pose."""
    result = send_query(obj_type='human')
    if result:
        return result  # Assuming result is of type PointStamped or similar.
    return None


@init_robokudo_interface
def stop_query():
    """Stop any ongoing query to RoboKudo."""
    init_robokudo_interface()
    client = actionlib.SimpleActionClient('robokudo/query', QueryAction)
    client.wait_for_server()
    client.cancel_all_goals()
    rospy.loginfo("Cancelled current RoboKudo query goal")


@init_robokudo_interface
def query_specific_region(region: str) -> Any:
    """Query RoboKudo to scan a specific region."""
    return send_query(region=region)


@init_robokudo_interface
def query_human_attributes() -> Any:
    """Query RoboKudo for human attributes like brightness of clothes, headgear, and gender."""
    return send_query(obj_type='human', attributes=["attributes"])


@init_robokudo_interface
def query_waving_human() -> Pose:
    """Query RoboKudo for detecting a waving human."""
    result = send_query(obj_type='human')
    if result and result.res:
        try:
            pose = Pose.from_pose_stamped(result.res[0].pose[0])
            return pose
        except IndexError:
            pass
    return None


##New # Content from: #<src/pycram/external_interfaces/ik.py>#
import rosnode
import tf
from typing_extensions import List, Union, Tuple, Dict

import rospy
from moveit_msgs.msg import PositionIKRequest
from moveit_msgs.msg import RobotState
from moveit_msgs.srv import GetPositionIK
from sensor_msgs.msg import JointState

from ..datastructures.world import World, UseProspectionWorld
from ..world_concepts.world_object import Object
from ..utils import _apply_ik
from ..local_transformer import LocalTransformer
from ..datastructures.pose import Pose
from ..robot_description import RobotDescription
from ..plan_failures import IKError
from ..external_interfaces.giskard import projection_cartesian_goal, allow_gripper_collision


def _make_request_msg(root_link: str, tip_link: str, target_pose: Pose, robot_object: Object,
                      joints: List[str]) -> PositionIKRequest:
    """
    Generates an ik request message for the kdl_ik_service. The message is
    of the type moveit_msgs/PositionIKRequest and contains all information
    contained in the parameter.

    :param root_link: The first link of the chain of joints to be altered
    :param tip_link: The last link of the chain of joints to be altered
    :param target_pose: Target pose for which the message should be created
    :param robot_object: The robot for which the ik should be generated
    :param joints: A list of joint names between the root_link and tip_link that should be altered.
    :return: A moveit_msgs/PositionIKRequest message containing all the information from the parameter
    """
    local_transformer = LocalTransformer()
    target_pose = local_transformer.transform_pose(target_pose, robot_object.get_link_tf_frame(root_link))

    robot_state = RobotState()
    joint_state = JointState()
    joint_state.name = joints
    joint_state.position = [robot_object.get_joint_position(joint) for joint in joints]
    # joint_state.velocity = [0.0 for x in range(len(joints))]
    # joint_state.effort = [0.0 for x in range(len(joints))]
    robot_state.joint_state = joint_state

    msg_request = PositionIKRequest()
    # msg_request.group_name = "arm"
    msg_request.ik_link_name = tip_link
    msg_request.pose_stamped = target_pose
    msg_request.avoid_collisions = False
    msg_request.robot_state = robot_state
    msg_request.timeout = rospy.Duration(secs=1000)
    # msg_request.attempts = 1000

    return msg_request


def call_ik(root_link: str, tip_link: str, target_pose: Pose, robot_object: Object, joints: List[str]) -> List[float]:
    """
   Sends a request to the kdl_ik_service and returns the solution.
   Note that the robot in robot_object should be identical to the robot description
   uploaded to the parameter server. Furthermore, note that the root_link and
   tip_link are the links attached to the first and last joints in the joints list.

   :param root_link: The first link of the chain of joints to be altered
   :param tip_link: The last link in the chain of joints to be altered
   :param target_pose: The target pose in frame of root link second is the orientation as quaternion in world coordinate frame
   :param robot_object: The robot object for which the ik solution should be generated
   :param joints: A list of joint name that should be altered
   :return: The solution that was generated as a list of joint values corresponding to the order of joints given
   """
    if RobotDescription.current_robot_description.name == "pr2":
        ik_service = "/pr2_right_arm_kinematics/get_ik" if "r_wrist" in tip_link else "/pr2_left_arm_kinematics/get_ik"
    else:
        ik_service = "/kdl_ik_service/get_ik"

    rospy.loginfo_once(f"Waiting for IK service: {ik_service}")
    rospy.wait_for_service(ik_service)

    req = _make_request_msg(root_link, tip_link, target_pose, robot_object, joints)
    req.pose_stamped.header.frame_id = root_link
    ik = rospy.ServiceProxy(ik_service, GetPositionIK)
    try:
        resp = ik(req)
    except rospy.ServiceException as e:
        if RobotDescription.current_robot_description.name == "pr2":
            raise IKError(target_pose, root_link, tip_link)
        else:
            raise e

    if resp.error_code.val == -31:
        raise IKError(target_pose, root_link, tip_link)

    return resp.solution.joint_state.position


def try_to_reach_with_grasp(pose_or_object: Union[Pose, Object],
                            prospection_robot: Object, gripper_name: str,
                            grasp: str) -> Union[Pose, None]:
    """
    Checks if the robot can reach a given position with a specific grasp orientation.
    To determine this the inverse kinematics are calculated and applied.

    :param pose_or_object: The position and rotation or Object for which reachability should be checked or an Object
    :param prospection_robot: The robot that should reach for the position
    :param gripper_name: The name of the end effector
    :param grasp: The grasp type with which the object should be grasped
    """

    input_pose = pose_or_object.get_pose() if isinstance(pose_or_object, Object) else pose_or_object

    target_pose = apply_grasp_orientation_to_pose(grasp, input_pose)

    return try_to_reach(target_pose, prospection_robot, gripper_name)


def apply_grasp_orientation_to_pose(grasp: str, pose: Pose) -> Pose:
    """
    Applies the orientation of a grasp to a given pose. This is done by using the grasp orientation
    of the given grasp and applying it to the given pose.

    :param grasp: The name of the grasp
    :param pose: The pose to which the grasp orientation should be applied
    """
    local_transformer = LocalTransformer()
    target_map = local_transformer.transform_pose(pose, "map")
    grasp_orientation = RobotDescription.current_robot_description.grasps[grasp]
    target_map.orientation.x = grasp_orientation[0]
    target_map.orientation.y = grasp_orientation[1]
    target_map.orientation.z = grasp_orientation[2]
    target_map.orientation.w = grasp_orientation[3]
    return target_map


def try_to_reach(pose_or_object: Union[Pose, Object], prospection_robot: Object,
                 gripper_name: str) -> Union[Pose, None]:
    """
    Tries to reach a given position with a given robot. This is done by calculating the inverse kinematics.

    :param pose_or_object: The position and rotation or Object for which reachability should be checked.
    :param prospection_robot: The robot that should be used to check for reachability, should be the one in the prospection world
    :param gripper_name: Name of the gripper tool frame
    :return: The pose at which the robot should stand or None if the target is not reachable
    """
    input_pose = pose_or_object.get_pose() if isinstance(pose_or_object, Object) else pose_or_object

    arm_chain = list(filter(lambda chain: chain.get_tool_frame() == gripper_name, RobotDescription.current_robot_description.get_manipulator_chains()))[0]

    joints = arm_chain.joints

    try:
        inv = request_ik(input_pose, prospection_robot, joints, gripper_name)
    except IKError as e:
        rospy.logerr(f"Pose is not reachable: {e}")
        return None
    _apply_ik(prospection_robot, inv)

    return input_pose


def request_ik(target_pose: Pose, robot: Object, joints: List[str], gripper: str) -> Tuple[Pose, Dict[str, float]]:
    """
    Top-level method to request ik solution for a given pose. This method will check if the giskard node is running
    and if so will call the giskard service. If the giskard node is not running the kdl_ik_service will be called.

    :param target_pose: Pose of the end-effector for which an ik solution should be found
    :param robot: The robot object which should be used
    :param joints: A list of joints that should be used in computation, this is only relevant for the kdl_ik_service
    :param gripper: Name of the tool frame which should grasp, this should be at the end of the given joint chain
    :return: A Pose at which the robt should stand as well as a dictionary of joint values
    """
    if "/giskard" not in rosnode.get_node_names():
        return robot.pose, request_kdl_ik(target_pose, robot, joints, gripper)
    return request_giskard_ik(target_pose, robot, gripper)


def request_kdl_ik(target_pose: Pose, robot: Object, joints: List[str], gripper: str) -> Dict[str, float]:
    """
    Top-level method to request ik solution for a given pose. Before calling the ik service the links directly before
    and after the joint chain will be queried and the target_pose will be transformed into the frame of the root_link.
    Afterward, the offset between the tip_link and end effector will be calculated and taken into account. Lastly the
    ik service is called and the result returned

    :param target_pose: Pose for which an ik solution should be found
    :param robot: Robot object which should be used
    :param joints: List of joints that should be used in computation
    :param gripper: Name of the gripper which should grasp, this should be at the end of the given joint chain
    :return: A list of joint values
    """
    local_transformer = LocalTransformer()
    base_link = RobotDescription.current_robot_description.get_parent(joints[0])
    # Get link after last joint in chain
    end_effector = RobotDescription.current_robot_description.get_child(joints[-1])

    target_torso = local_transformer.transform_pose(target_pose, robot.get_link_tf_frame(base_link))

    wrist_tool_frame_offset = robot.get_transform_between_links(end_effector, gripper)
    target_diff = target_torso.to_transform("target").inverse_times(wrist_tool_frame_offset).to_pose()

    inv = call_ik(base_link, end_effector, target_diff, robot, joints)

    return dict(zip(joints, inv))


def request_giskard_ik(target_pose: Pose, robot: Object, gripper: str) -> Tuple[Pose, Dict[str, float]]:
    """
    Calls giskard in projection mode and queries the ik solution for a full body ik solution. This method will
    try to drive the robot directly to a pose from which the target_pose is reachable for the end effector. If there
    are obstacles in the way this method will fail. In this case please use the GiskardLocation designator.

    :param target_pose: Pose at which the end effector should be moved.
    :param robot: Robot object which should be used.
    :param gripper: Name of the tool frame which should grasp, this should be at the end of the given joint chain.
    :return: A list of joint values.
    """
    rospy.loginfo_once(f"Using Giskard for full body IK")
    local_transformer = LocalTransformer()
    target_map = local_transformer.transform_pose(target_pose, "map")

    allow_gripper_collision("all")
    result = projection_cartesian_goal(target_map, gripper, "map")
    last_point = result.trajectory.points[-1]
    joint_names = result.trajectory.joint_names

    joint_states = dict(zip(joint_names, last_point.positions))
    prospection_robot = World.current_world.get_prospection_object_for_object(robot)

    orientation = list(tf.transformations.quaternion_from_euler(0, 0, joint_states["brumbrum_yaw"], axes="sxyz"))
    pose = Pose([joint_states["brumbrum_x"], joint_states["brumbrum_y"], 0], orientation)

    robot_joint_states = {}
    for joint_name, state in joint_states.items():
        if joint_name in robot.joints.keys():
            robot_joint_states[joint_name] = state

    with UseProspectionWorld():
        prospection_robot.set_joint_positions(robot_joint_states)
        prospection_robot.set_pose(pose)

        tip_pose = prospection_robot.get_link_pose(gripper)
        dist = tip_pose.dist(target_map)

        if dist > 0.01:
            raise IKError(target_pose, "map", gripper)
        return pose, robot_joint_states



##New # Content from: #<src/pycram/object_descriptors/urdf.py>#
import pathlib
from xml.etree import ElementTree

import rospkg
import rospy
from geometry_msgs.msg import Point
from tf.transformations import quaternion_from_euler
from typing_extensions import Union, List, Optional
from urdf_parser_py import urdf
from urdf_parser_py.urdf import (URDF, Collision, Box as URDF_Box, Cylinder as URDF_Cylinder,
                                 Sphere as URDF_Sphere, Mesh as URDF_Mesh)

from ..datastructures.enums import JointType
from ..datastructures.pose import Pose
from ..description import JointDescription as AbstractJointDescription, \
    LinkDescription as AbstractLinkDescription, ObjectDescription as AbstractObjectDescription
from ..datastructures.dataclasses import Color, VisualShape, BoxVisualShape, CylinderVisualShape, \
    SphereVisualShape, MeshVisualShape
from ..utils import suppress_stdout_stderr


class LinkDescription(AbstractLinkDescription):
    """
    A class that represents a link description of an object.
    """

    def __init__(self, urdf_description: urdf.Link):
        super().__init__(urdf_description)

    @property
    def geometry(self) -> Union[VisualShape, None]:
        """
        Returns the geometry type of the URDF collision element of this link.
        """
        if self.collision is None:
            return None
        urdf_geometry = self.collision.geometry
        return self._get_visual_shape(urdf_geometry)

    @staticmethod
    def _get_visual_shape(urdf_geometry) -> Union[VisualShape, None]:
        """
        Returns the VisualShape of the given URDF geometry.
        """
        if isinstance(urdf_geometry, URDF_Box):
            return BoxVisualShape(Color(), [0, 0, 0], urdf_geometry.size)
        if isinstance(urdf_geometry, URDF_Cylinder):
            return CylinderVisualShape(Color(), [0, 0, 0], urdf_geometry.radius, urdf_geometry.length)
        if isinstance(urdf_geometry, URDF_Sphere):
            return SphereVisualShape(Color(), [0, 0, 0], urdf_geometry.radius)
        if isinstance(urdf_geometry, URDF_Mesh):
            return MeshVisualShape(Color(), [0, 0, 0], urdf_geometry.scale, urdf_geometry.filename)
        return None

    @property
    def origin(self) -> Union[Pose, None]:
        if self.collision is None:
            return None
        if self.collision.origin is None:
            return None
        return Pose(self.collision.origin.xyz,
                    quaternion_from_euler(*self.collision.origin.rpy).tolist())

    @property
    def name(self) -> str:
        return self.parsed_description.name

    @property
    def collision(self) -> Collision:
        return self.parsed_description.collision


class JointDescription(AbstractJointDescription):
    urdf_type_map = {'unknown': JointType.UNKNOWN,
                     'revolute': JointType.REVOLUTE,
                     'continuous': JointType.CONTINUOUS,
                     'prismatic': JointType.PRISMATIC,
                     'floating': JointType.FLOATING,
                     'planar': JointType.PLANAR,
                     'fixed': JointType.FIXED}

    def __init__(self, urdf_description: urdf.Joint):
        super().__init__(urdf_description)

    @property
    def origin(self) -> Pose:
        return Pose(self.parsed_description.origin.xyz,
                    quaternion_from_euler(*self.parsed_description.origin.rpy))

    @property
    def name(self) -> str:
        return self.parsed_description.name

    @property
    def has_limits(self) -> bool:
        return bool(self.parsed_description.limit)

    @property
    def type(self) -> JointType:
        """
        :return: The type of this joint.
        """
        return self.urdf_type_map[self.parsed_description.type]

    @property
    def axis(self) -> Point:
        """
        :return: The axis of this joint, for example the rotation axis for a revolute joint.
        """
        return Point(*self.parsed_description.axis)

    @property
    def lower_limit(self) -> Union[float, None]:
        """
        :return: The lower limit of this joint, or None if the joint has no limits.
        """
        if self.has_limits:
            return self.parsed_description.limit.lower
        else:
            return None

    @property
    def upper_limit(self) -> Union[float, None]:
        """
        :return: The upper limit of this joint, or None if the joint has no limits.
        """
        if self.has_limits:
            return self.parsed_description.limit.upper
        else:
            return None

    @property
    def parent_link_name(self) -> str:
        """
        :return: The name of the parent link of this joint.
        """
        return self.parsed_description.parent

    @property
    def child_link_name(self) -> str:
        """
        :return: The name of the child link of this joint.
        """
        return self.parsed_description.child

    @property
    def damping(self) -> float:
        """
        :return: The damping of this joint.
        """
        return self.parsed_description.dynamics.damping

    @property
    def friction(self) -> float:
        """
        :return: The friction of this joint.
        """
        return self.parsed_description.dynamics.friction


class ObjectDescription(AbstractObjectDescription):
    """
    A class that represents an object description of an object.
    """

    class Link(AbstractObjectDescription.Link, LinkDescription):
        ...

    class RootLink(AbstractObjectDescription.RootLink, Link):
        ...

    class Joint(AbstractObjectDescription.Joint, JointDescription):
        ...

    def load_description(self, path) -> URDF:
        with open(path, 'r') as file:
            # Since parsing URDF causes a lot of warning messages which can't be deactivated, we suppress them
            with suppress_stdout_stderr():
                return URDF.from_xml_string(file.read())

    def generate_from_mesh_file(self, path: str, name: str, color: Optional[Color] = Color()) -> str:
        """
        Generates an URDf file with the given .obj or .stl file as mesh. In addition, the given rgba_color will be
        used to create a material tag in the URDF.

        :param path: The path to the mesh file.
        :param name: The name of the object.
        :param color: The color of the object.
        :return: The absolute path of the created file
        """
        urdf_template = '<?xml version="0.0" ?> \n \
                        <robot name="~a_object"> \n \
                         <link name="~a_main"> \n \
                            <visual> \n \
                                <geometry>\n \
                                    <mesh filename="~b" scale="1 1 1"/> \n \
                                </geometry>\n \
                                <material name="white">\n \
                                    <rgba_color rgba="~c"/>\n \
                                </material>\n \
                          </visual> \n \
                        <collision> \n \
                        <geometry>\n \
                            <mesh filename="~b" scale="1 1 1"/>\n \
                        </geometry>\n \
                        </collision>\n \
                        </link> \n \
                        </robot>'
        urdf_template = self.fix_missing_inertial(urdf_template)
        rgb = " ".join(list(map(str, color.get_rgba())))
        pathlib_obj = pathlib.Path(path)
        path = str(pathlib_obj.resolve())
        content = urdf_template.replace("~a", name).replace("~b", path).replace("~c", rgb)
        return content

    def generate_from_description_file(self, path: str) -> str:
        with open(path, mode="r") as f:
            urdf_string = self.fix_missing_inertial(f.read())
            urdf_string = self.remove_error_tags(urdf_string)
            urdf_string = self.fix_link_attributes(urdf_string)
            try:
                urdf_string = self.correct_urdf_string(urdf_string)
            except rospkg.ResourceNotFound as e:
                rospy.logerr(f"Could not find resource package linked in this URDF")
                raise e
        return urdf_string

    def generate_from_parameter_server(self, name: str) -> str:
        urdf_string = rospy.get_param(name)
        return self.correct_urdf_string(urdf_string)

    def get_link_by_name(self, link_name: str) -> LinkDescription:
        """
        :return: The link description with the given name.
        """
        for link in self.links:
            if link.name == link_name:
                return link
        raise ValueError(f"Link with name {link_name} not found")

    @property
    def links(self) -> List[LinkDescription]:
        """
        :return: A list of links descriptions of this object.
        """
        return [LinkDescription(link) for link in self.parsed_description.links]

    def get_joint_by_name(self, joint_name: str) -> JointDescription:
        """
        :return: The joint description with the given name.
        """
        for joint in self.joints:
            if joint.name == joint_name:
                return joint
        raise ValueError(f"Joint with name {joint_name} not found")

    @property
    def joints(self) -> List[JointDescription]:
        """
        :return: A list of joints descriptions of this object.
        """
        return [JointDescription(joint) for joint in self.parsed_description.joints]

    def get_root(self) -> str:
        """
        :return: the name of the root link of this object.
        """
        return self.parsed_description.get_root()

    def get_chain(self, start_link_name: str, end_link_name: str) -> List[str]:
        """
        :return: the chain of links from 'start_link_name' to 'end_link_name'.
        """
        return self.parsed_description.get_chain(start_link_name, end_link_name)

    def correct_urdf_string(self, urdf_string: str) -> str:
        """
        Changes paths for files in the URDF from ROS paths to paths in the file system. Since World (PyBullet legacy)
        can't deal with ROS package paths.

        :param urdf_string: The name of the URDf on the parameter server
        :return: The URDF string with paths in the filesystem instead of ROS packages
        """
        r = rospkg.RosPack()
        new_urdf_string = ""
        for line in urdf_string.split('\n'):
            if "package://" in line:
                s = line.split('//')
                s1 = s[1].split('/')
                path = r.get_path(s1[0])
                line = line.replace("package://" + s1[0], path)
            new_urdf_string += line + '\n'

        return self.fix_missing_inertial(new_urdf_string)

    @staticmethod
    def fix_missing_inertial(urdf_string: str) -> str:
        """
        Insert inertial tags for every URDF link that has no inertia.
        This is used to prevent Legacy(PyBullet) from dumping warnings in the terminal

        :param urdf_string: The URDF description as string
        :returns: The new, corrected URDF description as string.
        """

        inertia_tree = ElementTree.ElementTree(ElementTree.Element("inertial"))
        inertia_tree.getroot().append(ElementTree.Element("mass", {"value": "0.1"}))
        inertia_tree.getroot().append(ElementTree.Element("origin", {"rpy": "0 0 0", "xyz": "0 0 0"}))
        inertia_tree.getroot().append(ElementTree.Element("inertia", {"ixx": "0.01",
                                                                      "ixy": "0",
                                                                      "ixz": "0",
                                                                      "iyy": "0.01",
                                                                      "iyz": "0",
                                                                      "izz": "0.01"}))

        # create tree from string
        tree = ElementTree.ElementTree(ElementTree.fromstring(urdf_string))

        for link_element in tree.iter("link"):
            inertial = [*link_element.iter("inertial")]
            if len(inertial) == 0:
                link_element.append(inertia_tree.getroot())

        return ElementTree.tostring(tree.getroot(), encoding='unicode')

    @staticmethod
    def remove_error_tags(urdf_string: str) -> str:
        """
        Removes all tags in the removing_tags list from the URDF since these tags are known to cause errors with the
        URDF_parser

        :param urdf_string: String of the URDF from which the tags should be removed
        :return: The URDF string with the tags removed
        """
        tree = ElementTree.ElementTree(ElementTree.fromstring(urdf_string))
        removing_tags = ["gazebo", "transmission"]
        for tag_name in removing_tags:
            all_tags = tree.findall(tag_name)
            for tag in all_tags:
                tree.getroot().remove(tag)

        return ElementTree.tostring(tree.getroot(), encoding='unicode')

    @staticmethod
    def fix_link_attributes(urdf_string: str) -> str:
        """
        Removes the attribute 'type' from links since this is not parsable by the URDF parser.

        :param urdf_string: The string of the URDF from which the attributes should be removed
        :return: The URDF string with the attributes removed
        """
        tree = ElementTree.ElementTree(ElementTree.fromstring(urdf_string))

        for link in tree.iter("link"):
            if "type" in link.attrib.keys():
                del link.attrib["type"]

        return ElementTree.tostring(tree.getroot(), encoding='unicode')

    @staticmethod
    def get_file_extension() -> str:
        """
        :return: The file extension of the URDF file.
        """
        return '.urdf'

    @property
    def origin(self) -> Pose:
        return Pose(self.parsed_description.origin.xyz,
                    quaternion_from_euler(*self.parsed_description.origin.rpy))

    @property
    def name(self) -> str:
        return self.parsed_description.name


##New # Content from: #<src/pycram/object_descriptors/generic.py>#
from typing_extensions import List, Any, Union, Dict

from geometry_msgs.msg import Point

from ..datastructures.dataclasses import VisualShape, BoxVisualShape, Color
from ..datastructures.enums import JointType
from ..datastructures.pose import Pose
from ..description import JointDescription as AbstractJointDescription, LinkDescription as AbstractLinkDescription, \
    ObjectDescription as AbstractObjectDescription


class LinkDescription(AbstractLinkDescription):

    def __init__(self, name: str, visual_frame_position: List[float], half_extents: List[float], color: Color = Color()):
        self.parsed_description: BoxVisualShape = BoxVisualShape(color, visual_frame_position, half_extents)
        self._name: str = name

    @property
    def geometry(self) -> Union[VisualShape, None]:
        return self.parsed_description

    @property
    def origin(self) -> Pose:
        return Pose(self.parsed_description.visual_frame_position)

    @property
    def name(self) -> str:
        return self._name

    @property
    def color(self) -> Color:
        return self.parsed_description.rgba_color


class JointDescription(AbstractJointDescription):

    @property
    def type(self) -> JointType:
        return JointType.UNKNOWN

    @property
    def axis(self) -> Point:
        return Point(0, 0, 0)

    @property
    def has_limits(self) -> bool:
        return False

    @property
    def lower_limit(self) -> Union[float, None]:
        return 0

    @property
    def upper_limit(self) -> Union[float, None]:
        return 0

    @property
    def parent_link_name(self) -> str:
        raise NotImplementedError

    @property
    def child_link_name(self) -> str:
        raise NotImplementedError

    @property
    def origin(self) -> Pose:
        raise NotImplementedError

    @property
    def name(self) -> str:
        raise NotImplementedError


class ObjectDescription(AbstractObjectDescription):
    """
    A generic description of an object in the environment. This description can be applied to any object.
    The current use case involves perceiving objects using RoboKudo and spawning them with specified size and color.
    """

    class Link(AbstractObjectDescription.Link, LinkDescription):
        ...

    class RootLink(AbstractObjectDescription.RootLink, Link):
        ...

    class Joint(AbstractObjectDescription.Joint, JointDescription):
        ...

    def __init__(self, *args, **kwargs):
        self._links = [LinkDescription(*args, **kwargs)]

    def load_description(self, path: str) -> Any:
        ...

    @classmethod
    def generate_from_mesh_file(cls, path: str, name: str) -> str:
        raise NotImplementedError

    @classmethod
    def generate_from_description_file(cls, path: str) -> str:
        raise NotImplementedError

    @classmethod
    def generate_from_parameter_server(cls, name: str) -> str:
        raise NotImplementedError

    @property
    def shape_data(self) -> List[float]:
        return self._links[0].geometry.shape_data()['halfExtents']

    @property
    def color(self) -> Color:
        return self._links[0].color

    @property
    def links(self) -> List[LinkDescription]:
        return self._links

    def get_link_by_name(self, link_name: str) -> LinkDescription:
        if link_name == self._links[0].name:
            return self._links[0]

    @property
    def joints(self) -> List[JointDescription]:
        return []

    def get_joint_by_name(self, joint_name: str) -> JointDescription:
        ...

    def get_root(self) -> str:
        return self._links[0].name

    def get_chain(self, start_link_name: str, end_link_name: str) -> List[str]:
        raise NotImplementedError("Do Not Do This on generic objects as they have no chains")

    @staticmethod
    def get_file_extension() -> str:
        raise NotImplementedError("Do Not Do This on generic objects as they have no extensions")

    @property
    def origin(self) -> Pose:
        return self._links[0].origin

    @property
    def name(self) -> str:
        return self._links[0].name


##New # Content from: #<src/pycram/world_concepts/world_object.py>#
from __future__ import annotations

import logging
import os

import numpy as np
import rospy
from geometry_msgs.msg import Point, Quaternion
from typing_extensions import Type, Optional, Dict, Tuple, List, Union

from ..description import ObjectDescription, LinkDescription, Joint
from ..object_descriptors.urdf import ObjectDescription as URDFObject
from ..object_descriptors.generic import ObjectDescription as GenericObjectDescription
from ..robot_descriptions import robot_description
from ..datastructures.world import WorldEntity, World
from ..world_concepts.constraints import Attachment
from ..datastructures.dataclasses import (Color, ObjectState, LinkState, JointState,
                                               AxisAlignedBoundingBox, VisualShape)
from ..datastructures.enums import ObjectType, JointType
from ..local_transformer import LocalTransformer
from ..datastructures.pose import Pose, Transform
from ..robot_description import RobotDescriptionManager

Link = ObjectDescription.Link


class Object(WorldEntity):
    """
    Represents a spawned Object in the World.
    """

    prospection_world_prefix: str = "prospection/"
    """
    The ObjectDescription of the object, this contains the name and type of the object as well as the path to the source 
    file.
    """

    def __init__(self, name: str, obj_type: ObjectType, path: str,
                 description: Optional[Type[ObjectDescription]] = URDFObject,
                 pose: Optional[Pose] = None,
                 world: Optional[World] = None,
                 color: Optional[Color] = Color(),
                 ignore_cached_files: Optional[bool] = False):
        """
        The constructor loads the description file into the given World, if no World is specified the
        :py:attr:`~World.current_world` will be used. It is also possible to load .obj and .stl file into the World.
        The rgba_color parameter is only used when loading .stl or .obj files,
        for URDFs :func:`~Object.set_color` can be used.

        :param name: The name of the object
        :param obj_type: The type of the object as an ObjectType enum.
        :param path: The path to the source file, if only a filename is provided then the resources directories will be searched.
        :param description: The ObjectDescription of the object, this contains the joints and links of the object.
        :param pose: The pose at which the Object should be spawned
        :param world: The World in which the object should be spawned, if no world is specified the :py:attr:`~World.current_world` will be used.
        :param color: The rgba_color with which the object should be spawned.
        :param ignore_cached_files: If true the file will be spawned while ignoring cached files.
        """

        super().__init__(-1, world)

        if pose is None:
            pose = Pose()
        if name in [obj.name for obj in self.world.objects]:
            rospy.logerr(f"An object with the name {name} already exists in the world.")
            return None
        self.name: str = name
        self.obj_type: ObjectType = obj_type
        self.color: Color = color
        self.description = description()
        self.cache_manager = self.world.cache_manager

        self.local_transformer = LocalTransformer()
        self.original_pose = self.local_transformer.transform_pose(pose, "map")
        self._current_pose = self.original_pose

        self.id, self.path = self._load_object_and_get_id(path, ignore_cached_files)

        self.description.update_description_from_file(self.path)

        self.tf_frame = ((self.prospection_world_prefix if self.world.is_prospection_world else "")
                         + f"{self.name}")

        self._init_joint_name_and_id_map()
        self._init_link_name_and_id_map()

        self._init_links_and_update_transforms()
        self._init_joints()

        self.attachments: Dict[Object, Attachment] = {}

        if not self.world.is_prospection_world:
            self._add_to_world_sync_obj_queue()

        self.world.objects.append(self)

        if self.obj_type == ObjectType.ROBOT and not self.world.is_prospection_world:
            rdm = RobotDescriptionManager()
            rdm.load_description(self.description.name)
            World.robot = self

    @property
    def pose(self):
        return self.get_pose()

    @pose.setter
    def pose(self, pose: Pose):
        self.set_pose(pose)

    def _load_object_and_get_id(self, path: Optional[str] = None,
                                ignore_cached_files: Optional[bool] = False) -> Tuple[int, Union[str, None]]:
        """
        Loads an object to the given World with the given position and orientation. The rgba_color will only be
        used when an .obj or .stl file is given.
        If a .obj or .stl file is given, before spawning, an urdf file with the .obj or .stl as mesh will be created
        and this URDf file will be loaded instead.
        When spawning a URDf file a new file will be created in the cache directory, if there exists none.
        This new file will have resolved mesh file paths, meaning there will be no references
        to ROS packges instead there will be absolute file paths.

        :param path: The path to the description file, if None then no file will be loaded, this is useful when the PyCRAM is not responsible for loading the file but another system is.
        :param ignore_cached_files: Whether to ignore files in the cache directory.
        :return: The unique id of the object and the path of the file that was loaded.
        """
        if isinstance(self.description, GenericObjectDescription):
            return self.world.load_generic_object_and_get_id(self.description), path

        if path is not None:
            try:
                path = self.world.update_cache_dir_with_object(path, ignore_cached_files, self)
            except FileNotFoundError as e:
                logging.error("Could not generate description from file.")
                raise e

        try:
            simulator_object_path = path
            if simulator_object_path is None:
                # This is useful when the object is already loaded in the simulator so it would use its name instead of
                #  its path
                simulator_object_path = self.name
            obj_id = self.world.load_object_and_get_id(simulator_object_path, Pose(self.get_position_as_list(),
                                                                                   self.get_orientation_as_list()))
            return obj_id, path

        except Exception as e:
            logging.error(
                "The File could not be loaded. Please note that the path has to be either a URDF, stl or obj file or"
                " the name of an URDF string on the parameter server.")
            os.remove(path)
            raise e

    def _init_joint_name_and_id_map(self) -> None:
        """
        Creates a dictionary which maps the joint names to their unique ids and vice versa.
        """
        n_joints = len(self.joint_names)
        self.joint_name_to_id = dict(zip(self.joint_names, range(n_joints)))
        self.joint_id_to_name = dict(zip(self.joint_name_to_id.values(), self.joint_name_to_id.keys()))

    def _init_link_name_and_id_map(self) -> None:
        """
        Creates a dictionary which maps the link names to their unique ids and vice versa.
        """
        n_links = len(self.link_names)
        self.link_name_to_id: Dict[str, int] = dict(zip(self.link_names, range(n_links)))
        self.link_name_to_id[self.description.get_root()] = -1
        self.link_id_to_name: Dict[int, str] = dict(zip(self.link_name_to_id.values(), self.link_name_to_id.keys()))

    def _init_links_and_update_transforms(self) -> None:
        """
        Initializes the link objects from the URDF file and creates a dictionary which maps the link names to the
        corresponding link objects.
        """
        self.links = {}
        for link_name, link_id in self.link_name_to_id.items():
            link_description = self.description.get_link_by_name(link_name)
            if link_name == self.description.get_root():
                self.links[link_name] = self.description.RootLink(self)
            else:
                self.links[link_name] = self.description.Link(link_id, link_description, self)

        self.update_link_transforms()

    def _init_joints(self):
        """
        Initialize the joint objects from the URDF file and creates a dictionary which mas the joint names to the
        corresponding joint objects
        """
        self.joints = {}
        for joint_name, joint_id in self.joint_name_to_id.items():
            joint_description = self.description.get_joint_by_name(joint_name)
            self.joints[joint_name] = self.description.Joint(joint_id, joint_description, self)

    def _add_to_world_sync_obj_queue(self) -> None:
        """
        Adds this object to the objects queue of the WorldSync object of the World.
        """
        self.world.world_sync.add_obj_queue.put(self)

    @property
    def link_names(self) -> List[str]:
        """
        :return: The name of each link as a list.
        """
        return self.world.get_object_link_names(self)

    @property
    def joint_names(self) -> List[str]:
        """
        :return: The name of each joint as a list.
        """
        return self.world.get_object_joint_names(self)

    def get_link(self, link_name: str) -> ObjectDescription.Link:
        """
        Returns the link object with the given name.

        :param link_name: The name of the link.
        :return: The link object.
        """
        return self.links[link_name]

    def get_link_pose(self, link_name: str) -> Pose:
        """
        Returns the pose of the link with the given name.

        :param link_name: The name of the link.
        :return: The pose of the link.
        """
        return self.links[link_name].pose

    def get_link_position(self, link_name: str) -> Point:
        """
        Returns the position of the link with the given name.

        :param link_name: The name of the link.
        :return: The position of the link.
        """
        return self.links[link_name].position

    def get_link_position_as_list(self, link_name: str) -> List[float]:
        """
        Returns the position of the link with the given name.

        :param link_name: The name of the link.
        :return: The position of the link.
        """
        return self.links[link_name].position_as_list

    def get_link_orientation(self, link_name: str) -> Quaternion:
        """
        Returns the orientation of the link with the given name.

        :param link_name: The name of the link.
        :return: The orientation of the link.
        """
        return self.links[link_name].orientation

    def get_link_orientation_as_list(self, link_name: str) -> List[float]:
        """
        Returns the orientation of the link with the given name.

        :param link_name: The name of the link.
        :return: The orientation of the link.
        """
        return self.links[link_name].orientation_as_list

    def get_link_tf_frame(self, link_name: str) -> str:
        """
        Returns the tf frame of the link with the given name.

        :param link_name: The name of the link.
        :return: The tf frame of the link.
        """
        return self.links[link_name].tf_frame

    def get_link_axis_aligned_bounding_box(self, link_name: str) -> AxisAlignedBoundingBox:
        """
        Returns the axis aligned bounding box of the link with the given name.

        :param link_name: The name of the link.
        :return: The axis aligned bounding box of the link.
        """
        return self.links[link_name].get_axis_aligned_bounding_box()

    def get_transform_between_links(self, from_link: str, to_link: str) -> Transform:
        """
        Returns the transform between two links.

        :param from_link: The name of the link from which the transform should be calculated.
        :param to_link: The name of the link to which the transform should be calculated.
        """
        return self.links[from_link].get_transform_to_link(self.links[to_link])

    def get_link_color(self, link_name: str) -> Color:
        """
        Returns the color of the link with the given name.

        :param link_name: The name of the link.
        :return: The color of the link.
        """
        return self.links[link_name].color

    def set_link_color(self, link_name: str, color: List[float]) -> None:
        """
        Sets the color of the link with the given name.

        :param link_name: The name of the link.
        :param color: The new color of the link.
        """
        self.links[link_name].color = Color.from_list(color)

    def get_link_geometry(self, link_name: str) -> Union[VisualShape, None]:
        """
        Returns the geometry of the link with the given name.

        :param link_name: The name of the link.
        :return: The geometry of the link.
        """
        return self.links[link_name].geometry

    def get_link_transform(self, link_name: str) -> Transform:
        """
        Returns the transform of the link with the given name.

        :param link_name: The name of the link.
        :return: The transform of the link.
        """
        return self.links[link_name].transform

    def get_link_origin(self, link_name: str) -> Pose:
        """
        Returns the origin of the link with the given name.

        :param link_name: The name of the link.
        :return: The origin of the link as a 'Pose'.
        """
        return self.links[link_name].origin

    def get_link_origin_transform(self, link_name: str) -> Transform:
        """
        Returns the origin transform of the link with the given name.

        :param link_name: The name of the link.
        :return: The origin transform of the link.
        """
        return self.links[link_name].origin_transform

    @property
    def base_origin_shift(self) -> np.ndarray:
        """
        The shift between the base of the object and the origin of the object.

        :return: A numpy array with the shift between the base of the object and the origin of the object.
        """
        return np.array(self.get_position_as_list()) - np.array(self.get_base_position_as_list())

    def __repr__(self):
        skip_attr = ["links", "joints", "description", "attachments"]
        return self.__class__.__qualname__ + f"(" + ', \n'.join(
            [f"{key}={value}" if key not in skip_attr else f"{key}: ..." for key, value in self.__dict__.items()]) + ")"

    def remove(self) -> None:
        """
        Removes this object from the World it currently resides in.
        For the object to be removed it has to be detached from all objects it
        is currently attached to. After this is done a call to world remove object is done
        to remove this Object from the simulation/world.
        """
        self.world.remove_object(self)

    def reset(self, remove_saved_states=True) -> None:
        """
        Resets the Object to the state it was first spawned in.
        All attached objects will be detached, all joints will be set to the
        default position of 0 and the object will be set to the position and
        orientation in which it was spawned.

        :param remove_saved_states: If True the saved states will be removed.
        """
        self.detach_all()
        self.reset_all_joints_positions()
        self.set_pose(self.original_pose)
        if remove_saved_states:
            self.remove_saved_states()

    def attach(self,
               child_object: Object,
               parent_link: Optional[str] = None,
               child_link: Optional[str] = None,
               bidirectional: Optional[bool] = True) -> None:
        """
        Attaches another object to this object. This is done by
        saving the transformation between the given link, if there is one, and
        the base pose of the other object. Additionally, the name of the link, to
        which the object is attached, will be saved.
        Furthermore, a simulator constraint will be created so the attachment
        also works while simulation.
        Loose attachments means that the attachment will only be one-directional. For example, if this object moves the
        other, attached, object will also move but not the other way around.

        :param child_object: The other object that should be attached.
        :param parent_link: The link name of this object.
        :param child_link: The link name of the other object.
        :param bidirectional: If the attachment should be a loose attachment.
        """
        parent_link = self.links[parent_link] if parent_link else self.root_link
        child_link = child_object.links[child_link] if child_link else child_object.root_link

        attachment = Attachment(parent_link, child_link, bidirectional)

        self.attachments[child_object] = attachment
        child_object.attachments[self] = attachment.get_inverse()

        self.world.attachment_event(self, [self, child_object])

    def detach(self, child_object: Object) -> None:
        """
        Detaches another object from this object. This is done by
        deleting the attachment from the attachments dictionary of both objects
        and deleting the constraint of the simulator.
        Afterward the detachment event of the corresponding World will be fired.

        :param child_object: The object which should be detached
        """
        del self.attachments[child_object]
        del child_object.attachments[self]

        self.world.detachment_event(self, [self, child_object])

    def detach_all(self) -> None:
        """
        Detach all objects attached to this object.
        """
        attachments = self.attachments.copy()
        for att in attachments.keys():
            self.detach(att)

    def update_attachment_with_object(self, child_object: Object):
        self.attachments[child_object].update_transform_and_constraint()

    def get_position(self) -> Point:
        """
        Returns the position of this Object as a list of xyz.

        :return: The current position of this object
        """
        return self.get_pose().position

    def get_orientation(self) -> Pose.orientation:
        """
        Returns the orientation of this object as a list of xyzw, representing a quaternion.

        :return: A list of xyzw
        """
        return self.get_pose().orientation

    def get_position_as_list(self) -> List[float]:
        """
        Returns the position of this Object as a list of xyz.

        :return: The current position of this object
        """
        return self.get_pose().position_as_list()

    def get_base_position_as_list(self) -> List[float]:
        """
        Returns the position of this Object as a list of xyz.

        :return: The current position of this object
        """
        return self.get_base_origin().position_as_list()

    def get_orientation_as_list(self) -> List[float]:
        """
        Returns the orientation of this object as a list of xyzw, representing a quaternion.

        :return: A list of xyzw
        """
        return self.get_pose().orientation_as_list()

    def get_pose(self) -> Pose:
        """
        Returns the position of this object as a list of xyz. Alias for :func:`~Object.get_position`.

        :return: The current pose of this object
        """
        return self._current_pose

    def set_pose(self, pose: Pose, base: Optional[bool] = False, set_attachments: Optional[bool] = True) -> None:
        """
        Sets the Pose of the object.

        :param pose: New Pose for the object
        :param base: If True places the object base instead of origin at the specified position and orientation
        :param set_attachments: Whether to set the poses of the attached objects to this object or not.
        """
        pose_in_map = self.local_transformer.transform_pose(pose, "map")
        if base:
            pose_in_map.position = (np.array(pose_in_map.position_as_list()) + self.base_origin_shift).tolist()

        self.reset_base_pose(pose_in_map)

        if set_attachments:
            self._set_attached_objects_poses()

    def reset_base_pose(self, pose: Pose):
        self.world.reset_object_base_pose(self, pose)
        self.update_pose()

    def update_pose(self):
        """
        Updates the current pose of this object from the world, and updates the poses of all links.
        """
        self._current_pose = self.world.get_object_pose(self)
        self._update_all_links_poses()
        self.update_link_transforms()

    def _update_all_links_poses(self):
        """
        Updates the poses of all links by getting them from the simulator.
        """
        for link in self.links.values():
            link._update_pose()

    def move_base_to_origin_pose(self) -> None:
        """
        Move the object such that its base will be at the current origin position.
        This is useful when placing objects on surfaces where you want the object base in contact with the surface.
        """
        self.set_pose(self.get_pose(), base=True)

    def save_state(self, state_id) -> None:
        """
        Saves the state of this object by saving the state of all links and attachments.

        :param state_id: The unique id of the state.
        """
        self.save_links_states(state_id)
        self.save_joints_states(state_id)
        super().save_state(state_id)

    def save_links_states(self, state_id: int) -> None:
        """
        Saves the state of all links of this object.

        :param state_id: The unique id of the state.
        """
        for link in self.links.values():
            link.save_state(state_id)

    def save_joints_states(self, state_id: int) -> None:
        """
        Saves the state of all joints of this object.

        :param state_id: The unique id of the state.
        """
        for joint in self.joints.values():
            joint.save_state(state_id)

    @property
    def current_state(self) -> ObjectState:
        return ObjectState(self.get_pose().copy(), self.attachments.copy(), self.link_states.copy(), self.joint_states.copy())

    @current_state.setter
    def current_state(self, state: ObjectState) -> None:
        if self.get_pose().dist(state.pose) != 0.0:
            self.set_pose(state.pose, base=False, set_attachments=False)

        self.set_attachments(state.attachments)
        self.link_states = state.link_states
        self.joint_states = state.joint_states

    def set_attachments(self, attachments: Dict[Object, Attachment]) -> None:
        """
        Sets the attachments of this object to the given attachments.

        :param attachments: A dictionary with the object as key and the attachment as value.
        """
        for obj, attachment in attachments.items():
            if self.world.is_prospection_world and not obj.world.is_prospection_world:
                # In case this object is in the prospection world and the other object is not, the attachment will no
                # be set.
                continue
            if obj in self.attachments:
                if self.attachments[obj] != attachment:
                    self.detach(obj)
                else:
                    continue
            self.attach(obj, attachment.parent_link.name, attachment.child_link.name,
                        attachment.bidirectional)

    @property
    def link_states(self) -> Dict[int, LinkState]:
        """
        Returns the current state of all links of this object.

        :return: A dictionary with the link id as key and the current state of the link as value.
        """
        return {link.id: link.current_state for link in self.links.values()}

    @link_states.setter
    def link_states(self, link_states: Dict[int, LinkState]) -> None:
        """
        Sets the current state of all links of this object.

        :param link_states: A dictionary with the link id as key and the current state of the link as value.
        """
        for link in self.links.values():
            link.current_state = link_states[link.id]

    @property
    def joint_states(self) -> Dict[int, JointState]:
        """
        Returns the current state of all joints of this object.

        :return: A dictionary with the joint id as key and the current state of the joint as value.
        """
        return {joint.id: joint.current_state for joint in self.joints.values()}

    @joint_states.setter
    def joint_states(self, joint_states: Dict[int, JointState]) -> None:
        """
        Sets the current state of all joints of this object.

        :param joint_states: A dictionary with the joint id as key and the current state of the joint as value.
        """
        for joint in self.joints.values():
            joint.current_state = joint_states[joint.id]

    def remove_saved_states(self) -> None:
        """
        Removes all saved states of this object.
        """
        super().remove_saved_states()
        self.remove_links_saved_states()
        self.remove_joints_saved_states()

    def remove_links_saved_states(self) -> None:
        """
        Removes all saved states of the links of this object.
        """
        for link in self.links.values():
            link.remove_saved_states()

    def remove_joints_saved_states(self) -> None:
        """
        Removes all saved states of the joints of this object.
        """
        for joint in self.joints.values():
            joint.remove_saved_states()

    def _set_attached_objects_poses(self, already_moved_objects: Optional[List[Object]] = None) -> None:
        """
        Updates the positions of all attached objects. This is done
        by calculating the new pose in world coordinate frame and setting the
        base pose of the attached objects to this new pose.
        After this the _set_attached_objects method of all attached objects
        will be called.

        :param already_moved_objects: A list of Objects that were already moved, these will be excluded to prevent loops in the update.
        """

        if already_moved_objects is None:
            already_moved_objects = []

        for child in self.attachments:

            if child in already_moved_objects:
                continue

            attachment = self.attachments[child]
            if attachment.loose:
                self.update_attachment_with_object(child)
                child.update_attachment_with_object(self)

            else:
                link_to_object = attachment.parent_to_child_transform
                child.set_pose(link_to_object.to_pose(), set_attachments=False)
                child._set_attached_objects_poses(already_moved_objects + [self])

    def set_position(self, position: Union[Pose, Point, List], base=False) -> None:
        """
        Sets this Object to the given position, if base is true the bottom of the Object will be placed at the position
        instead of the origin in the center of the Object. The given position can either be a Pose,
        in this case only the position is used or a geometry_msgs.msg/Point which is the position part of a Pose.

        :param position: Target position as xyz.
        :param base: If the bottom of the Object should be placed or the origin in the center.
        """
        pose = Pose()
        if isinstance(position, Pose):
            target_position = position.position
            pose.frame = position.frame
        elif isinstance(position, Point):
            target_position = position
        elif isinstance(position, list):
            target_position = position
        else:
            raise TypeError("The given position has to be a Pose, Point or a list of xyz.")

        pose.position = target_position
        pose.orientation = self.get_orientation()
        self.set_pose(pose, base=base)

    def set_orientation(self, orientation: Union[Pose, Quaternion, List, Tuple, np.ndarray]) -> None:
        """
        Sets the orientation of the Object to the given orientation. Orientation can either be a Pose, in this case only
        the orientation of this pose is used or a geometry_msgs.msg/Quaternion which is the orientation of a Pose.

        :param orientation: Target orientation given as a list of xyzw.
        """
        pose = Pose()
        if isinstance(orientation, Pose):
            target_orientation = orientation.orientation
            pose.frame = orientation.frame
        elif isinstance(orientation, Quaternion):
            target_orientation = orientation
        elif (isinstance(orientation, list) or isinstance(orientation, np.ndarray) or isinstance(orientation, tuple)) \
                and len(orientation) == 4:
            target_orientation = Quaternion(*orientation)
        else:
            raise TypeError("The given orientation has to be a Pose, Quaternion or one of list/tuple/ndarray of xyzw.")

        pose.pose.position = self.get_position()
        pose.pose.orientation = target_orientation
        self.set_pose(pose)

    def get_joint_id(self, name: str) -> int:
        """
        Returns the unique id for a joint name. As used by the world/simulator.

        :param name: The joint name
        :return: The unique id
        """
        return self.joint_name_to_id[name]

    def get_root_link_description(self) -> LinkDescription:
        """
        Returns the root link of the URDF of this object.

        :return: The root link as defined in the URDF of this object.
        """
        for link_description in self.description.links:
            if link_description.name == self.root_link_name:
                return link_description

    @property
    def root_link(self) -> ObjectDescription.Link:
        """
        Returns the root link of this object.

        :return: The root link of this object.
        """
        return self.links[self.description.get_root()]

    @property
    def root_link_name(self) -> str:
        """
        Returns the name of the root link of this object.

        :return: The name of the root link of this object.
        """
        return self.description.get_root()

    def get_root_link_id(self) -> int:
        """
        Returns the unique id of the root link of this object.

        :return: The unique id of the root link of this object.
        """
        return self.get_link_id(self.description.get_root())

    def get_link_id(self, link_name: str) -> int:
        """
        Returns a unique id for a link name.

        :param link_name: The name of the link.
        :return: The unique id of the link.
        """
        return self.link_name_to_id[link_name]

    def get_link_by_id(self, link_id: int) -> ObjectDescription.Link:
        """
        Returns the link for a given unique link id

        :param link_id: The unique id of the link.
        :return: The link object.
        """
        return self.links[self.link_id_to_name[link_id]]

    def reset_all_joints_positions(self) -> None:
        """
        Sets the current position of all joints to 0. This is useful if the joints should be reset to their default
        """
        joint_names = list(self.joint_name_to_id.keys())
        joint_positions = [0] * len(joint_names)
        self.set_joint_positions(dict(zip(joint_names, joint_positions)))

    def set_joint_positions(self, joint_poses: dict) -> None:
        """
        Sets the current position of multiple joints at once, this method should be preferred when setting
        multiple joints at once instead of running :func:`~Object.set_joint_position` in a loop.

        :param joint_poses:
        """
        for joint_name, joint_position in joint_poses.items():
            self.joints[joint_name].position = joint_position
        # self.update_pose()
        self._update_all_links_poses()
        self.update_link_transforms()
        self._set_attached_objects_poses()

    def set_joint_position(self, joint_name: str, joint_position: float) -> None:
        """
        Sets the position of the given joint to the given joint pose and updates the poses of all attached objects.

        :param joint_name: The name of the joint
        :param joint_position: The target pose for this joint
        """
        self.joints[joint_name].position = joint_position
        self._update_all_links_poses()
        self.update_link_transforms()
        self._set_attached_objects_poses()

    def get_joint_position(self, joint_name: str) -> float:
        """
        :param joint_name: The name of the joint
        :return: The current position of the given joint
        """
        return self.joints[joint_name].position

    def get_joint_damping(self, joint_name: str) -> float:
        """
        :param joint_name: The name of the joint
        :return: The damping of the given joint
        """
        return self.joints[joint_name].damping

    def get_joint_upper_limit(self, joint_name: str) -> float:
        """
        :param joint_name: The name of the joint
        :return: The upper limit of the given joint
        """
        return self.joints[joint_name].upper_limit

    def get_joint_lower_limit(self, joint_name: str) -> float:
        """
        :param joint_name: The name of the joint
        :return: The lower limit of the given joint
        """
        return self.joints[joint_name].lower_limit

    def get_joint_axis(self, joint_name: str) -> Point:
        """
        :param joint_name: The name of the joint
        :return: The axis of the given joint
        """
        return self.joints[joint_name].axis

    def get_joint_type(self, joint_name: str) -> JointType:
        """
        :param joint_name: The name of the joint
        :return: The type of the given joint
        """
        return self.joints[joint_name].type

    def get_joint_limits(self, joint_name: str) -> Tuple[float, float]:
        """
        :param joint_name: The name of the joint
        :return: The lower and upper limits of the given joint
        """
        return self.joints[joint_name].limits

    def get_joint_child_link(self, joint_name: str) -> ObjectDescription.Link:
        """
        :param joint_name: The name of the joint
        :return: The child link of the given joint
        """
        return self.joints[joint_name].child_link

    def get_joint_parent_link(self, joint_name: str) -> ObjectDescription.Link:
        """
        :param joint_name: The name of the joint
        :return: The parent link of the given joint
        """
        return self.joints[joint_name].parent_link

    def find_joint_above_link(self, link_name: str, joint_type: JointType) -> str:
        """
        Traverses the chain from 'link' to the URDF origin and returns the first joint that is of type 'joint_type'.

        :param link_name: AbstractLink name above which the joint should be found
        :param joint_type: Joint type that should be searched for
        :return: Name of the first joint which has the given type
        """
        chain = self.description.get_chain(self.description.get_root(), link_name)
        reversed_chain = reversed(chain)
        container_joint = None
        for element in reversed_chain:
            if element in self.joint_name_to_id and self.get_joint_type(element) == joint_type:
                container_joint = element
                break
        if not container_joint:
            rospy.logwarn(f"No joint of type {joint_type} found above link {link_name}")
        return container_joint

    def get_positions_of_all_joints(self) -> Dict[str, float]:
        """
        Returns the positions of all joints of the object as a dictionary of joint names and joint positions.

        :return: A dictionary with all joints positions'.
        """
        return {j.name: j.position for j in self.joints.values()}

    def update_link_transforms(self, transform_time: Optional[rospy.Time] = None) -> None:
        """
        Updates the transforms of all links of this object using time 'transform_time' or the current ros time.
        """
        for link in self.links.values():
            link.update_transform(transform_time)

    def contact_points(self) -> List:
        """
        Returns a list of contact points of this Object with other Objects.

        :return: A list of all contact points with other objects
        """
        return self.world.get_object_contact_points(self)

    def contact_points_simulated(self) -> List:
        """
        Returns a list of all contact points between this Object and other Objects after stepping the simulation once.

        :return: A list of contact points between this Object and other Objects
        """
        state_id = self.world.save_state()
        self.world.step()
        contact_points = self.contact_points()
        self.world.restore_state(state_id)
        return contact_points

    def set_color(self, rgba_color: Color) -> None:
        """
        Changes the color of this object, the color has to be given as a list
        of RGBA values.

        :param rgba_color: The color as Color object with RGBA values between 0 and 1
        """
        # Check if there is only one link, this is the case for primitive
        # forms or if loaded from an .stl or .obj file
        if self.links != {}:
            for link in self.links.values():
                link.color = rgba_color
        else:
            self.root_link.color = rgba_color

    def get_color(self) -> Union[Color, Dict[str, Color]]:
        """
        This method returns the rgba_color of this object. The return is either:

            1. A Color object with RGBA values, this is the case if the object only has one link (this
                happens for example if the object is spawned from a .obj or .stl file)
            2. A dict with the link name as key and the rgba_color as value. The rgba_color is given as a Color Object.
                Please keep in mind that not every link may have a rgba_color. This is dependent on the URDF from which
                 the object is spawned.

        :return: The rgba_color as Color object with RGBA values between 0 and 1 or a dict with the link name as key and the rgba_color as value.
        """
        link_to_color_dict = self.links_colors

        if len(link_to_color_dict) == 1:
            return list(link_to_color_dict.values())[0]
        else:
            return link_to_color_dict

    @property
    def links_colors(self) -> Dict[str, Color]:
        """
        The color of each link as a dictionary with link names as keys and RGBA colors as values.
        """
        return self.world.get_colors_of_object_links(self)

    def get_axis_aligned_bounding_box(self) -> AxisAlignedBoundingBox:
        """
        :return: The axis aligned bounding box of this object.
        """
        return self.world.get_object_axis_aligned_bounding_box(self)

    def get_base_origin(self) -> Pose:
        """
        :return: the origin of the base/bottom of this object.
        """
        aabb = self.get_axis_aligned_bounding_box()
        base_width = np.absolute(aabb.min_x - aabb.max_x)
        base_length = np.absolute(aabb.min_y - aabb.max_y)
        return Pose([aabb.min_x + base_width / 2, aabb.min_y + base_length / 2, aabb.min_z],
                    self.get_orientation_as_list())

    def get_joint_by_id(self, joint_id: int) -> Joint:
        """
        Returns the joint object with the given id.

        :param joint_id: The unique id of the joint.
        :return: The joint object.
        """
        return dict([(joint.id, joint) for joint in self.joints.values()])[joint_id]

    def copy_to_prospection(self) -> Object:
        """
        Copies this object to the prospection world.

        :return: The copied object in the prospection world.
        """
        obj = Object(self.name, self.obj_type, self.path, type(self.description), self.get_pose(),
                     self.world.prospection_world, self.color)
        obj.current_state = self.current_state
        return obj

    def get_link_for_attached_objects(self) -> Dict[Object, ObjectDescription.Link]:
        """
        Returns a dictionary which maps attached object to the link of this object to which the given object is attached.

        :return: The link of this object to which the given object is attached.
        """
        return {obj: attachment.parent_link for obj, attachment in self.attachments.items()}


    def __copy__(self) -> Object:
        """
        Returns a copy of this object. The copy will have the same name, type, path, description, pose, world and color.

        :return: A copy of this object.
        """
        obj = Object(self.name, self.obj_type, self.path, type(self.description), self.get_pose(),
                     self.world.prospection_world, self.color)
        obj.current_state = self.current_state
        return obj

    def __eq__(self, other):
        if not isinstance(other, Object):
            return False
        return (self.id == other.id and self.world == other.world and self.name == other.name
                and self.obj_type == other.obj_type)

    def __hash__(self):
        return hash((self.name, self.obj_type, self.id, self.world.id))


##New # Content from: #<src/pycram/world_concepts/constraints.py>#
from __future__ import annotations

import numpy as np
from geometry_msgs.msg import Point
from typing_extensions import Union, List, Optional, TYPE_CHECKING

from ..datastructures.enums import JointType
from ..datastructures.pose import Transform, Pose

if TYPE_CHECKING:
    from ..description import Link


class AbstractConstraint:
    """
    Represents an abstract constraint concept, this could be used to create joints for example or any kind of constraint
    between two links in the world.
    """

    def __init__(self,
                 parent_link: Link,
                 child_link: Link,
                 _type: JointType,
                 parent_to_constraint: Transform,
                 child_to_constraint: Transform):
        self.parent_link: Link = parent_link
        self.child_link: Link = child_link
        self.type: JointType = _type
        self.parent_to_constraint = parent_to_constraint
        self.child_to_constraint = child_to_constraint
        self._parent_to_child = None

    @property
    def parent_to_child_transform(self) -> Union[Transform, None]:
        if self._parent_to_child is None:
            if self.parent_to_constraint is not None and self.child_to_constraint is not None:
                self._parent_to_child = self.parent_to_constraint * self.child_to_constraint.invert()
        return self._parent_to_child

    @parent_to_child_transform.setter
    def parent_to_child_transform(self, transform: Transform) -> None:
        self._parent_to_child = transform

    @property
    def parent_object_id(self) -> int:
        """
        Returns the id of the parent object of the constraint.

        :return: The id of the parent object of the constraint
        """
        return self.parent_link.object_id

    @property
    def child_object_id(self) -> int:
        """
        Returns the id of the child object of the constraint.

        :return: The id of the child object of the constraint
        """
        return self.child_link.object_id

    @property
    def parent_link_id(self) -> int:
        """
        Returns the id of the parent link of the constraint.

        :return: The id of the parent link of the constraint
        """
        return self.parent_link.id

    @property
    def child_link_id(self) -> int:
        """
        Returns the id of the child link of the constraint.

        :return: The id of the child link of the constraint
        """
        return self.child_link.id

    @property
    def position_wrt_parent_as_list(self) -> List[float]:
        """
        Returns the constraint frame pose with respect to the parent origin as a list.

        :return: The constraint frame pose with respect to the parent origin as a list
        """
        return self.pose_wrt_parent.position_as_list()

    @property
    def orientation_wrt_parent_as_list(self) -> List[float]:
        """
        Returns the constraint frame orientation with respect to the parent origin as a list.

        :return: The constraint frame orientation with respect to the parent origin as a list
        """
        return self.pose_wrt_parent.orientation_as_list()

    @property
    def pose_wrt_parent(self) -> Pose:
        """
        Returns the joint frame pose with respect to the parent origin.

        :return: The joint frame pose with respect to the parent origin
        """
        return self.parent_to_constraint.to_pose()

    @property
    def position_wrt_child_as_list(self) -> List[float]:
        """
        Returns the constraint frame pose with respect to the child origin as a list.

        :return: The constraint frame pose with respect to the child origin as a list
        """
        return self.pose_wrt_child.position_as_list()

    @property
    def orientation_wrt_child_as_list(self) -> List[float]:
        """
        Returns the constraint frame orientation with respect to the child origin as a list.

        :return: The constraint frame orientation with respect to the child origin as a list
        """
        return self.pose_wrt_child.orientation_as_list()

    @property
    def pose_wrt_child(self) -> Pose:
        """
        Returns the joint frame pose with respect to the child origin.

        :return: The joint frame pose with respect to the child origin
        """
        return self.child_to_constraint.to_pose()


class Constraint(AbstractConstraint):
    """
    Represents a constraint between two links in the World.
    """

    def __init__(self,
                 parent_link: Link,
                 child_link: Link,
                 _type: JointType,
                 axis_in_child_frame: Point,
                 constraint_to_parent: Transform,
                 child_to_constraint: Transform):
        parent_to_constraint = constraint_to_parent.invert()
        AbstractConstraint.__init__(self, parent_link, child_link, _type, parent_to_constraint, child_to_constraint)
        self.axis: Point = axis_in_child_frame

    @property
    def axis_as_list(self) -> List[float]:
        """
        Returns the axis of this constraint as a list.

        :return: The axis of this constraint as a list of xyz
        """
        return [self.axis.x, self.axis.y, self.axis.z]


class Attachment(AbstractConstraint):
    def __init__(self,
                 parent_link: Link,
                 child_link: Link,
                 bidirectional: Optional[bool] = False,
                 parent_to_child_transform: Optional[Transform] = None,
                 constraint_id: Optional[int] = None):
        """
        Creates an attachment between the parent object link and the child object link.
        This could be a bidirectional attachment, meaning that both objects will move when one moves.

        :param parent_link: The parent object link.
        :param child_link: The child object link.
        :param bidirectional: If true, both objects will move when one moves.
        :param parent_to_child_transform: The transform from the parent link to the child object link.
        :param constraint_id: The id of the constraint in the simulator.
        """
        super().__init__(parent_link, child_link, JointType.FIXED, parent_to_child_transform,
                         Transform(frame=child_link.tf_frame))
        self.id = constraint_id
        self.bidirectional: bool = bidirectional
        self._loose: bool = False

        if self.parent_to_child_transform is None:
            self.update_transform()

        if self.id is None:
            self.add_fixed_constraint()

    def update_transform_and_constraint(self) -> None:
        """
        Updates the transform and constraint of this attachment.
        """
        self.update_transform()
        self.update_constraint()

    def update_transform(self) -> None:
        """
        Updates the transform of this attachment by calculating the transform from the parent link to the child link.
        """
        self.parent_to_child_transform = self.calculate_transform()

    def update_constraint(self) -> None:
        """
        Updates the constraint of this attachment by removing the old constraint if one exists and adding a new one.
        """
        self.remove_constraint_if_exists()
        self.add_fixed_constraint()

    def add_fixed_constraint(self) -> None:
        """
        Adds a fixed constraint between the parent link and the child link.
        """
        self.id = self.parent_link.add_fixed_constraint_with_link(self.child_link)

    def calculate_transform(self) -> Transform:
        """
        Calculates the transform from the parent link to the child link.
        """
        return self.parent_link.get_transform_to_link(self.child_link)

    def remove_constraint_if_exists(self) -> None:
        """
        Removes the constraint between the parent and the child links if one exists.
        """
        if self.child_link in self.parent_link.constraint_ids:
            self.parent_link.remove_constraint_with_link(self.child_link)

    def get_inverse(self) -> 'Attachment':
        """
        :return: A new Attachment object with the parent and child links swapped.
        """
        attachment = Attachment(self.child_link, self.parent_link, self.bidirectional,
                                constraint_id=self.id)
        attachment.loose = not self._loose
        return attachment

    @property
    def loose(self) -> bool:
        """
        If true, then the child object will not move when parent moves.
        """
        return self._loose

    @loose.setter
    def loose(self, loose: bool) -> None:
        """
        Sets the loose property of this attachment.

        :param loose: If true, then the child object will not move when parent moves.
        """
        self._loose = loose and not self.bidirectional

    @property
    def is_reversed(self) -> bool:
        """
        :return: True if the parent and child links are swapped.
        """
        return self.loose

    def __del__(self) -> None:
        """
        Removes the constraint between the parent and the child links if one exists when the attachment is deleted.
        """
        self.remove_constraint_if_exists()

    def __copy__(self):
        return Attachment(self.parent_link, self.child_link, self.bidirectional, self.parent_to_child_transform,
                          self.id)

    def __eq__(self, other):
        return (self.parent_link.name == other.parent_link.name
                and self.child_link.name == other.child_link.name
                and self.bidirectional == other.bidirectional
                and np.allclose(self.parent_to_child_transform.translation_as_list(),
                                other.parent_to_child_transform.translation_as_list(), rtol=0, atol=1e-4)
                and np.allclose(self.parent_to_child_transform.rotation_as_list(),
                                other.parent_to_child_transform.rotation_as_list(), rtol=0, atol=1e-4))

    def __hash__(self):
        return hash((self.parent_link.name, self.child_link.name, self.bidirectional, self.parent_to_child_transform))


##New # Content from: #<src/pycram/world_concepts/event.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

from typing_extensions import Callable, List, Optional, Any


class Event:
    """
    Base implementation of events in PyCRAM.
    Events allow to attach handler methods to events that fire for specific occurences in the world.

    :ivar handler: List of methods that are called when this event is fired.
    """

    def __init__(self):
        self.handlers: List[Callable] = []

    def add(self, handler: Callable) -> None:
        """
        Adds a new handler to the list of handlers. All handler methods are called when this event is fired.
        Handler have to take the event sender as parameter as well as args* which can contain further parameter.

        :param handler: A method that should be added
        """
        self.handlers.append(handler)

    def remove(self, handler: Callable) -> None:
        """
        Removes a method from the list of handlers, the method will not be called when the event is fired.

        :param handler: The method that should be removed.
        """
        self.handlers.remove(handler)

    def fire(self, sender: Any, earg: Optional[Any] = None) -> None:
        """
        Fire this event, this causes every method to be called with a sender as well as additional args.

        :param sender: The entity that fired the event.
        :param earg: Additional arguments.
        """
        for handler in self.handlers:
            handler(sender, earg)

    def __iadd__(self, other: Callable) -> Event:
        """
        Operator overload that allows to add handlers by the '+=' operator.

        :param other: The handler that should be added.
        :return: This instance
        """
        self.add(other)
        return self

    def __isub__(self, other: Callable) -> Event:
        """
        Operator overload that allows to remove methods as handlers by using the '-=' operator.

        :param other: The method that should be removed as handler.
        :return: This instance
        """
        self.remove(other)
        return self

    __call__ = fire
    """
    Allows to directly call the reference.
    """

##New # Content from: #<src/pycram/designators/action_designator.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import abc
import inspect
import itertools

import numpy as np
from sqlalchemy.orm import Session
from tf import transformations
from typing_extensions import Any, List, Union, Callable, Optional, Type

import rospy

from .location_designator import CostmapLocation
from .motion_designator import MoveJointsMotion, MoveGripperMotion, MoveArmJointsMotion, MoveTCPMotion, MoveMotion, \
    LookingMotion, DetectingMotion, OpeningMotion, ClosingMotion
from .object_designator import ObjectDesignatorDescription, BelieveObject, ObjectPart
from ..local_transformer import LocalTransformer
from ..plan_failures import ObjectUnfetchable, ReachabilityFailure
# from ..robot_descriptions import robot_description
from ..robot_description import RobotDescription
from ..tasktree import with_tree

from owlready2 import Thing

from ..datastructures.enums import Arms, Grasp, GripperState
from ..designator import ActionDesignatorDescription
from ..datastructures.pose import Pose
from ..datastructures.world import World
from ..ontology.ontology import OntologyConceptHolder

from ..orm.action_designator import (ParkArmsAction as ORMParkArmsAction, NavigateAction as ORMNavigateAction,
                                     PickUpAction as ORMPickUpAction, PlaceAction as ORMPlaceAction,
                                     MoveTorsoAction as ORMMoveTorsoAction, SetGripperAction as ORMSetGripperAction,
                                     LookAtAction as ORMLookAtAction, DetectAction as ORMDetectAction,
                                     TransportAction as ORMTransportAction, OpenAction as ORMOpenAction,
                                     CloseAction as ORMCloseAction, GraspingAction as ORMGraspingAction, Action,
                                     FaceAtAction as ORMFaceAtAction)
from ..orm.base import Pose as ORMPose
from ..orm.object_designator import Object as ORMObject
from ..orm.action_designator import Action as ORMAction
from dataclasses import dataclass, field


class MoveTorsoAction(ActionDesignatorDescription):
    """
    Action Designator for Moving the torso of the robot up and down
    """

    def __init__(self, positions: List[float], resolver=None,
                 ontology_concept_holders: Optional[List[OntologyConceptHolder]] = None):
        """
        Create a designator description to move the torso of the robot up and down.

        :param positions: List of possible positions of the robots torso, possible position is a float of height in metres
        :param resolver: An optional specialized_designators that returns a performable designator for a designator description.
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.positions: List[float] = positions

        if self.soma:
            self.init_ontology_concepts({"move_torso": self.soma.MoveTorso})

    def ground(self) -> MoveTorsoActionPerformable:
        """
        Creates a performable action designator with the first element from the list of possible torso heights.

        :return: A performable action designator
        """
        return MoveTorsoActionPerformable(self.positions[0])

    def __iter__(self):
        """
        Iterates over all possible values for this designator and returns a performable action designator with the value.

        :return: A performable action designator
        """
        for position in self.positions:
            yield MoveTorsoActionPerformable(position)


class SetGripperAction(ActionDesignatorDescription):
    """
    Set the gripper state of the robot
    """

    def __init__(self, grippers: List[Arms], motions: List[GripperState], resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Sets the gripper state, the desired state is given with the motion. Motion can either be 'open' or 'close'.

        :param grippers: A list of possible grippers
        :param motions: A list of possible motions
        :param resolver: An alternative specialized_designators that returns a performable designator for a designator description
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.grippers: List[GripperState] = grippers
        self.motions: List[Arms] = motions

        if self.soma:
            self.init_ontology_concepts({"setting_gripper": self.soma.SettingGripper})

    def ground(self) -> SetGripperActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the first element in the grippers and motions list.

        :return: A performable designator
        """
        return SetGripperActionPerformable(self.grippers[0], self.motions[0])

    def __iter__(self):
        """
        Iterates over all possible combinations of grippers and motions

        :return: A performable designator with a combination of gripper and motion
        """
        for parameter_combination in itertools.product(self.grippers, self.motions):
            yield SetGripperActionPerformable(*parameter_combination)


class ReleaseAction(ActionDesignatorDescription):
    """
    Releases an Object from the robot.

    Note: This action can not be used yet.
    """

    def __init__(self, grippers: List[Arms], object_designator_description: ObjectDesignatorDescription,
                 resolver=None, ontology_concept_holders: Optional[List[Thing]] = None):
        super().__init__(resolver, ontology_concept_holders)
        self.grippers: List[Arms] = grippers
        self.object_designator_description = object_designator_description

        if self.soma:
            self.init_ontology_concepts({"releasing": self.soma.Releasing})

    def ground(self) -> ReleaseActionPerformable:
        return ReleaseActionPerformable(self.grippers[0], self.object_designator_description.ground())


class GripAction(ActionDesignatorDescription):
    """
    Grip an object with the robot.

    :ivar grippers: The grippers to consider
    :ivar object_designator_description: The description of objects to consider
    :ivar efforts: The efforts to consider

    Note: This action can not be used yet.
    """

    def __init__(self, grippers: List[Arms], object_designator_description: ObjectDesignatorDescription,
                 efforts: List[float], resolver=None, ontology_concept_holders: Optional[List[Thing]] = None):
        super().__init__(resolver, ontology_concept_holders)
        self.grippers: List[Arms] = grippers
        self.object_designator_description: ObjectDesignatorDescription = object_designator_description
        self.efforts: List[float] = efforts

        if self.soma:
            self.init_ontology_concepts({"holding": self.soma.Holding})

    def ground(self) -> GripActionPerformable:
        return GripActionPerformable(self.grippers[0], self.object_designator_description.ground(), self.efforts[0])


class ParkArmsAction(ActionDesignatorDescription):
    """
    Park the arms of the robot.
    """

    def __init__(self, arms: List[Arms], resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Moves the arms in the pre-defined parking position. Arms are taken from pycram.enum.Arms

        :param arms: A list of possible arms, that could be used
        :param resolver: An optional specialized_designators that returns a performable designator from the designator description
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.arms: List[Arms] = arms

        if self.soma:
            self.init_ontology_concepts({"parking_arms": self.soma.ParkingArms})

    def ground(self) -> ParkArmsActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the first element of the list of possible arms

        :return: A performable designator
        """
        return ParkArmsActionPerformable(self.arms[0])


class PickUpAction(ActionDesignatorDescription):
    """
    Designator to let the robot pick up an object.
    """

    def __init__(self,
                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],
                 arms: List[Arms], grasps: List[Grasp], resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Lets the robot pick up an object. The description needs an object designator describing the object that should be
        picked up, an arm that should be used as well as the grasp from which side the object should be picked up.

        :param object_designator_description: List of possible object designator
        :param arms: List of possible arms that could be used
        :param grasps: List of possible grasps for the object
        :param resolver: An optional specialized_designators that returns a performable designator with elements from the lists of possible paramter
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.object_designator_description: Union[
            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description
        self.arms: List[Arms] = arms
        self.grasps: List[Grasp] = grasps

        if self.soma:
            self.init_ontology_concepts({"picking_up": self.soma.PickingUp})

    def ground(self) -> PickUpActionPerformable:
        """
        Default specialized_designators, returns a performable designator with the first entries from the lists of possible parameter.

        :return: A performable designator
        """
        if isinstance(self.object_designator_description, ObjectDesignatorDescription.Object):
            obj_desig = self.object_designator_description
        else:
            obj_desig = self.object_designator_description.resolve()

        return PickUpActionPerformable(obj_desig, self.arms[0], self.grasps[0])


class PlaceAction(ActionDesignatorDescription):
    """
    Places an Object at a position using an arm.
    """

    def __init__(self,
                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],
                 target_locations: List[Pose],
                 arms: List[Arms], resolver=None, ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Create an Action Description to place an object

        :param object_designator_description: Description of object to place.
        :param target_locations: List of possible positions/orientations to place the object
        :param arms: List of possible arms to use
        :param resolver: Grounding method to resolve this designator
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.object_designator_description: Union[
            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description
        self.target_locations: List[Pose] = target_locations
        self.arms: List[Arms] = arms

        if self.soma:
            self.init_ontology_concepts({"placing": self.soma.Placing})

    def ground(self) -> PlaceActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the first entries from the list of possible entries.

        :return: A performable designator
        """
        obj_desig = self.object_designator_description if isinstance(self.object_designator_description,
                                                                     ObjectDesignatorDescription.Object) else self.object_designator_description.resolve()

        return PlaceActionPerformable(obj_desig, self.arms[0], self.target_locations[0])


class NavigateAction(ActionDesignatorDescription):
    """
    Navigates the Robot to a position.
    """

    def __init__(self, target_locations: List[Pose], resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Navigates the robot to a location.

        :param target_locations: A list of possible target locations for the navigation.
        :param resolver: An alternative specialized_designators that creates a performable designator from the list of possible parameter
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.target_locations: List[Pose] = target_locations

        if self.soma:
            self.init_ontology_concepts({"navigating": self.soma.Navigating})

    def ground(self) -> NavigateActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the first entry of possible target locations.

        :return: A performable designator
        """
        return NavigateActionPerformable(self.target_locations[0])


class TransportAction(ActionDesignatorDescription):
    """
    Transports an object to a position using an arm
    """

    def __init__(self,
                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],
                 arms: List[Arms],
                 target_locations: List[Pose], resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Designator representing a pick and place plan.

        :param object_designator_description: Object designator description or a specified Object designator that should be transported
        :param arms: A List of possible arms that could be used for transporting
        :param target_locations: A list of possible target locations for the object to be placed
        :param resolver: An alternative specialized_designators that returns a performable designator for the list of possible parameter
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.object_designator_description: Union[
            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description
        self.arms: List[Arms] = arms
        self.target_locations: List[Pose] = target_locations

        if self.soma:
            self.init_ontology_concepts({"transporting": self.soma.Transporting})

    def ground(self) -> TransportActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the first entries from the lists of possible parameter.

        :return: A performable designator
        """
        obj_desig = self.object_designator_description \
            if isinstance(self.object_designator_description, ObjectDesignatorDescription.Object) \
            else self.object_designator_description.resolve()

        return TransportActionPerformable(obj_desig, self.arms[0], self.target_locations[0])


class LookAtAction(ActionDesignatorDescription):
    """
    Lets the robot look at a position.
    """

    def __init__(self, targets: List[Pose], resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Moves the head of the robot such that it points towards the given target location.

        :param targets: A list of possible locations to look at
        :param resolver: An alternative specialized_designators that returns a performable designator for a list of possible target locations
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.targets: List[Pose] = targets

        if self.soma:
            self.init_ontology_concepts({"looking_at": self.soma.LookingAt})

    def ground(self) -> LookAtActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the first entry in the list of possible targets

        :return: A performable designator
        """
        return LookAtActionPerformable(self.targets[0])


class DetectAction(ActionDesignatorDescription):
    """
    Detects an object that fits the object description and returns an object designator describing the object.
    """

    def __init__(self, object_designator_description: ObjectDesignatorDescription, resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Tries to detect an object in the field of view (FOV) of the robot.

        :param object_designator_description: Object designator describing the object
        :param resolver: An alternative specialized_designators
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.object_designator_description: ObjectDesignatorDescription = object_designator_description

        if self.soma:
            self.init_ontology_concepts({"looking_for": self.soma.LookingFor,
                                         "checking_object_presence": self.soma.CheckingObjectPresence})

    def ground(self) -> DetectActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the resolved object description.

        :return: A performable designator
        """
        return DetectActionPerformable(self.object_designator_description.resolve())


class OpenAction(ActionDesignatorDescription):
    """
    Opens a container like object

    Can currently not be used
    """

    def __init__(self, object_designator_description: ObjectPart, arms: List[Arms], resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Moves the arm of the robot to open a container.

        :param object_designator_description: Object designator describing the handle that should be used to open
        :param arms: A list of possible arms that should be used
        :param resolver: A alternative specialized_designators that returns a performable designator for the lists of possible parameter.
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.object_designator_description: ObjectPart = object_designator_description
        self.arms: List[Arms] = arms

        if self.soma:
            self.init_ontology_concepts({"opening": self.soma.Opening})

    def ground(self) -> OpenActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the resolved object description and the first entries
        from the lists of possible parameter.

        :return: A performable designator
        """
        return OpenActionPerformable(self.object_designator_description.resolve(), self.arms[0])


class CloseAction(ActionDesignatorDescription):
    """
    Closes a container like object.

    Can currently not be used
    """

    def __init__(self, object_designator_description: ObjectPart, arms: List[Arms],
                 resolver=None, ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Attempts to close an open container

        :param object_designator_description: Object designator description of the handle that should be used
        :param arms: A list of possible arms to use
        :param resolver: An alternative specialized_designators that returns a performable designator for the list of possible parameter
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.object_designator_description: ObjectPart = object_designator_description
        self.arms: List[Arms] = arms

        if self.soma:
            self.init_ontology_concepts({"closing": self.soma.Closing})

    def ground(self) -> CloseActionPerformable:
        """
        Default specialized_designators that returns a performable designator with the resolved object designator and the first entry from
        the list of possible arms.

        :return: A performable designator
        """
        return CloseActionPerformable(self.object_designator_description.resolve(), self.arms[0])


class GraspingAction(ActionDesignatorDescription):
    """
    Grasps an object described by the given Object Designator description
    """

    def __init__(self, arms: List[Arms], object_description: Union[ObjectDesignatorDescription, ObjectPart],
                 resolver: Callable = None, ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Will try to grasp the object described by the given description. Grasping is done by moving into a pre grasp
        position 10 cm before the object, opening the gripper, moving to the object and then closing the gripper.

        :param arms: List of Arms that should be used for grasping
        :param object_description: Description of the object that should be grasped
        :param resolver: An alternative specialized_designators to get a specified designator from the designator description
        :param ontology_concept_holders: A list of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(resolver, ontology_concept_holders)
        self.arms: List[Arms] = arms
        self.object_description: ObjectDesignatorDescription = object_description

        if self.soma:
            self.init_ontology_concepts({"grasping": self.soma.Grasping})

    def ground(self) -> GraspingActionPerformable:
        """
        Default specialized_designators that takes the first element from the list of arms and the first solution for the object
        designator description ond returns it.

        :return: A performable action designator that contains specific arguments
        """
        return GraspingActionPerformable(self.arms[0], self.object_description.resolve())


# ----------------------------------------------------------------------------
# ---------------- Performables ----------------------------------------------
# ----------------------------------------------------------------------------


@dataclass
class ActionAbstract(ActionDesignatorDescription.Action, abc.ABC):
    """Base class for performable performables."""
    orm_class: Type[ORMAction] = field(init=False, default=None)
    """
    The ORM class that is used to insert this action into the database. Must be overwritten by every action in order to
    be able to insert the action into the database.
    """

    @abc.abstractmethod
    def perform(self) -> None:
        """
        Perform the action.

        Will be overwritten by each action.
        """
        pass

    def to_sql(self) -> Action:
        """
        Convert this action to its ORM equivalent.

        Needs to be overwritten by an action if it didn't overwrite the orm_class attribute with its ORM equivalent.

        :return: An instance of the ORM equivalent of the action with the parameters set
        """
        # get all class parameters (ignore inherited ones)
        class_variables = {key: value for key, value in vars(self).items()
                           if key in inspect.getfullargspec(self.__init__).args}

        # get all orm class parameters (ignore inherited ones)
        orm_class_variables = inspect.getfullargspec(self.orm_class.__init__).args

        # list of parameters that will be passed to the ORM class. If the name does not match the orm_class equivalent
        # or if it is a type that needs to be inserted into the session manually, it will not be added to the list
        parameters = [value for key, value in class_variables.items() if key in orm_class_variables
                      and not isinstance(value, (ObjectDesignatorDescription.Object, Pose))]

        return self.orm_class(*parameters)

    def insert(self, session: Session, **kwargs) -> Action:
        """
        Insert this action into the database.

        Needs to be overwritten by an action if the action has attributes that do not exist in the orm class
        equivalent. In that case, the attributes need to be inserted into the session manually.

        :param session: Session with a database that is used to add and commit the objects
        :param kwargs: Possible extra keyword arguments
        :return: The completely instanced ORM action that was inserted into the database
        """

        action = super().insert(session)

        # get all class parameters (ignore inherited ones)
        class_variables = {key: value for key, value in vars(self).items()
                           if key in inspect.getfullargspec(self.__init__).args}

        # get all orm class parameters (ignore inherited ones)
        orm_class_variables = inspect.getfullargspec(self.orm_class.__init__).args

        # loop through all class parameters and insert them into the session unless they are already added by the ORM
        for key, value in class_variables.items():
            if key not in orm_class_variables:
                variable = value.insert(session)
                if isinstance(variable, ORMObject):
                    action.object = variable
                elif isinstance(variable, ORMPose):
                    action.pose = variable
        session.add(action)

        return action


@dataclass
class MoveTorsoActionPerformable(ActionAbstract):
    """
    Move the torso of the robot up and down.
    """

    position: float
    """
    Target position of the torso joint
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMMoveTorsoAction)

    @with_tree
    def perform(self) -> None:
        MoveJointsMotion([RobotDescription.current_robot_description.torso_joint], [self.position]).perform()


@dataclass
class SetGripperActionPerformable(ActionAbstract):
    """
    Set the gripper state of the robot.
    """

    gripper: Arms
    """
    The gripper that should be set 
    """
    motion: GripperState
    """
    The motion that should be set on the gripper
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMSetGripperAction)

    @with_tree
    def perform(self) -> None:
        MoveGripperMotion(gripper=self.gripper, motion=self.motion).perform()


@dataclass
class ReleaseActionPerformable(ActionAbstract):
    """
    Releases an Object from the robot.

    Note: This action can not ve used yet.
    """

    gripper: Arms

    object_designator: ObjectDesignatorDescription.Object

    def perform(self) -> None:
        raise NotImplementedError


@dataclass
class GripActionPerformable(ActionAbstract):
    """
    Grip an object with the robot.

    Note: This action can not be used yet.
    """

    gripper: Arms
    object_designator: ObjectDesignatorDescription.Object
    effort: float

    @with_tree
    def perform(self) -> None:
        raise NotImplementedError()


@dataclass
class ParkArmsActionPerformable(ActionAbstract):
    """
    Park the arms of the robot.
    """

    arm: Arms
    """
    Entry from the enum for which arm should be parked
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMParkArmsAction)

    @with_tree
    def perform(self) -> None:
        # create the keyword arguments
        kwargs = dict()
        left_poses = None
        right_poses = None

        # add park left arm if wanted
        if self.arm in [Arms.LEFT, Arms.BOTH]:
            kwargs["left_arm_config"] = "park"
            left_poses = RobotDescription.current_robot_description.get_arm_chain(Arms.LEFT).get_static_joint_states(kwargs["left_arm_config"])

        # add park right arm if wanted
        if self.arm in [Arms.RIGHT, Arms.BOTH]:
            kwargs["right_arm_config"] = "park"
            right_poses = RobotDescription.current_robot_description.get_arm_chain(Arms.RIGHT).get_static_joint_states(kwargs["right_arm_config"])

        MoveArmJointsMotion(left_poses, right_poses).perform()


@dataclass
class PickUpActionPerformable(ActionAbstract):
    """
    Let the robot pick up an object.
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    Object designator describing the object that should be picked up
    """

    arm: Arms
    """
    The arm that should be used for pick up
    """

    grasp: Grasp
    """
    The grasp that should be used. For example, 'left' or 'right'
    """

    object_at_execution: Optional[ObjectDesignatorDescription.Object] = field(init=False)
    """
    The object at the time this Action got created. It is used to be a static, information holding entity. It is
    not updated when the BulletWorld object is changed.
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMPickUpAction)

    @with_tree
    def perform(self) -> None:
        # Store the object's data copy at execution
        self.object_at_execution = self.object_designator.frozen_copy()
        robot = World.robot
        # Retrieve object and robot from designators
        object = self.object_designator.world_object
        # Get grasp orientation and target pose
        grasp = RobotDescription.current_robot_description.grasps[self.grasp]
        # oTm = Object Pose in Frame map
        oTm = object.get_pose()
        # Transform the object pose to the object frame, basically the origin of the object frame
        mTo = object.local_transformer.transform_to_object_frame(oTm, object)
        # Adjust the pose according to the special knowledge of the object designator
        adjusted_pose = self.object_designator.special_knowledge_adjustment_pose(self.grasp, mTo)
        # Transform the adjusted pose to the map frame
        adjusted_oTm = object.local_transformer.transform_pose(adjusted_pose, "map")
        # multiplying the orientation therefore "rotating" it, to get the correct orientation of the gripper

        adjusted_oTm.multiply_quaternions(grasp)

        # prepose depending on the gripper (its annoying we have to put pr2_1 here tbh
        # gripper_frame = "pr2_1/l_gripper_tool_frame" if self.arm == "left" else "pr2_1/r_gripper_tool_frame"
        gripper_frame = robot.get_link_tf_frame(RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame())
        # First rotate the gripper, so the further calculations makes sense
        tmp_for_rotate_pose = object.local_transformer.transform_pose(adjusted_oTm, gripper_frame)
        tmp_for_rotate_pose.pose.position.x = 0
        tmp_for_rotate_pose.pose.position.y = 0
        tmp_for_rotate_pose.pose.position.z = -0.1
        gripper_rotate_pose = object.local_transformer.transform_pose(tmp_for_rotate_pose, "map")

        # Perform Gripper Rotate
        # BulletWorld.current_bullet_world.add_vis_axis(gripper_rotate_pose)
        # MoveTCPMotion(gripper_rotate_pose, self.arm).resolve().perform()

        oTg = object.local_transformer.transform_pose(adjusted_oTm, gripper_frame)
        oTg.pose.position.x -= 0.1  # in x since this is how the gripper is oriented
        prepose = object.local_transformer.transform_pose(oTg, "map")

        # Perform the motion with the prepose and open gripper
        World.current_world.add_vis_axis(prepose)
        MoveTCPMotion(prepose, self.arm, allow_gripper_collision=True).perform()
        MoveGripperMotion(motion=GripperState.OPEN, gripper=self.arm).perform()

        # Perform the motion with the adjusted pose -> actual grasp and close gripper
        World.current_world.add_vis_axis(adjusted_oTm)
        MoveTCPMotion(adjusted_oTm, self.arm, allow_gripper_collision=True).perform()
        adjusted_oTm.pose.position.z += 0.03
        MoveGripperMotion(motion=GripperState.CLOSE, gripper=self.arm).perform()
        tool_frame = RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame()
        robot.attach(object, tool_frame)

        # Lift object
        World.current_world.add_vis_axis(adjusted_oTm)
        MoveTCPMotion(adjusted_oTm, self.arm, allow_gripper_collision=True).perform()

        # Remove the vis axis from the world
        World.current_world.remove_vis_axis()


@dataclass
class PlaceActionPerformable(ActionAbstract):
    """
    Places an Object at a position using an arm.
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    Object designator describing the object that should be place
    """
    arm: Arms
    """
    Arm that is currently holding the object
    """
    target_location: Pose
    """
    Pose in the world at which the object should be placed
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMPlaceAction)

    @with_tree
    def perform(self) -> None:
        object_pose = self.object_designator.world_object.get_pose()
        local_tf = LocalTransformer()

        # Transformations such that the target position is the position of the object and not the tcp
        tcp_to_object = local_tf.transform_pose(object_pose,
                                                World.robot.get_link_tf_frame(
                                                    RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame()))
        target_diff = self.target_location.to_transform("target").inverse_times(
            tcp_to_object.to_transform("object")).to_pose()

        MoveTCPMotion(target_diff, self.arm).perform()
        MoveGripperMotion(GripperState.OPEN, self.arm).perform()
        World.robot.detach(self.object_designator.world_object)
        retract_pose = local_tf.transform_pose(target_diff, World.robot.get_link_tf_frame(
            RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame()))
        retract_pose.position.x -= 0.07
        MoveTCPMotion(retract_pose, self.arm).perform()


@dataclass
class NavigateActionPerformable(ActionAbstract):
    """
    Navigates the Robot to a position.
    """

    target_location: Pose
    """
    Location to which the robot should be navigated
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMNavigateAction)

    @with_tree
    def perform(self) -> None:
        MoveMotion(self.target_location).perform()


@dataclass
class TransportActionPerformable(ActionAbstract):
    """
    Transports an object to a position using an arm
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    Object designator describing the object that should be transported.
    """
    arm: Arms
    """
    Arm that should be used
    """
    target_location: Pose
    """
    Target Location to which the object should be transported
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMTransportAction)

    @with_tree
    def perform(self) -> None:
        robot_desig = BelieveObject(names=[RobotDescription.current_robot_description.name])
        ParkArmsActionPerformable(Arms.BOTH).perform()
        pickup_loc = CostmapLocation(target=self.object_designator, reachable_for=robot_desig.resolve(),
                                     reachable_arm=self.arm)
        # Tries to find a pick-up posotion for the robot that uses the given arm
        pickup_pose = None
        for pose in pickup_loc:
            if self.arm in pose.reachable_arms:
                pickup_pose = pose
                break
        if not pickup_pose:
            raise ObjectUnfetchable(
                f"Found no pose for the robot to grasp the object: {self.object_designator} with arm: {self.arm}")

        NavigateActionPerformable(pickup_pose.pose).perform()
        PickUpActionPerformable(self.object_designator, self.arm, Grasp.FRONT).perform()
        ParkArmsActionPerformable(Arms.BOTH).perform()
        try:
            place_loc = CostmapLocation(target=self.target_location, reachable_for=robot_desig.resolve(),
                                        reachable_arm=self.arm).resolve()
        except StopIteration:
            raise ReachabilityFailure(
                f"No location found from where the robot can reach the target location: {self.target_location}")
        NavigateActionPerformable(place_loc.pose).perform()
        PlaceActionPerformable(self.object_designator, self.arm, self.target_location).perform()
        ParkArmsActionPerformable(Arms.BOTH).perform()


@dataclass
class LookAtActionPerformable(ActionAbstract):
    """
    Lets the robot look at a position.
    """

    target: Pose
    """
    Position at which the robot should look, given as 6D pose
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMLookAtAction)

    @with_tree
    def perform(self) -> None:
        LookingMotion(target=self.target).perform()


@dataclass
class DetectActionPerformable(ActionAbstract):
    """
    Detects an object that fits the object description and returns an object designator describing the object.
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    Object designator loosely describing the object, e.g. only type. 
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMDetectAction)

    @with_tree
    def perform(self) -> None:
        return DetectingMotion(object_type=self.object_designator.obj_type).perform()


@dataclass
class OpenActionPerformable(ActionAbstract):
    """
    Opens a container like object
    """

    object_designator: ObjectPart.Object
    """
    Object designator describing the object that should be opened
    """
    arm: Arms
    """
    Arm that should be used for opening the container
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMOpenAction)

    @with_tree
    def perform(self) -> None:
        GraspingActionPerformable(self.arm, self.object_designator).perform()
        OpeningMotion(self.object_designator, self.arm).perform()

        MoveGripperMotion(GripperState.OPEN, self.arm, allow_gripper_collision=True).perform()


@dataclass
class CloseActionPerformable(ActionAbstract):
    """
    Closes a container like object.
    """

    object_designator: ObjectPart.Object
    """
    Object designator describing the object that should be closed
    """
    arm: Arms
    """
    Arm that should be used for closing
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMCloseAction)

    @with_tree
    def perform(self) -> None:
        GraspingActionPerformable(self.arm, self.object_designator).perform()
        ClosingMotion(self.object_designator, self.arm).perform()

        MoveGripperMotion(GripperState.OPEN, self.arm, allow_gripper_collision=True).perform()


@dataclass
class GraspingActionPerformable(ActionAbstract):
    """
    Grasps an object described by the given Object Designator description
    """
    arm: Arms
    """
    The arm that should be used to grasp
    """
    object_desig: Union[ObjectDesignatorDescription.Object, ObjectPart.Object]
    """
    Object Designator for the object that should be grasped
    """
    orm_class: Type[ActionAbstract] = field(init=False, default=ORMGraspingAction)

    @with_tree
    def perform(self) -> None:
        if isinstance(self.object_desig, ObjectPart.Object):
            object_pose = self.object_desig.part_pose
        else:
            object_pose = self.object_desig.world_object.get_pose()
        lt = LocalTransformer()
        gripper_name = RobotDescription.current_robot_description.get_arm_chain(self.arm).get_tool_frame()

        object_pose_in_gripper = lt.transform_pose(object_pose,
                                                   World.robot.get_link_tf_frame(gripper_name))

        pre_grasp = object_pose_in_gripper.copy()
        pre_grasp.pose.position.x -= 0.1

        MoveTCPMotion(pre_grasp, self.arm).perform()
        MoveGripperMotion(GripperState.OPEN, self.arm).perform()

        MoveTCPMotion(object_pose, self.arm, allow_gripper_collision=True).perform()
        MoveGripperMotion(GripperState.CLOSE, self.arm, allow_gripper_collision=True).perform()


@dataclass
class FaceAtPerformable(ActionAbstract):
    """
    Turn the robot chassis such that is faces the ``pose`` and after that perform a look at action.
    """

    pose: Pose
    """
    The pose to face 
    """

    orm_class = ORMFaceAtAction

    @with_tree
    def perform(self) -> None:
        # get the robot position
        robot_position = World.robot.pose

        # calculate orientation for robot to face the object
        angle = np.arctan2(robot_position.position.y - self.pose.position.y,
                           robot_position.position.x - self.pose.position.x) + np.pi
        orientation = list(transformations.quaternion_from_euler(0, 0, angle, axes="sxyz"))

        # create new robot pose
        new_robot_pose = Pose(robot_position.position_as_list(), orientation)

        # turn robot
        NavigateActionPerformable(new_robot_pose).perform()

        # look at target
        LookAtActionPerformable(self.pose).perform()


@dataclass
class MoveAndPickUpPerformable(ActionAbstract):
    """
    Navigate to `standing_position`, then turn towards the object and pick it up.
    """

    standing_position: Pose
    """
    The pose to stand before trying to pick up the object
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    The object to pick up
    """

    arm: Arms
    """
    The arm to use
    """

    grasp: Grasp
    """
    The grasp to use
    """

    def perform(self):
        NavigateActionPerformable(self.standing_position).perform()
        FaceAtPerformable(self.object_designator.pose).perform()
        PickUpActionPerformable(self.object_designator, self.arm, self.grasp).perform()


##New # Content from: #<src/pycram/designators/object_designator.py>#
from __future__ import annotations

import dataclasses
from typing_extensions import List, Optional, Callable, TYPE_CHECKING
import sqlalchemy.orm
from ..datastructures.world import World
from ..world_concepts.world_object import Object as WorldObject
from ..designator import ObjectDesignatorDescription
from ..orm.base import ProcessMetaData
from ..orm.object_designator import (BelieveObject as ORMBelieveObject, ObjectPart as ORMObjectPart)
from ..datastructures.pose import Pose
from ..external_interfaces.robokudo import *

if TYPE_CHECKING:
    import owlready2


class BelieveObject(ObjectDesignatorDescription):
    """
    Description for Objects that are only believed in.
    """

    @dataclasses.dataclass
    class Object(ObjectDesignatorDescription.Object):
        """
        Concrete object that is believed in.
        """

        def to_sql(self) -> ORMBelieveObject:
            return ORMBelieveObject(self.obj_type, self.name)

        def insert(self, session: sqlalchemy.orm.session.Session) -> ORMBelieveObject:
            metadata = ProcessMetaData().insert(session)
            self_ = self.to_sql()
            self_.process_metadata = metadata
            session.add(self_)

            return self_


class ObjectPart(ObjectDesignatorDescription):
    """
    Object Designator Descriptions for Objects that are part of some other object.
    """

    @dataclasses.dataclass
    class Object(ObjectDesignatorDescription.Object):

        # The rest of attributes is inherited
        part_pose: Pose

        def to_sql(self) -> ORMObjectPart:
            return ORMObjectPart(self.obj_type, self.name)

        def insert(self, session: sqlalchemy.orm.session.Session) -> ORMObjectPart:
            metadata = ProcessMetaData().insert(session)
            pose = self.part_pose.insert(session)
            obj = self.to_sql()
            obj.process_metadata = metadata
            obj.pose = pose
            session.add(obj)

            return obj

    def __init__(self, names: List[str],
                 part_of: ObjectDesignatorDescription.Object,
                 type: Optional[str] = None,
                 resolver: Optional[Callable] = None):
        """
        Describing the relationship between an object and a specific part of it.

        :param names: Possible names for the part
        :param part_of: Parent object of which the part should be described
        :param type: Type of the part
        :param resolver: An alternative specialized_designators to resolve the input parameter to an object designator
        :param ontology_concept_holders: A list of ontology concepts that the object part is categorized as or associated with
        """
        super().__init__(names, type, resolver)

        if not part_of:
            raise AttributeError("part_of cannot be None.")

        self.type: Optional[str] = type
        self.names: Optional[List[str]] = names
        self.part_of = part_of

    def ground(self) -> Object:
        """
        Default specialized_designators, returns the first result of the iterator of this instance.

        :return: A resolved object designator
        """
        return next(iter(self))

    def __iter__(self):
        """
        Iterates through every possible solution for the given input parameter.

        :yield: A resolved Object designator
        """
        for name in self.names:
            if name in self.part_of.world_object.link_name_to_id.keys():
                yield self.Object(name, self.type, self.part_of.world_object,
                                  self.part_of.world_object.get_link_pose(name))


class LocatedObject(ObjectDesignatorDescription):
    """
    Description for KnowRob located objects.
    **Currently has no specialized_designators**
    """

    @dataclasses.dataclass
    class Object(ObjectDesignatorDescription.Object):
        reference_frame: str
        """
        Reference frame in which the position is given
        """
        timestamp: float
        """
        Timestamp at which the position was valid
        """

    def __init__(self, names: List[str], types: List[str],
                 reference_frames: List[str], timestamps: List[float], resolver: Optional[Callable] = None,
                 ontology_concept_holders: Optional[List[owlready2.Thing]] = None):
        """
        Describing an object resolved through knowrob.

        :param names: List of possible names describing the object
        :param types: List of possible types describing the object
        :param reference_frames: Frame of reference in which the object position should be
        :param timestamps: Timestamps for which positions should be returned
        :param resolver: An alternative specialized_designators that resolves the input parameter to an object designator.
        :param ontology_concept_holders: A list of ontology concepts that the object is categorized as
        """
        super(LocatedObject, self).__init__(names, types, resolver, ontology_concept_holders)
        self.reference_frames: List[str] = reference_frames
        self.timestamps: List[float] = timestamps


@DeprecationWarning
# Depricated class this will be done differently
class RealObject(ObjectDesignatorDescription):
    """
    Object designator representing an object in the real world, when resolving this object designator description ]
    RoboKudo is queried to perceive an object fitting the given criteria. Afterward the specialized_designators tries to match
    the found object to an Object in the World.
    """

    @dataclasses.dataclass
    class Object(ObjectDesignatorDescription.Object):
        pose: Pose
        """
        Pose of the perceived object
        """

    def __init__(self, names: Optional[List[str]] = None, types: Optional[List[str]] = None,
                 world_object: WorldObject = None, resolver: Optional[Callable] = None):
        """

        :param names:
        :param types:
        :param world_object:
        :param resolver:
        """
        super().__init__(resolver)
        self.types: Optional[List[str]] = types
        self.names: Optional[List[str]] = names
        self.world_object: WorldObject = world_object

    def __iter__(self):
        """
        Queries RoboKudo for objects that fit the description and then iterates over all World objects that have
        the same type to match a World object to the real object.

        :yield: A resolved object designator with reference world object
        """
        object_candidates = query(self)
        for obj_desig in object_candidates:
            for world_obj in World.get_object_by_type(obj_desig.obj_type):
                obj_desig.world_object = world_obj
                yield obj_desig


##New # Content from: #<src/pycram/designators/location_designator.py>#
import dataclasses
import time

from typing_extensions import List, Union, Iterable, Optional, Callable

from .object_designator import ObjectDesignatorDescription, ObjectPart
from ..datastructures.world import World, UseProspectionWorld
from ..local_transformer import LocalTransformer
from ..world_reasoning import link_pose_for_joint_config
from ..designator import DesignatorError, LocationDesignatorDescription
from ..costmaps import OccupancyCostmap, VisibilityCostmap, SemanticCostmap, GaussianCostmap
from ..datastructures.enums import JointType, Arms
from ..pose_generator_and_validator import PoseGenerator, visibility_validator, reachability_validator
from ..robot_description import RobotDescription
from ..datastructures.pose import Pose


class Location(LocationDesignatorDescription):
    """
    Default location designator which only wraps a pose.
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        pass

    def __init__(self, pose: Pose, resolver=None):
        """
        Basic location designator that represents a single pose.

        :param pose: The pose that should be represented by this location designator
        :param resolver: An alternative specialized_designators that returns a resolved location
        """
        super().__init__(resolver)
        self.pose: Pose = pose

    def ground(self) -> Location:
        """
        Default specialized_designators which returns a resolved designator which contains the pose given in init.

        :return: A resolved designator
        """
        return self.Location(self.pose)


# TODO Maybe delete this
class ObjectRelativeLocation(LocationDesignatorDescription):
    """
    Location relative to an object
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        relative_pose: Pose
        """
        Pose relative to the object
        """
        reference_object: ObjectDesignatorDescription.Object
        """
        Object to which the pose is relative
        """

    def __init__(self, relative_pose: Pose = None, reference_object: ObjectDesignatorDescription = None,
                 resolver=None):
        """
        Location designator representing a location relative to a given object.

        :param relative_pose: Pose that should be relative, in world coordinate frame
        :param reference_object: Object to which the pose should be relative
        :param resolver: An alternative specialized_designators that returns a resolved location for the input parameter
        """
        super().__init__(resolver)
        self.relative_pose: Pose = relative_pose
        self.reference_object: ObjectDesignatorDescription = reference_object

    def ground(self) -> Location:
        """
        Default specialized_designators which returns a resolved location for description input. Resolved location is the first result
        of the iteration of this instance.

        :return: A resolved location
        """
        return next(iter(self))

    def __iter__(self) -> Iterable[Location]:
        """
        Iterates over all possible solutions for a resolved location that is relative to the given object.

        :yield: An instance of ObjectRelativeLocation.Location with the relative pose
        """
        if self.relative_pose is None or self.reference_object is None:
            raise DesignatorError(
                "Could not ground ObjectRelativeLocation: (Relative) pose and reference object must be given")
        # Fetch the object pose and yield the grounded description
        obj_grounded = self.reference_object.resolve()

        lt = LocalTransformer()
        pose = lt.transform_to_object_frame(self.relative_pose, obj_grounded)

        yield self.Location(self.relative_pose, pose, self.reference_object)


class CostmapLocation(LocationDesignatorDescription):
    """
    Uses Costmaps to create locations for complex constrains
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        reachable_arms: List[Arms]
        """
        List of arms with which the pose can be reached, is only used when the 'rechable_for' parameter is used
        """

    def __init__(self, target: Union[Pose, ObjectDesignatorDescription.Object],
                 reachable_for: Optional[ObjectDesignatorDescription.Object] = None,
                 visible_for: Optional[ObjectDesignatorDescription.Object] = None,
                 reachable_arm: Optional[Arms] = None, resolver: Optional[Callable] = None):
        """
        Location designator that uses costmaps as base to calculate locations for complex constrains like reachable or
        visible. In case of reachable the resolved location contains a list of arms with which the location is reachable.

        :param target: Location for which visibility or reachability should be calculated
        :param reachable_for: Object for which the reachability should be calculated, usually a robot
        :param visible_for: Object for which the visibility should be calculated, usually a robot
        :param reachable_arm: An optional arm with which the target should be reached
        :param resolver: An alternative specialized_designators that returns a resolved location for the given input of this description
        """
        super().__init__(resolver)
        self.target: Union[Pose, ObjectDesignatorDescription.Object] = target
        self.reachable_for: ObjectDesignatorDescription.Object = reachable_for
        self.visible_for: ObjectDesignatorDescription.Object = visible_for
        self.reachable_arm: Optional[Arms] = reachable_arm

    def ground(self) -> Location:
        """
        Default specialized_designators which returns the first result from the iterator of this instance.

        :return: A resolved location
        """
        return next(iter(self))

    def __iter__(self):
        """
           Generates positions for a given set of constrains from a costmap and returns
           them. The generation is based of a costmap which itself is the product of
           merging costmaps, each for a different purpose. In any case an occupancy costmap
           is used as the base, then according to the given constrains a visibility or
           gaussian costmap is also merged with this. Once the costmaps are merged,
           a generator generates pose candidates from the costmap. Each pose candidate
           is then validated against the constraints given by the designator if all validators
           pass the pose is considered valid and yielded.

           :yield: An instance of CostmapLocation.Location with a valid position that satisfies the given constraints
           """
        min_height = RobotDescription.current_robot_description.get_default_camera().minimal_height
        max_height = RobotDescription.current_robot_description.get_default_camera().maximal_height
        # This ensures that the costmaps always get a position as their origin.
        if isinstance(self.target, ObjectDesignatorDescription.Object):
            target_pose = self.target.world_object.get_pose()
        else:
            target_pose = self.target.copy()

        # ground_pose = [[target_pose[0][0], target_pose[0][1], 0], target_pose[1]]
        ground_pose = Pose(target_pose.position_as_list())
        ground_pose.position.z = 0

        occupancy = OccupancyCostmap(0.32, False, 200, 0.02, ground_pose)
        final_map = occupancy

        if self.reachable_for:
            gaussian = GaussianCostmap(200, 15, 0.02, ground_pose)
            final_map += gaussian
        if self.visible_for:
            visible = VisibilityCostmap(min_height, max_height, 200, 0.02, Pose(target_pose.position_as_list()))
            final_map += visible

        if self.visible_for or self.reachable_for:
            robot_object = self.visible_for.world_object if self.visible_for else self.reachable_for.world_object
            test_robot = World.current_world.get_prospection_object_for_object(robot_object)
        with UseProspectionWorld():
            for maybe_pose in PoseGenerator(final_map, number_of_samples=600):
                res = True
                arms = None
                if self.visible_for:
                    res = res and visibility_validator(maybe_pose, test_robot, target_pose,
                                                       World.current_world)
                if self.reachable_for:
                    hand_links = []
                    for description in RobotDescription.current_robot_description.get_manipulator_chains():
                        hand_links += description.end_effector.links
                    valid, arms = reachability_validator(maybe_pose, test_robot, target_pose,
                                                         allowed_collision={test_robot: hand_links})
                    if self.reachable_arm:
                        res = res and valid and self.reachable_arm in arms
                    else:
                        res = res and valid
                if res:
                    yield self.Location(maybe_pose, arms)


class AccessingLocation(LocationDesignatorDescription):
    """
    Location designator which describes poses used for opening drawers
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        arms: List[Arms]
        """
        List of arms that can be used to for accessing from this pose
        """

    def __init__(self, handle_desig: ObjectPart.Object, robot_desig: ObjectDesignatorDescription.Object, resolver=None):
        """
        Describes a position from where a drawer can be opened. For now this position should be calculated before the
        drawer will be opened. Calculating the pose while the drawer is open could lead to problems.

        :param handle_desig: ObjectPart designator for handle of the drawer
        :param robot: Object designator for the robot which should open the drawer
        :param resolver: An alternative specialized_designators to create the location
        """
        super().__init__(resolver)
        self.handle: ObjectPart.Object = handle_desig
        self.robot: ObjectDesignatorDescription.Object = robot_desig.world_object

    def ground(self) -> Location:
        """
        Default specialized_designators for this location designator, just returns the first element from the iteration

        :return: A location designator for a pose from which the drawer can be opened
        """
        return next(iter(self))

    def __iter__(self) -> Location:
        """
        Creates poses from which the robot can open the drawer specified by the ObjectPart designator describing the
        handle. Poses are validated by checking if the robot can grasp the handle while the drawer is closed and if
        the handle can be grasped if the drawer is open.

        :yield: A location designator containing the pose and the arms that can be used.
        """
        # ground_pose = [[self.handle.part_pose[0][0], self.handle.part_pose[0][1], 0], self.handle.part_pose[1]]
        ground_pose = Pose(self.handle.part_pose.position_as_list())
        ground_pose.position.z = 0
        occupancy = OccupancyCostmap(distance_to_obstacle=0.4, from_ros=False, size=200, resolution=0.02,
                                     origin=ground_pose)
        gaussian = GaussianCostmap(200, 15, 0.02, ground_pose)

        final_map = occupancy + gaussian


        test_robot = World.current_world.get_prospection_object_for_object(self.robot)

        # Find a Joint of type prismatic which is above the handle in the URDF tree
        container_joint = self.handle.world_object.find_joint_above_link(self.handle.name, JointType.PRISMATIC)

        init_pose = link_pose_for_joint_config(self.handle.world_object, {
            container_joint: self.handle.world_object.get_joint_limits(container_joint)[0]},
                                               self.handle.name)

        # Calculate the pose the handle would be in if the drawer was to be fully opened
        goal_pose = link_pose_for_joint_config(self.handle.world_object, {
            container_joint: self.handle.world_object.get_joint_limits(container_joint)[1] - 0.05},
                                               self.handle.name)

        # Handle position for calculating rotation of the final pose
        half_pose = link_pose_for_joint_config(self.handle.world_object, {
            container_joint: self.handle.world_object.get_joint_limits(container_joint)[1] / 1.5},
                                               self.handle.name)

        with UseProspectionWorld():
            for maybe_pose in PoseGenerator(final_map, number_of_samples=600,
                                             orientation_generator=lambda p, o: PoseGenerator.generate_orientation(p, half_pose)):

                hand_links = []
                for description in RobotDescription.current_robot_description.get_manipulator_chains():
                    hand_links += description.links

                valid_init, arms_init = reachability_validator(maybe_pose, test_robot, init_pose,
                                                               allowed_collision={test_robot: hand_links})

                valid_goal, arms_goal = reachability_validator(maybe_pose, test_robot, goal_pose,
                                                               allowed_collision={test_robot: hand_links})

                if valid_init and valid_goal:
                    yield self.Location(maybe_pose, list(set(arms_init).intersection(set(arms_goal))))


class SemanticCostmapLocation(LocationDesignatorDescription):
    """
    Locations over semantic entities, like a table surface
    """

    @dataclasses.dataclass
    class Location(LocationDesignatorDescription.Location):
        pass

    def __init__(self, urdf_link_name, part_of, for_object=None, resolver=None):
        """
        Creates a distribution over a urdf link to sample poses which are on this link. Can be used, for example, to find
        poses that are on a table. Optionally an object can be given for which poses should be calculated, in that case
        the poses are calculated such that the bottom of the object is on the link.

        :param urdf_link_name: Name of the urdf link for which a distribution should be calculated
        :param part_of: Object of which the urdf link is a part
        :param for_object: Optional object that should be placed at the found location
        :param resolver: An alternative specialized_designators that creates a resolved location for the input parameter of this description
        """
        super().__init__(resolver)
        self.urdf_link_name: str = urdf_link_name
        self.part_of: ObjectDesignatorDescription.Object = part_of
        self.for_object: Optional[ObjectDesignatorDescription.Object] = for_object

    def ground(self) -> Location:
        """
        Default specialized_designators which returns the first element of the iterator of this instance.

        :return: A resolved location
        """
        return next(iter(self))

    def __iter__(self):
        """
        Creates a costmap on top of a link of an Object and creates positions from it. If there is a specific Object for
        which the position should be found, a height offset will be calculated which ensures that the bottom of the Object
        is at the position in the Costmap and not the origin of the Object which is usually in the centre of the Object.

        :yield: An instance of SemanticCostmapLocation.Location with the found valid position of the Costmap.
        """
        sem_costmap = SemanticCostmap(self.part_of.world_object, self.urdf_link_name)
        height_offset = 0
        if self.for_object:
            min_p, max_p = self.for_object.world_object.get_axis_aligned_bounding_box().get_min_max_points()
            height_offset = (max_p.z - min_p.z) / 2
        for maybe_pose in PoseGenerator(sem_costmap):
            maybe_pose.position.z += height_offset
            yield self.Location(maybe_pose)


##New # Content from: #<src/pycram/designators/motion_designator.py>#
from abc import ABC, abstractmethod
from dataclasses import dataclass

from sqlalchemy.orm import Session
from .object_designator import ObjectDesignatorDescription, ObjectPart, RealObject
from ..designator import ResolutionError
from ..orm.base import ProcessMetaData
from ..plan_failures import PerceptionObjectNotFound
from ..process_module import ProcessModuleManager
from ..orm.motion_designator import (MoveMotion as ORMMoveMotion,
                                     MoveTCPMotion as ORMMoveTCPMotion, LookingMotion as ORMLookingMotion,
                                     MoveGripperMotion as ORMMoveGripperMotion, DetectingMotion as ORMDetectingMotion,
                                     OpeningMotion as ORMOpeningMotion, ClosingMotion as ORMClosingMotion,
                                     Motion as ORMMotionDesignator)
from ..datastructures.enums import ObjectType, Arms, GripperState, ExecutionType

from typing_extensions import Dict, Optional, get_type_hints
from ..datastructures.pose import Pose
from ..tasktree import with_tree
from ..designator import BaseMotion


@dataclass
class MoveMotion(BaseMotion):
    """
    Moves the robot to a designated location
    """

    target: Pose
    """
    Location to which the robot should be moved
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.navigate().execute(self)
        # return ProcessModule.perform(self)

    def to_sql(self) -> ORMMoveMotion:
        return ORMMoveMotion()

    def insert(self, session, *args, **kwargs) -> ORMMoveMotion:
        motion = super().insert(session)
        pose = self.target.insert(session)
        motion.pose = pose
        session.add(motion)

        return motion


@dataclass
class MoveTCPMotion(BaseMotion):
    """
    Moves the Tool center point (TCP) of the robot
    """

    target: Pose
    """
    Target pose to which the TCP should be moved
    """
    arm: Arms
    """
    Arm with the TCP that should be moved to the target
    """
    allow_gripper_collision: Optional[bool] = None
    """
    If the gripper can collide with something
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.move_tcp().execute(self)

    def to_sql(self) -> ORMMoveTCPMotion:
        return ORMMoveTCPMotion(self.arm, self.allow_gripper_collision)

    def insert(self, session: Session, *args, **kwargs) -> ORMMoveTCPMotion:
        motion = super().insert(session)
        pose = self.target.insert(session)
        motion.pose = pose
        session.add(motion)

        return motion


@dataclass
class LookingMotion(BaseMotion):
    """
    Lets the robot look at a point
    """
    target: Pose

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.looking().execute(self)

    def to_sql(self) -> ORMLookingMotion:
        return ORMLookingMotion()

    def insert(self, session: Session, *args, **kwargs) -> ORMLookingMotion:
        motion = super().insert(session)
        pose = self.target.insert(session)
        motion.pose = pose
        session.add(motion)

        return motion


@dataclass
class MoveGripperMotion(BaseMotion):
    """
    Opens or closes the gripper
    """

    motion: GripperState
    """
    Motion that should be performed, either 'open' or 'close'
    """
    gripper: Arms
    """
    Name of the gripper that should be moved
    """
    allow_gripper_collision: Optional[bool] = None
    """
    If the gripper is allowed to collide with something
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.move_gripper().execute(self)

    def to_sql(self) -> ORMMoveGripperMotion:
        return ORMMoveGripperMotion(self.motion, self.gripper, self.allow_gripper_collision)

    def insert(self, session: Session, *args, **kwargs) -> ORMMoveGripperMotion:
        motion = super().insert(session)
        session.add(motion)

        return motion


@dataclass
class DetectingMotion(BaseMotion):
    """
    Tries to detect an object in the FOV of the robot
    """

    object_type: ObjectType
    """
    Type of the object that should be detected
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        world_object = pm_manager.detecting().execute(self)
        if not world_object:
            raise PerceptionObjectNotFound(
                f"Could not find an object with the type {self.object_type} in the FOV of the robot")
        if ProcessModuleManager.execution_type == ExecutionType.REAL:
            return RealObject.Object(world_object.name, world_object.obj_type,
                                     world_object, world_object.get_pose())

        return ObjectDesignatorDescription.Object(world_object.name, world_object.obj_type,
                                                  world_object)

    def to_sql(self) -> ORMDetectingMotion:
        return ORMDetectingMotion(self.object_type)

    def insert(self, session: Session, *args, **kwargs) -> ORMDetectingMotion:
        motion = super().insert(session)
        session.add(motion)

        return motion


@dataclass
class MoveArmJointsMotion(BaseMotion):
    """
    Moves the joints of each arm into the given position
    """

    left_arm_poses: Optional[Dict[str, float]] = None
    """
    Target positions for the left arm joints
    """
    right_arm_poses: Optional[Dict[str, float]] = None
    """
    Target positions for the right arm joints
    """

    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.move_arm_joints().execute(self)

    def to_sql(self) -> ORMMotionDesignator:
        pass

    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        pass


@dataclass
class WorldStateDetectingMotion(BaseMotion):
    """
    Detects an object based on the world state.
    """

    object_type: ObjectType
    """
    Object type that should be detected
    """

    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.world_state_detecting().execute(self)

    def to_sql(self) -> ORMMotionDesignator:
        pass

    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        pass


@dataclass
class MoveJointsMotion(BaseMotion):
    """
    Moves any joint on the robot
    """

    names: list
    """
    List of joint names that should be moved 
    """
    positions: list
    """
    Target positions of joints, should correspond to the list of names
    """

    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.move_joints().execute(self)

    def to_sql(self) -> ORMMotionDesignator:
        pass

    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        pass


@dataclass
class OpeningMotion(BaseMotion):
    """
    Designator for opening container
    """

    object_part: ObjectPart.Object
    """
    Object designator for the drawer handle
    """
    arm: Arms
    """
    Arm that should be used
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.open().execute(self)

    def to_sql(self) -> ORMOpeningMotion:
        return ORMOpeningMotion(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMOpeningMotion:
        motion = super().insert(session)
        op = self.object_part.insert(session)
        motion.object = op
        session.add(motion)

        return motion


@dataclass
class ClosingMotion(BaseMotion):
    """
    Designator for closing a container
    """

    object_part: ObjectPart.Object
    """
    Object designator for the drawer handle
    """
    arm: Arms
    """
    Arm that should be used
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.close().execute(self)

    def to_sql(self) -> ORMClosingMotion:
        return ORMClosingMotion(self.arm)

    def insert(self, session: Session, *args, **kwargs) -> ORMClosingMotion:
        motion = super().insert(session)
        op = self.object_part.insert(session)
        motion.object = op
        session.add(motion)

        return motion


@dataclass
class TalkingMotion(BaseMotion):
    """
    Talking Motion, lets the robot say a sentence.
    """

    cmd: str
    """
    Talking Motion, let the robot say a sentence.
    """

    @with_tree
    def perform(self):
        pm_manager = ProcessModuleManager.get_manager()
        return pm_manager.talk().execute(self)

    def to_sql(self) -> ORMMotionDesignator:
        pass

    def insert(self, session: Session, *args, **kwargs) -> ORMMotionDesignator:
        pass


##New # Content from: #<src/pycram/designators/specialized_designators/action/dual_arm_pickup_action.py>#
import rospy
from typing_extensions import List, Union, Optional
from numpy.linalg import norm
from numpy import array
from geometry_msgs.msg import Vector3

from owlready2 import Thing

from ...action_designator import PickUpAction, PickUpActionPerformable
from ....local_transformer import LocalTransformer
from ....datastructures.world import World
from ....datastructures.pose import Pose, Transform
from ....datastructures.enums import Arms, Grasp
from ....robot_description import RobotDescription, KinematicChainDescription
from ....designator import ObjectDesignatorDescription


class DualArmPickupAction(PickUpAction):
    """
    Specialization version of the PickUpAction designator which uses heuristics to solve for a dual pickup solution.
    """

    def __init__(self,
                 object_designator_description: Union[ObjectDesignatorDescription, ObjectDesignatorDescription.Object],
                 grasps: List[Grasp], resolver=None,
                 ontology_concept_holders: Optional[List[Thing]] = None):
        """
        Specialized version of the PickUpAction designator which uses heuristics to solve for a dual pickup problem. The
        designator will choose the arm which is closest to the object that is to be picked up.

        :param object_designator_description: List of object designator which should be picked up
        :param grasps: List of possible grasps which should be used for the pickup
        :param resolver: Optional specialized_designators that returns a performable designator with elements from the
                         lists of possible parameter
        :param ontology_concept_holders: List of ontology concepts that the action is categorized as or associated with
        """
        super().__init__(object_designator_description,
                         arms=[Arms.LEFT, Arms.RIGHT],
                         grasps=grasps,
                         resolver=resolver,
                         ontology_concept_holders=ontology_concept_holders)

        self.object_designator_description: Union[
            ObjectDesignatorDescription, ObjectDesignatorDescription.Object] = object_designator_description

        left_gripper = RobotDescription.current_robot_description.get_arm_chain(Arms.LEFT)
        right_gripper = RobotDescription.current_robot_description.get_arm_chain(Arms.RIGHT)
        self.gripper_list: List[KinematicChainDescription] = [left_gripper, right_gripper]


    def ground(self) -> PickUpActionPerformable:
        if isinstance(self.object_designator_description, ObjectDesignatorDescription.Object):
            obj_desig = self.object_designator_description
        else:
            obj_desig = self.object_designator_description.resolve()

        rospy.loginfo("Calculating closest gripper to object {}".format(obj_desig.name))

        local_transformer = LocalTransformer()

        object_pose: Pose = obj_desig.world_object.pose
        distances = []
        # Iterate over possible grippers
        for gripper in self.gripper_list:
            # Object pose in gripper frame
            gripper_frame = World.robot.get_link_tf_frame(gripper.get_tool_frame())

            object_T_gripper: Pose = local_transformer.transform_pose(object_pose, gripper_frame)
            object_V_gripper: Vector3 = object_T_gripper.pose.position  # translation vector
            distance = norm(array([object_V_gripper.x, object_V_gripper.y, object_V_gripper.z]))
            rospy.loginfo(f"Distance between {gripper} and {obj_desig.name}: {distance}")
            distances.append(distance)

        min_index = distances.index(min(distances))
        winner = self.gripper_list[min_index]
        rospy.loginfo(f"Winner is {winner.arm_type.name} with distance {min(distances):.2f}")

        return PickUpActionPerformable(object_designator=obj_desig, arm=winner.arm_type, grasp=self.grasps[0])


##New # Content from: #<src/pycram/designators/specialized_designators/location/giskard_location.py>#
import tf

from ....datastructures.pose import Pose
from ....designators.location_designator import CostmapLocation
from ....external_interfaces.giskard import projection_cartesian_goal_with_approach, projection_joint_goal
from ....robot_description import RobotDescription
from ....datastructures.world import UseProspectionWorld, World
from ....local_transformer import LocalTransformer
from ....costmaps import OccupancyCostmap, GaussianCostmap
from ....pose_generator_and_validator import PoseGenerator


class GiskardLocation(CostmapLocation):
    """'
    Specialization version of the CostmapLocation which uses Giskard to solve for a full-body IK solution. This
    designator is especially useful for robots which lack a degree of freedom and therefore need to use the base to
    manipulate the environment effectively.
    """

    def __iter__(self) -> CostmapLocation.Location:
        """
        Uses Giskard to perform full body ik solving to get the pose of a robot at which it is able to reach a certain point.

        :yield: An instance of CostmapLocation.Location with a pose from which the robot can reach the target
        """
        if self.visible_for:
            raise ValueError("GiskardLocation does not support the visible_for parameter")
        local_transformer = LocalTransformer()
        target_map = local_transformer.transform_pose(self.target, "map")

        manipulator_descs = RobotDescription.current_robot_description.get_manipulator_chains()

        near_costmap = (OccupancyCostmap(0.35, False, 200, 0.02, target_map)
                        + GaussianCostmap(200, 15, 0.02, target_map))
        for maybe_pose in PoseGenerator(near_costmap, 200):
            for chain in manipulator_descs:
                projection_joint_goal(chain.get_static_joint_states("park"), allow_collisions=True)

                trajectory = projection_cartesian_goal_with_approach(maybe_pose, target_map, chain.tool_frame,
                                                                     "map", RobotDescription.current_robot_description.base_link)
                last_point_positions = trajectory.trajectory.points[-1].positions
                last_point_names = trajectory.trajectory.joint_names
                last_joint_states = dict(zip(last_point_names, last_point_positions))
                orientation = list(
                    tf.transformations.quaternion_from_euler(0, 0, last_joint_states["brumbrum_yaw"], axes="sxyz"))
                pose = Pose([last_joint_states["brumbrum_x"], last_joint_states["brumbrum_y"], 0], orientation)

                robot_joint_states = {}
                for joint_name, state in last_joint_states.items():
                    if joint_name in World.robot.joints.keys():
                        robot_joint_states[joint_name] = state

                prospection_robot = World.current_world.get_prospection_object_for_object(World.robot)

                with UseProspectionWorld():
                    prospection_robot.set_joint_positions(robot_joint_states)
                    prospection_robot.set_pose(pose)
                    gripper_pose = prospection_robot.get_link_pose(chain.get_tool_frame())

                    if gripper_pose.dist(target_map) <= 0.02:
                        yield CostmapLocation.Location(pose, [chain.arm_type])




##New # Content from: #<src/pycram/designators/specialized_designators/location/database_location.py>#
from dataclasses import dataclass

import sqlalchemy.orm
import sqlalchemy.sql
from sqlalchemy import select, Select
from typing_extensions import List, Type
from ....costmaps import Rectangle, OccupancyCostmap
from ....designator import LocationDesignatorDescription
from ....designators.location_designator import CostmapLocation
from ....orm.views import PickUpWithContextView
from ....datastructures.pose import Pose


@dataclass
class Location(LocationDesignatorDescription.Location):
    """
    A location that is described by a pose, a reachable arm, a torso height and a grasp.
    """
    pose: Pose
    reachable_arm: str
    torso_height: float
    grasp: str


class AbstractCostmapLocation(CostmapLocation):
    """
    Abstract Class for JPT and Database costmaps.
    """

    def __init__(self, target, reachable_for=None, reachable_arm=None):
        """
        Create a new AbstractCostmapLocation instance.
        :param target: The target object
        :param reachable_for:
        :param reachable_arm:
        """
        super().__init__(target, reachable_for, None, reachable_arm, None)

    def create_occupancy_rectangles(self) -> List[Rectangle]:
        """
        :return: A list of rectangles that represent the occupied space of the target object.
        """
        # create Occupancy costmap for the target object
        ocm = OccupancyCostmap(distance_to_obstacle=0.3, from_ros=False, size=200, resolution=0.02,
                               origin=self.target.pose)
        return ocm.partitioning_rectangles()


class DatabaseCostmapLocation(AbstractCostmapLocation):
    """
    Class that represents costmap locations from a given Database.
    The database has to have a schema that is compatible with the pycram.orm package.
    """

    def __init__(self, target, session: sqlalchemy.orm.Session = None, reachable_for=None, reachable_arm=None):
        """
        Create a Database Costmap

        :param target: The target object
        :param session: A session that can be used to execute queries
        :param reachable_for: The robot to grab the object with
        :param reachable_arm: The arm to use

        """
        super().__init__(target, reachable_for, reachable_arm)
        self.session = session

    @staticmethod
    def select_statement(view: Type[PickUpWithContextView]) -> Select:
        return (select(view.arm, view.grasp, view.torso_height, view.relative_x, view.relative_y, view.quaternion_x,
                       view.quaternion_y, view.quaternion_z, view.quaternion_w).distinct())

    def create_query_from_occupancy_costmap(self) -> Select:
        """
        Create a query that queries all relative robot positions from an object that are not occluded using an
        OccupancyCostmap.
        """

        view = PickUpWithContextView

        # get query
        query = self.select_statement(view)

        # constraint query to correct object type and successful task status
        query = query.where(view.obj_type == self.target.obj_type).where(view.status == "SUCCEEDED")

        filters = []

        # for every rectangle
        for rectangle in self.create_occupancy_rectangles():
            # add sql filter
            filters.append(sqlalchemy.and_(view.relative_x >= rectangle.x_lower,
                                           view.relative_x < rectangle.x_upper,
                                           view.relative_y >= rectangle.y_lower,
                                           view.relative_y < rectangle.y_upper))

        return query.where(sqlalchemy.or_(*filters))

    def sample_to_location(self, sample: sqlalchemy.engine.row.Row) -> Location:
        """
        Convert a database row to a costmap location.

        :param sample: The database row.
        :return: The costmap location
        """

        target_x, target_y, target_z = self.target.pose.position_as_list()
        position = [target_x + sample[3], target_y + sample[4], 0]
        orientation = [sample[5], sample[6], sample[7], sample[8]]

        result = Location(Pose(position, orientation), sample.arm, sample.torso_height, sample.grasp)
        return result

    def __iter__(self) -> Location:
        statement = self.create_query_from_occupancy_costmap().limit(200)
        samples = self.session.execute(statement).all()
        if samples:
            for sample in samples:
                yield self.sample_to_location(sample)
        else:
            raise ValueError("No samples found")


##New # Content from: #<src/pycram/designators/specialized_designators/probabilistic/probabilistic_action.py>#
import numpy as np
import tqdm
from probabilistic_model.probabilistic_circuit.distributions import GaussianDistribution, SymbolicDistribution
from probabilistic_model.probabilistic_circuit.probabilistic_circuit import ProbabilisticCircuit, \
    DecomposableProductUnit
from probabilistic_model.utils import MissingDict
from random_events.interval import *
from random_events.product_algebra import Event, SimpleEvent
from random_events.set import SetElement
from random_events.variable import Symbolic, Continuous
from sqlalchemy import select
from typing_extensions import Optional, List, Iterator

from ...action_designator import MoveAndPickUpPerformable, ActionAbstract
from ....costmaps import OccupancyCostmap, VisibilityCostmap
from ....datastructures.enums import Arms as EArms, Grasp as EGrasp, TaskStatus
from ....datastructures.pose import Pose
from ....datastructures.world import World
from ....designator import ActionDesignatorDescription, ObjectDesignatorDescription
from ....local_transformer import LocalTransformer
from ....orm.views import PickUpWithContextView
from ....plan_failures import ObjectUnreachable, PlanFailure


class Grasp(SetElement):
    EMPTY_SET = -1
    FRONT = 0
    LEFT = 1
    RIGHT = 2
    TOP = 3


class Arms(SetElement):
    EMPTY_SET = -1
    LEFT = 0
    RIGHT = 1


class ProbabilisticAction:
    """
    Abstract class for probabilistic performables.
    """

    @dataclass
    class Variables:
        """
        Variables for probabilistic performables.

        This inner class serves the purpose to define the variables that are used in a model and make them easily
        accessible for the user. The user can access the variables by using the dot notation, e.g. `self.variables.x`.

        The members of this class have to be ordered the same way as the variables in the policy.
        The order of the variables in the policy is most likely alphabetical by name.
        """
        ...

    policy: ProbabilisticCircuit
    """
    The policy that is used to determine the parameters.
    """

    variables: Variables
    """
    The variables of this action.
    """

    def __init__(self, policy: Optional[ProbabilisticCircuit] = None):
        if policy is None:
            policy = self.default_policy()
        self.policy = policy
        self.variables = self.Variables(*self.policy.variables)

    def default_policy(self) -> ProbabilisticCircuit:
        """
        Create a default policy for the action.

        :return: The default policy for the action
        """
        raise NotImplementedError

    def sample_to_action(self, sample: List) -> ActionAbstract:
        """
        Convert a sample from the policy to a performable action.
        :param sample: The sample
        :return: The action
        """
        raise NotImplementedError


class GaussianCostmapModel:
    """
    Class that generates a Gaussian Costmap around the center of an object. The costmap cuts out a square in the middle
    that has side lengths given by ``distance_to_center``.
    """

    distance_to_center: float
    """
    The side length of the cut out square.
    """

    variance: float
    """
    The variance of the distributions involved
    """

    relative_x = Continuous("relative_x")
    relative_y = Continuous("relative_y")
    grasp = Symbolic("grasp", Grasp)
    arm = Symbolic("arm", Arms)

    def __init__(self, distance_to_center: float = 0.2, variance: float = 0.5):
        self.distance_to_center = distance_to_center
        self.variance = variance

    def center_event(self) -> Event:
        """
        Create an event that describes the center of the map.
        """
        return SimpleEvent({self.relative_x: open(-self.distance_to_center, self.distance_to_center),
                            self.relative_y: open(-self.distance_to_center,
                                                  self.distance_to_center)}).as_composite_set()

    def create_model_with_center(self) -> ProbabilisticCircuit:
        """
        Create a fully factorized gaussian at the center of the map.
        """
        centered_model = DecomposableProductUnit()
        centered_model.add_subcircuit(GaussianDistribution(self.relative_x, 0., np.sqrt(self.variance)))
        centered_model.add_subcircuit(GaussianDistribution(self.relative_y, 0., np.sqrt(self.variance)))

        grasp_probabilities = MissingDict(float, {int(element): 1 / len(self.grasp.domain.simple_sets) for element in
                                                  self.grasp.domain.simple_sets})

        centered_model.add_subcircuit(SymbolicDistribution(self.grasp, grasp_probabilities))

        arm_probabilities = MissingDict(float, {int(element): 1 / len(self.arm.domain.simple_sets) for element in
                                                self.arm.domain.simple_sets})
        centered_model.add_subcircuit(SymbolicDistribution(self.arm, arm_probabilities))
        return centered_model.probabilistic_circuit

    def create_model(self) -> ProbabilisticCircuit:
        """
        Create a gaussian model that assumes mass everywhere besides the center square.

        :return: The probabilistic circuit
        """
        centered_model = self.create_model_with_center()
        outer_event = self.center_event().complement()
        limiting_event = SimpleEvent({self.relative_x: open(-2, 2),
                                      self.relative_y: open(-2, 2)}).as_composite_set()
        event = outer_event & limiting_event
        # go.Figure(event.plot()).show()
        result, _ = centered_model.conditional(event)
        return result


class MoveAndPickUp(ActionDesignatorDescription, ProbabilisticAction):
    @dataclass
    class Variables:
        arm: Symbolic = Symbolic("arm", Arms)
        grasp: Symbolic = Symbolic("grasp", Grasp)
        relative_x: Continuous = Continuous("relative_x")
        relative_y: Continuous = Continuous("relative_y")

    variables: Variables  # Type hint variables

    sample_amount: int = 20
    """
    The amount of samples that should be drawn from the policy when iterating over it.
    """

    object_designator: ObjectDesignatorDescription.Object
    """
    The object designator that should be picked up.
    """

    arms: List[Arms]
    """
    The arms that can be used for the pick up.
    """

    grasps: List[Grasp]
    """
    The grasps that can be used for the pick up.
    """

    def __init__(self, object_designator: ObjectDesignatorDescription.Object, arms: List[Arms], grasps: List[Grasp],
                 policy: Optional[ProbabilisticCircuit] = None):
        ActionDesignatorDescription.__init__(self)
        ProbabilisticAction.__init__(self, policy)
        self.object_designator = object_designator
        self.arms = arms
        self.grasps = grasps

    def default_policy(self) -> ProbabilisticCircuit:
        return GaussianCostmapModel().create_model()

    def sample_to_action(self, sample: List) -> MoveAndPickUpPerformable:
        """
        Convert a sample from the underlying distribution to a performable action.
        :param sample: The sample
        :return:  action
        """
        arm, grasp, relative_x, relative_y = sample
        position = [relative_x, relative_y, 0.]
        pose = Pose(position, frame=self.object_designator.world_object.tf_frame)
        standing_position = LocalTransformer().transform_pose(pose, "map")
        standing_position.position.z = 0
        action = MoveAndPickUpPerformable(standing_position, self.object_designator, EArms(int(arm)), EGrasp(int(grasp)))
        return action

    def events_from_occupancy_and_visibility_costmap(self) -> Event:
        """
        Create events from the occupancy and visibility costmap.

        :return: The events that can be used as evidence for the model.
        """

        # create occupancy and visibility costmap for the target object
        ocm = OccupancyCostmap(distance_to_obstacle=0.3, from_ros=False, size=200, resolution=0.1,
                               origin=self.object_designator.pose)
        vcm = VisibilityCostmap(min_height=1.27, max_height=1.69,
                                size=200, resolution=0.1, origin=self.object_designator.pose)
        mcm = ocm + vcm

        # convert rectangles to events
        events = []
        for rectangle in mcm.partitioning_rectangles():
            event = SimpleEvent({self.variables.relative_x: open(rectangle.x_lower, rectangle.x_upper),
                                 self.variables.relative_y: open(rectangle.y_lower, rectangle.y_upper)})
            events.append(event)
        return Event(*events)

    def ground_model(self, model: Optional[ProbabilisticCircuit] = None,
                     event: Optional[Event] = None) -> ProbabilisticCircuit:
        """
        Ground the model to the current evidence.

        :param model: The model that should be grounded. If None, the policy is used.
        :param event: The events that should be used as evidence. If None, the occupancy costmap is used.
        :return: The grounded model
        """

        if model is None:
            model = self.policy
        if event is None:
            event = self.events_from_occupancy_and_visibility_costmap()

        result, probability = model.conditional(event)

        if probability == 0:
            raise ObjectUnreachable("No possible locations found")

        return result

    def iter_with_mode(self) -> Iterator[MoveAndPickUpPerformable]:
        """
        Generate performables by sampling from the mode of the policy conditioned on visibility and occupancy.
        """
        model = self.ground_model()
        modes, _ = model.mode()
        model = self.ground_model(model, modes)
        samples = model.sample(self.sample_amount)

        for sample in samples:
            action = self.sample_to_action(sample)
            yield action

    def __iter__(self) -> Iterator[MoveAndPickUpPerformable]:
        """
        Generate performables by sampling from the policy conditioned on visibility and occupancy.
        """
        model = self.ground_model(self.policy, self.events_from_occupancy_and_visibility_costmap())
        samples = model.sample(self.sample_amount)
        likelihoods = model.likelihood(samples)

        # sort samples by likelihood
        samples = [x for _, x in sorted(zip(likelihoods, samples), key=lambda pair: pair[0], reverse=True)]

        for sample in samples:
            action = self.sample_to_action(sample)
            yield action

    def iterate_without_occupancy_costmap(self) -> Iterator[MoveAndPickUpPerformable]:
        """
        Generate performables by sampling from the policy without conditioning on visibility and occupancy.
        """
        samples = self.policy.sample(self.sample_amount)
        for sample in samples:
            action = self.sample_to_action(sample)
            yield action

    @staticmethod
    def query_for_database():
        view = PickUpWithContextView
        query = (select(view.arm, view.grasp, view.relative_x, view.relative_y)
                 .where(view.status == TaskStatus.SUCCEEDED))
        return query

    def batch_rollout(self):
        """
        Try the policy without conditioning on visibility and occupancy and count the successful tries.

        :amount: The amount of tries
        """

        # initialize statistics
        successful_tries = 0
        total_tries = 0

        # create the progress bar
        progress_bar = tqdm.tqdm(iter(self.iterate_without_occupancy_costmap()), total=self.sample_amount)

        for action in progress_bar:
            total_tries += 1
            try:
                action.perform()
                successful_tries += 1
            except PlanFailure as p:
                pass

            # update progress bar
            progress_bar.set_postfix({"Success Probability": successful_tries / total_tries})

            # reset world
            World.current_world.reset_world()


##New # Content from: #<src/pycram/worlds/bullet_world.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import threading
import time

import numpy as np
import pybullet as p
import rosgraph
import rospy
from geometry_msgs.msg import Point
from typing_extensions import List, Optional, Dict

from ..datastructures.dataclasses import Color, AxisAlignedBoundingBox, MultiBody, VisualShape, BoxVisualShape
from ..datastructures.enums import ObjectType, WorldMode, JointType
from ..datastructures.pose import Pose
from ..datastructures.world import World
from ..object_descriptors.generic import ObjectDescription as GenericObjectDescription
from ..object_descriptors.urdf import ObjectDescription
from ..world_concepts.constraints import Constraint
from ..world_concepts.world_object import Object

Link = ObjectDescription.Link
RootLink = ObjectDescription.RootLink
Joint = ObjectDescription.Joint


class BulletWorld(World):
    """
    This class represents a BulletWorld, which is a simulation environment that uses the Bullet Physics Engine. This
    class is the main interface to the Bullet Physics Engine and should be used to spawn Objects, simulate Physic and
    manipulate the Bullet World.
    """

    extension: str = ObjectDescription.get_file_extension()

    # Check is for sphinx autoAPI to be able to work in a CI workflow
    if rosgraph.is_master_online():  # and "/pycram" not in rosnode.get_node_names():
        rospy.init_node('pycram')

    def __init__(self, mode: WorldMode = WorldMode.DIRECT, is_prospection_world: bool = False, sim_frequency=240):
        """
        Creates a new simulation, the type decides of the simulation should be a rendered window or just run in the
        background. There can only be one rendered simulation.
        The BulletWorld object also initializes the Events for attachment, detachment and for manipulating the world.

        :param mode: Can either be "GUI" for rendered window or "DIRECT" for non-rendered. The default is "GUI"
        :param is_prospection_world: For internal usage, decides if this BulletWorld should be used as a shadow world.
        """
        super().__init__(mode=mode, is_prospection_world=is_prospection_world, simulation_frequency=sim_frequency)

        # This disables file caching from PyBullet, since this would also cache
        # files that can not be loaded
        p.setPhysicsEngineParameter(enableFileCaching=0)

        # Needed to let the other thread start the simulation, before Objects are spawned.
        time.sleep(0.1)
        self.vis_axis: List[int] = []

        # Some default settings
        self.set_gravity([0, 0, -9.8])

        if not is_prospection_world:
            _ = Object("floor", ObjectType.ENVIRONMENT, "plane" + self.extension,
                       world=self)

    def _init_world(self, mode: WorldMode):
        self._gui_thread: Gui = Gui(self, mode)
        self._gui_thread.start()
        time.sleep(0.1)

    def load_generic_object_and_get_id(self, description: GenericObjectDescription) -> int:
        """
        Creates a visual and collision box in the simulation.
        """
        # Create visual shape
        vis_shape = p.createVisualShape(p.GEOM_BOX, halfExtents=description.shape_data,
                                        rgbaColor=description.color.get_rgba())

        # Create collision shape
        col_shape = p.createCollisionShape(p.GEOM_BOX, halfExtents=description.shape_data)

        # Create MultiBody with both visual and collision shapes
        obj_id = p.createMultiBody(baseMass=1.0, baseCollisionShapeIndex=col_shape, baseVisualShapeIndex=vis_shape,
                                   basePosition=description.origin.position_as_list(),
                                   baseOrientation=description.origin.orientation_as_list())

        # Assuming you have a list to keep track of created objects
        return obj_id

    def load_object_and_get_id(self, path: Optional[str] = None, pose: Optional[Pose] = None) -> int:
        if pose is None:
            pose = Pose()
        return self._load_object_and_get_id(path, pose)

    def _load_object_and_get_id(self, path: str, pose: Pose) -> int:
        if path is None:
            raise ValueError("Path to the object file is required.")
        return p.loadURDF(path,
                          basePosition=pose.position_as_list(),
                          baseOrientation=pose.orientation_as_list(), physicsClientId=self.id)

    def remove_object_from_simulator(self, obj: Object) -> None:
        p.removeBody(obj.id, self.id)

    def remove_object_by_id(self, obj_id: int) -> None:
        p.removeBody(obj_id, self.id)

    def add_constraint(self, constraint: Constraint) -> int:

        constraint_id = p.createConstraint(constraint.parent_object_id,
                                           constraint.parent_link_id,
                                           constraint.child_object_id,
                                           constraint.child_link_id,
                                           constraint.type.value,
                                           constraint.axis_as_list,
                                           constraint.position_wrt_parent_as_list,
                                           constraint.position_wrt_child_as_list,
                                           constraint.orientation_wrt_parent_as_list,
                                           constraint.orientation_wrt_child_as_list,
                                           physicsClientId=self.id)
        return constraint_id

    def remove_constraint(self, constraint_id):
        p.removeConstraint(constraint_id, physicsClientId=self.id)

    def get_joint_position(self, joint: ObjectDescription.Joint) -> float:
        return p.getJointState(joint.object_id, joint.id, physicsClientId=self.id)[0]

    def get_object_joint_names(self, obj: Object) -> List[str]:
        return [p.getJointInfo(obj.id, i, physicsClientId=self.id)[1].decode('utf-8')
                for i in range(self.get_object_number_of_joints(obj))]

    def get_link_pose(self, link: ObjectDescription.Link) -> Pose:
        bullet_link_state = p.getLinkState(link.object_id, link.id, physicsClientId=self.id)
        return Pose(*bullet_link_state[4:6])

    def get_object_link_names(self, obj: Object) -> List[str]:
        num_links = self.get_object_number_of_links(obj)
        return [p.getJointInfo(obj.id, i, physicsClientId=self.id)[12].decode('utf-8')
                for i in range(num_links)]

    def get_object_number_of_links(self, obj: Object) -> int:
        return p.getNumJoints(obj.id, physicsClientId=self.id)

    get_object_number_of_joints = get_object_number_of_links

    def perform_collision_detection(self) -> None:
        p.performCollisionDetection(physicsClientId=self.id)

    def get_object_contact_points(self, obj: Object) -> List:
        """
        For a more detailed explanation of the
         returned list please look at:
         `PyBullet Doc <https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit#>`_
        """
        self.perform_collision_detection()
        return p.getContactPoints(obj.id, physicsClientId=self.id)

    def get_contact_points_between_two_objects(self, obj1: Object, obj2: Object) -> List:
        self.perform_collision_detection()
        return p.getContactPoints(obj1.id, obj2.id, physicsClientId=self.id)

    def reset_joint_position(self, joint: ObjectDescription.Joint, joint_position: str) -> None:
        p.resetJointState(joint.object_id, joint.id, joint_position, physicsClientId=self.id)

    def reset_object_base_pose(self, obj: Object, pose: Pose) -> None:
        p.resetBasePositionAndOrientation(obj.id, pose.position_as_list(), pose.orientation_as_list(),
                                          physicsClientId=self.id)

    def step(self):
        p.stepSimulation(physicsClientId=self.id)

    def get_object_pose(self, obj: Object) -> Pose:
        return Pose(*p.getBasePositionAndOrientation(obj.id, physicsClientId=self.id))

    def set_link_color(self, link: ObjectDescription.Link, rgba_color: Color):
        p.changeVisualShape(link.object_id, link.id, rgbaColor=rgba_color.get_rgba(), physicsClientId=self.id)

    def get_link_color(self, link: ObjectDescription.Link) -> Color:
        return self.get_colors_of_object_links(link.object)[link.name]

    def get_colors_of_object_links(self, obj: Object) -> Dict[str, Color]:
        visual_data = p.getVisualShapeData(obj.id, physicsClientId=self.id)
        link_id_to_name = {v: k for k, v in obj.link_name_to_id.items()}
        links = list(map(lambda x: link_id_to_name[x[1]], visual_data))
        colors = list(map(lambda x: Color.from_rgba(x[7]), visual_data))
        link_to_color = dict(zip(links, colors))
        return link_to_color

    def get_object_axis_aligned_bounding_box(self, obj: Object) -> AxisAlignedBoundingBox:
        return AxisAlignedBoundingBox.from_min_max(*p.getAABB(obj.id, physicsClientId=self.id))

    def get_link_axis_aligned_bounding_box(self, link: ObjectDescription.Link) -> AxisAlignedBoundingBox:
        return AxisAlignedBoundingBox.from_min_max(*p.getAABB(link.object_id, link.id, physicsClientId=self.id))

    def set_realtime(self, real_time: bool) -> None:
        p.setRealTimeSimulation(1 if real_time else 0, physicsClientId=self.id)

    def set_gravity(self, gravity_vector: List[float]) -> None:
        p.setGravity(gravity_vector[0], gravity_vector[1], gravity_vector[2], physicsClientId=self.id)

    def disconnect_from_physics_server(self):
        p.disconnect(physicsClientId=self.id)

    def join_threads(self):
        """
        Joins the GUI thread if it exists.
        """
        self.join_gui_thread_if_exists()

    def join_gui_thread_if_exists(self):
        if self._gui_thread:
            self._gui_thread.join()

    def save_physics_simulator_state(self) -> int:
        return p.saveState(physicsClientId=self.id)

    def restore_physics_simulator_state(self, state_id):
        p.restoreState(state_id, physicsClientId=self.id)

    def remove_physics_simulator_state(self, state_id: int):
        p.removeState(state_id, physicsClientId=self.id)

    def add_vis_axis(self, pose: Pose,
                     length: Optional[float] = 0.2) -> None:
        """
        Creates a Visual object which represents the coordinate frame at the given
        position and orientation. There can be an unlimited amount of vis axis objects.

        :param pose: The pose at which the axis should be spawned
        :param length: Optional parameter to configure the length of the axes
        """

        pose_in_map = self.local_transformer.transform_pose(pose, "map")

        box_vis_shape = BoxVisualShape(Color(1, 0, 0, 0.8), [length, 0.01, 0.01], [length, 0.01, 0.01])
        vis_x = self.create_visual_shape(box_vis_shape)

        box_vis_shape = BoxVisualShape(Color(0, 1, 0, 0.8), [0.01, length, 0.01], [0.01, length, 0.01])
        vis_y = self.create_visual_shape(box_vis_shape)

        box_vis_shape = BoxVisualShape(Color(0, 0, 1, 0.8), [0.01, 0.01, length], [0.01, 0.01, length])
        vis_z = self.create_visual_shape(box_vis_shape)

        multibody = MultiBody(base_visual_shape_index=-1, base_pose=pose_in_map,
                              link_visual_shape_indices=[vis_x, vis_y, vis_z],
                              link_poses=[Pose(), Pose(), Pose()], link_masses=[1.0, 1.0, 1.0],
                              link_inertial_frame_poses=[Pose(), Pose(), Pose()], link_parent_indices=[0, 0, 0],
                              link_joint_types=[JointType.FIXED.value, JointType.FIXED.value, JointType.FIXED.value],
                              link_joint_axis=[Point(1, 0, 0), Point(0, 1, 0), Point(0, 0, 1)],
                              link_collision_shape_indices=[-1, -1, -1])

        self.vis_axis.append(self.create_multi_body(multibody))

    def remove_vis_axis(self) -> None:
        """
        Removes all spawned vis axis objects that are currently in this BulletWorld.
        """
        for vis_id in self.vis_axis:
            p.removeBody(vis_id, physicsClientId=self.id)
        self.vis_axis = []

    def ray_test(self, from_position: List[float], to_position: List[float]) -> int:
        res = p.rayTest(from_position, to_position, physicsClientId=self.id)
        return res[0][0]

    def ray_test_batch(self, from_positions: List[List[float]], to_positions: List[List[float]],
                       num_threads: int = 1) -> List[int]:
        return p.rayTestBatch(from_positions, to_positions, numThreads=num_threads,
                              physicsClientId=self.id)

    def create_visual_shape(self, visual_shape: VisualShape) -> int:
        return p.createVisualShape(visual_shape.visual_geometry_type.value,
                                   rgbaColor=visual_shape.rgba_color.get_rgba(),
                                   visualFramePosition=visual_shape.visual_frame_position,
                                   physicsClientId=self.id, **visual_shape.shape_data())

    def create_multi_body(self, multi_body: MultiBody) -> int:
        return p.createMultiBody(baseVisualShapeIndex=-multi_body.base_visual_shape_index,
                                 linkVisualShapeIndices=multi_body.link_visual_shape_indices,
                                 basePosition=multi_body.base_pose.position_as_list(),
                                 baseOrientation=multi_body.base_pose.orientation_as_list(),
                                 linkPositions=[pose.position_as_list() for pose in multi_body.link_poses],
                                 linkMasses=multi_body.link_masses,
                                 linkOrientations=[pose.orientation_as_list() for pose in multi_body.link_poses],
                                 linkInertialFramePositions=[pose.position_as_list()
                                                             for pose in multi_body.link_inertial_frame_poses],
                                 linkInertialFrameOrientations=[pose.orientation_as_list()
                                                                for pose in multi_body.link_inertial_frame_poses],
                                 linkParentIndices=multi_body.link_parent_indices,
                                 linkJointTypes=multi_body.link_joint_types,
                                 linkJointAxis=[[point.x, point.y, point.z] for point in multi_body.link_joint_axis],
                                 linkCollisionShapeIndices=multi_body.link_collision_shape_indices)

    def get_images_for_target(self,
                              target_pose: Pose,
                              cam_pose: Pose,
                              size: Optional[int] = 256) -> List[np.ndarray]:
        # TODO: Might depend on robot cameras, if so please add these camera parameters to RobotDescription object
        # TODO: of your robot with a CameraDescription object.
        fov = 90
        aspect = size / size
        near = 0.2
        far = 100

        view_matrix = p.computeViewMatrix(cam_pose.position_as_list(), target_pose.position_as_list(), [0, 0, 1])
        projection_matrix = p.computeProjectionMatrixFOV(fov, aspect, near, far)
        return list(p.getCameraImage(size, size, view_matrix, projection_matrix,
                                     physicsClientId=self.id))[2:5]

    def add_text(self, text: str, position: List[float], orientation: Optional[List[float]] = None,
                 size: Optional[float] = None, color: Optional[Color] = Color(), life_time: Optional[float] = 0,
                 parent_object_id: Optional[int] = None, parent_link_id: Optional[int] = None) -> int:
        args = {}
        if orientation:
            args["textOrientation"] = orientation
        if size:
            args["textSize"] = size
        if life_time:
            args["lifeTime"] = life_time
        if parent_object_id:
            args["parentObjectUniqueId"] = parent_object_id
        if parent_link_id:
            args["parentLinkIndex"] = parent_link_id
        return p.addUserDebugText(text, position, color.get_rgb(), physicsClientId=self.id, **args)

    def remove_text(self, text_id: Optional[int] = None) -> None:
        if text_id is not None:
            p.removeUserDebugItem(text_id, physicsClientId=self.id)
        else:
            p.removeAllUserDebugItems(physicsClientId=self.id)

    def enable_joint_force_torque_sensor(self, obj: Object, fts_joint_idx: int) -> None:
        p.enableJointForceTorqueSensor(obj.id, fts_joint_idx, enableSensor=1, physicsClientId=self.id)

    def disable_joint_force_torque_sensor(self, obj: Object, joint_id: int) -> None:
        p.enableJointForceTorqueSensor(obj.id, joint_id, enableSensor=0, physicsClientId=self.id)

    def get_joint_reaction_force_torque(self, obj: Object, joint_id: int) -> List[float]:
        return p.getJointState(obj.id, joint_id, physicsClientId=self.id)[2]

    def get_applied_joint_motor_torque(self, obj: Object, joint_id: int) -> float:
        return p.getJointState(obj.id, joint_id, physicsClientId=self.id)[3]


class Gui(threading.Thread):
    """
    For internal use only. Creates a new thread for the physics simulation that is active until closed by
    :func:`~World.exit`
    Also contains the code for controlling the camera.
    """

    def __init__(self, world: World, mode: WorldMode):
        threading.Thread.__init__(self)
        self.world = world
        self.mode: WorldMode = mode

    def run(self):
        """
        Initializes the new simulation and checks in an endless loop
        if it is still active. If it is the thread will be suspended for 1/80 seconds, if it is not the method and
        thus the thread terminates. The loop also checks for mouse and keyboard inputs to control the camera.
        """
        if self.mode == WorldMode.DIRECT:
            self.world.id = p.connect(p.DIRECT)
        else:
            self.world.id = p.connect(p.GUI)

            # DISCLAIMER
            # This camera control only works if the WorldMooe.GUI BulletWorld is the first one to be created. This is
            # due to a bug in the function pybullet.getDebugVisualizerCamera() which only returns the information of
            # the first created simulation.

            # Disable the side windows of the GUI
            p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0, physicsClientId=self.world.id)
            # Change the init camera pose
            p.resetDebugVisualizerCamera(cameraDistance=1.5, cameraYaw=270.0, cameraPitch=-50,
                                         cameraTargetPosition=[-2, 0, 1], physicsClientId=self.world.id)

            # Get the initial camera target location
            camera_target_position = p.getDebugVisualizerCamera(physicsClientId=self.world.id)[11]

            sphere_visual_id = p.createVisualShape(p.GEOM_SPHERE, radius=0.05, rgbaColor=[1, 0, 0, 1],
                                                   physicsClientId=self.world.id)

            # Create a sphere with a radius of 0.05 and a mass of 0
            sphere_uid = p.createMultiBody(baseMass=0.0,
                                           baseInertialFramePosition=[0, 0, 0],
                                           baseVisualShapeIndex=sphere_visual_id,
                                           basePosition=camera_target_position,
                                           physicsClientId=self.world.id)

            # Define the maxSpeed, used in calculations
            max_speed = 16

            # Set initial Camera Rotation
            camera_yaw = 50
            camera_pitch = -35

            # Keep track of the mouse state
            mouse_state = [0, 0, 0]
            old_mouse_x, old_mouse_y = 0, 0

            # Determines if the sphere at cameraTargetPosition is visible
            visible = 1

            # Loop to update the camera position based on keyboard events
            while p.isConnected(self.world.id):
                # Monitor user input
                keys = p.getKeyboardEvents(self.world.id)
                mouse = p.getMouseEvents(self.world.id)

                # Get infos about the camera
                width, height, dist = (p.getDebugVisualizerCamera()[0],
                                       p.getDebugVisualizerCamera()[1],
                                       p.getDebugVisualizerCamera()[10])
                #print("width: ", width, "height: ", height, "dist: ", dist)
                camera_target_position = p.getDebugVisualizerCamera(self.world.id)[11]

                # Get vectors used for movement on x,y,z Vector
                x_vec = [p.getDebugVisualizerCamera(self.world.id)[2][i] for i in [0, 4, 8]]
                y_vec = [p.getDebugVisualizerCamera(self.world.id)[2][i] for i in [2, 6, 10]]
                z_vec = (0, 0, 1)  # [p.getDebugVisualizerCamera()[2][i] for i in [1, 5, 9]]

                # Check the mouse state
                if mouse:
                    for m in mouse:

                        mouse_x = m[2]
                        mouse_y = m[1]

                        # update mouseState
                        # Left Mouse button
                        if m[0] == 2 and m[3] == 0:
                            mouse_state[0] = m[4]
                        # Middle mouse button (scroll wheel)
                        if m[0] == 2 and m[3] == 1:
                            mouse_state[1] = m[4]
                        # right mouse button
                        if m[0] == 2 and m[3] == 2:
                            mouse_state[2] = m[4]

                        # change visibility by clicking the mousewheel
                        # if m[4] == 6 and m[3] == 1 and visible == 1:
                        #     visible = 0
                        # elif m[4] == 6 and visible == 0:
                        #     visible = 1

                        # camera movement when the left mouse button is pressed
                        if mouse_state[0] == 3:
                            speed_x = abs(old_mouse_x - mouse_x) if (abs(old_mouse_x - mouse_x)) < max_speed \
                                else max_speed
                            speed_y = abs(old_mouse_y - mouse_y) if (abs(old_mouse_y - mouse_y)) < max_speed \
                                else max_speed

                            # max angle of 89.5 and -89.5 to make sure the camera does not flip (is annoying)
                            if mouse_x < old_mouse_x:
                                if (camera_pitch + speed_x) < 89.5:
                                    camera_pitch += (speed_x / 4) + 1
                            elif mouse_x > old_mouse_x:
                                if (camera_pitch - speed_x) > -89.5:
                                    camera_pitch -= (speed_x / 4) + 1

                            if mouse_y < old_mouse_y:
                                camera_yaw += (speed_y / 4) + 1
                            elif mouse_y > old_mouse_y:
                                camera_yaw -= (speed_y / 4) + 1

                        # Camera movement when the middle mouse button is pressed
                        if mouse_state[1] == 3:
                            speed_x = abs(old_mouse_x - mouse_x)
                            factor = 0.05

                            if mouse_x < old_mouse_x:
                                dist = dist - speed_x * factor
                            elif mouse_x > old_mouse_x:
                                dist = dist + speed_x * factor
                            dist = max(dist, 0.1)

                        # camera movement when the right mouse button is pressed
                        if mouse_state[2] == 3:
                            speed_x = abs(old_mouse_x - mouse_x) if (abs(old_mouse_x - mouse_x)) < 5 else 5
                            speed_y = abs(old_mouse_y - mouse_y) if (abs(old_mouse_y - mouse_y)) < 5 else 5
                            factor = 0.05

                            if mouse_x < old_mouse_x:
                                camera_target_position = np.subtract(camera_target_position,
                                                                     np.multiply(np.multiply(z_vec, factor), speed_x))
                            elif mouse_x > old_mouse_x:
                                camera_target_position = np.add(camera_target_position,
                                                                np.multiply(np.multiply(z_vec, factor), speed_x))

                            if mouse_y < old_mouse_y:
                                camera_target_position = np.add(camera_target_position,
                                                                np.multiply(np.multiply(x_vec, factor), speed_y))
                            elif mouse_y > old_mouse_y:
                                camera_target_position = np.subtract(camera_target_position,
                                                                     np.multiply(np.multiply(x_vec, factor), speed_y))
                        # update oldMouse values
                        old_mouse_y, old_mouse_x = mouse_y, mouse_x

                # check the keyboard state
                if keys:
                    # if shift is pressed, double the speed
                    if p.B3G_SHIFT in keys:
                        speed_mult = 5
                    else:
                        speed_mult = 2.5

                    # if control is pressed, the movements caused by the arrowkeys, the '+' as well as the '-' key
                    # change
                    if p.B3G_CONTROL in keys:

                        # the up and down arrowkeys cause the targetPos to move along the z axis of the map
                        if p.B3G_DOWN_ARROW in keys:
                            camera_target_position = np.subtract(camera_target_position,
                                                                 np.multiply(np.multiply(z_vec, 0.03), speed_mult))
                        elif p.B3G_UP_ARROW in keys:
                            camera_target_position = np.add(camera_target_position,
                                                            np.multiply(np.multiply(z_vec, 0.03), speed_mult))

                        # left and right arrowkeys cause the targetPos to move horizontally relative to the camera
                        if p.B3G_LEFT_ARROW in keys:
                            camera_target_position = np.subtract(camera_target_position,
                                                                 np.multiply(np.multiply(x_vec, 0.03), speed_mult))
                        elif p.B3G_RIGHT_ARROW in keys:
                            camera_target_position = np.add(camera_target_position,
                                                            np.multiply(np.multiply(x_vec, 0.03), speed_mult))

                        # the '+' and '-' keys cause the targetpos to move forwards and backwards relative to the camera
                        # while the camera stays at a constant distance. SHIFT + '=' is for US layout
                        if ord("+") in keys or p.B3G_SHIFT in keys and ord("=") in keys:
                            camera_target_position = np.subtract(camera_target_position,
                                                                 np.multiply(np.multiply(y_vec, 0.03), speed_mult))
                        elif ord("-") in keys:
                            camera_target_position = np.add(camera_target_position,
                                                            np.multiply(np.multiply(y_vec, 0.03), speed_mult))

                    # standard bindings for thearrowkeys, the '+' as well as the '-' key
                    else:

                        # left and right arrowkeys cause the camera to rotate around the yaw axis
                        if p.B3G_RIGHT_ARROW in keys:
                            camera_yaw += (360 / width) * speed_mult
                        elif p.B3G_LEFT_ARROW in keys:
                            camera_yaw -= (360 / width) * speed_mult

                        # the up and down arrowkeys cause the camera to rotate around the pitch axis
                        if p.B3G_DOWN_ARROW in keys:
                            if (camera_pitch + (360 / height) * speed_mult) < 89.5:
                                camera_pitch += (360 / height) * speed_mult
                        elif p.B3G_UP_ARROW in keys:
                            if (camera_pitch - (360 / height) * speed_mult) > -89.5:
                                camera_pitch -= (360 / height) * speed_mult

                        # the '+' and '-' keys cause the camera to zoom towards and away from the targetPos without
                        # moving it. SHIFT + '=' is for US layout since the events can't handle shift plus something
                        if ord("+") in keys or p.B3G_SHIFT in keys and ord("=") in keys:
                            if (dist - (dist * 0.02) * speed_mult) > 0.1:
                                dist -= dist * 0.02 * speed_mult
                        elif ord("-") in keys:
                            dist += dist * 0.02 * speed_mult
                # print("dist: ", dist)
                # print("camera_yaw: ", camera_yaw)
                # print("camera_pitch: ", camera_pitch)
                # print("camera_target_position: ", camera_target_position)

                p.resetDebugVisualizerCamera(cameraDistance=dist, cameraYaw=camera_yaw, cameraPitch=camera_pitch,
                                             cameraTargetPosition=camera_target_position, physicsClientId=self.world.id)
                if visible == 0:
                    camera_target_position = (0.0, -50, 50)
                p.resetBasePositionAndOrientation(sphere_uid, camera_target_position, [0, 0, 0, 1], physicsClientId=self.world.id)
                time.sleep(1. / 80.)


##New # Content from: #<src/pycram/datastructures/dataclasses.py>#
from __future__ import annotations

from dataclasses import dataclass
from typing_extensions import List, Optional, Tuple, Callable, Dict, Any, Union, TYPE_CHECKING
from .enums import JointType, Shape
from .pose import Pose, Point
from abc import ABC, abstractmethod

if TYPE_CHECKING:
    from ..description import Link
    from ..world_concepts.world_object import Object
    from ..world_concepts.constraints import Attachment


def get_point_as_list(point: Point) -> List[float]:
    """
    Returns the point as a list.

    :param point: The point.
    :return: The point as a list
    """
    return [point.x, point.y, point.z]


@dataclass
class Color:
    """
    Dataclass for storing rgba_color as an RGBA value.
    The values are stored as floats between 0 and 1.
    The default rgba_color is white. 'A' stands for the opacity.
    """
    R: float = 1
    G: float = 1
    B: float = 1
    A: float = 1

    @classmethod
    def from_list(cls, color: List[float]):
        """
        Sets the rgba_color from a list of RGBA values.

        :param color: The list of RGBA values
        """
        if len(color) == 3:
            return cls.from_rgb(color)
        elif len(color) == 4:
            return cls.from_rgba(color)
        else:
            raise ValueError("Color list must have 3 or 4 elements")

    @classmethod
    def from_rgb(cls, rgb: List[float]):
        """
        Sets the rgba_color from a list of RGB values.

        :param rgb: The list of RGB values
        """
        return cls(rgb[0], rgb[1], rgb[2], 1)

    @classmethod
    def from_rgba(cls, rgba: List[float]):
        """
        Sets the rgba_color from a list of RGBA values.

        :param rgba: The list of RGBA values
        """
        return cls(rgba[0], rgba[1], rgba[2], rgba[3])

    def get_rgba(self) -> List[float]:
        """
        Returns the rgba_color as a list of RGBA values.

        :return: The rgba_color as a list of RGBA values
        """
        return [self.R, self.G, self.B, self.A]

    def get_rgb(self) -> List[float]:
        """
        Returns the rgba_color as a list of RGB values.

        :return: The rgba_color as a list of RGB values
        """
        return [self.R, self.G, self.B]


@dataclass
class AxisAlignedBoundingBox:
    """
    Dataclass for storing an axis-aligned bounding box.
    """
    min_x: float
    min_y: float
    min_z: float
    max_x: float
    max_y: float
    max_z: float

    @classmethod
    def from_min_max(cls, min_point: List[float], max_point: List[float]):
        """
        Sets the axis-aligned bounding box from a minimum and maximum point.

        :param min_point: The minimum point
        :param max_point: The maximum point
        """
        return cls(min_point[0], min_point[1], min_point[2], max_point[0], max_point[1], max_point[2])

    def get_min_max_points(self) -> Tuple[Point, Point]:
        """
        Returns the axis-aligned bounding box as a tuple of minimum and maximum points.

        :return: The axis-aligned bounding box as a tuple of minimum and maximum points
        """
        return self.get_min_point(), self.get_max_point()

    def get_min_point(self) -> Point:
        """
        Returns the axis-aligned bounding box as a minimum point.

        :return: The axis-aligned bounding box as a minimum point
        """
        return Point(self.min_x, self.min_y, self.min_z)

    def get_max_point(self) -> Point:
        """
        Returns the axis-aligned bounding box as a maximum point.

        :return: The axis-aligned bounding box as a maximum point
        """
        return Point(self.max_x, self.max_y, self.max_z)

    def get_min_max(self) -> Tuple[List[float], List[float]]:
        """
        Returns the axis-aligned bounding box as a tuple of minimum and maximum points.

        :return: The axis-aligned bounding box as a tuple of minimum and maximum points
        """
        return self.get_min(), self.get_max()

    def get_min(self) -> List[float]:
        """
        Returns the minimum point of the axis-aligned bounding box.

        :return: The minimum point of the axis-aligned bounding box
        """
        return [self.min_x, self.min_y, self.min_z]

    def get_max(self) -> List[float]:
        """
        Returns the maximum point of the axis-aligned bounding box.

        :return: The maximum point of the axis-aligned bounding box
        """
        return [self.max_x, self.max_y, self.max_z]


@dataclass
class CollisionCallbacks:
    on_collision_cb: Callable
    no_collision_cb: Optional[Callable] = None


@dataclass
class MultiBody:
    base_visual_shape_index: int
    base_pose: Pose
    link_visual_shape_indices: List[int]
    link_poses: List[Pose]
    link_masses: List[float]
    link_inertial_frame_poses: List[Pose]
    link_parent_indices: List[int]
    link_joint_types: List[JointType]
    link_joint_axis: List[Point]
    link_collision_shape_indices: List[int]


@dataclass
class VisualShape(ABC):
    rgba_color: Color
    visual_frame_position: List[float]

    @abstractmethod
    def shape_data(self) -> Dict[str, Any]:
        """
        Returns the shape data of the visual shape (e.g. half extents for a box, radius for a sphere).
        """
        pass

    @property
    @abstractmethod
    def visual_geometry_type(self) -> Shape:
        """
        Returns the visual geometry type of the visual shape (e.g. box, sphere).
        """
        pass


@dataclass
class BoxVisualShape(VisualShape):
    half_extents: List[float]

    def shape_data(self) -> Dict[str, List[float]]:
        return {"halfExtents": self.half_extents}

    @property
    def visual_geometry_type(self) -> Shape:
        return Shape.BOX

    @property
    def size(self) -> List[float]:
        return self.half_extents


@dataclass
class SphereVisualShape(VisualShape):
    radius: float

    def shape_data(self) -> Dict[str, float]:
        return {"radius": self.radius}

    @property
    def visual_geometry_type(self) -> Shape:
        return Shape.SPHERE


@dataclass
class CapsuleVisualShape(VisualShape):
    radius: float
    length: float

    def shape_data(self) -> Dict[str, float]:
        return {"radius": self.radius, "length": self.length}

    @property
    def visual_geometry_type(self) -> Shape:
        return Shape.CAPSULE


@dataclass
class CylinderVisualShape(CapsuleVisualShape):

    @property
    def visual_geometry_type(self) -> Shape:
        return Shape.CYLINDER


@dataclass
class MeshVisualShape(VisualShape):
    scale: List[float]
    file_name: str

    def shape_data(self) -> Dict[str, Union[List[float], str]]:
        return {"meshScale": self.scale, "meshFileName": self.file_name}

    @property
    def visual_geometry_type(self) -> Shape:
        return Shape.MESH


@dataclass
class PlaneVisualShape(VisualShape):
    normal: List[float]

    def shape_data(self) -> Dict[str, List[float]]:
        return {"normal": self.normal}

    @property
    def visual_geometry_type(self) -> Shape:
        return Shape.PLANE


@dataclass
class State(ABC):
    pass


@dataclass
class LinkState(State):
    constraint_ids: Dict[Link, int]


@dataclass
class JointState(State):
    position: float


@dataclass
class ObjectState(State):
    pose: Pose
    attachments: Dict[Object, Attachment]
    link_states: Dict[int, LinkState]
    joint_states: Dict[int, JointState]


@dataclass
class WorldState(State):
    simulator_state_id: int
    object_states: Dict[str, ObjectState]


##New # Content from: #<src/pycram/datastructures/enums.py>#
"""Module holding all enums of PyCRAM."""

from enum import Enum, auto

class ExecutionType(Enum):
    """Enum for Execution Process Module types."""
    REAL = auto()
    SIMULATED = auto()
    SEMI_REAL = auto()

class Arms(Enum):
    """Enum for Arms."""
    LEFT = auto()
    RIGHT = auto()
    BOTH = auto()


class TaskStatus(Enum):
    """
    Enum for readable descriptions of a tasks' status.
    """
    CREATED = 0
    RUNNING = 1
    SUCCEEDED = 2
    FAILED = 3


class JointType(Enum):
    """
    Enum for readable joint types.
    """
    REVOLUTE = 0
    PRISMATIC = 1
    SPHERICAL = 2
    PLANAR = 3
    FIXED = 4
    UNKNOWN = 5
    CONTINUOUS = 6
    FLOATING = 7


class Grasp(Enum):
    """
    Enum for Grasp orientations.
    """
    FRONT = 0
    LEFT = 1
    RIGHT = 2
    TOP = 3


class ObjectType(Enum):
    """
    Enum for Object types to easier identify different objects
    """
    METALMUG = auto()
    PRINGLES = auto()
    MILK = auto()
    SPOON = auto()
    BOWL = auto()
    BREAKFAST_CEREAL = auto()
    JEROEN_CUP = auto()
    ROBOT = auto()
    ENVIRONMENT = auto()
    GENERIC_OBJECT = auto()
    HUMAN = auto()


class State(Enum):
    """
    Enumeration which describes the result of a language expression.
    """
    SUCCEEDED = 1
    FAILED = 0
    RUNNING = 2
    INTERRUPTED = 3


class Shape(Enum):
    """
    Enum for visual shapes of objects
    """
    SPHERE = 2
    BOX = 3
    CYLINDER = 4
    MESH = 5
    PLANE = 6
    CAPSULE = 7


class WorldMode(Enum):
    """
    Enum for the different modes of the world.
    """
    GUI = "GUI"
    DIRECT = "DIRECT"


class AxisIdentifier(Enum):
    """
    Enum for translating the axis name to a vector along that axis.
    """
    X = (1, 0, 0)
    Y = (0, 1, 0)
    Z = (0, 0, 1)


class GripperState(Enum):
    """
    Enum for the different motions of the gripper.
    """
    OPEN = auto()
    CLOSE = auto()


class GripperType(Enum):
    """
    Enum for the different types of grippers.
    """
    PARALLEL = auto()
    SUCTION = auto()
    FINGER = auto()
    HYDRAULIC = auto()
    PNEUMATIC = auto()
    CUSTOM = auto()


class PerceptionTechniques(Enum):
    """
    Enum for techniques for perception tasks.
    """
    ALL = auto()
    HUMAN = auto()
    TYPES = auto()


class ImageEnum(Enum):
    """
    Enum for image switch view on hsrb display.
    """
    HI = 0
    TALK = 1
    DISH = 2
    DONE = 3
    DROP = 4
    HANDOVER = 5
    ORDER = 6
    PICKING = 7
    PLACING = 8
    REPEAT = 9
    SEARCH = 10
    WAVING = 11
    FOLLOWING = 12
    DRIVINGBACK = 13
    PUSHBUTTONS = 14
    FOLLOWSTOP = 15
    JREPEAT = 16
    SOFA = 17
    INSPECT = 18
    CHAIR = 37


##New # Content from: #<src/pycram/datastructures/world.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import os
import threading
import time
from abc import ABC, abstractmethod
from copy import copy
from queue import Queue


import numpy as np
import rospy
from geometry_msgs.msg import Point
from typing_extensions import List, Optional, Dict, Tuple, Callable, TYPE_CHECKING
from typing_extensions import Union

from ..cache_manager import CacheManager
from .enums import JointType, ObjectType, WorldMode
from ..world_concepts.event import Event
from ..local_transformer import LocalTransformer
from .pose import Pose, Transform
from ..world_concepts.constraints import Constraint
from .dataclasses import (Color, AxisAlignedBoundingBox, CollisionCallbacks,
                                               MultiBody, VisualShape, BoxVisualShape, CylinderVisualShape, SphereVisualShape,
                                               CapsuleVisualShape, PlaneVisualShape, MeshVisualShape,
                                               ObjectState, State, WorldState)

if TYPE_CHECKING:
    from ..world_concepts.world_object import Object
    from ..description import Link, Joint


class StateEntity:
    """
    The StateEntity class is used to store the state of an object or the physics simulator. This is used to save and
    restore the state of the World.
    """

    def __init__(self):
        self._saved_states: Dict[int, State] = {}

    @property
    def saved_states(self) -> Dict[int, State]:
        """
        Returns the saved states of this entity.
        """
        return self._saved_states

    def save_state(self, state_id: int) -> int:
        """
        Saves the state of this entity with the given state id.

        :param state_id: The unique id of the state.
        """
        self._saved_states[state_id] = self.current_state
        return state_id

    @property
    @abstractmethod
    def current_state(self) -> State:
        """
        Returns the current state of this entity.

        :return: The current state of this entity.
        """
        pass

    @current_state.setter
    @abstractmethod
    def current_state(self, state: State) -> None:
        """
        Sets the current state of this entity.

        :param state: The new state of this entity.
        """
        pass

    def restore_state(self, state_id: int) -> None:
        """
        Restores the state of this entity from a saved state using the given state id.

        :param state_id: The unique id of the state.
        """
        self.current_state = self.saved_states[state_id]

    def remove_saved_states(self) -> None:
        """
        Removes all saved states of this entity.
        """
        self._saved_states = {}


class WorldEntity(StateEntity, ABC):
    """
    A data class that represents an entity of the world, such as an object or a link.
    """

    def __init__(self, _id: int, world: Optional[World] = None):
        StateEntity.__init__(self)
        self.id = _id
        self.world: World = world if world is not None else World.current_world


class World(StateEntity, ABC):
    """
    The World Class represents the physics Simulation and belief state, it is the main interface for reasoning about
    the World. This is implemented as a singleton, the current World can be accessed via the static variable
    current_world which is managed by the World class itself.
    """

    simulation_frequency: float
    """
    Global reference for the simulation frequency (Hz), used in calculating the equivalent real time in the simulation.
    """

    current_world: Optional[World] = None
    """
        Global reference to the currently used World, usually this is the
        graphical one. However, if you are inside a UseProspectionWorld() environment the current_world points to the
        prospection world. In this way you can comfortably use the current_world, which should point towards the World
        used at the moment.
    """

    robot: Optional[Object] = None
    """
    Global reference to the spawned Object that represents the robot. The robot is identified by checking the name in
     the URDF with the name of the URDF on the parameter server. 
    """

    data_directory: List[str] = [os.path.join(os.path.dirname(__file__), '..', '..', '..', 'resources')]
    """
    Global reference for the data directories, this is used to search for the description files of the robot 
    and the objects.
    """

    cache_dir = data_directory[0] + '/cached/'
    """
    Global reference for the cache directory, this is used to cache the description files of the robot and the objects.
    """

    def __init__(self, mode: WorldMode, is_prospection_world: bool, simulation_frequency: float):
        """
       Creates a new simulation, the mode decides if the simulation should be a rendered window or just run in the
       background. There can only be one rendered simulation.
       The World object also initializes the Events for attachment, detachment and for manipulating the world.

       :param mode: Can either be "GUI" for rendered window or "DIRECT" for non-rendered. The default parameter is "GUI"
       :param is_prospection_world: For internal usage, decides if this World should be used as a prospection world.
        """

        StateEntity.__init__(self)

        if World.current_world is None:
            World.current_world = self
        World.simulation_frequency = simulation_frequency

        self.cache_manager = CacheManager(self.cache_dir, self.data_directory)

        self.id: Optional[int] = -1
        # This is used to connect to the physics server (allows multiple clients)

        self._init_world(mode)

        self.is_prospection_world: bool = is_prospection_world
        self._init_and_sync_prospection_world()

        self.local_transformer = LocalTransformer()
        self._update_local_transformer_worlds()

        self.objects: List[Object] = []
        # List of all Objects in the World



        self.mode: WorldMode = mode
        # The mode of the simulation, can be "GUI" or "DIRECT"

        self.coll_callbacks: Dict[Tuple[Object, Object], CollisionCallbacks] = {}

        self._init_events()

        self._current_state: Optional[WorldState] = None

    @abstractmethod
    def _init_world(self, mode: WorldMode):
        """
        Initializes the physics simulation.
        """
        raise NotImplementedError

    def _init_events(self):
        """
        Initializes dynamic events that can be used to react to changes in the World.
        """
        self.detachment_event: Event = Event()
        self.attachment_event: Event = Event()
        self.manipulation_event: Event = Event()

    def _init_and_sync_prospection_world(self):
        """
        Initializes the prospection world and the synchronization between the main and the prospection world.
        """
        self._init_prospection_world()
        self._sync_prospection_world()

    def _update_local_transformer_worlds(self):
        """
        Updates the local transformer worlds with the current world and prospection world.
        """
        self.local_transformer.world = self
        self.local_transformer.prospection_world = self.prospection_world

    def _init_prospection_world(self):
        """
        Initializes the prospection world, if this is a prospection world itself it will not create another prospection,
        world, but instead set the prospection world to None, else it will create a prospection world.
        """
        if self.is_prospection_world:  # then no need to add another prospection world
            self.prospection_world = None
        else:
            self.prospection_world: World = self.__class__(WorldMode.DIRECT,
                                                           True,
                                                           World.simulation_frequency)

    def _sync_prospection_world(self):
        """
        Synchronizes the prospection world with the main world, this means that every object in the main world will be
        added to the prospection world and vice versa.
        """
        if self.is_prospection_world:  # then no need to add another prospection world
            self.world_sync = None
        else:
            self.world_sync: WorldSync = WorldSync(self, self.prospection_world)
            self.world_sync.start()

    def update_cache_dir_with_object(self, path: str, ignore_cached_files: bool,
                                     obj: Object) -> str:
        """
        Updates the cache directory with the given object.

        :param path: The path to the object.
        :param ignore_cached_files: If the cached files should be ignored.
        :param obj: The object to be added to the cache directory.
        """
        return self.cache_manager.update_cache_dir_with_object(path, ignore_cached_files, obj.description, obj.name)

    @property
    def simulation_time_step(self):
        """
        The time step of the simulation in seconds.
        """
        return 1 / World.simulation_frequency

    @abstractmethod
    def load_object_and_get_id(self, path: Optional[str] = None, pose: Optional[Pose] = None) -> int:
        """
        Loads a description file (e.g. URDF) at the given pose and returns the id of the loaded object.

        :param path: The path to the description file, if None the description file is assumed to be already loaded.
        :param pose: The pose at which the object should be loaded.
        :return: The id of the loaded object.
        """
        pass

    def get_object_by_name(self, name: str) -> Optional[Object]:
        """
        Returns the object with the given name. If there is no object with the given name, None is returned.

        :param name: The name of the returned Objects.
        :return: The object with the given name, if there is one.
        """

        object = list(filter(lambda obj: obj.name == name, self.objects))
        if len(object) > 0:
            return object[0]
        return None

    def get_object_by_type(self, obj_type: ObjectType) -> List[Object]:
        """
        Returns a list of all Objects which have the type 'obj_type'.

        :param obj_type: The type of the returned Objects.
        :return: A list of all Objects that have the type 'obj_type'.
        """
        return list(filter(lambda obj: obj.obj_type == obj_type, self.objects))

    def get_object_by_id(self, obj_id: int) -> Object:
        """
        Returns the single Object that has the unique id.

        :param obj_id: The unique id for which the Object should be returned.
        :return: The Object with the id 'id'.
        """
        return list(filter(lambda obj: obj.id == obj_id, self.objects))[0]

    @abstractmethod
    def remove_object_by_id(self, obj_id: int) -> None:
        """
        Removes the object with the given id from the world.

        :param obj_id: The unique id of the object to be removed.
        """
        pass

    @abstractmethod
    def remove_object_from_simulator(self, obj: Object) -> None:
        """
        Removes an object from the physics simulator.

        :param obj: The object to be removed.
        """
        pass

    def remove_object(self, obj: Object) -> None:
        """
        Removes this object from the current world.
        For the object to be removed it has to be detached from all objects it
        is currently attached to. After this is done a call to world remove object is done
        to remove this Object from the simulation/world.

        :param obj: The object to be removed.
        """
        obj.detach_all()

        self.objects.remove(obj)

        # This means the current world of the object is not the prospection world, since it
        # has a reference to the prospection world
        if self.prospection_world is not None:
            self.world_sync.remove_obj_queue.put(obj)
            self.world_sync.remove_obj_queue.join()

        self.remove_object_from_simulator(obj)

        if World.robot == obj:
            World.robot = None

    def add_fixed_constraint(self, parent_link: Link, child_link: Link,
                             child_to_parent_transform: Transform) -> int:
        """
        Creates a fixed joint constraint between the given parent and child links,
        the joint frame will be at the origin of the child link frame, and would have the same orientation
        as the child link frame.

        :param parent_link: The constrained link of the parent object.
        :param child_link: The constrained link of the child object.
        :param child_to_parent_transform: The transform from the child link frame to the parent link frame.
        :return: The unique id of the created constraint.
        """

        constraint = Constraint(parent_link=parent_link,
                                child_link=child_link,
                                _type=JointType.FIXED,
                                axis_in_child_frame=Point(0, 0, 0),
                                constraint_to_parent=child_to_parent_transform,
                                child_to_constraint=Transform(frame=child_link.tf_frame)
                                )
        constraint_id = self.add_constraint(constraint)
        return constraint_id

    @abstractmethod
    def add_constraint(self, constraint: Constraint) -> int:
        """
        Add a constraint between two objects links so that they become attached for example.

        :param constraint: The constraint data used to create the constraint.
        """
        pass

    @abstractmethod
    def remove_constraint(self, constraint_id) -> None:
        """
        Remove a constraint by its ID.

        :param constraint_id: The unique id of the constraint to be removed.
        """
        pass

    @abstractmethod
    def get_joint_position(self, joint: Joint) -> float:
        """
        Get the position of a joint of an articulated object

        :param joint: The joint to get the position for.
        :return: The joint position as a float.
        """
        pass

    @abstractmethod
    def get_object_joint_names(self, obj: Object) -> List[str]:
        """
        Returns the names of all joints of this object.

        :param obj: The object.
        :return: A list of joint names.
        """
        pass

    @abstractmethod
    def get_link_pose(self, link: Link) -> Pose:
        """
        Get the pose of a link of an articulated object with respect to the world frame.

        :param link: The link as a AbstractLink object.
        :return: The pose of the link as a Pose object.
        """
        pass

    @abstractmethod
    def get_object_link_names(self, obj: Object) -> List[str]:
        """
        Returns the names of all links of this object.

        :param obj: The object.
        :return: A list of link names.
        """
        pass

    def simulate(self, seconds: float, real_time: Optional[bool] = False) -> None:
        """
        Simulates Physics in the World for a given amount of seconds. Usually this simulation is faster than real
        time. By setting the 'real_time' parameter this simulation is slowed down such that the simulated time is equal
        to real time.

        :param seconds: The amount of seconds that should be simulated.
        :param real_time: If the simulation should happen in real time or faster.
        """
        self.set_realtime(real_time)
        for i in range(0, int(seconds * self.simulation_frequency)):
            curr_time = rospy.Time.now()
            self.step()
            for objects, callbacks in self.coll_callbacks.items():
                contact_points = self.get_contact_points_between_two_objects(objects[0], objects[1])
                if contact_points != ():
                    callbacks.on_collision_cb()
                elif callbacks.no_collision_cb is not None:
                    callbacks.no_collision_cb()
            if real_time:
                loop_time = rospy.Time.now() - curr_time
                time_diff = self.simulation_time_step - loop_time.to_sec()
                time.sleep(max(0, time_diff))
        self.update_all_objects_poses()

    def update_all_objects_poses(self) -> None:
        """
        Updates the positions of all objects in the world.
        """
        for obj in self.objects:
            obj.update_pose()

    @abstractmethod
    def get_object_pose(self, obj: Object) -> Pose:
        """
        Get the pose of an object in the world frame from the current object pose in the simulator.
        """
        pass

    @abstractmethod
    def perform_collision_detection(self) -> None:
        """
        Checks for collisions between all objects in the World and updates the contact points.
        """
        pass

    @abstractmethod
    def get_object_contact_points(self, obj: Object) -> List:
        """
        Returns a list of contact points of this Object with all other Objects.

        :param obj: The object.
        :return: A list of all contact points with other objects
        """
        pass

    @abstractmethod
    def get_contact_points_between_two_objects(self, obj1: Object, obj2: Object) -> List:
        """
        Returns a list of contact points between obj1 and obj2.

        :param obj1: The first object.
        :param obj2: The second object.
        :return: A list of all contact points between the two objects.
        """
        pass

    @abstractmethod
    def reset_joint_position(self, joint: Joint, joint_position: float) -> None:
        """
        Reset the joint position instantly without physics simulation

        :param joint: The joint to reset the position for.
        :param joint_position: The new joint pose.
        """
        pass

    @abstractmethod
    def reset_object_base_pose(self, obj: Object, pose: Pose):
        """
        Reset the world position and orientation of the base of the object instantaneously,
        not through physics simulation. (x,y,z) position vector and (x,y,z,w) quaternion orientation.

        :param obj: The object.
        :param pose: The new pose as a Pose object.
        """
        pass

    @abstractmethod
    def step(self):
        """
        Step the world simulation using forward dynamics
        """
        pass

    @abstractmethod
    def set_link_color(self, link: Link, rgba_color: Color):
        """
        Changes the rgba_color of a link of this object, the rgba_color has to be given as Color object.

        :param link: The link which should be colored.
        :param rgba_color: The rgba_color as Color object with RGBA values between 0 and 1.
        """
        pass

    @abstractmethod
    def get_link_color(self, link: Link) -> Color:
        """
        This method returns the rgba_color of this link.

        :param link: The link for which the rgba_color should be returned.
        :return: The rgba_color as Color object with RGBA values between 0 and 1.
        """
        pass

    @abstractmethod
    def get_colors_of_object_links(self, obj: Object) -> Dict[str, Color]:
        """
        Get the RGBA colors of each link in the object as a dictionary from link name to rgba_color.

        :param obj: The object
        :return: A dictionary with link names as keys and a Color object for each link as value.
        """
        pass

    @abstractmethod
    def get_object_axis_aligned_bounding_box(self, obj: Object) -> AxisAlignedBoundingBox:
        """
        Returns the axis aligned bounding box of this object. The return of this method are two points in
        world coordinate frame which define a bounding box.

        :param obj: The object for which the bounding box should be returned.
        :return: AxisAlignedBoundingBox object containing the min and max points of the bounding box.
        """
        pass

    @abstractmethod
    def get_link_axis_aligned_bounding_box(self, link: Link) -> AxisAlignedBoundingBox:
        """
        Returns the axis aligned bounding box of the link. The return of this method are two points in
        world coordinate frame which define a bounding box.
        """
        pass

    @abstractmethod
    def set_realtime(self, real_time: bool) -> None:
        """
        Enables the real time simulation of Physics in the World. By default, this is disabled and Physics is only
        simulated to reason about it.

        :param real_time: Whether the World should simulate Physics in real time.
        """
        pass

    @abstractmethod
    def set_gravity(self, gravity_vector: List[float]) -> None:
        """
        Sets the gravity that is used in the World. By default, it is set to the gravity on earth ([0, 0, -9.8]).
         Gravity is given as a vector in x,y,z. Gravity is only applied while simulating Physic.

        :param gravity_vector: The gravity vector that should be used in the World.
        """
        pass

    def set_robot_if_not_set(self, robot: Object) -> None:
        """
        Sets the robot if it is not set yet.

        :param robot: The Object reference to the Object representing the robot.
        """
        if not self.robot_is_set():
            self.set_robot(robot)

    @staticmethod
    def set_robot(robot: Union[Object, None]) -> None:
        """
        Sets the global variable for the robot Object This should be set on spawning the robot.

        :param robot: The Object reference to the Object representing the robot.
        """
        World.robot = robot

    @staticmethod
    def robot_is_set() -> bool:
        """
        Returns whether the robot has been set or not.

        :return: True if the robot has been set, False otherwise.
        """
        return World.robot is not None

    def exit(self) -> None:
        """
        Closes the World as well as the prospection world, also collects any other thread that is running.
        """
        self.exit_prospection_world_if_exists()
        self.disconnect_from_physics_server()
        self.reset_robot()
        self.join_threads()
        if World.current_world == self:
            World.current_world = None

    def exit_prospection_world_if_exists(self) -> None:
        """
        Exits the prospection world if it exists.
        """
        if self.prospection_world:
            self.terminate_world_sync()
            self.prospection_world.exit()

    @abstractmethod
    def disconnect_from_physics_server(self) -> None:
        """
        Disconnects the world from the physics server.
        """
        pass

    def reset_current_world(self) -> None:
        """
        Resets the pose of every object in the World to the pose it was spawned in and sets every joint to 0.
        """
        for obj in self.objects:
            obj.set_pose(obj.original_pose)
            obj.set_joint_positions(dict(zip(list(obj.joint_names), [0] * len(obj.joint_names))))

    def reset_robot(self) -> None:
        """
        Sets the robot class variable to None.
        """
        self.set_robot(None)

    @abstractmethod
    def join_threads(self) -> None:
        """
        Join any running threads. Useful for example when exiting the world.
        """
        pass

    def terminate_world_sync(self) -> None:
        """
        Terminates the world sync thread.
        """
        self.world_sync.terminate = True
        self.world_sync.join()

    def save_state(self, state_id: Optional[int] = None) -> int:
        """
        Returns the id of the saved state of the World. The saved state contains the states of all the objects and
        the state of the physics simulator.

        :return: A unique id of the state
        """
        state_id = self.save_physics_simulator_state()
        self.save_objects_state(state_id)
        self._current_state = WorldState(state_id, self.object_states)
        return super().save_state(state_id)

    @property
    def current_state(self) -> WorldState:
        if self._current_state is None:
            self._current_state = WorldState(self.save_physics_simulator_state(), self.object_states)
        return self._current_state

    @current_state.setter
    def current_state(self, state: WorldState) -> None:
        self.restore_physics_simulator_state(state.simulator_state_id)
        self.object_states = state.object_states

    @property
    def object_states(self) -> Dict[str, ObjectState]:
        """
        Returns the states of all objects in the World.

        :return: A dictionary with the object id as key and the object state as value.
        """
        return {obj.name: obj.current_state for obj in self.objects}

    @object_states.setter
    def object_states(self, states: Dict[str, ObjectState]) -> None:
        """
        Sets the states of all objects in the World.
        """
        for obj_name, obj_state in states.items():
            self.get_object_by_name(obj_name).current_state = obj_state

    def save_objects_state(self, state_id: int) -> None:
        """
        Saves the state of all objects in the World according to the given state using the unique state id.

        :param state_id: The unique id representing the state.
        """
        for obj in self.objects:
            obj.save_state(state_id)

    @abstractmethod
    def save_physics_simulator_state(self) -> int:
        """
        Saves the state of the physics simulator and returns the unique id of the state.

        :return: The unique id representing the state.
        """
        pass

    @abstractmethod
    def remove_physics_simulator_state(self, state_id: int) -> None:
        """
        Removes the state of the physics simulator with the given id.

        :param state_id: The unique id representing the state.
        """
        pass

    @abstractmethod
    def restore_physics_simulator_state(self, state_id: int) -> None:
        """
        Restores the objects and environment state in the physics simulator according to
         the given state using the unique state id.

        :param state_id: The unique id representing the state.
        """
        pass

    def get_images_for_target(self,
                              target_pose: Pose,
                              cam_pose: Pose,
                              size: Optional[int] = 256) -> List[np.ndarray]:
        """
        Calculates the view and projection Matrix and returns 3 images:

        1. An RGB image
        2. A depth image
        3. A segmentation Mask, the segmentation mask indicates for every pixel the visible Object

        :param target_pose: The pose to which the camera should point.
        :param cam_pose: The pose of the camera.
        :param size: The height and width of the images in pixels.
        :return: A list containing an RGB and depth image as well as a segmentation mask, in this order.
        """
        pass

    def register_two_objects_collision_callbacks(self,
                                                 object_a: Object,
                                                 object_b: Object,
                                                 on_collision_callback: Callable,
                                                 on_collision_removal_callback: Optional[Callable] = None) -> None:
        """
        Registers callback methods for contact between two Objects. There can be a callback for when the two Objects
        get in contact and, optionally, for when they are not in contact anymore.

        :param object_a: An object in the World
        :param object_b: Another object in the World
        :param on_collision_callback: A function that should be called if the objects are in contact
        :param on_collision_removal_callback: A function that should be called if the objects are not in contact
        """
        self.coll_callbacks[(object_a, object_b)] = CollisionCallbacks(on_collision_callback,
                                                                       on_collision_removal_callback)

    @classmethod
    def add_resource_path(cls, path: str) -> None:
        """
        Adds a resource path in which the World will search for files. This resource directory is searched if an
        Object is spawned only with a filename.

        :param path: A path in the filesystem in which to search for files.
        """
        cls.data_directory.append(path)

    def get_prospection_object_for_object(self, obj: Object) -> Object:
        """
        Returns the corresponding object from the prospection world for a given object in the main world.
         If the given Object is already in the prospection world, it is returned.

        :param obj: The object for which the corresponding object in the prospection World should be found.
        :return: The corresponding object in the prospection world.
        """
        self.world_sync.add_obj_queue.join()
        try:
            return self.world_sync.object_mapping[obj]
        except KeyError:
            prospection_world = self if self.is_prospection_world else self.prospection_world
            if obj in prospection_world.objects:
                return obj
            else:
                raise ValueError(
                    f"There is no prospection object for the given object: {obj}, this could be the case if"
                    f" the object isn't anymore in the main (graphical) World"
                    f" or if the given object is already a prospection object. ")

    def get_object_for_prospection_object(self, prospection_object: Object) -> Object:
        """
        Returns the corresponding object from the main World for a given
        object in the prospection world. If the  given object is not in the prospection
        world an error will be raised.

        :param prospection_object: The object for which the corresponding object in the main World should be found.
        :return: The object in the main World.
        """
        object_map = self.world_sync.object_mapping
        try:
            return list(object_map.keys())[list(object_map.values()).index(prospection_object)]
        except ValueError:
            raise ValueError("The given object is not in the prospection world.")

    def reset_world(self, remove_saved_states=True) -> None:
        """
        Resets the World to the state it was first spawned in.
        All attached objects will be detached, all joints will be set to the
        default position of 0 and all objects will be set to the position and
        orientation in which they were spawned.

        :param remove_saved_states: If the saved states should be removed.
        """

        if remove_saved_states:
            self.remove_saved_states()

        for obj in self.objects:
            obj.reset(remove_saved_states)

    def remove_saved_states(self) -> None:
        """
        Removes all saved states of the World.
        """
        for state_id in self.saved_states:
            self.remove_physics_simulator_state(state_id)
        super().remove_saved_states()

    def update_transforms_for_objects_in_current_world(self) -> None:
        """
        Updates transformations for all objects that are currently in :py:attr:`~pycram.world.World.current_world`.
        """
        curr_time = rospy.Time.now()
        for obj in list(self.current_world.objects):
            obj.update_link_transforms(curr_time)

    @abstractmethod
    def ray_test(self, from_position: List[float], to_position: List[float]) -> int:
        """ Cast a ray and return the first object hit, if any.

        :param from_position: The starting position of the ray in Cartesian world coordinates.
        :param to_position: The ending position of the ray in Cartesian world coordinates.
        :return: The object id of the first object hit, or -1 if no object was hit.
        """
        pass

    @abstractmethod
    def ray_test_batch(self, from_positions: List[List[float]], to_positions: List[List[float]],
                       num_threads: int = 1) -> List[int]:
        """ Cast a batch of rays and return the result for each of the rays (first object hit, if any. or -1)
         Takes optional argument num_threads to specify the number of threads to use
           to compute the ray intersections for the batch. Specify 0 to let simulator decide, 1 (default) for single
            core execution, 2 or more to select the number of threads to use.

        :param from_positions: The starting positions of the rays in Cartesian world coordinates.
        :param to_positions: The ending positions of the rays in Cartesian world coordinates.
        :param num_threads: The number of threads to use to compute the ray intersections for the batch.
        """
        pass

    def create_visual_shape(self, visual_shape: VisualShape) -> int:
        """
        Creates a visual shape in the physics simulator and returns the unique id of the created shape.

        :param visual_shape: The visual shape to be created, uses the VisualShape dataclass defined in world_dataclasses
        :return: The unique id of the created shape.
        """
        raise NotImplementedError

    def create_multi_body_from_visual_shapes(self, visual_shape_ids: List[int], pose: Pose) -> int:
        """
        Creates a multi body from visual shapes in the physics simulator and returns the unique id of the created
        multi body.

        :param visual_shape_ids: The ids of the visual shapes that should be used to create the multi body.
        :param pose: The pose of the origin of the multi body relative to the world frame.
        :return: The unique id of the created multi body.
        """
        # Dummy parameter since these are needed to spawn visual shapes as a multibody.
        num_of_shapes = len(visual_shape_ids)
        link_poses = [Pose() for _ in range(num_of_shapes)]
        link_masses = [1.0 for _ in range(num_of_shapes)]
        link_parent = [0 for _ in range(num_of_shapes)]
        link_joints = [JointType.FIXED.value for _ in range(num_of_shapes)]
        link_collision = [-1 for _ in range(num_of_shapes)]
        link_joint_axis = [Point(1, 0, 0) for _ in range(num_of_shapes)]

        multi_body = MultiBody(base_visual_shape_index=-1, base_pose=pose,
                               link_visual_shape_indices=visual_shape_ids, link_poses=link_poses,
                               link_masses=link_masses,
                               link_inertial_frame_poses=link_poses,
                               link_parent_indices=link_parent, link_joint_types=link_joints,
                               link_joint_axis=link_joint_axis,
                               link_collision_shape_indices=link_collision)
        return self.create_multi_body(multi_body)

    def create_multi_body(self, multi_body: MultiBody) -> int:
        """
        Creates a multi body in the physics simulator and returns the unique id of the created multi body. The multibody
        is created by joining multiple links/shapes together with joints.

        :param multi_body: The multi body to be created, uses the MultiBody dataclass defined in world_dataclasses.
        :return: The unique id of the created multi body.
        """
        raise NotImplementedError

    def create_box_visual_shape(self, shape_data: BoxVisualShape) -> int:
        """
        Creates a box visual shape in the physics simulator and returns the unique id of the created shape.

        :param shape_data: The parameters that define the box visual shape to be created, uses the BoxVisualShape dataclass defined in world_dataclasses.
        :return: The unique id of the created shape.
        """
        raise NotImplementedError

    def create_cylinder_visual_shape(self, shape_data: CylinderVisualShape) -> int:
        """
        Creates a cylinder visual shape in the physics simulator and returns the unique id of the created shape.

        :param shape_data: The parameters that define the cylinder visual shape to be created, uses the CylinderVisualShape dataclass defined in world_dataclasses.
        :return: The unique id of the created shape.
        """
        raise NotImplementedError

    def create_sphere_visual_shape(self, shape_data: SphereVisualShape) -> int:
        """
        Creates a sphere visual shape in the physics simulator and returns the unique id of the created shape.

        :param shape_data: The parameters that define the sphere visual shape to be created, uses the SphereVisualShape dataclass defined in world_dataclasses.
        :return: The unique id of the created shape.
        """
        raise NotImplementedError

    def create_capsule_visual_shape(self, shape_data: CapsuleVisualShape) -> int:
        """
        Creates a capsule visual shape in the physics simulator and returns the unique id of the created shape.

        :param shape_data: The parameters that define the capsule visual shape to be created, uses the CapsuleVisualShape dataclass defined in world_dataclasses.
        :return: The unique id of the created shape.
        """
        raise NotImplementedError

    def create_plane_visual_shape(self, shape_data: PlaneVisualShape) -> int:
        """
        Creates a plane visual shape in the physics simulator and returns the unique id of the created shape.

        :param shape_data: The parameters that define the plane visual shape to be created, uses the PlaneVisualShape dataclass defined in world_dataclasses.
        :return: The unique id of the created shape.
        """
        raise NotImplementedError

    def create_mesh_visual_shape(self, shape_data: MeshVisualShape) -> int:
        """
        Creates a mesh visual shape in the physics simulator and returns the unique id of the created shape.

        :param shape_data: The parameters that define the mesh visual shape to be created,
        uses the MeshVisualShape dataclass defined in world_dataclasses.
        :return: The unique id of the created shape.
        """
        raise NotImplementedError

    def add_text(self, text: str, position: List[float], orientation: Optional[List[float]] = None, size: float = 0.1,
                 color: Optional[Color] = Color(), life_time: Optional[float] = 0,
                 parent_object_id: Optional[int] = None, parent_link_id: Optional[int] = None) -> int:
        """
        Adds text to the world.

        :param text: The text to be added.
        :param position: The position of the text in the world.
        :param orientation: By default, debug text will always face the camera, automatically rotation. By specifying a text orientation (quaternion), the orientation will be fixed in world space or local space (when parent is specified).
        :param size: The size of the text.
        :param color: The color of the text.
        :param life_time: The lifetime in seconds of the text to remain in the world, if 0 the text will remain in the world until it is removed manually.
        :param parent_object_id: The id of the object to which the text should be attached.
        :param parent_link_id: The id of the link to which the text should be attached.
        :return: The id of the added text.
        """
        raise NotImplementedError

    def remove_text(self, text_id: Optional[int] = None) -> None:
        """
        Removes text from the world using the given id. if no id is given all text will be removed.

        :param text_id: The id of the text to be removed.
        """
        raise NotImplementedError

    def enable_joint_force_torque_sensor(self, obj: Object, fts_joint_idx: int) -> None:
        """
        You can enable a joint force/torque sensor in each joint. Once enabled, if you perform
        a simulation step, the get_joint_reaction_force_torque will report the joint reaction forces in
        the fixed degrees of freedom: a fixed joint will measure all 6DOF joint forces/torques.
        A revolute/hinge joint force/torque sensor will measure 5DOF reaction forces along all axis except
        the hinge axis. The applied force by a joint motor is available through get_applied_joint_motor_torque.

        :param obj: The object in which the joint is located.
        :param fts_joint_idx: The index of the joint for which the force torque sensor should be enabled.
        """
        raise NotImplementedError

    def disable_joint_force_torque_sensor(self, obj: Object, joint_id: int) -> None:
        """
        Disables the force torque sensor of a joint.

        :param obj: The object in which the joint is located.
        :param joint_id: The id of the joint for which the force torque sensor should be disabled.
        """
        raise NotImplementedError

    def get_joint_reaction_force_torque(self, obj: Object, joint_id: int) -> List[float]:
        """
        Returns the joint reaction forces and torques of the specified joint.

        :param obj: The object in which the joint is located.
        :param joint_id: The id of the joint for which the force torque should be returned.
        :return: The joint reaction forces and torques of the specified joint.
        """
        raise NotImplementedError

    def get_applied_joint_motor_torque(self, obj: Object, joint_id: int) -> float:
        """
        Returns the applied torque by a joint motor.

        :param obj: The object in which the joint is located.
        :param joint_id: The id of the joint for which the applied motor torque should be returned.
        :return: The applied torque by a joint motor.
        """
        raise NotImplementedError

    def __del__(self):
        self.exit()


class UseProspectionWorld:
    """
    An environment for using the prospection world, while in this environment the :py:attr:`~World.current_world`
    variable will point to the prospection world.

    Example:
        with UseProspectionWorld():
            NavigateAction.Action([[1, 0, 0], [0, 0, 0, 1]]).perform()
    """

    WAIT_TIME_FOR_ADDING_QUEUE = 20
    """
    The time in seconds to wait for the adding queue to be ready.
    """

    def __init__(self):
        self.prev_world: Optional[World] = None
        # The previous world is saved to restore it after the with block is exited.

    def sync_worlds(self):
        """
        Synchronizes the state of the prospection world with the main world.
        """
        for world_obj, prospection_obj in World.current_world.world_sync.object_mapping.items():
            prospection_obj.current_state = world_obj.current_state

    def __enter__(self):
        """
        This method is called when entering the with block, it will set the current world to the prospection world
        """
        if not World.current_world.is_prospection_world:
            time.sleep(self.WAIT_TIME_FOR_ADDING_QUEUE * World.current_world.simulation_time_step)
            # blocks until the adding queue is ready
            World.current_world.world_sync.add_obj_queue.join()
            self.sync_worlds()

            self.prev_world = World.current_world
            World.current_world.world_sync.pause_sync = True
            World.current_world = World.current_world.prospection_world

    def __exit__(self, *args):
        """
        This method is called when exiting the with block, it will restore the previous world to be the current world.
        """
        if self.prev_world is not None:
            World.current_world = self.prev_world
            World.current_world.world_sync.pause_sync = False


class WorldSync(threading.Thread):
    """
    Synchronizes the state between the World and its prospection world.
    Meaning the cartesian and joint position of everything in the prospection world will be
    synchronized with the main World.
    Adding and removing objects is done via queues, such that loading times of objects
    in the prospection world does not affect the World.
    The class provides the possibility to pause the synchronization, this can be used
    if reasoning should be done in the prospection world.
    """

    def __init__(self, world: World, prospection_world: World):
        threading.Thread.__init__(self)
        self.world: World = world
        self.prospection_world: World = prospection_world
        self.prospection_world.world_sync = self

        self.terminate: bool = False
        self.add_obj_queue: Queue = Queue()
        self.remove_obj_queue: Queue = Queue()
        self.pause_sync: bool = False
        # Maps world to prospection world objects
        self.object_mapping: Dict[Object, Object] = {}
        self.equal_states = False

    def run(self, wait_time_as_n_simulation_steps: Optional[int] = 1):
        """
        Main method of the synchronization, this thread runs in a loop until the
        terminate flag is set.
        While this loop runs it continuously checks the cartesian and joint position of
        every object in the World and updates the corresponding object in the
        prospection world. When there are entries in the adding or removing queue the corresponding objects will
        be added or removed in the same iteration.

        :param wait_time_as_n_simulation_steps: The time in simulation steps to wait between each iteration of
         the syncing loop.
        """
        while not self.terminate:
            self.check_for_pause()
            while not self.add_obj_queue.empty():
                obj = self.add_obj_queue.get()
                # Maps the World object to the prospection world object
                self.object_mapping[obj] = copy(obj)
                self.add_obj_queue.task_done()
            while not self.remove_obj_queue.empty():
                obj = self.remove_obj_queue.get()
                # Get prospection world object reference from object mapping
                prospection_obj = self.object_mapping[obj]
                prospection_obj.remove()
                del self.object_mapping[obj]
                self.remove_obj_queue.task_done()
            self.check_for_pause()
            time.sleep(wait_time_as_n_simulation_steps * self.world.simulation_time_step)

    def check_for_pause(self) -> None:
        """
        Checks if :py:attr:`~self.pause_sync` is true and sleeps this thread until it isn't anymore.
        """
        while self.pause_sync:
            time.sleep(0.1)

    def check_for_equal(self) -> bool:
        """
        Checks if both Worlds have the same state, meaning all objects are in the same position.
        This is currently not used, but might be used in the future if synchronization issues worsen.

        :return: True if both Worlds have the same state, False otherwise.
        """
        eql = True
        for obj, prospection_obj in self.object_mapping.items():
            eql = eql and obj.get_pose().dist(prospection_obj.get_pose()) < 0.001
        self.equal_states = eql
        return eql


##New # Content from: #<src/pycram/datastructures/pose.py>#
# used for delayed evaluation of typing until python 3.11 becomes mainstream
from __future__ import annotations

import math
import datetime
from typing_extensions import List, Union, Optional

import numpy as np
import rospy
import sqlalchemy.orm
from geometry_msgs.msg import PoseStamped, TransformStamped, Vector3, Point
from geometry_msgs.msg import (Pose as GeoPose, Quaternion as GeoQuaternion)
from tf import transformations
from ..orm.base import Pose as ORMPose, Position, Quaternion, ProcessMetaData


def get_normalized_quaternion(quaternion: np.ndarray) -> GeoQuaternion:
    """
    Normalizes a given quaternion such that it has a magnitude of 1.

    :param quaternion: The quaternion that should be normalized
    :return: The normalized quaternion
    """
    mag = math.sqrt(sum(v**2 for v in quaternion))
    normed_rotation = [f / mag for f in quaternion]

    geo_quaternion = GeoQuaternion()
    geo_quaternion.x = normed_rotation[0]
    geo_quaternion.y = normed_rotation[1]
    geo_quaternion.z = normed_rotation[2]
    geo_quaternion.w = normed_rotation[3]

    return geo_quaternion


class Pose(PoseStamped):
    """
    Pose representation for PyCRAM, this class extends the PoseStamped ROS message from geometry_msgs. Thus making it
    compatible with every ROS service and message expecting a PoseStamped message.

    Naming convention for Poses:
        Pose: Instances of this class, representing a cartesian position and a quaternion for orientation

        Position: Only the cartesian position in xyz

        Orientation: Only the quaternion as xyzw
    """

    def __init__(self, position: Optional[List[float]] = None, orientation: Optional[List[float]] = None,
                 frame: str = "map", time: rospy.Time = None):
        """
        Poses can be initialized by a position and orientation given as lists, this is optional. By default, Poses are
        initialized with the position being [0, 0, 0], the orientation being [0, 0, 0, 1] and the frame being 'map'.

        :param position: An optional position of this Pose
        :param orientation: An optional orientation of this Pose
        :param frame: An optional frame in which this pose is
        :param time: The time at which this Pose is valid, as ROS time
        """
        super().__init__()
        if position is not None:
            self.position = position

        if orientation is not None:
            self.orientation = orientation
        else:
            self.pose.orientation.w = 1.0

        self.header.frame_id = frame

        self.header.stamp = time if time else rospy.Time.now()

        self.frame = frame

    @staticmethod
    def from_pose_stamped(pose_stamped: PoseStamped) -> Pose:
        """
        Converts a geometry_msgs/PoseStamped message to a Pose object. Should be used for compatability with ROS.

        :param pose_stamped: The pose stamped message which should be converted
        :return: A Pose object with the same information as the given message
        """
        p = Pose()
        p.header = pose_stamped.header
        p.pose = pose_stamped.pose
        return p

    @property
    def frame(self) -> str:
        """
        Property for the frame_id such that it is easier accessible. Instead of Pose.header.frame_id it is Pose.frame

        :return: The TF frame of this Pose
        """
        return self.header.frame_id

    @frame.setter
    def frame(self, value: str) -> None:
        """
        Sets the TF frame of this pose to the given new frame

        :param value: The new TF frame
        """
        self.header.frame_id = value

    @property
    def position(self) -> Point:
        """
        Property that points to the position of this pose
        """
        return self.pose.position

    @position.setter
    def position(self, value) -> None:
        """
        Sets the position for this Pose, the position can either be a list of xyz or a geometry_msgs/Pose message.

        :param value: List or geometry_msgs/Pose message for the position
        """
        if (not isinstance(value, list) and not isinstance(value, tuple) and not isinstance(value, GeoPose)
                and not isinstance(value, Point)):
            rospy.logerr("Position can only be a list or geometry_msgs/Pose")
            raise TypeError("Position can only be a list/tuple or geometry_msgs/Pose")
        if isinstance(value, list) or isinstance(value, tuple) and len(value) == 3:
            self.pose.position.x = value[0]
            self.pose.position.y = value[1]
            self.pose.position.z = value[2]
        else:
            # TODO: Check if this is correct or if it should be handled as an error
            self.pose.position = value

    @property
    def orientation(self) -> GeoQuaternion:
        """
        Property that points to the orientation of this pose
        """
        return self.pose.orientation

    @orientation.setter
    def orientation(self, value) -> None:
        """
        Sets the orientation of this Pose, the orientation can either be a list of xyzw or a geometry_msgs/Quaternion
        message

        :param value: New orientation, either a list or geometry_msgs/Quaternion
        """
        if not isinstance(value, list) and not isinstance(value, tuple) and not isinstance(value, GeoQuaternion):
            rospy.logwarn("Orientation can only be a list or geometry_msgs/Quaternion")
            return

        if isinstance(value, list) or isinstance(value, tuple) and len(value) == 4:
            orientation = np.array(value)
        else:
            orientation = np.array([value.x, value.y, value.z, value.w])
        # This is used instead of np.linalg.norm since numpy is too slow on small arrays
        self.pose.orientation = get_normalized_quaternion(orientation)

    def to_list(self) -> List[List[float]]:
        """
        Returns the position and orientation of this pose as a list containing two list.

        :return: The position and orientation as lists
        """
        return [[self.pose.position.x, self.pose.position.y, self.pose.position.z],
                [self.pose.orientation.x, self.pose.orientation.y, self.pose.orientation.z, self.pose.orientation.w]]

    def to_transform(self, child_frame: str) -> Transform:
        """
        Converts this pose to a Transform from the TF frame of the pose to the given child_frame

        :param child_frame: Child frame id to which the Transform points
        :return: A new Transform
        """
        return Transform(self.position_as_list(), self.orientation_as_list(), self.frame, child_frame,
                         self.header.stamp)

    def copy(self) -> Pose:
        """
        Creates a deep copy of this pose.

        :return: A copy of this pose
        """
        p = Pose(self.position_as_list(), self.orientation_as_list(), self.frame, self.header.stamp)
        p.header.frame_id = self.header.frame_id
        return p

    def position_as_list(self) -> List[float]:
        """
        Returns only the position as a list of xyz.

        :return: The position as a list
        """
        return [self.position.x, self.position.y, self.position.z]

    def orientation_as_list(self) -> List[float]:
        """
        Returns only the orientation as a list of a quaternion

        :return: The orientation as a quaternion with xyzw
        """
        return [self.pose.orientation.x, self.pose.orientation.y, self.pose.orientation.z, self.pose.orientation.w]

    def dist(self, other_pose: Pose) -> float:
        """
        Calculates the euclidian distance between this Pose and the given one. For distance calculation only the
        position is used.

        :param other_pose: Pose to which the distance should be calculated
        :return: The distance between the Poses
        """
        self_position = self.position_as_list()
        other_position = other_pose.position_as_list()
        return np.linalg.norm(np.array(self_position) - np.array(other_position))

    def __eq__(self, other: Pose) -> bool:
        """
        Overloads the '==' operator to check for equality between two Poses. Only compares the position, orientation and
        frame. Timestamps of Poses are not takes into account.

        :param other: Other pose which should be compared
        :return: True if both Poses have the same position, orientation and frame. False otherwise
        """
        if not isinstance(other, Pose):
            return False
        self_position = self.position_as_list()
        other_position = other.position_as_list()

        self_orient = self.orientation_as_list()
        other_orient = other.orientation_as_list()

        return self_position == other_position and self_orient == other_orient and self.frame == other.frame

    def set_position(self, new_position: List[float]) -> None:
        """
        Sets the position of this Pose to the given position. Position has to be given as a vector in cartesian space.

        :param new_position: New position as a vector of xyz
        """
        self.position = new_position

    def set_orientation(self, new_orientation: List[float]) -> None:
        """
        Sets the orientation to the given quaternion. The new orientation has to be given as a quaternion.

        :param new_orientation: New orientation as a quaternion with xyzw
        """
        self.orientation = new_orientation

    def to_sql(self) -> ORMPose:
        return ORMPose(datetime.datetime.utcfromtimestamp(self.header.stamp.to_sec()), self.frame)

    def insert(self, session: sqlalchemy.orm.Session) -> ORMPose:

        metadata = ProcessMetaData().insert(session)

        position = Position(*self.position_as_list())
        position.process_metadata = metadata
        orientation = Quaternion(*self.orientation_as_list())
        orientation.process_metadata = metadata
        session.add(position)
        session.add(orientation)

        pose = self.to_sql()
        pose.process_metadata = metadata
        pose.orientation = orientation
        pose.position = position
        session.add(pose)

        return pose

    def multiply_quaternions(self, quaternion: List) -> None:
        """
        Multiply the quaternion of this Pose with the given quaternion, the result will be the new orientation of this
        Pose.

        :param quaternion: The quaternion by which the orientation of this Pose should be multiplied
        """
        x1, y1, z1, w1 = quaternion
        x2, y2, z2, w2 = self.orientation_as_list()

        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2
        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2
        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2
        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2

        self.orientation = (x, y, z, w)

    def set_orientation_from_euler(self, axis: List, euler_angles: List[float]) -> None:
        """
        Convert axis-angle to quaternion.

        :param axis: (x, y, z) tuple representing rotation axis.
        :param angle: rotation angle in degree
        :return: The quaternion representing the axis angle
        """
        angle = math.radians(euler_angles)
        axis_length = math.sqrt(sum([i ** 2 for i in axis]))
        normalized_axis = tuple(i / axis_length for i in axis)

        x = normalized_axis[0] * math.sin(angle / 2)
        y = normalized_axis[1] * math.sin(angle / 2)
        z = normalized_axis[2] * math.sin(angle / 2)
        w = math.cos(angle / 2)

        return (x, y, z, w)


class Transform(TransformStamped):
    """
    Represents a Transformation from one TF frame to another in PyCRAM. Like with Poses this class inherits from the ROS
    message TransformStamped form geometry_msgs and is therefore compatible with ROS services and messages that require
    a TransformStamped message.

    Naming Convention for Transforms:
        Transform: Instances of this class, representing a translation and rotation from frame_id to child_frame_id

        Translation: A vector representing the conversion in cartesian space

        Rotation: A quaternion representing the conversion of rotation between both frames
    """
    def __init__(self, translation: Optional[List[float]] = None, rotation: Optional[List[float]] = None,
                 frame: Optional[str] = "map", child_frame: Optional[str] = "", time: rospy.Time = None):
        """
        Transforms take a translation, rotation, frame and child_frame as optional arguments. If nothing is given the
        Transform will be initialized with [0, 0, 0] for translation, [0, 0, 0, 1] for rotation, 'map' for frame and an
        empty string for child_frame

        :param translation: Optional translation from frame to child_frame in cartesian space
        :param rotation: Optional rotation from frame to child frame given as quaternion
        :param frame: Origin TF frame of this Transform
        :param child_frame: Target frame for this Transform
        :param time: The time at which this Transform is valid, as ROS time
        """
        super().__init__()
        if translation:
            self.translation = translation

        if rotation:
            self.rotation = rotation
        else:
            self.transform.rotation.w = 1.0

        self.header.frame_id = frame
        self.child_frame_id = child_frame
        self.header.stamp = time if time else rospy.Time.now()

        self.frame = frame

    @classmethod
    def from_pose_and_child_frame(cls, pose: Pose, child_frame_name: str) -> Transform:
        return cls(pose.position_as_list(), pose.orientation_as_list(), pose.frame, child_frame_name,
                   time=pose.header.stamp)

    @staticmethod
    def from_transform_stamped(transform_stamped: TransformStamped) -> Transform:
        """
        Creates a Transform instance from a geometry_msgs/TransformStamped message. Should be used for compatibility with
        ROS.

        :param transform_stamped: The transform stamped message that should be converted
        :return: An Transform with the same information as the transform stamped message
        """
        t = Transform()
        t.header = transform_stamped.header
        t.child_frame_id = transform_stamped.child_frame_id
        t.transform = transform_stamped.transform

        return t

    @property
    def frame(self) -> str:
        """
        Property for the frame_id such that it is easier accessible. Instead of Pose.header.frame_id it is Pose.frame

        :return: The TF frame of this Pose
        """
        return self.header.frame_id

    @frame.setter
    def frame(self, value: str) -> None:
        """
        Sets the TF frame of this pose to the given new frame

        :param value: The new TF frame
        """
        self.header.frame_id = value

    @property
    def translation(self) -> None:
        """
        Property that points to the translation of this Transform
        """
        return self.transform.translation

    @translation.setter
    def translation(self, value) -> None:
        """
        Setter for the translation of this Transform, the new value can either be of type list or a
        geometry_msgs/Vector message.

        :param value: The new value for the translation, either a list or geometry_msgs/Vector3
        """
        if not isinstance(value, list) and not isinstance(value, Vector3):
            rospy.logwarn("Value of a translation can only be a list of a geometry_msgs/Vector3")
            return
        if isinstance(value, list) and len(value) == 3:
            self.transform.translation.x = value[0]
            self.transform.translation.y = value[1]
            self.transform.translation.z = value[2]
        else:
            self.transform.translation = value

    @property
    def rotation(self) -> None:
        """
        Property that points to the rotation of this Transform
        """
        return self.transform.rotation

    @rotation.setter
    def rotation(self, value):
        """
        Setter for the rotation of this Transform, the new value can either be a list or a geometry_msgs/Quaternion
        message

        :param value: The new value for the rotation, either a list or geometry_msgs/Quaternion
        """
        if not isinstance(value, list) and not isinstance(value, GeoQuaternion):
            rospy.logwarn("Value of the rotation can only be a list or a geometry.msgs/Quaternion")
            return
        if isinstance(value, list) and len(value) == 4:
            rotation = np.array(value)

        else:
            rotation = np.array([value.x, value.y, value.z, value.w])
        # This is used instead of np.linalg.norm since numpy is too slow on small arrays
        self.transform.rotation = get_normalized_quaternion(rotation)

    def copy(self) -> Transform:
        """
        Creates a deep copy of this pose.

        :return: A copy of this pose
        """
        t = Transform(self.translation_as_list(), self.rotation_as_list(), self.frame, self.child_frame_id, self.header.stamp)
        t.header.frame_id = self.header.frame_id
        # t.header.stamp = self.header.stamp
        return t

    def translation_as_list(self) -> List[float]:
        """
        Returns the translation of this Transform as a list.

        :return: The translation as a list of xyz
        """
        return [self.transform.translation.x, self.transform.translation.y, self.transform.translation.z]

    def rotation_as_list(self) -> List[float]:
        """
        Returns the rotation of this Transform as a list representing a quaternion.

        :return: The rotation of this Transform as a list with xyzw
        """
        return [self.transform.rotation.x, self.transform.rotation.y, self.transform.rotation.z,
                self.transform.rotation.w]

    def to_pose(self) -> Pose:
        """
        Converts this Transform to a Pose, in this process the child_frame_id is lost.

        :return: A new pose with same translation as position and rotation as orientation
        """
        return Pose(self.translation_as_list(), self.rotation_as_list(), self.frame, self.header.stamp)

    def invert(self) -> Transform:
        """
        Inverts this Transform, the new Transform points from the child_frame_id to the frame_id

        :return: A new inverted Transform
        """
        transform = transformations.concatenate_matrices(transformations.translation_matrix(self.translation_as_list()),
                                                         transformations.quaternion_matrix(self.rotation_as_list()))
        inverse_transform = transformations.inverse_matrix(transform)
        translation = transformations.translation_from_matrix(inverse_transform)
        quaternion = transformations.quaternion_from_matrix(inverse_transform)
        return Transform(list(translation), list(quaternion), self.child_frame_id, self.header.frame_id, self.header.stamp)

    def __mul__(self, other: Transform) -> Union[Transform, None]:
        """
        Multiplies this Transform with another one. The resulting Transform points from the frame_id of this Transform
        to the child_frame_id of the other Transform.

        :param other: The Transform which should be multiplied with this one.
        :return: The resulting Transform from the multiplication
        """
        if not isinstance(other, Transform):
            rospy.logerr(f"Can only multiply two Transforms")
            return
        self_trans = transformations.translation_matrix(self.translation_as_list())
        self_rot = transformations.quaternion_matrix(self.rotation_as_list())
        self_mat = np.dot(self_trans, self_rot)

        other_trans = transformations.translation_matrix(other.translation_as_list())
        other_rot = transformations.quaternion_matrix(other.rotation_as_list())
        other_mat = np.dot(other_trans, other_rot)

        new_mat = np.dot(self_mat, other_mat)
        new_trans = transformations.translation_from_matrix(new_mat)
        new_rot = transformations.quaternion_from_matrix(new_mat)
        return Transform(list(new_trans), list(new_rot), self.frame, other.child_frame_id)

    def inverse_times(self, other_transform: Transform) -> Transform:
        """
        Like a 'minus' for Transforms, subtracts the other_transform from this one.

        :param other_transform: Transform which should be subtracted from this one
        :return: The resulting Transform form the calculation
        """
        inv = other_transform.invert()
        return self * inv

    def __eq__(self, other: Transform) -> bool:
        """
        Overloads the '==' operator to check for equality between two Transforms. Only compares the translation,
        rotation, frame and child frame. Timestamps of Poses are not takes into account.

        :param other: Other pose which should be compared
        :return: True if both Transforms have the same translation, rotation, frame and child frame. False otherwise
        """
        if not isinstance(other, Transform):
            return False
        self_position = self.translation_as_list()
        other_position = other.translation_as_list()

        self_orient = self.rotation_as_list()
        other_orient = other.rotation_as_list()

        return self_position == other_position and self_orient == other_orient and \
            self.frame == other.frame and self.child_frame_id == other.child_frame_id

    def set_translation(self, new_translation: List[float]) -> None:
        """
        Sets the translation of this Transform to the newly given one. Translation has to be a vector in cartesian space

        :param new_translation: The new translation as a vector with xyz.
        """
        self.translation = new_translation

    def set_rotation(self, new_rotation: List[float]) -> None:
        """
        Sets the rotation of this Transform to the newly given one. Rotation has to be a quaternion.

        :param new_rotation: The new rotation as a quaternion with xyzw
        """
        self.rotation = new_rotation




